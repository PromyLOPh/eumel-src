PACKET eumel coder                                 (* Autor: U. Bartling *) 
       DEFINES coder on, coder off,                (* 1.8.0-Korr. M.St. *) 
               declare, define, apply, identify,   (* 21.11.86 *)
               :=, =,                              (* EXTERNAL 10...Nummern*)
               dump,                               (* und coderon-flags *)
                                                   (* inspector/coder1 weg *)
               LABEL,
               gosub, goret,
               complement condition code,

               ADDRESS ,
               GLOB, LOC, REF, DEREF,
               ref length,
               +, 
               adjust,
               is global, is local, is ref,
 
               DTYPE, 
               type class, type name,
               void type, int type, real type, text type, bool type, 
               dataspace type, undefined type, 
               row type, struct type, proc type, end type,
 
               OPN, 
               set length of local storage, 
               begin module, end module, 
               is proc, is eumel 0 instruction,
               address, operation,
               nop, 
               init op codes,
               mnemonic, 

               parameter,
               next param,
               NEXTPARAM, 
               access , 
               dtype , 
               param address,
               same type ,
 
               reserve storage, 
               allocate denoter , 
               allocate variable, 
               data allocation by coder ,
               data allocation by user :

(**************************************************************************)
(*                                                                        *) 
(*                         E U M E L  -  C O D E R                        *) 
(*                                                                        *) 
(*                                                                        *) 
(*   Zur Beschreibung des Coders siehe                                    *) 
(*         U.Bartling, J. Liedtke: EUMEL-Coder-Interface                  *) 
(*                                                                        *) 
(*   Stand der Dokumentation  : 13.02.1986                                *) 
(*   Stand der Implementation : 21.03.1986                                *) 
(*                                                                        *) 
(*                                                                        *) 
(**************************************************************************) 
 
 
                   (***** Globale Variable *****) 

TEXT VAR object name;
 
FILE VAR bulletin file; 
 
INT VAR memory management mode, global address offset,
        nt link, permanent pointer, param link, index, mode, field pointer;
 
BOOL VAR found, end of params;
 
#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  1. Interface zum ELAN-Compiler            12.03.1986  *) 
(*                              1.7.5.4                                   *)
(*                                                                        *) 
(*   Beschreibung der      Tabellen (-groessen),                          *) 
(*                         internen Vercodung von Typen                   *) 
(*                    und  Kennungen .                                    *) 
(*   Initialisieren und Beenden des Compilers,                            *) 
(*   Lesen aus und Schreiben in Namens- bzw. Permanent-Tabelle            *) 
(*                                                                        *) 
(**************************************************************************) 
 
 
LET  begin of hash table         =     0 ,
     end of hash table           =  1023 ,
 
     begin of permanent table    = 22784 ,
(*     before first pt entry     = 22784 , *)
(*     first permanent entry     = 22785 , *)
(*   end of permanent table      = 32767 , *)

     wordlength                  =     1 ,  (* compile  u n d  run time *)
     two word length             =     2 ,
     three word length           =     3 ,
     four word length            =     4 ,
 
     permanent param const             = 10000 ,
     permanent param var               = 20000 ,
     permanent proc op                 = 30000 ,
     permanent type                    = 30000 ,
     permanent row                     =    10 ,
     permanent struct                  =    11 ,
     permanent param proc              =    12 ,
(*   permanent param proc end marker   =     0 , *)
     permanent type field              =     0 ,

     ptt limit                         = 10000 ,
     begin of pt minus ptt limit       = 12784 ,
     offset to row size                = 12785 ,
 
     void                              =     0 ,
     int                               =     1 ,
     real                              =     2 ,
     string                            =     3 ,
     bool                              =     5 ,
     bool result                       =     6 ,
     dataspace                         =     7 ,
     undefined                         =     9 ,
     row                               =    10 ,
     struct                            =    11 ,
     end                               =     0 ,

     const                             =     1 , 
     var                               =     2 ,
(*   proc                              =     3 , *)
(*   denoter                           =     5 , *)
(*   bold                              =     2 , *)
 
     ins                               = TRUE ,
     no ins                            = FALSE ,
     no lst                            = FALSE ,
     sermon                            = TRUE  ,
     no sermon                         = FALSE ,

(*   run again mode                    =     0 , *)
(*   compile file mode                 =     1 , *)
     prep coder mode                   =     5 , 
 
(*   warning message                   =     2 , *) 
(*   error message                     =     4 , *) 

     point line                        = "..............." ;
(* 
INT CONST permanent packet            :=     -2 ,
          permanent end               :=     -3 ;
*)
BOOL VAR coder active                 := FALSE ; 

INT  VAR run again mod nr             :=     0 ;
 
 
                     (***** Start/Ende *****)
 
LET invalid coder off = "CODER not active" ;

PROC coder on (INT CONST data allocation mode) : 
    mark coder on ; 
    init memory management ; 
    init opn section ; 
    init compiler .
 
mark coder on :
    coder active := TRUE .

init memory management :
    memory management mode := data allocation mode ;
    prep pbase (global address offset) .
 
init compiler :
    no do again ;
    elan (prep coder mode, bulletin file, "", run again mod nr,
          no ins, prot, check, no sermon) (* prot, check f.test, M.St. *)

ENDPROC coder on;
 
PROC coder off (BOOL CONST insert, sermon, OPN CONST start proc) :
    IF coder active 
       THEN mark coder off ; 
            end coder (insert, sermon, start mod nr if no insert)
       ELSE errorstop (invalid coder off)
    FI .
 
start mod nr if no insert :
    IF insert THEN run again mod nr := 0
              ELSE run again mod nr := start proc.mod nr
    FI ;
    run again mod nr .

mark coder off :
    reset memory management mode ;
    init opn section ;
    coder active := FALSE
ENDPROC coder off ; 
 
PROC end coder (BOOL CONST insert wanted, sermon wanted, INT CONST mod) :
    EXTERNAL 10021
ENDPROC end coder ; 

PROC elan (INT CONST mode, FILE VAR source, TEXT CONST line, 
           INT VAR start module number, BOOL CONST ins, lst, rtc, ser) :
  EXTERNAL 256
ENDPROC elan ;
 
                   (***** Hash/Namenstabelle *****) 

. yet another nt entry :
     nt link := cdb int (nt link) ;
     nt link <> 0 . ;
 
PROC declare object (TEXT CONST name, INT VAR nt link, pt pointer) : 
    EXTERNAL 10031
ENDPROC declare object ; 
 
PROC to object (TEXT CONST searched object) : 
     hash ;
     search nt entry .

hash :
     hash code := 0 ;
     FOR index FROM 1 UPTO LENGTH searched object REP
         addmult cyclic
     ENDREP .

addmult cyclic :
     hash code INCR hash code ;
     IF hash code > end of hash table THEN wrap around FI ;
     hash code := (hash code + code (searched object SUB index)) MOD 1024 .

wrap around :
     hash code DECR end of hash table .

hash code : nt link .

search nt entry :
     found := FALSE ;
     WHILE yet another nt entry REP
          read current entry ;
          IF object name = searched object 
             THEN found := TRUE ;
                  LEAVE to object
          FI
     PER .

read current entry :
     permanent pointer := cdb int (nt link + wordlength) ;
     object name := cdb text (nt link + two word length)
ENDPROC to object ;


                 (***** Permanent Tabelle *****) 
.
next procedure :
     permanent pointer := cdb int (permanent pointer) . ;

PROC next pt param :
     mode := cdb int (param link) MOD ptt limit ;
     param link INCR wordlength ;
     IF   mode = permanent row    THEN skip over permanent row 
     ELIF mode = permanent struct THEN skip over permanent struct
     FI ;
     set end marker if end of list .

skip over permanent row :
     param link INCR wordlength ;
     next pt param .

skip over permanent struct :
     REP
         next pt param ;
         mode := cdb int (param link)
     UNTIL mode = permanent type field PER ;
     param link INCR wordlength
ENDPROC next pt param ;

PROC set end marker if end of list :
     mode := cdb int (param link) ;
     end of params := mode >= permanent proc op OR mode <= 0 
ENDPROC set end marker if end of list ;

PROC get type and mode (INT VAR type) : 
     mode := cdb int (param link) ;
     IF mode = permanent param proc THEN type of param proc
                                    ELSE type of object
     FI .

type of param proc : 
     param link INCR wordlength ;
     get type and mode (type) ;
     mode := permanent param proc .

type of object :
     IF mode < 0 THEN type := 2769 + (32767 + mode) ;
                      mode := 0
                 ELSE type := mode MOD ptt limit ;
                      mode DECR type ;
                      translate type if necessary ;
                      translate mode if necessary 
     FI .

translate type if necessary :
     IF permanent row or struct THEN translate type FI .

translate type :
     type := param link - begin of pt minus ptt limit .

translate mode if necessary : 
    IF   mode = permanent param const THEN mode := const
    ELIF mode = permanent param var   THEN mode := var
    FI .

permanent row or struct :
     type = permanent row OR type = permanent struct
ENDPROC get type and mode ;
 

                 (***** Allgemeine Zugriffsprozeduren *****) 

INT PROC cdb int (INT CONST index) :
   EXTERNAL 116
ENDPROC cdb int ;

TEXT PROC cdb text (INT CONST index) :
   EXTERNAL 117
ENDPROC cdb text ;
 

#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  2. Spruenge und Marken                    07.03.1986  *) 
(*                                                                        *) 
(*   Definition des Datentyps LABEL                                       *) 
(*                                                                        *) 
(*   Deklaration, Definition und Applikation von Marken                   *) 
(*                                                                        *) 
(**************************************************************************) 


TYPE LABEL = INT ; 

BOOL VAR invers :: FALSE ; 
 
PROC declare (LABEL VAR label) : 
    CONCR (label) := 0
ENDPROC declare ; 
 
PROC define (LABEL VAR label) : 
    EXTERNAL 10083
ENDPROC define ; 
 
PROC complement condition code : 
    invers := TRUE
ENDPROC complement condition code ; 
 
PROC apply (LABEL VAR label) : 
    EXTERNAL 10148 
ENDPROC apply ; 
 
PROC apply (LABEL VAR label, BOOL CONST condition) : 
    IF condition xor invers THEN branch true (label) 
                            ELSE branch false (label)
    FI ;
    invers := FALSE .

condition xor invers : 
    IF condition THEN NOT invers
                 ELSE invers
    FI
ENDPROC apply ; 
 
OP := (LABEL VAR global label, local label) : (* EQUATE ! *)
    EXTERNAL 10014 
ENDOP := ; 
 
TEXT PROC dump (LABEL CONST label) : 
    "LAB " + text (CONCR (label)) 
ENDPROC dump ; 
 
PROC gosub (LABEL VAR label) : 
    EXTERNAL 10015 
ENDPROC gosub ; 
 
PROC goret : 
    s0 (q goret code) 
ENDPROC goret ; 
 
PROC branch true (LABEL VAR label) : 
    EXTERNAL 10028
ENDPROC branch true ; 
 
PROC branch false (LABEL VAR label) : 
    EXTERNAL 10029
ENDPROC branch false ; 
 
 
#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  3. Datenaddressen                         21.03.1986  *) 
(*                                                                        *) 
(*   Definition des Datentyps ADDRESS                                     *) 
(*                                                                        *) 
(*   Aufbau von Datenaddressen (Vercodung)                                *) 
(*   Fortschalten und Ausrichten von Adressen                             *) 
(*   Bereitstellen der Fehlermeldung "address overflow" (Coder-intern)    *) 
(*                                                                        *) 
(**************************************************************************) 
 
 
 
TYPE ADDRESS = STRUCT (INT kind, value) ; 
 
LET global                 = 0 , 
    local                  = 1 , 
    ref mask               = 2 , 
    global ref             = 2 , 
    local ref              = 3 , 
    module nr              = 4 ,
    immediate value        = 5 ,
 
    eumel0 stack offset    = 4 ,
    local address limit    = 16 384 ,
 
    illegal ref operation  = "REF not allowed" , 
    deref on non ref       = "DEREF on non-ref address" ,
    global ref not allowed = "GLOBAL REF not allowed" , 
    unknown kind           = "Unknown address kind" , 
    address overflow       = "Address Overflow" , 
    illegal plus operation = "+ not allowed" ;
 
ADDRESS VAR result addr;
 
INT CONST ref length :: 2 ;

OP := (ADDRESS VAR l, ADDRESS CONST r) : 
    CONCR (l) := CONCR (r) 
ENDOP := ; 
 
ADDRESS OP GLOB (INT CONST address level) : 
    result addr.kind  := global ; 
    result addr.value := address level ; 
    IF memory management mode = data allocation by user
       THEN result addr.value INCR global address offset
    FI ;
    result addr
ENDOP GLOB ;

ADDRESS OP LOC (INT CONST address level) : 
    result addr.kind  := local ;
    result addr.value := address level + eumel0 stack offset ; 
    result addr
ENDOP LOC ; 
 
ADDRESS OP REF (ADDRESS CONST addr) : 
    CONCR (result addr) := CONCR (addr) ;
    IF   result addr.kind = local  THEN result addr.kind INCR ref mask
    ELIF result addr.kind = global THEN errorstop (global ref not allowed)
                                   ELSE errorstop (illegal ref operation)
    FI ;
    result addr 
ENDOP REF ; 
 
ADDRESS OP DEREF (ADDRESS CONST ref address) : 
    CONCR (result addr) := CONCR (ref address) ;
    IF is not local ref THEN errorstop (deref on non ref) FI ; 
    result addr.kind DECR ref mask ; 
    result addr .
 
is not local ref :
    result addr.kind <> local ref
ENDOP DEREF ;
 
INT OP REPR (ADDRESS CONST addr) : 
    CONCR (result addr) := CONCR (addr) ;
    SELECT result addr.kind OF 
        CASE global     :
        CASE local      : set bit (result addr.value, 15) 
        CASE global ref : errorstop (global ref not allowed)
        CASE local ref  : prep local ref 
        OTHERWISE errorstop (unknown kind)
    ENDSELECT ; 
    result addr.value .
 
prep local ref : 
    IF address limit exceeded THEN errorstop (address overflow) FI ;
    set bit (result addr.value, 14) ; 
    set bit (result addr.value, 15) .

address limit exceeded :
    result addr.value < eumel0 stack offset OR
    result addr.value > local address limit
ENDOP REPR ; 
 
BOOL PROC is ref (ADDRESS CONST addr) : 
    addr.kind = local ref
ENDPROC is ref ; 
 
BOOL PROC is global (ADDRESS CONST addr) : 
    addr.kind = global 
ENDPROC is global ; 
 
BOOL PROC is local (ADDRESS CONST addr) : 
    addr.kind = local 
ENDPROC is local ; 
 
ADDRESS OP + (ADDRESS CONST addr, INT CONST offset) : 
    CONCR (result addr) := CONCR (addr) ; 
    SELECT result addr.kind OF 
        CASE global : inc global
        CASE local  : inc local
        OTHERWISE     errorstop (illegal plus operation) 
    ENDSELECT ; 
    result addr .
 
inc global : 
    result addr.value INCR offset ; 
    IF result addr.value < 0 THEN errorstop (address overflow) FI .
 
inc local : 
    result addr.value INCR offset ; 
    IF result addr.value < eumel 0 stack offset OR
       result addr.value > local address limit
       THEN errorstop (address overflow)
    FI
ENDOP + ; 
 
PROC adjust (ADDRESS VAR addr, INT CONST adjust length) :
    IF is local or global THEN adjust to length FI . 
 
is local or global :
    addr.kind <= local .

adjust to length :
    mode := addr.value MOD adjust length ;
    IF mode <> 0 THEN addr.value INCR (adjust length-mode) FI
ENDPROC adjust ;

TEXT PROC dump (ADDRESS CONST addr) : 
    kind + text (addr.value) . 
 
kind : 
    SELECT addr.kind OF 
        CASE global          : "GLOBAL " 
        CASE local           : "LOCAL " 
        CASE immediate value : "IMMEDIATE "
        CASE module nr       : "PARAM PROC "
        CASE global ref      : "GLOBAL REF " 
        CASE local ref       : "LOCAL REF " 
        OTHERWISE "undef. Addr:" 
    ENDSELECT 
ENDPROC dump; 


#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  4. Datentypen   Teil I                    03.12.1985  *) 
(*                                                                        *) 
(*   Definition des Datentyps DTYPE                                       *) 
(*                                                                        *) 
(*   Interne Repraesentation der primitiven Datentypen                    *) 
(*   Identifikation von DTYPEs                                            *)
(*                                                                        *) 
(**************************************************************************) 



TYPE DTYPE = INT ; 
 
OP := (DTYPE VAR l, DTYPE CONST r) : 
    CONCR (l) := CONCR (r) 
ENDOP := ; 
 
BOOL OP = (DTYPE CONST l, r) : 
    CONCR (l) = CONCR (r)
ENDOP = ; 
 
DTYPE PROC void type :      DTYPE :(void)      ENDPROC  void type ; 
 
DTYPE PROC int  type :      DTYPE :(int )      ENDPROC  int type ; 
 
DTYPE PROC real type :      DTYPE :(real)      ENDPROC  real type ; 
 
DTYPE PROC text type :      DTYPE :(string)    ENDPROC  text type ; 
 
DTYPE PROC bool type :      DTYPE :(bool)      ENDPROC  bool type ; 
 
DTYPE PROC dataspace type : DTYPE :(dataspace) ENDPROC dataspace type ; 
 
DTYPE PROC undefined type : DTYPE :(undefined) ENDPROC undefined type ; 
 
DTYPE PROC row type  :      DTYPE :(row)       ENDPROC row type ; 
 
DTYPE PROC struct type :    DTYPE :(struct)    ENDPROC struct type ; 
 
DTYPE PROC proc type :   DTYPE :(permanent param proc) ENDPROC proc type ; 
 
DTYPE PROC end type  :      DTYPE :(end)       ENDPROC end type ; 
 
INT PROC type class (DTYPE CONST type) : 
    SELECT type id OF 
        CASE int, real, bool, string, dataspace, undefined : 1 
        CASE void   : 0 
        CASE row    : 3 
        CASE struct : 4 
        CASE permanent param  proc : 5 
        OTHERWISE     pt type 
    ENDSELECT . 

pt type :
    IF type id > ptt limit THEN permanent row or struct
                           ELSE abstract type
    FI .

abstract type : 2 .

permanent row or struct :
    mode := cdbint (type link into pt) MOD ptt limit ; 
    IF   mode = struct THEN 4
    ELIF mode = row    THEN 3
                       ELSE 2
    FI .
 
type link into pt :
    type id + begin of pt minus ptt limit .

type id : CONCR (type)
ENDPROC type class ; 
 
PROC identify (TEXT CONST name,INT VAR size, align, DTYPE VAR type) : 
    SELECT type pos OF 
          CASE 1   : size := 0; align := 0; type id := void 
          CASE 6   : size := 1; align := 1; type id := int 
          CASE 10  : size := 4; align := 4; type id := real 
          CASE 15  : size := 8; align := 4; type id := string
          CASE 20  : size := 1; align := 1; type id := bool 
          CASE 25  : size := 1; align := 1; type id := dataspace
          OTHERWISE  search for type in permanent table 
    ENDSELECT . 
 
type pos : 
    enclose in delimiters ;
    pos (".VOID.INT.REAL.TEXT.BOOL.DATASPACE.", object name) . 
 
enclose in delimiters :
    object name := "." ;
    object name CAT name ;
    object name CAT "." .

search for type in permanent table : 
    to object (name) ;
    IF NOT found THEN size := 0; align := 0; type id := undefined 
                 ELSE size := cdbint (permanent pointer + two wordlength) ;
                      type id := permanent pointer - begin of permanent table ;
                      IF   size < two wordlength  THEN align := 1
                      ELIF size < four wordlength THEN align := 2
                                                  ELSE align := 4
                      FI
    FI . 
 
type id : CONCR (type)
ENDPROC identify ; 
 
 
#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  5. Operationen  Teil I                    21.03.1986  *) 
(*                                                                        *) 
(*   Definition des Datentyps OPN                                         *) 
(*   Primitive Operationen (:=  etc.)                                     *) 
(*   Bereitstellen dee Fehlermeldung 'proc op expected' (coder-intern)    *) 
(*                                                                        *) 
(**************************************************************************) 


TYPE OPN = STRUCT (INT kind, mod nr, top of stack) ;
 
LET proc op    = 0 ,
    param proc = 1 ,
    eumel 0    = 2 , 
    nil        = 3 , 
 
    param proc at non ref = "PARAM PROC at non-ref address" ,
    proc op expected      = "PROC expected" ;
 
OPN VAR eumel0 opn;
eumel0 opn.kind := eumel0 ;
eumel0 opn.top of stack := 0 ;

eumel0 opn.mod nr := q pp ;
OPN CONST pp       :: eumel0 opn ,
          nop code :: OPN :(nil, 0, 0) ;

THESAURUS VAR eumel 0 opcodes :: empty thesaurus ; 
 
PROC init op codes (FILE VAR eumelcodes) : 
    eumel 0 opcodes := empty thesaurus ;
    WHILE NOT eof (eumelcodes) REP
       getline (eumelcodes, object name) ;
       delete trailing blanks ;
       IF object name <> "" CAND NOT (eumel 0 opcodes CONTAINS object name)
          THEN insert (eumel 0 opcodes, object name)
       FI
    PER .

delete trailing blanks :
    WHILE (object name SUB LENGTH object name) = " " REP
       object name := subtext (object name, 1, LENGTH object name - 1)
    PER
ENDPROC init op codes ; 

ADDRESS PROC address (OPN CONST opn) :
    IF opn.kind <> proc op THEN errorstop (proc op expected) FI ;
    result addr.kind  := module nr ; 
    result addr.value := opn.mod nr ;
    result addr
ENDPROC address ;
 
OPN PROC operation (ADDRESS CONST addr) : 
    IF addr.kind <> local ref THEN errorstop (param proc at non ref) FI ; 
    OPN VAR opn ;
    opn.kind := param proc ; 
    opn.mod nr :=addr.value ; 
    opn.top of stack := 0 ; 
    opn 
ENDPROC operation ; 
 
TEXT PROC mnemonic (OPN CONST op code) : 
    name (eumel 0 opcodes, op code.mod nr)
ENDPROC mnemonic ;
 
OPN PROC nop : 
    nop code
ENDPROC nop ; 
 
OP := (OPN VAR r, OPN CONST l) : 
    CONCR (r) := CONCR (l) 
ENDOP := ; 
 
BOOL PROC is proc (OPN CONST operation) : 
    operation.kind = proc op
ENDPROC is proc ; 
 
BOOL PROC is eumel 0 instruction (TEXT CONST op code name) : 
    link (eumel 0 opcodes, op code name) <> 0
ENDPROC is eumel 0 instruction ; 
 

#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  6. Parameterfeld                          10.01.1986  *) 
(*                                                                        *) 
(*   Bereitstellen des Parameterfeldes                                    *) 
(*   Schreiben und Lesen von Eintraegen im Parameterfeld                  *) 
(*   Fortschalten von Zeigern in das Parameterfeld                        *) 
(*   Bereitstellen der Konstanten 'size of param field' (Coder-intern)    *) 
(*                                                                        *) 
(**************************************************************************) 



LET PARAMDESCRIPTOR = STRUCT (DTYPE type,   INT access, 
                              ADDRESS addr, OPN push opn) , 
 
    size of param field   = 100 ,
    param field exceeded  = "Param Field Overflow",
    param nr out of range = "Illegal Param Number" ;
 
ROW size of param field PARAMDESCRIPTOR VAR param field ;
 
 
                      (***** Schreiben *****) 
 
PROC test param pos (INT CONST param nr) : 
    IF param nr < 1 OR param nr > size of param field
       THEN errorstop (param nr out of range)
    FI 
ENDPROC test param pos ; 
 
PROC declare (INT CONST param nr, DTYPE CONST type) : 
    test param pos (param nr) ; 
    enter type . 
 
enter type :
    CONCR (param field [param nr].type) := CONCR (type) 
ENDPROC declare ; 
 
PROC declare (INT CONST param nr, access) : 
    test param pos (param nr) ; 
    enter access . 

enter access :
    param field [param nr].access := access 
ENDPROC declare ; 
 
PROC define (INT CONST param nr, ADDRESS CONST addr) : 
    test param pos (param nr) ; 
    enter address . 

enter address :
    CONCR (param field [param nr].addr) := CONCR (addr) 
ENDPROC define ; 
 
PROC define (INT CONST param nr, value) : 
    result addr.kind  := immediate value ;
    result addr.value := value ;
    define (param nr, result addr) 
ENDPROC define ; 
 
PROC apply (INT CONST param nr, OPN CONST opn) : 
    test param pos (param nr) ; 
    enter push opn . 
 
enter push opn : 
    CONCR (param field [param nr].push opn) := CONCR (opn) 
ENDPROC apply ; 
 
PROC parameter (INT CONST param nr, DTYPE CONST type, 
                INT CONST access, ADDRESS CONST addr) : 
    test param pos (param nr) ; 
    enter type ; 
    enter access ; 
    enter address ; 
    enter pp as default . 
 
enter type : 
    CONCR (param field [param nr].type) := CONCR (type) .

enter access :
    param field [param nr].access := access .

enter address :
    CONCR (param field [param nr].addr) := CONCR (addr) .

enter pp as default :
    CONCR (param field [param nr].push opn) := CONCR (pp) 
ENDPROC parameter ; 
 
 
                       (***** Lesen *****) 
 
ADDRESS PROC param address (INT CONST param nr) : 
    test param pos (param nr) ; 
    param field [param nr].addr 
ENDPROC param address ; 
 
DTYPE PROC dtype (INT CONST param nr) : 
    test param pos (param nr) ; 
    param field [param nr].type 
ENDPROC dtype ; 
 
INT PROC access (INT CONST param nr) : 
    test param pos (param nr) ; 
    param field [param nr].access 
ENDPROC access ; 
 
 
                      (***** Fortschalten *****) 
 
OP NEXTPARAM (INT VAR param nr) : 
   test param pos (param nr) ; 
   IF long entry THEN read until end FI ; 
   param nr INCR 1 .
 
long entry : 
    type class (param field [param nr].type) > 2 . 
 
read until end : 
    REP 
        param nr INCR 1 ; 
        NEXTPARAM param nr 
    UNTIL end marker read or end of field PER . 
 
end marker read or end of field :
    param nr > size of param field OR
    CONCR (param field [param nr].type) = end 
ENDOP NEXTPARAM ; 
 
INT PROC next param (INT CONST p) : 
    index := p ; 
    NEXTPARAM index ; 
    index
ENDPROC next param ; 
 
TEXT PROC dump (INT CONST p) : 
   IF p > 0 AND p <= 100 THEN dump entry (param field (p)) 
                         ELSE param nr out of range 
    FI 
ENDPROC dump ; 
 
TEXT PROC dump entry (PARAMDESCRIPTOR CONST id) : 
    object name := dump (id.type) ; 
    object name CAT text (id.access) ; 
    object name CAT dump (id.addr) ; 
    object name CAT dump (id.push opn) ;
    object name
ENDPROC dump entry ; 

 
#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  7. Datentypen   Teil II                   20.01.1986  *) 
(*                                                                        *) 
(*   Deklaration neuer Datentypen                                         *) 
(*   Vergleich von DTYPEs im Parameterfeld und in der Permanent-Tabelle   *) 
(*                                                                        *) 
(**************************************************************************) 



DTYPE VAR pt type ;

PROC declare (TEXT CONST name, INT CONST size, align, DTYPE VAR type) : 
    entry into name table ; 
    put next permanent (permanent type) ; 
    put next permanent (size) ; 
    put next permanent (nt link) ;
    mark no offsets of text elements . 
 
entry into name table : 
    declare object (name, nt link, CONCR (type)) . 
 
mark no offsets of text elements : 
    put next permanent (0) 
ENDPROC declare ; 
 
BOOL PROC same type (INT CONST param 1, param 2) : 
    INT CONST left type :: CONCR (param field [param 1].type) ;
    IF left type = right type
       THEN same fine structure if there is one
       ELSE left type = undefined OR right type = undefined
    FI .
 
right type : CONCR (param field [param 2].type) . 
 
same fine structure if there is one : 
    IF   left type = row    THEN compare row 
    ELIF left type = struct THEN compare struct 
                            ELSE TRUE 
    FI . 
 
compare row : 
    equal sizes AND same type (param1 + 1, param2 + 1) . 
 
equal sizes : 
    param field [param1+1].access = param field [param2+1].access .
 
compare struct : 
    INT VAR p1 :: param1+1, p2 :: param2+1 ; 
    REP 
       IF   NOT same type (p1, p2) THEN LEAVE same type WITH FALSE 
       ELIF end type found         THEN LEAVE same type WITH TRUE
       FI ;
       NEXTPARAM p1 ;
       NEXTPARAM p2
    UNTIL end of field PER ;
    FALSE .

end type found :
    CONCR (param field [p1].type) = end .

end of field : 
    p1 > size of param field OR p2 > size of param field 
ENDPROC same type ;
 
BOOL PROC same type (INT CONST param nr, DTYPE CONST type) : 
    field pointer := param nr ;
    CONCR (pt type) := CONCR (type) ;
    equal types 
ENDPROC same type ;

BOOL PROC equal types : 
    identical types OR one type is undefined .

one type is undefined :
    type of actual field = undefined OR CONCR(pt type) = undefined .

identical types :
    SELECT type class (pt type) OF 
        CASE 0, 1, 2 : type of actual field = CONCR (pt type)
        CASE 3       : perhaps equal rows
        CASE 4       : perhaps equal structs
        OTHERWISE      FALSE
    ENDSELECT .

perhaps equal rows :
    is row AND equal row sizes AND equal row types . 
 
is row :
    type of actual field = row .

perhaps equal structs : 
    is struct AND same type fields . 
 
is struct :
    type of actual field = struct .

equal row sizes :
    pt row size = row size within param field . 

equal row types :
    same type (field pointer + 1, pt row type) .

pt row size :
    cdb int (CONCR(pt type) + offset to row size) .

pt row type :
    CONCR (pt type) INCR 2 ;
    pt type .

row size within param field :
    param field [field pointer].access .
 
same type fields :
    field pointer INCR 1 ;
    CONCR (pt type) INCR 1 ;
    REP
        IF NOT equal types THEN LEAVE same type fields WITH FALSE FI ;
        IF type of actual field = end 
             THEN LEAVE same type fields WITH TRUE 
        FI ; 
        NEXTPARAM field pointer
    UNTIL end of field PER ;
    FALSE .

end of field :
    field pointer > size of param field .

type of actual field :
    CONCR (param field [field pointer].type) .
ENDPROC equal types ;

BOOL PROC is not void bool or undefined (DTYPE CONST dtype) :
    type <> void AND type <> bool AND type <> undefined .

type : CONCR (dtype)
ENDPROC is not void bool or undefined ;
 

#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  8. Operationen  Teil II                   07.03.1986  *) 
(*                                                                        *) 
(*   Definition der Opcodes                                               *) 
(*   Deklaration, Definition, Identifikation und Applikation              *) 
(*   Eroeffnen und Schliessen eines Moduls                                *)
(*                                                                        *) 
(**************************************************************************) 
 
 
 
LET module not opened  = "Module not opened" , 
    define missing     = "DEFINE missing" ,
    wrong nr of params = "Wrong Nr. of Params:" , 
    illegal kind       = "Opcode expected" ,
    nested module      = "Nested Modules" ,
    no mod nr          = "Param Proc expected" ,
    no immediate value = "Value expected" ,
    type error         = "Type Error" ,
 
    q ln              =  1 ,
    q move            =  2 ,    q move code             =  2 048 ,
    q inc1            =  3 ,    q inc1 code             =  3 072 ,
    q dec1            =  4 ,    q dec1 code             =  4 096 ,
    q inc             =  5 ,    q inc code              =  5 120 ,
    q dec             =  6 ,    q dec code              =  6 144 ,
    q add             =  7 ,    q add code              =  7 168 ,
    q sub             =  8 ,    q sub code              =  8 192 ,
    q clear           =  9 ,    q clear code            =  9 216 ,
    q test            = 10 , 
    q equ             = 11 ,    q equ code              = 11 264 , 
    q lsequ           = 12 ,    q lsequ code            = 12 288 , 
    q fmove           = 13 ,    q fmove code            = 13 312 , 
    q fadd            = 14 ,    q fadd code             = 14 336 , 
    q fsub            = 15 ,    q fsub code             = 15 360 , 
    q fmult           = 16 ,    q fmult code            = 16 384 , 
    q fdiv            = 17 ,    q fdiv code             = 17 408 ,
    q flsequ          = 18 ,    q flsequ code           = 18 432 ,
    q tmove           = 19 ,    q tmove code            = 19 456 ,
    q tequ            = 20 ,    q tequ code             = 20 480 , 
    q accds           = 21 ,    q access ds code        = 22 528 , 
    q ref             = 22 ,    q ref code              = 23 552 ,
    q subscript       = 23 ,    q subscript code        = 24 576 , 
    q select          = 24 ,    q select code           = 25 600 ,
    q ppv             = 25 , 
    q pp              = 26 , 
    q make false      = 27 , (* q make false code       = 65 513 *)
    q movex           = 28 ,
(*  q longa subs                q longa subs code       = 65 376 *) 
    q return          = 29 ,    q return code           = 32 512 ,
    q true return     = 30 ,    q true return code      = 32 513 ,
    q false return    = 31 ,    q false return code     = 32 514 ,
                                q goret code            = 32 519 ,
    q esc mult        = 32 ,    q esc mult code         = 32 553 ,
    q esc div         = 33 ,    q esc div code          = 32 554 , 
    q esc mod         = 34 ,    q esc mod code          = 32 555 , 
    q pproc           = 35 , 
    q compl int       = 36 ,    q compl int code        = 32 551 ,
    q compl real      = 37 ,    q compl real code       = 32 550 ,
(*  q alias ds        = 38 , *) 
    q movim           = 39 ,    q esc movim code        = 32 547 ,
    q fequ            = 40 ,    q fequ code             = 32 548 ,
    q tlsequ          = 41 ,    q tlsequ code           = 32 549 ,
(*  q case            = 42 , *)
    q plus            = 43 ,
    q minus           = 44 ,
    q mult            = 45 ,
    q int div         = 46 ,
    q real div        = 47 ,
    q equal           = 48 ,
    q lessequal       = 49 ;
 
INT CONST q make false code :: - 1 022 , 
          q longa subs code :: -   159 ;
 

                   (***** Deklaration *****) 
 
PROC declare (OPN VAR operation) : 
    operation.kind := proc op ;
    get module nr (operation.mod nr) ; 
    operation.top of stack := 0 
ENDPROC declare ; 
 
PROC declare (TEXT CONST name, INT CONST first, params, OPN VAR operation) : 
    declare (operation) ;
    entry into name and pt table if necessary ; 
    enter params ; 
    enter result ; 
    enter module number . 
 
entry into name and pt table if necessary : 
    declare object (name, nt link, permanent pointer) . 
 
enter params : 
    field pointer := first ;
    FOR index FROM 1 UPTO params REP
       enter param (param field [field pointer]) ;
       NEXTPARAM field pointer 
    PER .
 
enter result : 
    enter param (param field[field pointer].type, permanent proc op) .
 
enter module number : 
    put next permanent (operation.mod nr)
ENDPROC declare ; 
 
PROC enter param (PARAMDESCRIPTOR CONST param) :
    IF   param.access = const 
         THEN enter param (param.type, permanent param const)
    ELIF param.access = var 
         THEN enter param (param.type, permanent param var)
    ELSE errorstop ("Unknown Access")
    FI
ENDPROC enter param ;

PROC enter param (DTYPE CONST type, INT CONST permanent mode) :
    SELECT type class (type) OF
        CASE 0, 1, 2 : put next permanent (CONCR(type) + permanent mode)
        OTHERWISE      errorstop ("Illegal Type")
    ENDSELECT
ENDPROC enter param ;


                    (***** Definition *****) 
 
PROC define (OPN VAR opn) : 
    IF NOT module open THEN errorstop (module not opened)
                       ELSE proc head (opn.mod nr, opn.top of stack)
    FI 
ENDPROC define ; 
 
PROC set length of local storage (OPN VAR opn, INT CONST size) :
    IF   size < 0 OR size > local address limit
         THEN errorstop (address overflow)
    ELIF opn.top of stack = 0
         THEN errorstop (define missing)
    ELIF opn.kind <> proc op
         THEN errorstop (proc op expected)
    FI ;
    set length (opn.top of stack, size + eumel0 stack offset)
ENDPROC set length of local storage ; 
 
PROC define (OPN VAR operation, INT CONST size) : 
    define (operation) ; 
    set length of local storage (operation, size)
ENDPROC define ; 
 
 
                 (***** Identifikation *****) 
 
INT VAR counter, result index, result type repr;
 
PROC identify (TEXT CONST name, INT CONST first, params, OPN VAR operation,
               BOOL VAR object exists) :
    find result entry ; 
    to object (name) ;
    IF found  THEN first fit and leave if found FI ; 
    IF eumel0 THEN identify eumel0 instruction 
              ELSE yield undefined operation 
    FI .
 
find result entry : 
    result index := first; 
    counter := 0 ;
    WHILE counter < params REP 
        NEXTPARAM result index ; 
        counter INCR 1
    PER ;
    check on param field exceeded .

check on param field exceeded :
    IF result index > size of param field
       THEN errorstop (param field exceeded) 
    FI .
 
yield undefined operation :
    declare (result index, undefined type) ;
    apply (result index, nop) ;
    object exists := FALSE .
 
first fit and leave if found :
    WHILE yet another procedure exists REP 
        check one procedure and leave if match ; 
        next procedure 
    PER . 
 
yet another procedure exists : 
    permanent pointer <> 0 . 
 
check one procedure and leave if match: 
    param link := permanent pointer + wordlength ; 
    set end marker if end of list ;
    counter := params ; 
    field pointer := 1 ;
    REP
       IF   end of params AND counter = 0 
            THEN procedure found
       ELIF end of params OR  counter = 0 
            THEN LEAVE check one procedure and leave if match 
            ELSE check next param 
       FI 
   PER . 
 
check next param : 
    get type and mode (CONCR(pt type)) ;
    IF same types THEN set param mode ; 
                       counter DECR 1 ; 
                       field pointer INCR 1 ;
                       next pt param
                  ELSE LEAVE check one procedure and leave if match 
    FI . 
 
same types : (* inline version ! *)
    equal types .
 
set param mode : 
    param field [field pointer].access := mode . 
 
procedure found : 
    get result ; 
    operation.kind   := proc op ; 
    operation.mod nr := module number ; 
    operation.top of stack := 0 ;
    object exists := TRUE ;
    LEAVE identify . 
 
get result : 
    get type and mode (result type) ; 
    declare (result index, mode) .
 
module number :
    cdbint (param link + 1) . 

result type :
    CONCR (param field [result index].type) .
 
eumel0 : 
    eumel0 opn.mod nr := link (eumel 0 opcodes, name) ; 
    eumel0 opn.mod nr <> 0 .
 
identify eumel 0 instruction : 
    init result type with void ; 
    CONCR (operation) := CONCR (eumel0 opn) ;
    object exists := check params and set result ;
    declare (result index, DTYPE:(result type repr)) ;
    declare (result index, const) .

init result type with void :
    result type repr := void . 
 
check params and set result :
    SELECT operation.mod nr OF
       CASE q return, q false return, q true return : no params 
       CASE q inc1, q dec1          : one int param yielding void 
       CASE q pproc, q pp, q ln     : one param yielding void
       CASE q test                  : one param yielding bool
       CASE q clear, q ppv          : one int or bool param yielding void 
       CASE q make false            : one bool param yielding void 
       CASE q move                  : two int or bool params yielding void 
       CASE q compl int, q inc, q dec : two int params yielding void
       CASE q compl real, q fmove   : two real params yielding void 
       CASE q equ, q lsequ          : two int params yielding bool 
       CASE q fequ, q flsequ        : two real params yielding bool 
       CASE q tequ, q tlsequ        : two text params yielding bool
       CASE q tmove                 : two text params yielding void
       CASE q accds, q ref          : two params yielding void
       CASE q add, q sub, q esc mult,
            q esc div, q esc mod    : three int params yielding void
       CASE q fadd, q fsub, q fmult, q fdiv : three real params yielding void
       CASE q select, q movex       : three params 
       CASE q subscript             : five params 
       CASE q plus, q minus, q mult : two intreals yielding intreal
       CASE q int div               : two int params yielding int 
       CASE q real div              : two real params yielding real
       CASE q equal, q lessequal    : two intrealtexts yielding bool
       OTHERWISE                      FALSE
    ENDSELECT .
 
no params : 
    params = 0 . 

one int param yielding void : 
    p1 void (int type, first, params) .

one param yielding void :
    params = 1 . 

one param yielding bool :
    IF params = 1 THEN result type repr := bool ; 
                       TRUE 
                  ELSE FALSE
    FI .
 
one int or bool param yielding void :
    p1 void (int type, first, params) OR p1 void (bool type, first, params) . 

one bool param yielding void :
    p1 void (bool type, first, params) . 
 
two int or bool params yielding void : 
    p2 (int  type, first, params, void) OR
    p2 (bool type, first, params, void) .

two int params yielding void :
    p2 (int type, first, params, void) .

two real params yielding void :
    p2 (real type, first, params, void) .

two text params yielding void :
    p2 (text type, first, params, void) .

two int params yielding bool :
    p2 (int type, first, params, bool) .

two real params yielding bool :
    p2 (real type, first, params, bool) .

two text params yielding bool :
    p2 (text type, first, params, bool) .

two params yielding void :
    params = 2 . 

three int params yielding void :
    p3 void (int type, first, params) .

three real params yielding void :
    p3 void (real type, first, params) .

three params :
    params = 3 .

five params : 
    params = 5 . 

two intreals yielding intreal :
    two int params yielding int OR two real params yielding real .

two intrealtexts yielding bool :
    two int params yielding bool OR two real params yielding bool OR
    two text params yielding bool .

two int params yielding int :
    p2 (int type, first, params, int) .

two real params yielding real :
    p2 (real type, first, params, real)
ENDPROC identify ; 
 
BOOL PROC p1 void (DTYPE CONST requested type, INT CONST first, param nr) :
    param nr = 1 AND param type is requested plain type . 
 
param type is requested plain type :
    CONCR (param field [first].type) = CONCR (requested type) 
 
ENDPROC p1 void ;
 
BOOL PROC p2 (DTYPE CONST requested type, INT CONST first, param nr,
              INT CONST result type) :
    IF param nr = 2 AND param types equal requested plain type
       THEN result type repr := result type ;
            TRUE
       ELSE FALSE
    FI .
 
param types equal requested plain type :
    CONCR (param field [first]  .type) = CONCR (requested type) AND 
    CONCR (param field [first+1].type) = CONCR (requested type)

ENDPROC p2 ;
 
BOOL PROC p3 void (DTYPE CONST requested type, INT CONST first, param nr) :
    param nr = 3 AND param types ok .
 
param types ok :
    FOR index FROM first UPTO first+2 REP
       IF different param types THEN LEAVE p3 void WITH FALSE FI 
    PER ;
    TRUE .
 
different param types :
    CONCR (param field [index].type) <> CONCR (requested type)
ENDPROC p3 void; 


                   (***** Applikation *****) 
 
INT VAR address representation, left repr, right repr, result repr;

PROC apply (INT CONST first, nr of params, OPN CONST opn) : 
    IF NOT module open THEN errorstop (module not opened) FI ;
    SELECT opn.kind OF 
        CASE eumel 0    : generate eumel0 instruction 
        CASE proc op    : call operation 
        CASE param proc : call param proc
        CASE nil        :
        OTHERWISE         errorstop (illegal kind) 
    ENDSELECT .
 
call operation :
    push params if necessary (first, nr of params, opn.mod nr) ; 
    call (opn.mod nr) .
 
call param proc : 
    result addr.kind := local ref ;
    result addr.value := opn.mod nr ;
    address representation := REPR result addr ;
    push params if necessary (first, nr of params, address representation) ;
    call param (address representation) .

generate eumel0 instruction : 
    SELECT real nr of params OF 
        CASE 0 : p0 instruction 
        CASE 1 : apply p1 (opn, first addr) 
        CASE 2 : apply p2 (opn, first addr, second addr)
        CASE 3 : apply p3 (opn, left type, first addr, second addr, third addr) 
        CASE 5 : subscript operation
        OTHERWISE errorstop (wrong nr of params + text (nr of params)) 
    ENDSELECT . 
 
real nr of params :
    IF operator denotation THEN nr of params + 1
                           ELSE nr of params
    FI .

operator denotation :
    opn.mod nr >= q plus .

p0 instruction :
    IF   opn.mod nr = q return       THEN s0 (q return code) 
    ELIF opn.mod nr = q true return  THEN s0 (q true return code)
    ELIF opn.mod nr = q false return THEN s0 (q false return code)
                                     ELSE errorstop (wrong nr of params +
                                                     mnemonic (opn)) 
    FI .
 
subscript operation :
    IF opn.mod nr = q subscript 
       THEN subscription
       ELSE errorstop (wrong nr of params + text (nr of params))
    FI .

subscription :
    ADDRESS CONST element length :: param field [first+2].addr ,
                  limit          :: param field [first+3].addr ;
    check on immediates ;
    IF element length.value < 1024
       THEN s0 (q subscript code + element length.value)
       ELSE s0 (q longa subs code) ;
            s0 (element length.value)
    FI ;
    s3 (limit.value - 1, subs index, base addr, subs result) .

check on immediates :
    IF element length.kind <> immediate value OR
       limit.kind <> immediate value
       THEN errorstop (no immediate value)
    FI .

subs index  : REPR param field [first+1].addr .

base addr   : REPR param field [first].addr .

subs result : REPR param field [first+4].addr .

first addr : 
    param field [first].addr .
 
left type :
    param field [first].type .

second addr : 
    param field [nextparam (first)].addr .
 
third addr : 
    param field [nextparam(nextparam(first))].addr
ENDPROC apply ;
 
PROC push params if necessary (INT CONST first, nr of params, mod nr) : 
    init param push (mod nr) ;
    IF nr of params > 0 THEN push params ;
                             push result if there is one 
    FI . 
 
push params : 
    field pointer := first ;
    FOR index FROM 1 UPTO nr of params REP 
        apply p1 (push code, param addr) ; 
        NEXTPARAM field pointer
    PER . 
 
push code : 
    param field [field pointer].push opn . 
 
param addr :
    param field [field pointer].addr . 
 
push result if there is one : 
    IF push result necessary 
       THEN push result address (REPR param field [field pointer].addr)
    FI . 

push result necessary :
    param field [field pointer].push opn.kind <> nil AND 
    is not void bool or undefined (param field [field pointer].type) 
ENDPROC push params if necessary ;

PROC apply p1 (OPN CONST opn, ADDRESS CONST addr) : 
    IF   opn.mod nr = q ln    THEN generate line number 
    ELIF opn.mod nr = q pproc THEN push module nr
                              ELSE gen p1 instruction
    FI .

gen p1 instruction : 
    address representation := REPR addr ;
    SELECT opn.mod nr OF 
        CASE q inc1  : t1 (q inc1 code, address representation)
        CASE q dec1  : t1 (q dec1 code, address representation)
        CASE q clear : t1 (q clear code,address representation)
        CASE q test  : test bool object (address representation)
        CASE q pp    : push param (address representation)
        CASE q make false : s1 (q make false code, address representation)
        OTHERWISE errorstop (wrong nr of params + mnemonic (opn))
    ENDSELECT .

generate line number :
    IF addr.kind = immediate value THEN mark line (addr.value)
                                   ELSE errorstop (no immediate value)
    FI .

push module nr : 
    IF addr.kind = module nr THEN push param proc (addr.value)
                             ELSE errorstop (no mod nr)
    FI
ENDPROC apply p1; 
 
PROC apply p2 (OPN CONST opn, ADDRESS CONST left addr, right addr): 
    left repr := REPR left addr ;
    IF opn.mod nr = q movim THEN move immediate
                            ELSE gen p2 instruction 
    FI . 
 
gen p2 instruction : 
    right repr := REPR right addr ;
    SELECT opn.mod nr OF 
        CASE q move       : t2 (q move code, right repr, left repr)
        CASE q inc        : t2 (q inc code, right repr, left repr) 
        CASE q dec        : t2 (q dec code, right repr, left repr) 
        CASE q equ        : compare (q equ code, left repr, right repr) 
        CASE q lsequ      : compare (q lsequ code, left repr, right repr) 
        CASE q fmove      : t2 (q fmove code, right repr, left repr)
        CASE q flsequ     : compare (q flsequ code, left repr, right repr) 
        CASE q tmove      : t2 (q tmove code, right repr, left repr)
        CASE q tequ       : compare (q tequ code, left repr, right repr) 
        CASE q compl int  : s2 (q compl int code, left repr, right repr)
        CASE q compl real : s2 (q compl real code, left repr, right repr)
        CASE q fequ       : compare (q fequ code, left repr, right repr) 
        CASE q tlsequ     : compare (q tlsequ code, left repr, right repr) 
        CASE q accds      : t2 (q access ds code, left repr, right repr)
        CASE q ref        : t2 (q ref code, left repr, right repr) 
        OTHERWISE errorstop (wrong nr of params + mnemonic (opn))
    ENDSELECT .
 
move immediate :
    IF right addr.kind = immediate value 
       THEN s0 (q esc movim code) ;
            s1 (left repr, right addr.value)
       ELSE errorstop (no immediate value)
    FI
ENDPROC apply p2; 
 
PROC apply p3 (OPN CONST opn, DTYPE CONST left dtype, 
               ADDRESS CONST left addr, right addr, result addr ):
    left repr   := REPR left addr ; 
    result repr := REPR result addr ;
    IF   opn.mod nr = q select THEN gen select instruction
    ELIF opn.mod nr = q movex  THEN gen long move
                               ELSE gen p3 instruction
    FI .

gen p3 instruction :
    right repr  := REPR right addr ; 
    SELECT opn.mod nr OF 
        CASE q add                : int add
        CASE q sub                : int sub
        CASE q fadd               : real add 
        CASE q fsub               : real sub 
        CASE q fmult              : real mult 
        CASE q fdiv, q real div   : real div 
        CASE q esc mult           : int mult 
        CASE q esc div, q int div : int div 
        CASE q esc mod            : int mod 
        CASE q plus               : int real add
        CASE q minus              : int real sub
        CASE q mult               : int real mult
        CASE q equal, q lessequal : compare (comp code, left repr, right repr)
        OTHERWISE errorstop (wrong nr of params + mnemonic (opn))
    ENDSELECT . 
 
gen select instruction :
    IF right addr.kind = immediate value 
       THEN t1 (q select code, left repr) ;
            s1 (right addr.value, result repr)
       ELSE errorstop (no immediate value)
    FI .

gen long move :
    IF right addr.kind = immediate value
       THEN long move (left repr, result repr, right addr.value)
       ELSE errorstop (no immediate value)
    FI .

int add   : compute (q add code, left repr, right repr, result repr) . 
 
int sub   : compute (q sub code, left repr, right repr, result repr) . 
 
real add  : compute (q fadd code, left repr, right repr, result repr) . 
 
real sub  : compute (q fsub code, left repr, right repr, result repr) . 
 
real mult : compute (q fmult code, left repr, right repr, result repr) . 
 
real div  : compute (q fdiv code, left repr, right repr, result repr) . 
 
int mult  : s3 (q esc mult code, left repr, right repr, result repr) . 
 
int div   : s3 (q esc div code, left repr, right repr, result repr) . 
 
int mod   : s3 (q esc mod code, left repr, right repr, result repr) .
 
int real add : 
    IF left type = int THEN int add
                       ELSE real add
    FI . 
 
int real sub :
    IF left type = int THEN int sub 
                       ELSE real sub
    FI .

int real mult :
    IF left type = int THEN int mult
                       ELSE real mult
    FI . 

comp code : 
    SELECT left type OF
        CASE int    : IF opn.mod nr = q equal THEN q equ  ELSE q lsequ  FI 
        CASE real   : IF opn.mod nr = q equal THEN q fequ ELSE q flsequ FI
        CASE string : IF opn.mod nr = q equal THEN q tequ ELSE q tlsequ FI
        OTHERWISE errorstop (type error); q equ
    ENDSELECT .

left type : CONCR (left dtype)

ENDPROC apply p3; 
 

                      (***** Modul *****) 
 
BOOL VAR module open ;

.init opn section : 
    module open := FALSE .;

PROC begin module : 
    IF module open THEN errorstop (nested module) 
                   ELSE begin modul ; 
                        module open := TRUE 
    FI 
ENDPROC begin module ; 
 
PROC end module : 
    IF NOT module open
       THEN errorstop (module not opened) 
       ELSE end modul ;
            module open := FALSE
    FI
ENDPROC end module ; 

TEXT PROC dump (OPN CONST operation) : 
    IF   operation.kind = proc op THEN " PROC" + text (operation.mod nr, 5) 
    ELIF operation.kind = eumel 0 THEN " EUMEL0: " + mnemonic (operation)
                                  ELSE " undef. Opn" 
    FI 
ENDPROC dump ; 
 
PROC begin modul :
    EXTERNAL 10071
ENDPROC begin modul ; 
 
PROC end modul :
    EXTERNAL 10011
ENDPROC end modul ; 
 
PROC proc head (INT VAR mod nr, top of stack) :
    EXTERNAL 10012
ENDPROC proc head ; 
 
PROC set length (INT CONST top of stack, size) : 
    EXTERNAL 10013
ENDPROC set length ; 
 
PROC get module nr (INT VAR module nr) : 
    EXTERNAL 10016
ENDPROC get module nr ; 
 
PROC compute (INT CONST op code, l addr, r addr, result address) :
    EXTERNAL 10017
ENDPROC compute ; 
 
PROC compare (INT CONST op code, l addr, r addr) :
    EXTERNAL 10018
ENDPROC compare ; 
 
PROC long move (INT CONST to, from, length) :
    EXTERNAL 10019
ENDPROC long move ;

PROC put next permanent (INT CONST permanent value) : 
    EXTERNAL 10020
ENDPROC put next permanent ; 
 
PROC call (INT CONST mod nr) : 
    EXTERNAL 10022
ENDPROC call ; 
 
PROC call param (INT CONST mod nr) : 
    EXTERNAL 10023
ENDPROC call param ; 
 
PROC push param (INT CONST addr) : 
    EXTERNAL 10024
ENDPROC push param ; 
 
PROC push param proc (INT CONST mod nr) : 
    EXTERNAL 10025
ENDPROC push param proc ; 
 
PROC init param push (INT CONST mod nr) : 
    EXTERNAL 10026
ENDPROC init param push ; 
 
PROC push result address (INT CONST addr) : 
    EXTERNAL 10027
ENDPROC push result address ; 
 
PROC test bool object (INT CONST addr) : 
    EXTERNAL 10186
ENDPROC test bool object ; 
 
PROC mark line (INT CONST line number) : 
    EXTERNAL 10030
ENDPROC mark line ; 
 
PROC s0 (INT CONST op code) : 
    EXTERNAL 10038
ENDPROC s0 ; 
 
PROC s1 (INT CONST op code, addr) : 
    EXTERNAL 10039
ENDPROC s1 ; 
 
PROC s2 (INT CONST op code , addr1, addr2) : 
    EXTERNAL 10040
ENDPROC s2 ; 
 
PROC s3 (INT CONST op code, addr1, addr2, addr3) : 
    EXTERNAL 10041
ENDPROC s3 ; 
 
PROC t1 (INT CONST op code, addr) : 
    EXTERNAL 10042
ENDPROC t1 ; 
 
PROC t2 (INT CONST op code, addr1, addr2) : 
    EXTERNAL 10043
ENDPROC t2 ; 
 
#page#
(**************************************************************************) 
(*                                                                        *) 
(*                  9. Speicherverwaltung                     21.03.1986  *) 
(*                                                                        *) 
(*   Ablage der Paketdaten                                                *) 
(*                                                                        *) 
(**************************************************************************) 



INT VAR address value;
 
INT CONST data allocation by coder  := 1 , 
          data allocation by user   := 2 ; 

LET not initialized      = 0 ,
    wrong mm mode        = "Wrong MM Mode" ,
    define on non global = "Define for GLOB only" ,
    text too long        = "TEXT too long" ;
 
TEXT VAR const buffer :: point line ;

.reset memory management mode :
     memory management mode := not initialized . ;
 
PROC reserve storage (INT CONST size) : 
    IF memory management mode <> data allocation by user 
       THEN errorstop (wrong mm mode) 
    FI ; 
    allocate var (address value, size) ; 
    memory management mode := not initialized
ENDPROC reserve storage ; 
 
PROC allocate variable (ADDRESS VAR addr, INT CONST size) : 
    IF memory management mode <> data allocation by coder 
       THEN errorstop (wrong mm mode) 
    FI ; 
    allocate var (addr.value, size) ;
    addr.kind := global
ENDPROC allocate variable ; 
 
PROC allocate denoter (ADDRESS VAR addr, INT CONST value) :
    IF memory management mode <> data allocation by coder 
       THEN errorstop (wrong mm mode) 
    FI ; 
    allocate int denoter (addr.value) ;
    put data word (value, addr.value) ;
    addr.kind := global
ENDPROC allocate denoter ; 

PROC allocate denoter (ADDRESS VAR addr, REAL CONST value) :
    IF memory management mode <> data allocation by coder 
       THEN errorstop (wrong mm mode) 
    FI ; 
    allocate real denoter (addr.value) ;
    addr.kind := global ;
    define (addr, value)
ENDPROC allocate denoter ; 
 
PROC allocate denoter (ADDRESS VAR addr, TEXT CONST value) :
    IF memory management mode <> data allocation by coder 
       THEN errorstop (wrong mm mode) 
    FI ; 
    allocate text denoter (addr.value, (LENGTH value+1) DIV 2 + 2) ; 
    addr.kind := global ;
    skip heaplink; 
    define (addr, value) ; 
    reset heaplink .
 
skip heaplink : 
    addr.value INCR 1 .

reset heaplink :
    addr.value DECR 1
ENDPROC allocate denoter ; 
 
PROC define (ADDRESS CONST addr, INT CONST value) : 
    IF addr.kind <> global 
       THEN errorstop (define on non global) 
    FI ; 
    put data word (value, addr.value) 
ENDPROC define ; 
 
PROC define (ADDRESS CONST addr, REAL CONST value) : 
    IF addr.kind <> global 
       THEN errorstop (define on non global) 
    FI ; 
    replace (const buffer, 1, value) ; 
    address value := addr.value ;
    FOR index FROM 1 UPTO 4 REP 
        put data word (const buffer ISUB index, address value) ;
        address value INCR 1
    PER 
ENDPROC define ; 
 
PROC define (ADDRESS CONST addr, TEXT CONST value) : 
    IF   addr.kind <> global THEN errorstop (define on non global) 
    ELIF LENGTH value > 255  THEN errorstop (text too long)
    FI ; 
    address value := addr.value ;
    const buffer := code (LENGTH value) ; 
    const buffer CAT value ; 
    const buffer CAT " " ;
    FOR index FROM 1 UPTO LENGTH const buffer DIV 2 REP 
        put data word (const buffer ISUB index, address value) ;
        address value INCR 1
    PER ; 
    const buffer := point line
ENDPROC define ; 
 
PROC prep pbase (INT VAR offset) : 
    EXTERNAL 10032 
ENDPROC prep pbase; 
 
PROC allocate var (INT VAR addr, INT CONST length) : 
    EXTERNAL 10033
ENDPROC allocate var ; 
 
PROC allocate int denoter (INT VAR addr) : 
    EXTERNAL 10034
ENDPROC allocate int denoter ;
 
PROC allocate real denoter (INT VAR addr) : 
    EXTERNAL 10035 
ENDPROC allocate real denoter ;

PROC allocate text denoter (INT VAR addr, INT CONST length) : 
    EXTERNAL 10036 
ENDPROC allocate text denoter ;
 
PROC put data word (INT CONST value, INT CONST addr) :
    EXTERNAL 10037
ENDPROC put data word ; 
 
 
#page#
(**************************************************************************) 
(*                                                                        *) 
(*                 10. Inspector                              08.01.1986  *) 
(*                                                                        *) 
(**************************************************************************) 

TEXT VAR type and mode ;
 
TEXT PROC type name (DTYPE CONST type) : 
    type and mode := "" ; 
    name of type (CONCR (type)) ; 
    type and mode
ENDPROC type name ; 
 
TEXT PROC dump (DTYPE CONST type) :
    type and mode := "TYPE " ;
    name of type (CONCR (type)) ; 
    type and mode
ENDPROC dump ;

PROC name of type (INT CONST type) :
            SELECT type OF
     CASE void              :
     CASE int               : type and mode CAT "INT"
     CASE real              : type and mode CAT "REAL"
     CASE string            : type and mode CAT "TEXT"
     CASE bool, bool result : type and mode CAT "BOOL"
     CASE dataspace         : type and mode CAT "DATASPACE"
     OTHERWISE              : complex type
            ENDSELECT .

complex type :
     IF type > ptt limit THEN perhaps permanent struct or row
                         ELSE get complex type
     FI .

perhaps permanent struct or row :
     index := type + begin of pt minus ptt limit ;
     mode := cdb int (index) MOD ptt limit ;
     IF   mode = permanent row    THEN get permanent row 
     ELIF mode = permanent struct THEN get permanent struct
                                  ELSE type and mode CAT "-"
     FI .

get complex type :
     index := type + begin of permanent table ;
     IF is complex type THEN get name
                        ELSE type and mode CAT "-"
     FI .

is complex type :
     permanent type definition mode = permanent type .

get name :
     type and mode CAT cdb text (link to type name + two word length) .

link to type name :
     cdb int (index + three word length) .

permanent type definition mode :
     cdb int (index + wordlength) .

get permanent row :
     INT VAR t; 
     type and mode CAT "ROW " ;
     type and mode CAT text (cdb int (index + wordlength)) ;
     type and mode CAT " " ;
     param link := index + two wordlength ;
     get type and mode (t) ;
     name of type (t) .
 
get permanent struct :
     type and mode CAT "STRUCT ( ... )" 
ENDPROC name of type ;

ENDPACKET eumel coder ; 
