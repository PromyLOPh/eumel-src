#type ("times8")##limit (11.0)##start (2.2, 1.5)##pagelength (17.4)##block# 
 
#head# 
#type ("triumb14")# 
#center#EUMEL-Grafik-System 
 
#type ("times8")# 
#end# 
#type ("triumb14")# Teil 10: Graphik#type ("times8")# 
 
 
#type ("trium12")# 
#on("b")#1. Übersicht#off("b")# 
#type ("times8")# 
 
#limit (7.0)##type("times6")# 
            #on("i")#Dieser Teil des Benutzer-Handbuchs beschreibt die Graphik-
            Fähigkeiten des EUMEL-Systems. Die Graphik-Pakete gehö­
            ren nicht zum Eumel-Standard, sondern sind Anwenderpake­
            te, die im Quellcode ausgeliefert und von jeder Installation in das
            System aufgenommen werden können. #off("i")# 
#limit (11.0)# 
#foot#
    Eventuell müssen Programme erstellt werden, die die Anpassungen für spezielle graphische Geräte einer Installation
    vornehmen, soweit diese nicht von den EUMEL-Anbietern bezogen werden können. 
#end# 
 
#type("times8")# 
    Das #on("b")#Graphik-System#off("b")# ermöglicht es, durch ELAN-Programme geräteunabhängige Infor­
    mationen für Zeichnungen (#on("i")#Graphiken#off("i")#) zu erstellen. Die Graphik erzeugenden Programme
    brauchen dabei keine geräteabhängigen Größen oder Unterprogramme zu enthalten. Sie
    befassen sich somit ausschließlich mit der Erzeugung der problemorientierten Information
    für die Konstruktion einer Zeichnung. Nach der geräteunabhängigen Erzeugung einer
    Graphik kann diese auf unterschiedlichen Geräten ausgegeben werden (z.B. erst auf einem
    Terminal zur Kontrolle und dann auf einem Plotter). 
 
    Die EUMEL-Graphik umfaßt zwei- und dreidimensionale Graphik. Im dreidimensiona­
    len Fall sind perspektivische, orthografische und schiefwinklige Projektionen mit beliebi­
    gen Betrachtungswinkeln möglich. 
 
    Bei der EUMEL-Graphik wird streng zwischen Erzeugung und Manipulation von Gra­
    phiken auf der einen und der Darstellung der erzeugten Bilder auf der anderen Seite
    unterschieden. Für die Erzeugung und Manipulation der Graphiken wird von den Paketen
    #on("i")#picture#off("i")# und #on("i")#picfile#off("i")# der Datentype #on("b")#PICTURE#off("b")# bzw. #on("b")#PICFILE#off("b")# zur Verfügung gestellt. Dabei
    müssen Ausschnitt, Maßstab, Betrachtungswinkel und Projektionsart erst bei der Darstel­
    lung festgelegt werden. Diese Konstruktion des Graphik-Systems hat folgende Vorteile: 
 
    a)  Programme, die Graphik-Information erzeugen, sind geräteunabhängig. Das bedeu­
        tet, das der Programmierer sich ausschließlich mit einem logischen Problem befassen
        muß und nicht mit gerätespezifischen Besonderheiten. 
 
    b)  Graphiken können auf mehreren unterschiedlich gearteten Geräten mehrmals darge­
        stellt werden, ohne daß das erzeugende Programm geändert oder neu gestartet werden
        muß. Z.B. kann ein Programmierer eine Graphik erst auf dem Terminal überprüfen,
        bevor er die Graphik auf einem Plotter zeichnen läßt. 
 
    c)  Graphiken können leicht geändert (z. B. vergrößert oder in eine Richtung gestreckt
        o.ä.) werden, ohne daß sie erneut erzeugt werden müssen. Zudem können Graphiken
        aneinander oder übereinander gelegt werden. 
 
    d)  Graphiken mit unterschiedlichen Farben, Strichen usw. können leicht erzeugt werden. 
 
    e)  Der Anschluß von neuen Graphik.Geräten durch Benutzer ist leicht möglich, ohe daß
        die Graphik-Programme geändert werden müssen. 
 
    f)  Plotter können wie Drucker an einen Spooler gehängt werden. 
 
    g)  Bilder können als PICFILEs gespeichert und versandt werden. 
 
    h)  Es können auch auf Systemen ohne graphische Ausgabegeräte Graphiken erzeugt
        werden. 
 
    i)  Es können mit einfachen Mitteln universelle Unterprogrammpakete erstellt werden,
        um die Standardzeichnungen (Darstellen einer Funktion, Balken oder Liniendiagram­
        me, Achsen etc.) zu erstellen. 
 
 
#type ("trium12")# 
#on("b")#2. Erzeugung von Bildern#off("b")# 
#type ("times8")# 
 
    Bilder entstehen in Objektion vom Datentyp #on("b")#PICTURE#off("b")#. Diese müssen mit der Prozedur
    #on("i")#nilpicture#off("i")# initialisiert werden. Sie enthalten dann ein leeres Bild, dessen Dimension noch
    nicht festgelegt ist. Die Dimension eines #on("i")#PICTURE#off("i")#s wird mit dem ersten Schreibzugriff
    (#on("i")#move, draw#off("i")# o.ä.) festgelegt. Ein #on("i")#PICTURE#off("i")# kann immer nur entweder zwei- oder
    dreidimensional sein. 
    Außerdem kann einem #on("i")#PICTURE#off("i")# mit der Prozedur #on("i")#pen#off("i")# genau ein virtueller Stift zugeord­
    net oder der aktuelle Stift erfragt werden (Standardeinstellung: 1). 
 
    Für Erzeugung eines Bildes wird ein virtueller Zeichenstift benutzt, dem bei der Darstel­
    lung jeweils genau ein realer Stift zugeordnet wird. Dieser Stift kann mit der Prozedur
    #on("b")#move#off("b")# oder #on("b")#move r #off("b")#auf eine bestimmte Stelle positioniert werden ohne zu zeichnen. Mit
    #on("b")#draw#off("b")# oder #on("b")#draw r#off("b")# wird eine Linie von der letzten Position zur angegebene Position
    gezeichnet. Die aktuelle Stiftposition kann dabei mit #on("b")#where#off("b")# abgefragt werden. 
    Außerdem existiert noch die Prozedur #on("b")#draw#off("b")# die einen Text zur Beschriftung der Zeich­
    nung darstellt, sowie #on("b")#bar#off("b")# zum Zeichnen eines Balkens für Balkendiagramme, #on("b")#circle#off("b")# zum
    Zeichnen eines Kreisbogens für Kreisdiagramme und #on("b")#mark#off("b")# zum Markiern von Positionen.
    Dabei wird die aktuelle Stiftposition aber nicht verändert. 
 
#type ("trium12")# 
#on("b")#3. Manipulation von PICTUREs#off("b")# 
#type ("times8")# 
 
    Erstellte PICTUREs können auch als Ganzes manipuliert werde. Dazu dienen die Prozedu­
    ren #on("b")#translate, stretch#off("b")# und #on("b")#rotate#off("b")#. Es ist auch möglich mehrere PICTURE mit dem Opera­
    tor #on("b")#CAT#off("b")# aneinanderzufügen, wenn beide PICTURE die gleiche Dimension haben. In
    solcherart manipulierten Bildern kann ohne Einschränkung weitergezeichnet werden,
    solange die maximale Größe nicht überschritten wird. 
 
#type ("trium12")# 
#on("b")#4. Darstellung und Speicherung #off("b")# 
#type ("times8")# 
 
    Für die Darstellung und Speicherung der erzeugten Bilder existiert der Typ #on("b")#PICFILE#off("b")#.
    Dieser besteht aus eienm Datenraum mit max. 1024 PICTUREs, die mit den Prozeduren #on("b")#
    delete picture, insert picture, read picture, write picture, get picture#off("b")# und #on("b")#put picture#off("b")# einge­
    geben bzw. ausgegeben werden können. 
    Für die Positionierung innerhalb eines PICFILES stehen die Prozeduren #on("b")#to pic, up, down,
    eof, picture no, pictures#off("b")# zur Verfügung. 
    Für die Assoziation mit einem benannten Datenraum existiert ähnlich wie beim Datentyp
    FILE die Prozedur #on("b")#picture file#off("b")#; unbenannte Datenräume können mit dem Operator #on("b")#:=#off("b")#
    assoziert werden. 
    Die Darstellung des PICFILES auf einem Zeichengerät erfolgt mit der Prozdur #on("b")#plot#off("b")#. 
    Da die Graphiken aber in #on("i")#Weltkoordinaten#off("i")# erzeugt werden und die spätere Darstellung
    vollkommen unbeachtet bleibt, müssen gewisse Darstellungsparameter für die Zeichnung
    gesetzt werden. Dies Parameter werden im PICFILE abgelegt und gelten jeweils für alle
    darin enthaltenen PICTURE. Dadurch ist es möglich, einen PICFILE mit spezifierter
    Darstellungsart über einen SPOOLER an einen Plotter zu senden oder die bei der letzten
    Betrachtung gewählte Darstellung beizubehalten oder zu ändern. 
    Für die Darstellung können den virtuellen Stiften mit der Prozedur #on("b")#select pen#off("b")# reale Stifte
    zugeordnet werden. Voreingestellt ist für alle virtuellen Stifte die Standardfarbe, Standard­
    stärke und durchgängige Linie. Mit #on("b")#background#off("b")# kann eine bestimmte Hintergrundfarbe
    gewählt werden. 
    Indem man einem PICTURE den Stift 0 zuordnet, kann man dieses auch Ausblenden
    wenn es bei dieser Darstellung stört. 
    Die Größe der realen Zeichenfläche kann mit #on("b")#viewport#off("b")# eingestellt werden, wobei die
    gesamte Zeichenfäche voreingestellt ist. Dadurch können auch mehrere PICFILE auf ein
    Blatt oder einen Bildschirm gezeichnet werden, wenn man durch Angabe von #on("i")#background
     (0)#off("i")# das Löschen der Zeichenfläche unterdrückt. 
 
 
#type ("trium12")# 
#on("b")#5. Darstellung zweidimensionaler Graphik#off("b")# 
#type ("times8")# 
 
    Bei der Darstellung zweidimensionaler Bilder muß der zu zeichnende Ausschnitt (das
    #on("i")#Fenster#off("i")#) angegeben werden. Mit der Prozedur #on("b")#window#off("b")# wird durch Angabe der minimalen
    und maximalen X- bzw. Y-Koordinaten ein Fenster definiert. Linien, die über dieses
    Fenster hinausgehen, werden abgeschnitten. Dadurch kann man einen beliebigen Detailaus­
    schnitt eines Bildes ausgeben, ohne das Bild neu generieren zu müssen. 
    Da das so definierte Fenster auf die mit #on("i")#viewport#off("i")# definierte Zeichenfläche abgebildet wird,
    ist der Abbildungsmaßstab durch das Zusammenspiel von #on("i")#viewport#off("i")# und #on("i")#window#off("i")# bestimmt.
    Wenn eine Winkeltreue Darstellung erreicht werdenn soll, muß das Verhältnis der durch
    #on("i")#viewport#off("i")# eingestellten Breite und Höhe und das Verhältnis des durch #on("i")#window#off("i")# eingestellten
    Ausschnitts gleich sein. 
 
#type ("trium12")# 
#on("b")#6. Darstellung dreidimensionaler Graphik#off("b")# 
#type ("times8")# 
 
    Bei dreidimensionalen Zeichnungen wird das Fenster ebenfalls mit #on("b")#window#off("b")# definiert,
    wobei dann allerdings auch der Wertebereich der dritten Dimension (Z-Koordinaten) zu
    berücksichtigen ist. Auch hierbei werden Linien, die über die spezifierte Darstellungs­
    fläche hinausgehen abgeschnitten. Das Abschneiden erfolgt allerdings erst nach der Projek­
    tion auf die Darstellungsfläche, so daß auch Vektoren zu sehen sind, die über das mit
    #on("i")#window#off("i")# angegebene Quader hinausgehen, wenn ihre Projektion innerhalb der Zeichen­
    fläche liegt. 
    Da die dreidimensionale Graphik auf eine zweidimensionale Fläche projeziert wird,
    können aber noch weitere Darstellungsparameter angegeben werden. Der Betrachtungswin­
    kel wird mit Hilfe der Prozedur #on("b")#view#off("b")# angegeben. Ebenfalls kann mit #on("b")#view#off("b")# der Winkel der
    Y-Achse zur Horizontalen angegeben werden. 
    Zur Spezifikation der gewünschten Projektionsart existieren #on("b")#orthographic#off("b")# (orthographische
    Projektion), #on("b")#perspective#off("b")# (perspektivische Projektion, der Fluchtpunkt ist frei wählbar) und
    #on("b")#oblique#off("b")# (schiefwinklige Projektion). 
 
#page# 
#type ("trium12")# 
#on("b")#7. Beispiele#off("b")# 
#type ("times8")# 
 
    #on("u")#Sinuskurve#off("u")# 
 
#type("micro")# 
initialisiere picfile; 
zeichne überschrift; 
zeichne achsen; 
zeichne sinuskurve; 
wähle darstellung; 
plot (p)  . 
 
initialisiere picfile: 
  PICFILE VAR p :: picture file ("SINUS")  . 
 
zeichne überschrift: 
  PICTURE VAR überschrift :: nilpicture; 
  move (überschrift, -pi/2.0, 1.0); 
  draw (überschrift, "sinus (x)  [-pi, +pi]", 0.0, 1.0, 0.6); 
  put picture (p, überschrift)  . 
 
 zeichne achsen: 
  PICTURE VAR achsen :: nilpicture; 
  zeichne x achse; 
  zeichne y achse; 
  put picture (p, achsen)  . 
 
  zeichne x achse: 
  move (achsen, -pi, 0.0); 
  draw (achsen,  pi, 0.0)  . 
 
  zeichne y achse: 
  move (achsen, 0.0, -1.0); 
  draw (achsen, 0.0, +1.0)  . 
 
  zeichne sinuskurve: 
  PICTURE VAR sinus :: nilpicture; 
  REAL VAR x :: -pi; 
 
   move (sinus, x, sin (x)); 
  REP x INCR 0.1; 
      draw (sinus, x, sin (x)) 
  UNTIL x >= pi PER; 
 
    put picture (p, sinus)  . 
 
  wähle darstellung: 
  window (p, -pi, pi, -1.0, 1.3); 
  viewport (p, 0.0, 0.0, 0.0, 0.0)  . 
 
#page# 
#type ("times8")# 
    #on("u")#Achsenkreuz#off("u")# 
 
#type("micro")# 
initialisiere picfile; 
zeichne die x achse; 
zeichne die y achse; 
zeichne die z achse; 
stelle das achsenkreuz dar  . 
 
initialisiere picfile: 
  PICFILE VAR p :: picture file ("KREUZ")  . 
 
 zeichne die x achse: 
  PICTURE VAR x achse := nilpicture; 
  move (x achse, -1.0, 0.0, 0.0); 
  draw (x achse, "-X", 0.0, 0.0, 0.0); 
  draw (x achse,  1.0, 0.0, 0.0); 
  draw (x achse, "+X", 0.0, 0.0, 0.0); 
  put picture (p, x achse)  . 
 
 zeichne die y achse: 
  PICTURE VAR y achse := nilpicture; 
  move (y achse, 0. 0, -1.0, 0.0); 
  draw (y achse, "-Y", 0.0, 0.0, 0.0); 
  draw (y achse, 0.0, 1.0, 0.0); 
  draw (y achse, "+Y", 0.0, 0.0, 0.0); 
  put picture (p, y achse)  . 
 
 zeichne die z achse: 
  PICTURE VAR z achse := nilpicture; 
  move (z achse, 0. 0, 0.0, -1.0); 
  draw (z achse, "-Z", 0.0, 0.0, 0.0); 
  draw (z achse,  0.0, 0.0, 1.0); 
  draw (z achse, "+Z", 0.0, 0.0, 0.0); 
  put picture (p, z achse)  . 
 
 stelle das achsenkreuz dar: 
  viewport (p, 0. 0, 1.0, 0.0, 1.0); 
  window (p, -1.1, 1.1, -1.1, 1.1); 
  oblique (p, 0.25, 0.15); 
  plot (p)  . 
 
#foot# 
  #type("times6")# 
  Diese beiden Beispielprogramme befinden sich ebenfalls auf dem STD-Archive unter dem Namen #on("i")#Beispiel.Sinus#off("i")# und
  #on("i")#Beispiel.Kreuz#off("i")#. 
#end# 
 
#page# 
#type ("triumb14")# Beschreibung der Graphik-Prozeduren 
#type ("times8")# 
 
 
#type ("trium12")# 
#on("b")#1. PICTURE-Prozeduren#off("b")# 
#type ("times8")# 
 
#limit (7.0)##type("times6")# 
             #on("i")#Zweidimensionale PICTURES brauchen weniger Speicherplatz
             als dreidimensionale. Daher werden in einigen Fehlermeldungen
             unterschiedliche Größen angegeben. 
 
#limit (11.0)##type("times8")# 
 
#type("times10")##on("b")#:=#off("b")##type("times8")# 
   OP := (PICTURE VAR l, PICTURE CONST r) 
   Zweck:  Zuweisung 
 
#type("times10")##on("b")#CAT#off("b")##type("times8")# 
   OP CAT (PICTURE VAR l, PICTURE CONST r) 
   Zweck:  Aneinanderfügen von zwei PICTURE. 
   Fehlerfälle: 
       * left dimension <> right dimension 
         Es können nur PICTURE mit gleicher Dimension angefügt werden. 
       * Picture overflow 
         Die beiden PICTURE überschreiten die maximale Größe eines PICTURE. 
 
#type("times10")##on("b")#nilpicture#off("b")##type("times8")# 
   PICTURE PROC nilpicture 
   Zweck:  Die Prozedur liefert ein leeres PICTURE zur Initialisierung. 
 
   PICTURE PROC nilpicture (INT CONST pen) 
   Zweck:  Die Prozedur liefert ein leeres PICTURE mit dem Stift #on("i")#pen#off("i")# zur Initialisierung. 
 
#type("times10")##on("b")#draw#off("b")##type("times8")# 
   PROC draw (PICTURE VAR p, TEXT CONST text, REAL CONST angle, height, ­
              width) 
   Zweck:  Der angegebene Text wird unter dem Winkel #on("i")#angle#off("i")# gegenüber der Waagerech­
           ten mit der Zeichenhöhe #on("i")#hight#off("i")# und der Breite #on("i")#width#off("i")# gezeichnet. #on("i")#angle#off("i")# wird in
           Winkelgrad angegeben. #on("i")#height#off("i")# und #on("i")#width#off("i")# werden in #on("i")#Prozenten#off("i")# der Breite bzw.
           Höhe der Zeichenfläche angegeben, bei 0 wird 
           die Standardhöhe- und breite angenommen. 
           Der Anfang ist dabei die aktuelle Stiftposition, die nicht verändert wird. Es könne
           auch die Steuerzeichen ""1"", ""2"", ""3"", ""10"", ""13"" benutzt werden,
           wobei sie immer in der Richtung #on("i")#angle#off("i")# wirken. 
   Fehlerfälle: 
       * Picture overflow 
         Der Text paßt nicht mehr in das PICTURE. 
 
#type("times10")##on("b")#draw#off("b")##type("times8")# 
   PROC draw (PICTURE VAR p, REAL CONST x, y, z) 
   Zweck:  Zeichnen einer Linie von der aktuellen Position zur Position (x, y, z). 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is two dimensional 
 
   PROC draw (PICTURE VAR p, REAL CONST x, y) 
   Zweck:  Zeichnen einer Linie von der aktuellen Position zur Position (x, y). 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is three dimensional 
 
#type("times10")##on("b")#draw r#off("b")##type("times8")# 
   PROC draw r (PICTURE VAR p, REAL CONST x, y, z) 
   Zweck:  Zeichnen einer Linie der Länge (x, y, z) relativ zur aktuellen Position. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is two dimensional 
 
   PROC draw r (PICTURE VAR p, REAL CONST x, y) 
   Zweck:  Zeichnen einer Linie der Länge (x, y) relativ zur aktuellen Position. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is three dimensional 
 
#type("times10")##on("b")#move#off("b")##type("times8")# 
   PROC move (PICTURE VAR p, REAL CONST x, y, z) 
   Zweck:  Die aktuelle Position wird auf (x, y, z) gesetzt. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is two dimensional 
 
   PROC move (PICTURE VAR p, REAL CONST x, y) 
   Zweck:  Die aktuelle Position wird auf (x, y) gesetzt. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is three dimensional 
 
#type("times10")##on("b")#move r#off("b")##type("times8")# 
   PROC move r (PICTURE VAR p, REAL CONST x, y, z) 
   Zweck:  Die aktuelle Position wird um (x, y, z) erhöht. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is two dimensional 
 
   PROC move r (PICTURE VAR p, REAL CONST x, y) 
   Zweck:  Die aktuelle Position wird um (x, y) erhöht. 
           Position. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is three dimensional 
 
 
#type("times10")##on("b")#bar#off("b")##type("times8")# 
   PROC bar (PICTURE VAR p, REAL CONST width, hight, INT CONST pattern): 
   Zweck:  Die Prozedur zeichnet an der aktuellen Position einen Balken mit dem Muster
              #on("i")#pattern#off("i")#: 
              0  =  Leerer Balken 
              1  =  Gepunkteter Balken 
              2  =  Gefüllter Balken 
              3  =  Horizontale Linien 
              4  =  Vertikale Linien 
              5  =  Gekreuzte Linien 
              6  =  Diagonale Linien von Links nach Rechts 
              7  =  Diagonale Linien von Rechts nach Links 
              8  =  Gekreuzte diagonale Linien 
            > 8  =  nicht normiertes Sondermuster 
          Die aktuelle Stiftposition wird dabei nicht verändert. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is three dimensional 
 
   PROC bar (PICTURE VAR p, REAL CONST from, to, hight, INT CONST pattern): 
   Zweck:  Die Prozedur zeichnet einen Balken von der Position #on("i")#from#off("i")# zur Position #on("i")#to#off("i")# und der
           Höhe #on("i")#height#off("i")# mit dem Muster #on("i")#pattern#off("i")#. 
           s.o. 
 
#type("times10")##on("b")#circle#off("b")##type("times8")# 
   PROC circle (PICTURE VAR p, REAL CONST radius, from, to, INT CONST pattern) 
   Zweck:  Die Prozedur zeichnet an der aktuellen Position ein Kreissegment vom Winkel
           #on("i")#from#off("i")# bis #on("i")#to#off("i")# (im Gradmaß) mit dem Muster #on("i")#pattern#off("i")# (s.o.). Der #on("i")#radius#off("i")# wird in
           Prozenten der Diagonalen der Zeichenfläche angegeben. 
           Die aktuelle Stiftposition wird dabei nicht verändert. Dieses Kreissegment ist in
           jedem Fall 2-dimensional, so das es durch Drehungen nicht verändert wird. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
       * Picture is three dimensional 
 
#type("times10")##on("b")#mark#off("b")##type("times8")# 
   PROC mark (PICTURE VAR p, REAL CONST size, INT CONST no) 
   Zweck:  Es wird ein Marker mit der Größe #on("i")#size#off("i")# in Prozenten der Diagonalen der Zeichen­
           fläche an der aktuellen Stiftposition ausgegeben, ohne diese zu verändern. Es
           sollten dabei mindestens 10 verschiedene Marker gewählt werden können. 
   Fehlerfälle: 
       * Picture overflow 
         Zu viele Befehle in einem PICTURE 
 
#type("times10")##on("b")#dim#off("b")##type("times8")# 
   INT PROC dim (PICTURE CONST pic) 
   Zweck:  Liefert die Dimension eines PICTURE. 
 
#type("times10")##on("b")#pen#off("b")##type("times8")# 
   INT PROC pen (PICTURE CONST p) 
   Zweck:  Liefert den virtuellen Stift des PICTURE 
 
   PICTURE PROC pen (PICTURE CONST p, INT CONST pen) 
   Zweck:  Setzen des (virtuellen) Stiftes eines PICTURE. 
           Bei #on("i")#pen#off("i")# = 0 wird das Picture nicht gezeichnet. 
   Fehlerfälle: 
       * pen out of range 
         Der gewünschte Stift ist kleiner als 0 oder größer als 16. 
 
#type("times10")##on("b")#extrema#off("b")##type("times8")# 
   PROC extrema (PICTURE CONST p, REAL VAR x min, x max, y min, y max) 
   Zweck:  Die Prozedur liefert die größten und kleinsten Werte des PICTURE. 
   Fehlerfälle: 
       * Picture is three dimensional 
 
   PROC extrema (PICTURE CONST p, REAL VAR x min, x max, y min, y max,  
   z min, z max) 
   Zweck:  Die Prozedur liefert die größten und kleinsten Werte des PICTURE. 
   Fehlerfälle: 
       * Picture is two dimensional 
 
#type("times10")##on("b")#where#off("b")##type("times8")# 
   PROC where (PICTURE CONST p, REAL VAR x, y, z) 
   Zweck:  Die Prozedur liefert die aktuelle Stiftposition. 
   Fehlerfälle: 
       * Picture is two dimensional 
 
   PROC where (PICTURE CONST p, REAL VAR x, y, z) 
   Zweck:  Die Prozedur liefert die aktuelle Stiftposition. Fehlerfälle: 
       * Picture is three dimensional 
 
#type("times10")##on("b")#rotate#off("b")##type("times8")# 
   PROC rotate (PICTURE VAR p, REAL CONST angle) 
   Zweck:  Das PICTURE wird um den Punkt (0, 0) um den Winkel #on("i")#angle#off("i")# (im Gradmaß) im
           mathematisch positiven Sinn gedreht. 
 
   PROC rotate (PICTURE CONST p, REAL CONST phi, theta, lambda) 
   Zweck:  Das PICTURE wird um den Winkel #on("i")#lambda#off("i")# um die Drehachse #on("i")#(phi, theta)#off("i")# ge­
           dreht. 
 
#type("times10")##on("b")#stretch#off("b")##type("times8")# 
   PROC stretch (PICTURE VAR pic, REAL CONST sx, sy) 
   Zweck:  Das PICTURE wird in X-Richtung um den Faktor #on("i")#sx#off("i")#, in Y-Richtung um den
           Faktor #on("i")#sy#off("i")# gestreckt (bzw. gestaucht). Dabei bewirkt der Faktor 
                 s   >  1    eine Streckung 
           0  <  s   <  1    eine Stauchung 
                 s   <  0    zusätzlich eine Achsenspiegelung. 
   Fehlerfälle: 
       * Picture is three dimensional 
 
   PROC stretch (PICTURE VAR p, REAL CONST sx, sy, sz) 
   Zweck:  s. o. 
   Fehlerfälle: 
       * Picture is two dimensional 
 
#type("times10")##on("b")#translate#off("b")##type("times8")# 
   PROC translate (PICTURE VAR p, REAL CONST dx, dy) 
   Zweck:  Das PICTURE wird um #on("i")#dx#off("i")# und #on("i")#dy#off("i")# verschoben. Fehlerfälle: 
       * Picture is three dimensional 
 
   PROC translate (PICTURE VAR p, REAL CONST dx, dy, dz) 
   Zweck:  Das PICTURE wird um #on("i")#dx, dy#off("i")# und #on("i")#dz#off("i")# verschoben. Fehlerfälle: 
       * Picture is two dimensional 
 
 
#type ("trium12")# 
#on("b")#2. PICFILE-Prozeduren#off("b")# 
#type ("times8")# 
 
#type("times10")##on("b")#plot#off("b")##type("times8")# 
   PROC plot (TEXT CONST name) 
   Zweck:  Der PICFILE mit dem Namen #on("i")#name#off("i")# wird entsprechend der angegebenen Dar­
           stellungsart gezeichnet. Diese Parameter (#on("i")#perspective, orthographic, oblique, view,
           window etc.#off("i")#) müssen vorher eingestellt werden. 
   Fehlerfälle: 
       * PICFILE does not exist 
         Es existiert kein PICFILE mit dem Namen #on("i")#name#off("i")# 
 
   PROC plot (PICFILE VAR p) 
   Zweck:  Der PICFILE #on("i")#p#off("i")# wird entsprechend der angegebenen Darstellungsart gezeichnet.
           Diese Parameter müssen vorher eingestellt werden: 
 
           #on("b")#zweidimensional:#off("b")# 
           obligat:        #on("i")#window#off("i")#            (zweidimensional) 
           optional:       #on("i")#view#off("i")#              (zweidimensional) 
                           #on("i")#viewport#off("i")# 
                           #on("i")#select pen#off("i")# 
 
           #on("b")#dreidimensional:#off("b")# 
           obligat:        #on("i")#window#off("i")#            (dreidimensional) 
           optional:       #on("i")#view#off("i")#              (dreidimensional) 
                           #on("i")#orthographic | perspective | oblique#off("i")# 
                           #on("i")#viewport#off("i")# 
                           #on("i")#select pen#off("i")# 
 
 
#type("times10")##on("b")#select pen#off("b")##type("times8")# 
   PROC select pen (PICFILE VAR p, INT CONST pen, colour, thickness, line type) 
   Zweck:  Für die Darstellung des Bildes #on("i")#p#off("i")# soll dem #on("i")#virtuellen#off("i")# Stift #on("i")#pen#off("i")# ein realer Stift
           zugeordnet werden, der möglichst die Farbe #on("i")#colour#off("i")# und die Dicke #on("i")#thickness#off("i")# hat
           und dabei Linien mit dem Typ #on("i")#line type#off("i")# zeichnet. Es wird die beste Annäherung
           für das Ausgabegerät genommen. 
           Dabei gelten folgende Vereinbarungen: 
 
           #on("b")#Farbe:#off("b")# Negative Farben werden XOR gezeichnet (dunkel wird hell und hell wird
                  dunkel), Farbe 0 ist der Löschstift und positive Farben überschreiben
                  (ersetzen) den alten Punkt mit folgenden Werten: 
 
                  1      Standardfarbe des Endgerätes 
                  2      rot 
                  3      blau 
                  4      grün 
                  5      schwarz 
                  6      weiß 
                  >  6    nicht normierte Sonderfarben 
 
 
           #on("b")#Dicke:#off("b")#  0   Standardstrichstärke des Endgerätes 
                  > 0   Strichstärke in 1/10 mm. 
 
 
           #on("b")#Linientyp:#off("b")# 
                  0      keine sichtbare Linie 
                  1      durchgängige Linie 
                  2      gepunktete Linie 
                  3      kurz gestrichelte Linie 
                  4      lang gestrichelte Linie 
                  5      Strichpunktlinie 
                  > 5    nicht normierte Linie 
 
 
           Die hier aufgeführten Möglichkeiten müssen nicht an allen graphischen Endge­
           räten vorhanden sein. Der geräteabhängige Graphik-Treiber wählt jeweils die
           bestmögliche Annäherung. 
 
   Fehlerfälle: 
       * pen out of range 
         #on("i")#pen#off("i")# muss im Bereich 1-16 sein. 
 
#type("times10")##on("b")#background#off("b")##type("times8")# 
   PROC background (PICFILE VAR p, INT CONST colour) 
   Zweck:  Der Hintergrund wird auf die Farbe #on("i")#colour#off("i")# (s.o.) gesetzt wenn möglich. 
           Bei der Angabe #on("i")#background (p, 0)#off("i")# wird das Löschen des Bildschirms unterdrückt,
           so daß das Zeichen mehrerer PICFILE auf einem Blatt möglich wird. 
 
   INT PROC background (PICFILE CONST p): 
   Zweck:  Liefert die eingestellte Hintergrundfarbe. 
 
#type("times10")##on("b")#view#off("b")##type("times8")# 
   PROC view (PICFILE VAR p, REAL CONST alpha) 
   Zweck:  Setzt den Winkel der Y-Achse zur Senkrechten auf #on("i")#alpha#off("i")# Grad, falls diese nicht
           senkrecht auf der Betrachtungsebene steht. 
 
   PROC view (PICFILE VAR p, REAL CONST phi, theta) 
   Zweck:  Dreidimensionale Bilder werden häufig nicht direkt von vorne dargestellt, son­
           dern für die Betrachtung gedreht. Mit der Prozedur #on("i")#view#off("i")# kann die Betrachtungs­
           richtung durch die Polarwinkel #on("i")#phi#off("i")# und #on("i")#theta#off("i")# (im Gradmass) angegeben werden.
           Voreingestellt ist #on("i")#phi#off("i")# = 0 und #on("i")#theta#off("i")# = 0, d.h. senkrecht von oben (Die #on("i")#X-
           Achse#off("i")# bildet die Horizontale und die #on("i")#Y-Achse#off("i")# bildet die Vertikale). 
           Im Gegensatz zu #on("i")#rotate#off("i")# hat #on("i")#view#off("i")# keine Wirkung auf das eigentliche Bild (die
           PICTURE werden nicht verändert), sondern nur auf die gewählte Darstellung. So
           addieren sich zwar aufeinanderfolgende #on("i")#Rotationen#off("i")#, #on("i")#view#off("i")# aber geht immer von der
           Nullstellung aus. Auch kann das Bild durch eine #on("i")#Rotation#off("i")# ganz oder teilweise aus
           oder in das Darstellungsfenster (#on("i")#window#off("i")# gedreht werden. Bei #on("i")#view#off("i")# verändern sich
           die Koordinaten der Punkte nicht, d. h. das Fenster wird mitgedreht. 
 
   PROC view (PICFILE VAR p, REAL CONST x, y, z) 
   Zweck:  Wie oben, nur werden die Winkel nicht in Polarkoordinaten angegeben, sondern
           es wird die Blickrichtung als Vektor in Karthesischen Koordinaten angegeben.
           (Der Betrachtungsvektor muß nicht normiert sein). 
 
#type("times10")##on("b")#viewport#off("b")##type("times8")# 
   PROC viewport (PICFILE VAR p, REAL CONST hormin, hormax, vertmin, vertmax) 
   Zweck:  Die Zeichenfläche auf dem Endgerät, auf dem das Bild dargestellt werden soll,
           wird spezifiziert. Dabei wird sowohl die Größe als auch die relative Lage der
           Zeichenfläche definiert. Der linke untere Eckpunkt der physikalischen Zeichen­
           fläche des Gerätes hat die Koordinaten (0, 0). Die definierte Zeichenfläche er­
           streckt sich 
 
                  #on("i")#hormin   -  hormax#off("i")#        in der Horizontalen, 
                  #on("i")#vertmin  -  vertmax#off("i")#       in der Vertikalen. 
 
           So liegt der linke untere Eckpunkt dann bei (#on("i")#hormin, hormax#off("i")#), der rechte obere
           Eckpunkt bei (#on("i")#hormax, vertmax#off("i")#). 
 
           Damit sowohl geräteunabhängige als auch maßstabgetreue Zeichnungen möglich
           sind, können die Koordinaten in drei Arten spezifiziert werden: 
           a)  #on("b")#Gerätekoordinaten#off("b")# 
               Die Koordinaten können Werte von 0.0 bis 2.0 annehmen. Dabei hat die
               kürzere Seite der physikalischen Zeichenfläche definitionsgemäß die Länge
               1.0. 
           b)  #on("b")#Absolute Koordinaten#off("b")# 
               Die Werte werden in #on("i")#cm#off("i")# angegeben. Dabei müssen die Maximalwerte aber
               größer als 2.0 sein, da sonst Fall a) angenommen wird. 
           c)  #on("b")#Maximale Zeichenfläche#off("b")# Bei der Angabe (0.0, 0.0, 0.0, 0.0) wird die maxi­
               male physikalische Zeichenfläche eingestellt. 
 
           Voreingestellt ist 
                  viewport (0.0, 0.0, 0.0, 0.0) 
           d.h. die größtmögliche physikalische Zeichenfläche, beginnend mit der linken
                unteren Ecke. 
           Der Abbildungsmaßstab wird durch das Zusammenspiel von #on("i")#viewport#off("i")# und
           #on("i")#window#off("i")# festgelegt (s. dort). Dabei ist insbesondere darauf zu achten, daß winkel­
           treue Darstellung nur bei gleichen Verhältnissen von X-Bereich und Breite bzw.
           von Y-Bereich und Höhe möglich ist. 
 
 
#type("times10")##on("b")#window#off("b")##type("times8")# 
   PROC window (PICFILE VAR p, REAL CONST x min, x max, y min, y max) 
   Zweck:  Für die Darstellung eines zweidimensionalen Bildes wird das darzustellende
           Fenster definiert. Alle Bildpunkte, deren X-Koordinaten im Intervall [#on("i")#x min, x
           max#off("i")#] und deren Y-Koordinaten im Bereich [#on("i")#y min, y max#off("i")#] liegen, gehören zum
           definierten Fenster.Vektoren, die außerhalb dieses Fensters liegen, gehen über die
           durch #on("i")#viewport#off("i")# Fläche hinaus und werden abgeschnitten. 
 
           Der Darstellungsmaßstab ergibt sich als 
 
           #ub#               x max - x min               #ue# 
            horizontale Seitenlänge der Zeichenfläche 
 
 
           #ub#               y max - y min               #ue# 
             vertikale Seitenlänge der Zeichenfläche 
 
   PROC window (PICFILE VAR p, REAL CONST x min, x max, y min, y max,  
                                                        z min, z max) 
 
   Zweck:  Für die darstellung eines dreidimensionalen Bildes wird das darzustellende Fenster
           definiert. Alle Bildpunkte, deren X-Koordinaten im Intervall [#on("i")#x min, x max#off("i")#],
           deren Y-Koordinaten im Bereich [#on("i")#y min, y max#off("i")#] und deren Z-Koordinaten im
           Bereich [#on("i")#z min, z max#off("i")#] liegen, gehören zum definierten Fenster. Dieses dreidi­
           mensionale Fenster (#on("i")#Quader#off("i")#) wird entsprechend der eingestellten Projektionsart
           (orthographisch, perspektivisch oder schiefwinklig) und den Betrachtungswinkeln
           (s. #on("i")#view#off("i")#) auf die spezifizierte Zeichenfläche abgebildet. 
           Anders als im zweidimensionalen Fall ist das Problem der Maßstaäbe nicht mehr
           nur durch das Zusammenspiel von #on("i")#window#off("i")# und #on("i")#viewport#off("i")# zu beschreiben. Hier
           spielen auch die Projektionsart und Darstellungswinkel herein. 
 
#type("times10")##on("b")#oblique#off("b")##type("times8")# 
   PROC oblique (PICFILE VAR p, REAL CONST a, b) 
   Zweck:  Bei dem (dreidimensionalen) Bild #on("i")#p#off("i")# wird #on("u")#schiefwinklig#off("u")# als gewünschte Projek­
           tionsart eingestellt. Dabei ist (#on("i")#a, b#off("i")#) der Punkt auf der X-Y-Ebene, auf den der
           EinheitsVektor der Z-Richtung abgebildet werden soll. 
 
#type("times10")##on("b")#orthographic#off("b")##type("times8")# 
   PROC orthographic (PICFILE VAR p) 
   Zweck:  Bei dem (dreidimensionalen) Bild #on("i")#p#off("i")# wird #on("u")#orthographisch#off("u")# als gewünschte Projek­
           tionsart eingestellt. Bei der orthographischen Projektion wird ein dreidimensio­
           naler Körper mit parallelen Strahlen senkrecht auf der Projektionsebene abge­
           bildet. 
 
#type("times10")##on("b")#perpective#off("b")##type("times8")# 
   PROC perspective (PICFILE VAR p, REAL CONST cx, cy, cz) 
   Zweck:  Bei dem (dreidimensionalen) Bild #on("i")#p#off("i")# wird #on("u")#perspektivisch#off("u")# als gewünschte Projek­
           tionsart eingestellt. Der Punkt (#on("i")#cx, 1/cy, cz#off("i")#) ist der Fluchtpunkt der Projektion,
           d. h. alle Parallen zur Z-Achse schneiden sich in diesem Punkt. 
 
#type("times10")##on("b")#extrema#off("b")##type("times8")# 
   PROC extrema (PICFILE VAR p, REAL VAR x min, x max, y min, y max) 
   Zweck:  Die Prozedur liefert die größten und kleinsten Werte des PICFILE. 
 
   PROC extrema (PICFILE VAR p, REAL VAR x min,x max,y min,y max,z min,z max) 
   Zweck:  Die Prozedur liefert die größten und kleinsten Werte des PICFILE. 
 
#type ("trium12")# 
#on("b")#3. Prozeduren zur Manipulation von PICFILE#off("b")# 
#type("times 8")# 
 
#type("times10")##on("b")#:=#off("b")##type("times8")# 
   OP := (PICFILE VAR l, PICFILE CONST r) 
   Zweck:  Zuweisung des PIFILEs #on("i")#r#off("i")# an das PICFILE #on("i")#l#off("i")# 
 
   OP := (PICFILE VAR p, DATASPACE CONST d) 
   Zweck:  Assoziert die PICFILE Variable #on("i")#p#off("i")# mit dem Datenraum #on("i")#d#off("i")# und initialisiert die
           Variable, wenn nötig. 
   Fehlerfälle: 
       * dataspace is no PICFILE 
         Der anzukoppelnde Datenraum hat einen unzulässigen Typ 
 
#type("times10")##on("b")#picture file#off("b")##type("times8")# 
   DATASPACE PROC picture file (TEXT CONST name) 
   Zweck:  Assoziaten eines benannten Datenraumes mit einem PICFILE (s.o.). 
 
#type("times10")##on("b")#to pic#off("b")##type("times8")# 
   PROC to pic (PICFILE VAR p, INT CONST pos) 
   Zweck:  Positioniert auf das PICTURE Nummer #on("i")#pos#off("i")#. 
   Fehlerfälle: 
       *  Position underflow 
          Es wurde eine Position kleiner Null angegeben. 
       *  Position after eof 
          Es wurde versucht, hinter das Ende eines PICFILE zu positionieren. Die letzte
          erlaubte Position ist #on("i")#pictures (p)+1#off("i")#. 
 
#type("times10")##on("b")#up#off("b")##type("times8")# 
   PROC up (PICFILE VAR p) 
   Zweck:  Positioniert genau ein PICTURE zurück. 
   Fehlerfall: 
       *  Position underflow 
          Es wurde versucht, vor das erste PICTURE zu positionieren 
 
   PROC up (PICFILE VAR p, INT CONST n) 
   Zweck:  Positioniert genau #on("i")#n#off("i")# Picture zurück. 
   Fehlerfall: 
       *  Position underflow 
          Es wurde versucht, vor das erste PICTURE zu positionieren 
 
#type("times10")##on("b")#down#off("b")##type("times8")# 
   PROC down (PICFILE VAR p) 
   Zweck:  Positioniert genau ein PICTURE vorwärts. 
   Fehlerfall: 
       *  Position after eof 
          Es wurde versucht, hinter das Ende eines PICFILE zu positionieren. Die letzte
          erlaubte Position ist #on("i")#pictures (p)+1#off("i")#. 
 
   PROC down (PICFILE VAR p, INT CONST n) 
   Zweck:  Positioniert genau #on("i")#n#off("i")# Picture vorwärts. 
   Fehlerfall: 
       *  Position after eof 
          Es wurde versucht, hinter das Ende eines PICFILE zu positionieren Die letzte
          erlaubte Position ist #on("i")#pictures (p)+1#off("i")#. 
 
#type("times10")##on("b")#delete picture#off("b")##type("times8")# 
   PROC delete picture (PICFILE VAR p) 
   Zweck:  Löscht das aktuelle PICTURE 
 
#type("times10")##on("b")#insert picture#off("b")##type("times8")# 
   PROC insert picture (PICFILE VAR p) 
   Zweck:  Fügt ein PICTURE #on("u")#vor#off("u")# der aktuellen Position ein. 
 
#type("times10")##on("b")#read picture#off("b")##type("times8")# 
   PROC read picture (PICFILE CONST p, PICTURE VAR pic) 
   Zweck:  Liest das aktuelle PICTURE. 
 
#type("times10")##on("b")#write picture#off("b")##type("times8")# 
   PROC write picture (PICFILE VAR p, PICTURE CONST pic) 
   Zweck:  Schreibt das PICTURE #on("i")#pic#off("i")# auf der aktuellen Position. 
 
#type("times10")##on("b")#put picture#off("b")##type("times8")# 
   PROC put picture (PICFILE VAR p, PICTURE CONST pic) 
   Zweck:  Schreibt das PICTURE #on("i")#pic#off("i")# an die aktuelle Position und erhöht diese um 1. 
 
#type("times10")##on("b")#get picture#off("b")##type("times8")# 
   PROC get picture (PICFILE VAR p, PICTURE VAR pic) 
   Zweck:  Liest das PICTURE #on("i")#pic#off("i")# an dir aktuellen Position und erhöht diese um 1. 
 
#type("times10")##on("b")#eof#off("b")##type("times8")# 
   BOOL PROC eof (PICFILE CONST p) 
   Zweck:  Liefert genau dann #on("i")#TRUE#off("i")#, wenn das Ende eines PICFILE erreicht ist. 
 
#type("times10")##on("b")#picture no#off("b")##type("times8")# 
   INT PROC picture no (PICFILE CONST p) 
   Zweck:  Liefert die Nummer des aktuellen PICTURE. 
 
#type("times10")##on("b")#pictures#off("b")##type("times8")# 
   INT PROC pictures (PICFILE CONST p) 
    Zweck:  Liefert die Anzahl PICTURE eines PICFILE. 
 
 
#page# 
#type ("trium12")# 
#on("b")#4. Auslieferungsumfang#off("b")# 
#type ("times8")# 
 
   Die EUMEL-GRAPHIK wird auf einer Diskette mit folgendem Inhalt ausgeliefert. 
   Archive #on("i")#Graphik#off("i")#: 
 
       "gen Graphik" 
       "gen Plotter" 
       "GRAPHIK.book" 
       "GRAPHIK.Picfile" 
       "GRAPHIK.Transform" 
       "GRAPHIK.Plot" 
       "GRAPHIK.Plotter" 
       "GRAPHIK.Server" 
       "GRAPHIK.vektor plot" 
       "ZEICHENSATZ" 
       "PC.plot" 
       "HP7475.plot" 
       "Beispiel.Kreuz" 
       "Beispiel.Sinus" 
 
 
 
    #on("u")#Dateiinhalte#off("u")# 
 
    1. "gen Graphik"           Installationsprogramm für Terminals 
    2. "gen Plotter"           Installationsprogramm für Plotter 
    3. "GRAPHIK.book"          enthält diese Beschreibung. 
    4. "GRAPHIK.Picfile"       enthält die Pakete #on("i")#picture#off("i")# und #on("i")#picfile#off("i")#. 
    5. "GRAPHIK.Transform"     stellt das Paket #on("i")#transformation#off("i")# zur Verfügung, in dem
                               interne Prozeduren zur Projektion definiert werden. 
    6. "GRAPHIK.Plot"          definiert die Prozedur #on("i")#plot#off("i")# zur Darstellung eines
                               PICFILES auf dem Terminal 
    7. "GRAPHIK.Plotter"       definiert die Prozedur #on("i")#plotter#off("i")# zur Darstellung eines
                               PICFILES auf dem Plotter 
    8. "GRAPHIK.Server"        Server für einen Plotter-Spool 
    9. "GRAPHIK.vektor plot"   enthält Hilfsprogramme, die bei der Erstellung einer
                               eigenen Terminalanpassung benutzt werden können. 
   10. "ZEICHENSATZ"           enthält einen Zeichensatz für Terminals die im Graphik
                               Modus keinen Text ausgeben können. 
   11. "PC.plot"               Terminalanpassung für IBM-PC und ähnliche. 
   12. "HP7475.plot"           Terminalanpassung für HP7474-Plotter und Geräte mit
                               HP-GL. 
   13. "Beispiel.Kreuz"        Beispielprogramm 
   14. "Beispiel.Sinus"        Beispielprogramm 
 
#type ("trium12")# 
#on("b")#5. Installation#off("b")# 
#type ("times8")# 
 
 
    In der Datei #on("i")#gen Graphik#off("i")# ist ein Installationspragramm enthalten. Nach dem Starten des
    Programms mit #on("i")#run ("gen Graphik")#off("i")# fragt es nach dem Dateinamen der Terminalanpas­
    sung. 
    Steht keine Terminalanpassung für ein Endgerät zur Verfügung (und kann auch nicht
    beschafft werden) so kann man durch Insertieren der Datei #on("i")#GRAPHIK.Picfile#off("i")# lediglich die
    Leistungen der Pakete #on("i")#Picture#off("i")# und #on("i")#Picfile#off("i")# nutzen, ohne die erzeugten Graphiken darstellen
    zu können. 
    Zur Benutzung eines #on("i")#Plotters#off("i")# über einen Spooler wird die Datei #on("i")#gen Plotter#off("i")# gestartet. 
 
 
    Beispiel: 
    1.  archive ("Graphik") 
    2.  fetch all (archive) 
    3.  release (archive) 
    4.  run ("gen Graphik") 
            <--     PC.Plot 
 
 
#type ("trium12")# 
#on("b")#6. Besonderheiten der PC.plot-Anpassung#off("b")# 
#type ("times8")# 
 
 
  Da der IBM-PC verschiedene Graphik- und Text-Modi kennt, wird durch das Pro­
  gramm #on("i")#PC.plot#off("i")# die Prozedur #on("i")#graphik#off("i")# zusätzlich zur Verfügung gestellt. Sie erlaubt es den
  PC in verschiedenen Graphik-Modi zu betreiben. 
 
  PROC graphik (INT CONST modus, pause) 
 
  Modus:  0    ---    Keine Graphik (normaler Textmodus) 
          1    ---    hochauflösende Graphik, 50 Zeilen, 
                      640 * 400 Punkte, einfarbig 
          2    ---    hochauflösende Graphik, 25 Zeilen, 
                      640 * 400 Punkte, einfarbig 
          3    ---    mittlere Auflösung, 640 * 200 Punkte, 3 Farben 
          4    ---    IBM-PC Auflösung, 320 * 200 Punkte, 3 Farben. 
 
  Pause:  Da der PC bei #on("i")#end plot#off("i")# wieder in den Normalmodus umschaltet und die Graphik
          dann nicht mehr zu sehen ist, kann man eine #on("i")#pause#off("i")# angeben. Die hier eingestellte
          Zeit ist aber nicht die Länge der Pause, sondern der Kehrwert der Blinkfrequenz
          proportional. 
 

