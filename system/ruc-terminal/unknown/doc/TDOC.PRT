#type ("elite")##limit (16.2)##block# 
 
#type ("8")##center##on("b")##on("u")#Bedienungshandbuch zum ruc - Graphikterminal#off("u")##off("b")##type ("elite")# 
 
#center#Version 1.1 
 
#center#Oktober 1986 
#free (16.0)# 
ruc - Rolf Uhlig Computer 
GmbH & Co Kommanditgesellschaft 
Sendenhorster Straße 82 
D - 4406 Drensteinfurt 1 
Telefon 02508/8500 
 
Michael Staubermann 
Moränenstraße 29 
D - 4400 Münster-Hiltrup 
Telefon 02501/4320 
#pagenr (""224"", 1)##page (1)# 
#kopf ("Bedienungshandbuch zum ruc - Graphikterminal")# 
#h("1.", "Einige Worte zuvor")# 
 
 
Dieses Terminalprogramm wird in zwei Versionen (für den Basis 108 und den
Apple IIe) geliefert. Die Version ist in der Kommandozeile erkenntlich
(BASIS oder APPLE). 
 
Eigenschaften des Terminals: 
 
- Kommandozeilen für schnelle Offline Parametereinstellung 
- Statuszeile für spezielle Betriebzustände 
- Über 70 programmierbare Funktionstasten 
- Druckerspooler 32k (4 ganze Graphikhardcopys und noch mehr) 
- 7935 Zeichen Empfangspuffer 
- Verschiedene Hardcopy Modi für Text und Graphik 
- 192x280 Punkte auflösender Graphikmodus mit zwei Helligkeitsstufen 
- Zwei Graphikseiten mit getrennter Anzeige/Bearbeitung 
- Viele Graphikroutinen (Bogen, Flächenfüllung, Kreis, Rechteck...) 
- Graphikmodus für Texte in verschieden Richtungen, Dicken, Grössen 
- Griechische Graphikzeichen und Kursivschrift 
- Graphikseiten Scrollen, Mischen, vom Host laden, zum Host schicken 
 
 
Zum Handbuch 
 
Tasten werden durch Angabe ihres Aufdruckes in Grossbuchstaben angegeben und
in spitze Klammern gesetzt (z.B. <TAB>) in einigen Fällen auch durch ihren
Namen (z.B. <DOWN> oder <TOPLEFT>). Eine zusätzlich zu betätigende Umschalt-
taste, wie SHIFT, CTRL, OPEN APPLE (kurz: OA) oder beide zusammen, wird in
der Klammer davorgestellt (z.B. <SHIFT RETURN>). 
 
Nicht druckbare Ascii-Codes (z.B. <ESC> oder <SPACE>), sowie Kommandopara-
meter (z.B. <n>) werden ebenfalls in spitze Klammern gesetzt. Komandopara-
meter werden mit Kleinbuchstaben bezeichnet. 
 
#page# 
#h("2.", "Die Hardware")# 
 
 
Unterstützt wird eine 80-Zeichen Textanzeige, ein Basiskeyboard oder ein
Applekeyboard mit Open-Apple Taste. Am Basis kann ein Drucker angeschlossen
werden. 
 
 
#k("2.1", "Die serielle Schnittstelle")# 
 
Die Parameter der seriellen Schnittstelle können vom Host oder vom Terminal
(LOCAL) eingestellt werden (Siehe Kommando <ESC> <SPACE> <SPACE>). Es wer-
den alle 15 gängigen Baudrates zwischen 50 und 19200 Baud unterstützt. Pari-
tycheck kann mit gerader oder ungerader Parität durchgeführt werden. Fluß-
kontrolle ist in allen Kombinationen aus RTS/CTS, DTR/DSR, XON/XOFF möglich.
Empfohlen wird DTR/DSR oder XON/XOFF. 
 
             Benötigte Verdrahtung der seriellen Schnittstelle 
 
            Pin                                        Priorität 
              2 : TXD Sendedaten    zum Host (RXD)         1 
              3 : RXD Empfangsdaten vom Host (TXD)         1 
              4 : RTS Ready To Send zum Host (CTS)         3 
              5 : CTS Clear To Send vom Host (RTS)         3 
              6 : DSR DataSet Ready vom Host (DTR)         2 
              7 : Masse an Host Masse                      1 
              8 : DCD Eingang, nicht benötigt 
             20 : DTR Data Terminal Ready zum Host (DSR)   2 
 
Priorität: 
 1 : Muß verdrahtet werden 
 2 : Ist bei DSR/DTR Flußkontrolle zu verdrahten 
 3 : Ist bei RTS/CTS Flußkontrolle zu verdrahten 
 
Der Datentransfer geschieht in der Regel mit 8 Datenbits. Sollte der Host
nur über 7 Bit Datentransfer verfügen, müssen einige Einschränkungen bei der
Parameterübergabe von Uploads/Downloads gemacht werden (Kein Farbbit). Die
Anzahl der Datenbits kann auch in der Kommandozeile verändert werden. 
 
 
#k("2.2", "Der Reset")# 
 
Ein Reset bringt das Terminal in einen definierten Zustand. Alle Bildschirm-
seiten und Puffer, sowie der Druckerspooler werden gelöscht. Der Reset kann
vom Host durch 
 
                         #ib(1)#<ESC> 0#ie(1)#    (Hex 1B 30) 
 
initiiert werden, vom Basiskeyboard aus durch <SHIFT SHIFT CTRL>. Die Para-
meter in der Kommandozeile werden dem Setup entnommen. Nach dem Löschen
aller Bildschirmseiten, wird das Makro mit dem Code Hex EF aufgerufen. Dies
ist die Funktionstaste <SHIFT BOTRIGHT>. 
 
#page# 
#h("3.", "Die Kommandozeile")# 
 
 
Die wichtigsten Parameter des Terminals können im laufenden Betrieb in den
beiden Kommandozeilen geändert werden. Die erste Kommandozeile erscheint
beim Basiskeyboard durch Drücken von <SHIFT CE> und beim Apple durch <OA
CTRL X>. 
 
Im Graphikmodus ersetzt die Kommandozeile die untersten 32 Graphikzeilen
(entspricht vier Textzeilen). Man hat also auch im Graphikmodus die Mög-
lichkeit wichtige Parameter in der Kommandozeile zu ändern. 
 
Die angezeigten Einstellungen bieten außerdem eine Informationsmöglichkeit
über die aktuellen Parameter der seriellen Schnittstelle u.s.w. Die zweite
Kommandozeile enthält die Parameter der seriellen Schnittstelle. 
 
Alle in den Kommandozeilen angezeigten Parameter (bis auf BELL ON/BELL OFF)
können auch durch ESC-Kommandos vom Host oder im Localmodus geändert wer-
den. 
Ein laufender Druckvorgang wird unterbrochen, solange die Kommandozeilen
sichtbar sind. 
 
 
#k("3.1", "Tastenfunktionen in der Kommandozeile")# 
 
Folgende Tasten haben in der Kommandozeile eine Wirkung: 
 
Taste              Bedeutung 
#linie ("16.2")#
<UP> oder <DOWN>   Wechselt in die jeweils andere Kommandozeile 
 
<LEFT>             Springt zum vorherigen (linken) Parameter ohne etwas zu
                   verändern. 
 
<RIGHT>            Springt zum nächsten (rechten) Parameter ohne etwas zu
                   verändern. 
 
<SPACE>            Ändert das selektierte Parameterfeld. Das selektierte
                   Parameterfeld ist durch Invertierung hervorgehoben. Die
                   möglichen Parameter wiederholen sich zyklisch. 
 
<ESC>              Die Kommandozeile wird verlassen. Es werden keine Ände-
                   rungen durchgeführt. 
 
<SHIFT S>          Die Kommandozeile wird verlassen. Vorher werden alle
                   Änderungen permanent auf die Diskette geschrieben. Wei-
                   tere Einzelheiten s.u. (Setup) 
 
<SHIFT R>          Alle Parameter werden auf ihre Defaultwerte zurückge-
                   setzt. Die Kommandozeile wird noch nicht verlassen, daher
                   kann dieser 'Reset' durch <ESC> wieder aufgehoben werden. 
                   <CE> oder <CTRL X> Die Kommandozeile wird verlassen. Die
                   Änderungen werden nur im Speicher vermerkt. Nach dem
                   Ein-/Ausschalten des Rechners werden die alten Parameter
                   von der Diskette gelesen. Wird allerdings ein Hardware-
                   reset (s.o.) durchgeführt, sind diese Änderungen nicht
                   verloren. 
 
 
#k("3.2", "Setup")# 
 
Beim Setup, der in der Kommandozeile durch <SHIFT S> ausgelöst werden kann,
werden wichtige Parameter auf die Diskette geschrieben. Sie werden dann
'permanent' und müssen nach dem Einschalten des Terminals nicht neu einge-
stellt werden. Diese Parameter sind die 
- Parameter der seriellen Schnittstelle (2. Kommandozeile) 
- anderen Parameter der Kommandozeilen 
- vom Benutzer programmierte Belegung der Funktionstasten 
- Druckerspezifischen Hardcopyparameter 
 
Vor dem Setup ist zu prüfen, ob der Diskettenschreibschutz entfernt wurde
(Klebeschildchen an der Diskettenseite entfernen). Der Schreibschutz sollte
nach dem Setup wieder angebracht werden. Wurde der Schreibschutz nicht ent-
fernt, wird eine Meldung 'Diskettenschreibschutz entfernen !' angezeigt. In
diesem Falle erscheint nach dem Drücken einer Taste wieder die Kommando-
zeile. 
Wenn keine Diskette einliegt oder ein harter Schreibfehler auftritt, er-
scheint die Meldung 'Setup kann nicht geschrieben werden (Diskettenfeh-
ler)!'. Weitere Schreibversuche sind möglicherweise erfolgreich. 
 
 
#k("3.3", "Die zweite Kommandozeile")# 
 
Beim Basis (erste Zeile zeigt Defaultwerte für <SHIFT R>) 
 
#type ("micron")# 
GER|BASIS|MON OFF|PRT OFF|SCRN ON |KEY CLK|NORVID|SCROLL|BELL ON |CUR FLH|F STRG 
USA  TVI  MON ON  PRT ON  SCRN OFF CLK OFF REVVID  PAGE  BELL OFF CUR STD F CODE 
APL       HEX ON                                                  CUR OFF 
UNI 
#type ("elite")# 
 
Beim Apple (erste Zeile zeigt Defaultwerte für <SHIFT R>) 
 
#type ("micron")# 
USA|APPLE|MON OFF|PRT OFF|SCRN ON |KEY CLK|NORVID|SCROLL|BELL ON |CUR FLH|F STRG 
FLH  TVI  MON ON  PRT ON  SCRN OFF CLK OFF REVVID  PAGE  BELL OFF CUR STD F CODE 
          HEX ON                                                  CUR OFF 
#type ("elite")# 
 
 
Default Andere   Funktion 
#linie ("16.2")# 
Basis 
 GER    USA      Die Zeichensatzeinstellung ist für die gebräuchlichsten 
        APL      vier Zeichensätze in der Kommandozeile möglich. 
        UNI      GER = Deutsch Ascii, USA = US Ascii, APL = APL-Zeichensatz
                 UNI = Deutscher Zeichensatz mit inversen APL Zeichen. Der
                 APL-Zeichensatz entählt auch die Zeichen [\]{|}~. Über
                 ESC-Kommandos lassen weitere Möglichkeiten einstellen. 
 
 BASIS  TVI      Keyboard Emulation. BASIS sendet die Funktionstastencodes
                 mit Bit 7 = 1. TVI sendet für jede Funktionstaste eine
                 Zeichenfolge <SOH> x <CR>. Die Cursortasten sowie DEL CHAR,
                 INS CHAR, DEL LINE, INS LINE werden wie bei TVI üblich
                 gesendet. Weiter Einzelheiten s.u. (TVI-Emulation) 
 
Apple 
 USA    FLH      USA = US Ascii, FLH = Voller Ascii Zeichensatz mit Blinken
                 und Invers. 
 
 APPLE  TVI      Keyboard Emulation. APPLE führt keine Codeumsetzung durch.
                 Wird allerdings die <OPEN APPLE>-Taste mit einer anderen
                 Taste zusammen gedrückt, wird das Bit 7 im Code auf 1 ge-
                 setzt. Zur TVI-Emulation siehe oben. 
 
MON OFF MON ON   Der Monitor Modus wird mit MON ON eingeschaltet. In diesem 
        HEX ON   Modus werden alle Steuerzeichen auf dem Bildschirm mar-
                 kiert ausgegeben. Bis auf die Kommandos <ESC> u oder <ESC>
                 X (um den Monitormodus auszuschalten) werden keine Komman-
                 dos interpretiert. Alle anderen Zeichen werden unverändert
                 dargestellt. Der Monitormodus kann auch durch MON OFF aus-
                 geschaltet werden. 
                 Im Hexmodus werden keine Zeichen, sondern deren Ascii-
                 Codes in Hexadezimaldarstellung ausgegeben. 
 
PRT OFF PRT ON   Parallele Druckerausgabe. Ist PRT ON eingeschaltet, werden
                 alle Zeichen die von der seriellen Schnittstelle kommen,
                 auf dem Drucker ausgegeben bzw. in den Druckerspooler ge-
                 schrieben. Die Bildschirmausgabe wird hiervon nicht beein-
                 flußt. 
 
SCRN ON SCR OFF  Bildschirmausgabe an/aus. Ist SCRN ON eingeschaltet, wer-
                 den alle Zeichen die von der seriellen Schnittstelle kom-
                 men, auf dem Bildschirm ausgegeben. SCR OFF und PRT ON kann
                 zum Beispiel benutzt werden, um Daten nur an den Drucker zu
                 schicken, ohne daß diese auch auf dem Bildschirm erschei-
                 nen. 
 
KEY CLK CLK OFF  Tastaturklick an/aus. Ist KEY CLK eingeschaltet, gibt jede
                 Taste (bis auf SHIFT, CTRL) bei ihrer Betätigung einen Ton
                 (Klick) von sich. CLK OFF schaltet dies ab. 
 
NORVID  REVVID   Bildschirmdarstellung. NORVID stellt hellen Text auf
                 schwarzem Grund dar, REVVID stellt schwarzen Text auf hel-
                 lem Grund dar (Möglicherweise angenehmer für die Augen). 
 
SCROLL  PAGE     Ist SCROLL eingeschaltet, wird der Bildschirm um eine Zeile
                 nach oben geschoben, sobald der Cursor in der letzten Bild-
                 schirmzeile steht und ein Zeilenvorschub <LF> ausgeführt
                 werden soll. Die erste Bildschirmzeile verschwindet. Ist
                 PAGE eingeschaltet, springt der Cursor in einer solchen
                 Situation in die erste Bildschirmzeile. Die Cursorspalte
                 wird dabei nicht verändert. 
 
BELL ON BELL OFF Normalerweise erzeugt jedes empfangene <CTRL G> einen kur-
                 zen Signalton. Wenn das stört, kann die Tonausgabe mit BELL
                 OFF abgeschaltet werden. 
 
CUR FLH CUR STD  Cursordarstellung. CUR FLH zeigt einen blinkenden CUR OFF
                 Cursorblock. CUR STD zeigt einen nichtblinkenden Cursor-
                 block. CUR OFF schaltet den Cursor ab (unsichtbar). 
 
F STRG  F CODE   Funktionstastenbelegung. Ist F STRG eingeschaltet, erzeugt
                 eine programmierte (belegte) Funktionstaste keinen Tasten-
                 code, sondern sendet die programmierten Zeichen. Eine unbe-
                 legte Funktionstaste sendet ihren Tastencode. Ist F CODE
                 eingeschaltet, erzeugen auch belegte Funktionstasten einen
                 Tastencode und senden keine programmierten Zeichen. 
 
 
#k("3.4", "Die zweite Kommandozeile")# 
 
Die erste Zeile zeigt Defaultwerte für <SHIFT R>: 
 
#type ("micron")# 
STATOFF|TXT| 9600|STOP 1|DATA 8|NO  PAR|NO XONOFF|NO RTSCTS|NO DTRDSR 
STAT ON GFX 19200 STOP 2 DATA 7 EVN PAR  XON/XOFF  RTS/CTS   DTR/DSR 
               50               ODD PAR 
               75 
            109.9 
            134.6 
              150 
              300 
              600 
             1200 
             1800 
             2400 
             3600 
             4800 
             7200 
#type ("elite")# 
 
Default Andere   Funktion 
#linie ("16.2")# 
STATOFF STAT ON  Anzeige der Statuszeile. Der Arbeitsbereich des Bildschirms
                 beträgt zwar immer 24 Zeilen, allerdings ist bei STAT ON
                 anstelle der 24. Textzeile die Statuszeile sichtbar. Bei
                 STATOFF wird der aktuelle Inhalt der 24. Textzeile sicht-
                 bar. Einzelheiten s.u. (Die Statuszeile) 
 
TXT     GFX      Textmodus/Graphikmodus. TXT schaltet in die 80x24 Zeichen
                 Textdarstellung um. GFX schaltet auf die aktuelle Graphik-
                 seite um. 
 
9600    19200    Wählt die Baudrate für die serielle Schnittstelle. 
           50    Die Angabe erfolgt in Bits/Sekunde (Baud) 
           75 
          109.9 
          134.6 
          150 
          300 
          600 
         1200 
         1800 
         2400 
         3600 
         4800 
         7200 
 
STOP 1  STOP 2   Wählt die Anzahl der Stopbits für die serielle Schnitt-
                 stelle. 
 
DATA 8  DATA 7   Wählt die Anzahl der Datenbits für die serielle Schnitt-
                 stelle. 
 
NO PAR  EVN PAR  Wählt Parity Check Art. NO PAR = Kein Paritätsbit, keine 
        ODD PAR  Paritätsprüfung. EVN PAR = Gerade Parität, ODD PAR = Unge-
                 rade Parität. 
 
NO XONOFF        Wählt XON (CTRL Q) und XOFF (CTRL S) als Protokoll für die 
        XON/XOFF serielle Schnittstelle. Wird XOFF vom Host gesendet, kann
                 das Terminal noch 255 Zeichen empfangen, bis der Empfangs-
                 puffer überläuft. Mit NO XONXOFF wird dieses Protokoll
                 ausgeschaltet. 
 
NO RTSCTS        Wählt RTS/CTS als Protokoll für die serielle Schnittstel-
        RTS/CTS  le. Mit NO RTSCTS wird dieses Protokoll ausgeschaltet. 
 
NO DTRDSR        Wählt DTR/DSR als Protokoll für die serielle Schnittstel-
        DTR/DSR  le. Mit NO DTRDSR wird dieses Protokoll ausgeschaltet. 
 
#page# 
#h("4.", "Die Statuszeile")# 
 
 
Die Statuszeile enthält 5 Felder, die über die wichtigsten Betriebszustände
des Terminals Auskunft geben. Die Statuszeile ersetzt die (dann in den 'Hin-
tergrund' verlegte) 24. Zeile. Die Statuszeile kann in der Kommandozeile mit
STAT ON oder vom Host oder im Local Modus mit 
 
                         #ib(1)#<ESC> }#ie(1)#   (Hex 1B 7D) 
 
eingeschaltet werden. Ausschalten ebenso mit STATOFF oder 
 
                         #ib(1)#<ESC> {#ie(1)#   (Hex 1B 7B) 
 
Die Zuordnung der Felder: 
 
#type ("micron")# 
Spooler | Empfängerpuffer | Senderpuffer | Bereit/Beschäftigt | Local/Online
#type ("elite")# 
 
Kritische Zustände werden invers markiert. Dies sind alle Fälle, in denen
ein Puffer überläuft. 
Ist dies beim Empfangspuffer der Fall (RX FULL), gehen Daten verloren. 
Sollte der Druckerpuffer voll sein (PR FULL) und das Terminal keine Eingabe
mehr annehmen, kann man durch längeres Drücken von <SHIFT ESC> Zeichen aus
dem Druckerpuffer entfernen, damit wieder Platz frei wird. 
Sollte der Senderpuffer voll sein (TX FULL), so liegt das wahrscheinlich
daran, daß der Host kein XON gesendet hat oder dieses falsch übertragen
wurde. Durch Drücken von <SHIFT ESC> kann man den Transmitter wieder star-
ten. 
 
 
#k("4.1", "Spoolerstatus")# 
 
- Ein leeres Feld bedeutet: Der Spooler (Druckerpuffer) ist leer, es ist
  nichts zum Drucken im Puffer. 
 
- PRINT zeigt an: Der Spooler ist gefüllt. Das Terminal ist druckwillig oder
  der Drucker druckt. 
 
- PR FULL bedeutet: Der Druckerpuffer ist voll. Da das Terminal keine wei-
  teren Zeichen annimmt bis wieder Platz im Druckerpuffer ist, kann man
  einzelne Zeichen mit <SHIFT ESC> aus dem Druckerpuffer entfernen bis PRINT
  im Feld erscheint. 
 
 
#k("4.2", "Empfängerstatus")# 
 
- Ein leeres Feld bedeutet: Im Empfängerpuffer ist noch Platz. 
 
- RX FULL zeigt an: Es gehen Empfangsdaten verloren, da der Empfängerpuffer
  voll ist. 
 
 
#k("4.3", "Senderstatus")# 
 
- TX ON bedeutet: Der Sender ist eingeschaltet. Wenn jetzt ein Zeichen ge-
  sendet werden muß, wird es sofort auf die serielle Schnittstelle ge-
  schickt. 
  Ein > vor TX ON zeigt an, daß das Terminal auf Freiwerden der seriellen
  Schnittstelle wartet. 
 
- TX OFF bedeutet: Der Host hat entweder XOFF gesendet oder die Hardware-
  flußkontrolle aktiviert, um das Terminal zu stoppen. 
 
- TX FULL zeigt an: Der Senderpuffer ist voll. Das Terminal nimmt keine
  Eingaben mehr an bis der Puffer wieder frei ist. Dies kann mit <SHIFT ESC>
  erzwungen werden. 
 
 
#k("4.4", "Busy - Anzeige")# 
 
- READY bedeutet: Der Empfänger ist empfangsbereit, d.h. im Empfangspuffer
  sind noch mindestens 256 Zeichen frei und das Terminal hat den Host nicht
  per Flußkontrolle gestoppt. 
 
- BUSY bedeutet: Der Empfänger hat dem Host per Flußkontrolle angezeigt, daß
  nicht mehr genügend Platz im Empfangspuffer war. Die Flußkontrolle wird
  wieder freigegeben, wenn nur noch 256 Bytes im Empfangspuffer sind. 
  (Warnung: Wenn BUSY angezeigt wird, eine Taste gedrückt wird und der Host
  #on("u")#nicht#off("u")# empfangsbereit ist, gerät das Terminal in eine
  "Deadlock-Situation", die (mit Datenverlust) nur durch einen Hardwarereset
  abgebrochen werden kann.) 
 
 
#k("4.5", "Online/Local - Anzeige")# 
 
- ONLINE bedeutet: Das Terminal sendet Tasteneingaben an den Host und emp-
  fängt Zeichen und Kommandos vom Host. 
 
- LOCAL bedeutet: Keyboardeingaben erscheinen auf dem Bildschirm bzw. blei-
  ben innerhalb des Terminals. Escape-Kommandos wirken direkt auf das Ter-
  minal. 
 
#page# 
#h("5.", "Die Bedeutung der Tasten")# 
 
 
Zusätzlich zu den normalerweise von der Tastatur gesendeten Tastencodes sind
einige weitere zur Verfügung gestellt worden. Beim Apple senden fast alle
Tasten mit Open-Apple zusammen einen Code mit Bit 7 = 1. Diese werden vom
Terminal als Funktions- oder Steuertasten interpretiert. Beim Basis wurden
einige bisher nur einfach belegte Tasten wie <RETURN>, <TAB>, <ESC>, <CE>
und der Zehnerblock mit Doppelfunktionen über <SHIFT> versehen. 
 
 
#k("5.1", "Die Funktions- und Steuertasten")# 
 
Zuerst werden die Tastenfunktionen erläutert für ein nicht emulierendes
Terminal. Die TVI-Emulation kann in der Kommandozeile abgeschaltet werden
(1. Zeile, 2. Feld) oder mit dem Kommando 
 
                         #ib(1)#<ESC> <SPACE> 0#ie(1)#    (Hex 1B 20 30) 
 
Die Cursortasten liefern beim Basiskeyboard andere Tastencodes als beim
Applekeyboard. Wird das Bit 7 ignoriert (ausgeblendet), stimmen die Codes
überein. <TOPLEFT> bezeichnet beim Basiskeyboard die linke obere Eckposi-
tion des Cursorblocks, <TOPRIGHT> die rechte obere etc. 
 
Basis-Taste    Apple-Taste  Hex-Code   Bedeutung 
#linie ("16.2")# 
<TAB>            <TAB>         09      Der Cursor wird an die nächste (re-
                                       chte) Tabulatorposition gesetzt.
                                       Tabulatorpositionen sind alle 8 Spal-
                                       ten. Also 1, 9, 17, 25, 33, 41, 49,
                                       57, 65, 73. War der Cursor in Spalte
                                       73 bis 79, dann wird er in die erste
                                       Spalte der nächst tieferen Bild-
                                       schirmzeile gesetzt. War der Cursor
                                       vorher auch noch in Zeile 24, dann
                                       wird der Bildschirminhalt entweder
                                       nach oben gescrollt (SCROLL) oder in
                                       Homeposition gebracht (PAGE). 
 
<SHIFT TAB>      <OA TAB>      89      Back-Tab (Rückwärtstabulator). Der
                                       Cursor wird in die nächste links vom
                                       Cursor befindliche Tabulatorposition
                                       gebracht. War der Cursor in Spalte 1,
                                       dann steht er jetzt in Spalte 73 der
                                       darüberliegenden Zeile. War der Cur-
                                       sor in Homeposition, dann ändert sich
                                       seine Position nicht. 
 
<SHIFT CE>       <OA CTRL X>    -      Kommandozeile aktivieren. Einzelhei-
                                       ten zur Kommandozeile siehe Abschnitt
                                       3.: Die Kommandozeilen. 
 
<CE>             <CTRL X>      18      U.a. Kommandozeile verlassen. 
 
<RETURN>         <RETURN>      0D      Zum Zeilenanfang ohne Zeilenvorschub.
                                       Der Cursor steht dann in der ersten
                                       Spalte der Zeile. 
 
<SHIFT RETURN>   <OA RETURN>   8D      Zum Anfang der nächsten Zeile. Falls
                                       der Cursor in der letzten (24.) Bild-
                                       schirmzeile war, wird der Bildschir-
                                       minhalt entweder nach oben gescrollt
                                       (SCROLL) oder in Homeposition ge-
                                       bracht (PAGE). 
 
<UP>             <UP>       8B/0B      Cursor eine Zeile höher. War der
                                       Cursor in der ersten Bildschirmzei-
                                       le, ändert sich seine Position nicht. 
 
<DOWN>           <DOWN>     8A/0A      Cursor eine Zeile tiefer. War der
                                       Cursor in Zeile 24, dann wird der
                                       Bildschirminhalt entweder nach oben
                                       gescrollt (SCROLL) oder der Cursor in
                                       die erste Bildschirmzeile gesetzt
                                       (PAGE). 
 
<CTRL V>         <CTRL V>      16      Cursor eine Zeile tiefer. War der
                                       Cursor in Zeile 24, dann ändert er
                                       seine Position nicht. Die Spalte
                                       ändert sich nicht. 
 
<LEFT>           <LEFT>     88/08      Cursor eine Spalte nach links. War
                                       der Cursor in der ersten Bildschirm-
                                       spalte, dann steht er jetzt in der
                                       letzten Spalte der darüberliegenden
                                       Bildschirmspalte. War der Cursor
                                       allerdings in Homeposition, ändert
                                       sich seine Position nicht. 
 
<RIGHT>             -          95      Cursor eine Spalte nach rechts. War
                                       der Cursor in Spalte 79, dann steht
                                       er jetzt in der ersten Spalte der
                                       folgenden Zeile. War der Cursor in
                                       der letzten Zeile, dann wird der
                                       Bildschirminhalt um eine Zeile nach
                                       oben gescrollt (SCROLL) oder der
                                       Cursor in Homeposition gebracht
                                       (PAGE). 
 
<HOME>           <OA @>        C0      Der Cursor wird in die linke obere
                                       Bildschirmecke gebracht (Homeposi-
                                       tion). 
 
<SHIFT HOME>     <OA P>        D0      Bildschirm löschen und Cursor Home. 
 
<DELETE>         <DELETE>      7F      Dieses Zeichen wird auf dem Bild-
                                       schirm als Punktraster dargestellt.
                                       Der Host interpretiert es in der
                                       Regel als Zeichenlöschbefehl. 
 
<TOPLEFT>        <OA CTRL N>   8E      Zeichen bei Cursorposition einfügen.
                                       Der Cursor ändert seine Position
                                       nicht. Unter dem Cursor steht dann
                                       ein Leerzeichen. Das Zeichen in Spal-
                                       te 79 geht verloren. 
 
<SHIFT TOPLEFT>  <OA CTRL B>   82      Zeichen unter Cursorposition löschen.
                                       In Spalte 79 steht dann ein Leerzei-
                                       chen. 
 
<TOPRIGHT>       <OA CTRL O>   8F      Zeile bei Cursorposition einfügen.
                                       Die Cursorposition ändert sich nicht.
                                       Der Inhalt der letzten Bildschirmzei-
                                       le ist verloren. Die Zeile in der der
                                       Cursor steht wird mit Leerzeichen
                                       gefüllt. 
 
<SHIFT TOPRIGHT> <OA CTRL C>   83      Zeile in der der Cursor steht lö-
                                       schen. Die Cursorposition ändert sich
                                       nicht. Der Inhalt der gelöschten
                                       Zeile ist verloren. Die letzte Bild-
                                       schirmzeile wird mit Leerzeichen
                                       aufgefüllt. 
 
<BOTTOMLEFT>     <BACKSPACE>   08      Cursor eine Spalte nach links. Die
                                       Funktion ist mit der von <LEFT> iden-
                                       tisch. 
 
<BOTTOMRIGHT>    <RIGHT>       15      Apple: Cursor eine Spalte nach re-
                                       chts. Die Funktion ist mit der von
                                       <RIGHT> identisch. 
 
<SHIFT BOTTOMRIGHT> <OA RIGHT> EF      Diese Taste ist eine programmierbare
                                       Funktionstaste (siehe <ESC> e). 
 
<SHIFT DELETE>   <OA DELETE>   81      Diese das liefert den
                                       Makroparametercode (siehe <ESC> e). 
 
<ESC>            <ESC>         1B      Leitet eine Escape-Sequenz ein. 
 
<SHIFT ESC>      <OA ESC>      9B      Während der Funktionstastedefinition
                                       wirkt diese Taste wie ein Local
                                       Escape, sonst liefert sie den Code 9B.
                                       (siehe <ESC> e). 
                                       
<SHIFT CTRL HOME><OA 0>         -      Local/Online umschalten. 
 
<CTRL HOME>      <OA SPACE>   '00'     Sendet V24-Break (Hexcode 00 mit
                                       Rahmenfehler). Als Rahmenfehler wird
                                       das Fehlen des oder der Stopbits
                                       bezeichnet (Stopbitpegel ist norma-
                                       lerweise 1, bei Break dagegen 0). 
 
#on("u")#Zehnerblock:#off("u")# 
 
<SHIFT 1> ...    <OA a> ...    E1 ...  programmierbare Funktionstasten 
<SHIFT 9>        <OA i>        E9             "               " 
<SHIFT 0>        <OA j>        EA             "               " 
<SHIFT .>        <OA k>        EB             "               " 
<SHIFT +>        <OA l>        EC             "               " 
<SHIFT ->        <OA m>        ED             "               " 
 
<SHIFT BOTRIGHT> <OA RIGHT>    EF             "               " 
 (Dieser Code wird beim RESET des 
 Terminals ausgeführt. Der Benut- 
 zer kann damit das Terminal nach 
 seinen Wünschen konfigurieren.) 
 
 
#on("u")#Funktionstasten:#off("u")# 
 
<F1> ...         <OA A> ...    C1             "               " 
<F15>            <OA O>        CF             "               " 
<SHIFT F1> ...   <OA Q> ...    D1             "               " 
<SHIFT F15>      <OA _>        DF             "               " 
<CTRL F1> ...    <OA !> ...    A1             "               " 
<CTRL F15>       <OA />        AF             "               " 
<SHIFT CTRL F1>..<OA 1> ...    B1             "               " 
<SHIFT CTRL F15> <OA ?>        BF             "               " 
 
Die Programmierung der Funktionstasten geschieht mit #ib(1)#<ESC> e#ie(1)#. 
 
 
#k("5.2", "Die TVI-Emulation")# 
 
Wird das Terminal in den TVI-Emulationsmode gebracht, dann senden einige
Tasten andere Tastencodes oder Codesequenzen. Die Bedeutung der Escape-
Sequenzen ändert sich dadurch nicht. 
Der TVI-Modus kann in der Kommandozeile eingeschaltet werden (1. Zeile, 2.
Feld) oder durch 
 
                         #ib(1)#<ESC> <SPACE> 1#ie(1)#    (Hex 1B 20 31) 
 
An dieser Stelle erscheinen nur noch die Tastenbezeichnungen des Basiskey-
boards. Die entsprechenden Tasten, die beim Applekeyboard zu drücken sind,
kann man im letzten Abschnitt nachlesen. 
 
Folgende Tasten senden andere Tastencodes: 
 
Taste       TVI-Code(sequenz)       Bemerkung 
#linie ("16.2")# 
<RIGHT>     0C    #ib(1)#<CTRL L>#ie(1)#          Cursor nach rechts 
 
<HOME>      1E    #ib(1)#<CTRL SHIFT ^>#ie(1)#    Cursor in Homeposition 
 
<CLEAR>     1A    #ib(1)#<CTRL Z>#ie(1)#          Durch Drücken von <SHIFT HOME> 
                                    Bildschirm löschen und Cursor Home 
 
<DEL CHAR>  1B 57 #ib(1)#<ESC> W#ie(1)#           Durch Drücken von <SHIFT TOPLEFT> 
                                    Zeichen löschen 
 
<DEL LINE>  1B 52 #ib(1)#<ESC> R#ie(1)#           Durch Drücken von <SHIFT TOPRIGHT> 
                                    Zeile löschen 
 
<INS CHAR>  1B 51 #ib(1)#<ESC> Q#ie(1)#           Durch Drücken von <TOPLEFT> 
                                    Zeichen einfügen 
 
<INS LINE>  1B 45 #ib(1)#<ESC> E#ie(1)#           Durch Drücken von <TOPRIGHT> 
                                    Zeile einfügen 
 
<LEFT>      08    #ib(1)#<BACKSPACE>#ie(1)#       Cursor nach links 
 
<BACK TAB>  1B 49 #ib(1)#<ESC> I#ie(1)#           Durch Drücken von <SHIFT TAB> 
                                    Rückwärtstabulator 
 
<DOWN>      0A    #ib(1)#<LF>#ie(1)#              Cursor nach unten 
 
<UP>        0B    #ib(1)#<CTRL K>#ie(1)#          Cursor nach oben 
 
<NEWLINE>   1F    #ib(1)#<CTRL SHIFT _>#ie(1)#    Durch Drücken von <SHIFT RETURN> 
                                    Waagenrücklauf und Zeilenvorschub 
 
 
#on("u")#Funktionstasten:#off("u")# 
 
Für jede Funktionstaste, die nicht belegt wurde wird eine Codesequenz der
Form <CTRL A> <code> <CR> also 01 <code> 0D gesendet. Für <code> gilt: 
 
Taste             <code>    Hex-Code 
<F1> ...            @ ...      40 ...   Diese Tasten sind auf fast allen 
<F11>               J          4A       TVI-Terminals vorhanden. 
<F12> ...           ` ...      60 ... 
<F15>               c          63 
 
<SHIFT F1> ...      K ...      4B ... 
<SHIFT F15>         Y          59 
 
 
#on("u")#Zehnerblock:#off("u")# 
 
<SHIFT 1> ...       d ...      64 ... 
<SHIFT 9>           l          6C 
<SHIFT 0>           m          6D 
<SHIFT .>           n          6E 
<SHIFT +>           o          6F 
<SHIFT ->           p          70 
 
<SHIFT BOTRIGHT>    r          72 
 
Alle nicht in dieser Tabelle aufgeführten Funktionstasten senden den Basis-
tastencode. 
 
#page# 
#h("6.", "Der Graphikmodus")# 
 
 
#k("6.1", "Allgemeines")# 
 
Der Graphikmodus kann in der 2. Kommandozeile ein- und ausgeschaltet (Gra-
phik: GFX, Text: TXT) oder mit dem Kommando 
 
                         #ib(1)#<ESC> $#ie(1)#    (Hex 1B 24) 
 
eingeschaltet und mit dem Kommando 
 
                         #ib(1)#<ESC> %#ie(1)#    (Hex 1B 25) 
 
ausgeschaltet. 
 
Die Auflösung beträgt in y-Richtung 280 Punkte und in x-Richtung 192 Punk-
te, das sind 53760 Punkte. 
 
 
#k("6.2", "Koordinaten und Parameterübergabe")# 
 
Die Koordinaten für die Graphikkommandos dürfen den Bereich von -32768 bis
32767 überstreichen. Der sichtbare Bereich ist für die X-Koordinate 0..279
und für die Y-Koordinate von 0..191. Der Ursprung (d.h. der Punkt (0,0) )
des Koordinatensystems ist die linke untere Ecke. Die Graphikroutinen zeic-
hnen nur innerhalb des sichtbaren Bereichs (Clipping). 
 
 
#k("6.2.1", "Cursorposition/Fadenkreuz")# 
 
Der Graphikcursor ist ein gedachter unsichtbarer Punkt, der sich im gesam-
ten (auch unsichtbaren) Bereich des Koordinatensystems befinden kann. Wenn
sich der Cursor im sichtbaren Bereich befindet, dann kann man an der Posi-
tion ein Fadenkreuz darstellen. Das Fadenkreuz kann mit 
 
                         #ib(1)#<CTRL X>#ie(1)# oder #ib(1)#<CE>#ie(1)#    (Hex 18) 
 
ein- und ausgeschaltet werden. Das Fadenkreuz wird Exklusiv-Oder (XOR) ge-
zeichnet. Das heißt, daß die Punkte an der Stelle des Fadenkreuzes inver-
tiert (umgedreht) werden. Das hat wiederum zur Folge, daß an der Graphik-
seite nichts verändert wird, wenn zweimal <CTRL X> gesendet wird. Solange
der Bereich oder die Position des Fadenkreuzes nicht verändert wird, können
zwischen den beiden <CTRL X> Kommandos auch andere Graphikkommandos ausge-
führt werden. 
 
 
#k("6.2.2", "Binäre oder dezimale Parameter")# 
 
Die Übergabe der x/y Koordinaten, eines Radius oder relativer Koordinaten
und in einigen Fällen auch anderer Parameter, kann auf zwei verschiedene
Arten erfolgen. Das Terminal erkennt die Übergabeart am ersten Parameterby-
te: 
Bei dezimalen Parametern ist dies entweder <SPACE>, +, - oder eine Zahl. Bei
Binären Parametern liegt das Höherwertige Byte (das erste!) im Bereich von
00..1F oder 3A..FF. Die Festlegung auf dezimale oder binäre Parameter gilt
für beide (X und Y) Koordinaten. 
 
 
#k("6.2.2.1", "Binäre Parameter")# 
 
Binäre Parameter sind eine Folge von vier Bytes (mit 8 Bits). Die ersten
beiden Bytes stellen die X-Koordinate dar, die anderen beiden Bytes die
Y-Koordinate. Negative Koordinaten oder negative relative Koordinaten wer-
den durch Bilden des Zweierkomplements dargestellt. 
Zu beachten ist, daß zuerst das höherwertige (Highbyte) und dann das nie-
derwertige (Lowbyte) gesendet werden muß. 
 
Der Vorteil der binären Parameter ist, daß die Parameterübergabe schneller
ist als bei dezimalen Parametern, da weder Host noch Terminal eine Konver-
tierung vornehmen müssen und die Anzahl der Parameterbytes in der Regel
geringer ist als bei dezimaler Parameterübergabe. 
 
Der Nachteil ist, daß bei XON/XOFF Flußkontrolle einige Zahlen als XON oder
XOFF interpretiert werden können und daß diese Parameter nicht auf Funk-
tionstasten gelegt werden können, wenn sie Zeichen > Hex 7F enthalten. 
 
 
#k("6.2.2.2", "Dezimale Parameter")# 
 
Dezimale Parameter bestehen aus einer Folge von ASCII-Zeichen. Die beiden
Koordinaten werden durch einen Separator (Komma, CR, Semikolon o.ä.) ge-
trennt. Nach dem 2. Parameter steht ein weiterer Separator. An beliebiger
Stelle in und vor den Zahlen dürfen Leerzeichen (<SPACE>) oder Pluszeichen
(+) stehen, die keine Änderung des Ergebnisses bewirken. Ein Minuszeichen
vor einer Zahl negiert sie. 
 
Der Vorteil der dezimalen Parameter ist, daß sie in höheren Programmier-
sprachen bequem und lesbar in ein Programm geschrieben werden können und daß
keine Steuerzeichen vorkommen, die die XON/XOFF - Flußkontrolle stören könn-
ten. Außerdem können diese Parameter immer auf Funktionstasten gelegt wer-
den, da sie keine Codes > Hex 7F enthalten. 
 
Der Nachteil ist wie unter 6.2.2.1 geschrieben, die Zeitdauer der zweima-
liegen Konvertierung (Host, Terminal) und die in der Regel längeren Parame-
ter. 
 
 
#k("6.2.3", "Absolute oder relative Koordinaten")# 
 
Bei den Move- und Drawbefehlen hat man die Wahl zwischen relativen und abso-
luten Koordinaten. 
 
Absolute Koordinaten setzen den Graphikcursor direkt auf die als Parameter
angegebene Position. Z.B. <ESC> v 200, 100; setzt den Cursor direkt auf die
Position X=200, Y=100. Die meisten Programme unterstützen nur absolute Koor-
dinaten. 
 
Relative Koordinaten werden zur aktuellen Position des Graphikcursors ad-
diert. Das hat den Vorteil, daß eine Routine nicht zu wissen braucht, wo der
Graphikcursor gerade steht. Man kann sich zum Beispiel Folgen von relativen
Move's und Draw's auf Funktionstasten legen, die dann im Localmodus an der
aktuellen Cursorposition irgendwelche Symbole oder Sonderzeichen zeichnen.
Z.B. <ESC> q -4, 3; bewegt den Graphikcursor 4 Punkte nach links und 3 Punk-
te nach oben. 
 
 
#k("6.2.4", "Byteparameter")# 
 
Byteparameter sind solche, die nur aus einem Byte bestehen. Die Werte kön-
nen also normalerweise von 0 bis 255 oder Hex 00 bis Hex FF. In den Fällen,
in denen nicht der ganze Wertebereich genutzt wird, werden nur die nieder-
wertigsten Bits ausaskiert, die höherwertigen werden ignoriert, wenn nicht
ausdrücklich etwas anderes angegeben ist. Im Bereich von 0 bis 7 sind Wert
und ASCII-Ziffer identisch. Bei Werten großer als 9 geht das allerdings
nicht mehr. Sind zum Beispiel die Werte von 0 bis 15 erlaubt, dann kann man
folgende Tabelle benutzen: 
 
#on("u")#Wert   ASCII (Hex) oder Binär#off("u")# 
  0      0     30        00 
  1      1     31        01 
  2      2     32        02 
  3      3     33        03 
  4      4     34        04 
  5      5     35        05 
  6      6     36        06 
  7      7     37        07 
  8      8     38        08 
  9      9     39        09 
 10      :     3A        0A 
 11      ;     3B        0B 
 12      <     3C        0C 
 13      =     3D        0D 
 14      >     3E        0E 
 15      ?     3F        0F 
 
Für Werte zwischen 0 und 31 benutzt man dann besser die Buchstaben (Groß-
buchstaben und [\]^_ oder Kleinbuchstaben und {|}~ und <DEL>). Die Zuord-
nung entnimmt man der ASCII-Tabelle in Anhang A. 
 
 
#k("6.3", "Die Graphikparameter")# 
 
Für die Linien und Zeichen in der Graphik gibt es verschiedene Darstellungs-
weisen. Man kann die Strichdicke, die Farbe (auf einem Monochrommonitor die
Helligkeit), den Linientyp (durchgehend, gepunktet, gestrichelt etc.) und
die Bitverknüpfungen (löschen, invertieren...) festlegen. Diese Parameter
werden mit einem Kommando <ESC> O <n> ... verändert. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> O 0#ie(1)#    (Hex 1B 4F 30) 
 
werden all diese Parameter auf Defaultwerte zurückgesetzt. Diese Default-
werte sind: Strichdicke 1, durchgehende Linie, OR-Bitverknüpfung (Punkte
setzen), helle Farbe (gelb). Ausserdem wird die Seite 0 als sichtbare und
als Arbeitsseite gewählt. Es wird auf ganzseitige Graphik geschaltet (falls
im Graphikmodus). 
 
 
#k("6.3.1", "Strichdicke")# 
 
Die Strichdicke einer Linie ist normalerweise 1. Die Strichdicke 2 zeichnet
parallel zur ursprünglichen Linie auf beiden Seiten jeweils eine weitere
Linie der gleichen Länge. Die Strichdicke 3 zeichnet dann auf beiden Seiten
jeweils zwei parallele Linien usw. Die Strichdicke kann von 1 bis 15 ge-
wählt werden. Sie wird mit dem Kommando 
 
                         #ib(1)#<ESC> O 1#ie(1)# <dicke>   (Hex 1B 4F 31 <dicke>) 
 
eingestellt. <dicke> ist ein Byteparameter (Kapitel 6.2.4) mit dem Wertebe-
reich 1 bis 15. 
 
 
#k("6.3.2", "Farbe/Helligkeit")# 
 
Normalerweise ist Gelb (hell) eingestellt. Die Alternative ist Violett (dun-
kel). Jeweils 7 nebeneinanderliegene Graphikpunkte haben die gleiche Farbe.
Auf einem Farbmonitor kann die Farbe auch noch durch den Inhalt dieser 7
Graphikpunkte bestimmt werden. Der Farbmodus wird von diesem Terminalpro-
gramm allerdings nicht unterstützt, da sich dann die Auflösung in X-Richtung
halbiert (also nur noch 140 x 192 Punkte). 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> O 2#ie(1)# <n>    (Hex 1B 4F 32 <n>) 
 
kann die Helligkeit eingestellt werden. <n> ist ein Byteparameter bei dem
nur das Bit 0 wichtig ist: 
 
Bit 0   Bedeutung 
  0     dunkel/Violett     <n> ist eine gerade Zahl 
  1     hell/Gelb          <n> ist eine ungerade Zahl 
 
 
#k("6.3.3", "Linientyp")# 
 
Der Linientyp ist das "Muster" der Striche. Es gibt 7 vordefinierte Strich-
muster und ein vom Benutzer definiertes. Der Linientyp (im folgenden auch
Pattern genannt) wird mit dem Kommando 
 
                         #ib(1)#<ESC> O 3#ie(1)# <n>    (Hex 1B 4F 33 <n>) 
 
eingestellt. <n> ist ein Byteparameter mit dem Wertebereich von 0 bis 7. Die
Strichtypen sind <n> folgendermaßen zugeordnet: 
 
#on("u")#<n>  Bitmuster (16 Bit)  Name                    #off("u")# 
 0                       unsichtbare Linie 
 1   ----------------    durchgehende Linie 
 2   - - - - - - - -     gepunktete Linie 
 3   ----    ----        kurz gestrichelte Linie 
 4   --------            lang gestrichelte Linie 
 5   --------    -       Strichpunktlinie 
 6   -   -   -----       Strich-Punkt-Punkt Linie 
 7   - - - -  - - - -    Benutzerdefinierte Linie 
                         (Hier Defaultangabe) 
 
Die Bitmuster sind immer 16 Bit lang. Nach einem Movebefehl startet der
nächste Draw-Befehl mit dem linkesten (niederwertigsten!) Bit des Bitmu-
sters. Das Muster wiederholt sich bei längeren Linien zyklisch. Wird zwi-
schen zwei Draw-Befehlen kein Move-Befehl gegeben, dann setzt der zweite
Draw-Befehl im Bitmuster nach der gleichen Stelle fort, an der der erste
Draw-Befehl aufgehört hat. Auch dicke Linien behalten das Linienmuster bei,
man sollte dann allerdings von gepunkteter auf lang gestrichelte Linie über-
gehen, wenn man eine gepunktete dicke Linie haben will. 
 
 
#k("6.3.3.1", "Selbstdefinierte Linientypen (Pattern)")# 
 
Wie in 6.3.3 angemerkt kann ein Linientyp auch vom Benutzer selbst definiert
werden. Da die Länge 16 Bit ist, kann man mit den relativen Move's und
Draw's zusammen gut kleine Bildchen (Icons) zusammenstellen. Eine Hilfe ist
dabei auch die Bitverknüpfung COPY, die im nächsten Abschnitt erläutert
wird. Man legt dazu zuerst das 16 Bit-Pattern als jeweils eine Zeile des
Icons fest und zieht dann von links nach rechts eine 16 Punkte lange Linie
mit dem benutzerdefinierten Pattern. Nach einem relativen Move (-16, -1)
kann der Vorgang für die nächste Zeile fortgesetzt werden. 
 
Das benutzerdefinierbare Pattern wird mit dem Kommando 
 
                         #ib(1)#<ESC> O 6#ie(1)# <l> <h>    (Hex 1B 4F 36 <l> <h>) 
 
festgelegt. <l> ist dabei das niederwertige (Lowbyte) des Bitmusters, <h>
ist das höherwertige (Highbyte) des Bitmusters. Wenn das Pattern als Muster
für Linien (und nicht für Icons) benutzt wird, dann sollte man darauf ach-
ten, daß das Bit 0 im Lowbyte 1 ist, damit man bei kurzen Linien, denen ein
Move vorangegangen ist, zumindestes einen Punkt sieht. 
 
 
#k("6.3.4", "Bitverknüpfungen")# 
 
Über Bitverknüpfungen werden die Punkte auf der Graphikseite verändert. Das
Linienmuster wird dazu zyklisch punktweise abgetastet und jenachdem ob das
aktuelle Bit im Linienbitmuster 0 oder 1 ist eine Veränderung der Graphik-
seite durchgeführt. 
Bis auf die COPY-Funktion wirken die Bitverknüpfungen nur auf die Graphik-
seite, wenn der aktuelle Punkt im Linientyp-Bitmuster 1 ist. 
 
- Das Zeichnen einer sichtbaren Linie mit weißen Punkten geschieht zum Bei-
  spiel durch eine OR- (Oder-) Verknüpfung. 
 
- Das Löschen einer Linie (also das Zeichnen von "schwarzen" Punkten) ge-
  schieht mit einer AND- (Und-) Verknüpfung (Genau genommen eine NAND-, d.h.
  negierte AND-Verknüpfung). 
 
- Das Invertieren (d.h. Weißer Punkt wird schwarz, schwarzer Punkt wird
  weiß) kann man mit einer XOR- (Exklusiv-Oder-) Verknüpfung erreichen. 
 
- Für Icons (siehe 6.3.3.1) und andere Zwecke, gibt es noch die COPY-Funk-
  tion, die eigentlich keine einzelne Bitverknüpfung ist. Ist im Linientyp
  das aktuelle Bit 0, dann wird in der Graphikseite eine AND-Verknüpfung
  durchgeführt (d.h. der Punkt wird gelöscht) ist das aktuelle Bit im Li-
  nientyp 1, dann wird eine OR-Verknüpfung durchgeführt (d.h. der Punkt wird
  gelöscht). Der Effekt ist, daß genau das Bitmuster des Linientyps in der
  Graphikseite erscheint ("kopiert" wird), egal was vorher da stand, wo die
  Linie gezeichnet wurde. 
 
Die Bitverknüpfung kann mit dem Kommando 
 
                         #ib(1)#<ESC> O 4#ie(1)# <n>    (Hex 1B 4F 34 <n>) 
 
festgelegt werden. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 3. 
<n> hat folgende Bedeutung: 
 
<n>  Bitverknüpfung         Verwendung 
#linie ("16.2")# 
 0   OR (Oder)              Weiß (auf schwarzem Grund) zeichnen 
 1   AND (Und)              Schwarz (auf weißem Grund) zeichnen 
 2   XOR (Exklusiv Oder)    Schwarze und Weiße Punkte umdrehen (invertie-
 ren) 
 3   COPY (kopieren)        Icons zeichnen oder Bilduntergrund überschrei-
 ben 
 
 
#k("6.3.5", "Multiparametereinstellung")# 
 
Die obigen Parameter (bis auf Linientyp) können alle zugleich mit einem
Kommando gesetzt werden. Das Kommando lautet 
 
                         #ib(1)#<ESC> O 5#ie(1)# <n>    (Hex 1B 4F 35 <n>) 
 
<n> ist ein Byteparameter mit dem Wertebereich 0 bis 127. Die Bits sind
folgendermaßen zugeordnet: 
 
   Bit     Bedeutung        Werte 
#linie ("16.2")# 
 0 .. 3  : Strickdicke      1 .. 15 
 4 .. 5  : Bitverknüpfung   0 = OR, 16 = AND, 32 = XOR, 48 = COPY 
      6  : Farbe/Helligkeit 0 = Violett (dunkel), 64 = Gelb (hell) 
 
Standardeinstellung ist also '<ESC> O 5 A'. 
 
 
#k("6.4", "Graphikseiten")# 
 
Das Terminal verwaltet zwei Graphikseiten mit einer Größe von jeweils 8k
Byte (d.h. 8192 Bytes). 
 
 
#k("6.4.1", "Die sichtbare Seite und die Arbeitsseite")# 
 
Die beiden Graphikseiten können (müssen aber nicht) getrennt voneinander
angezeigt und bearbeitet werden. Das kann sinnvoll sein, wenn eine Seite "im
Hintergrund" aufbereitet werden soll, während die andere (schon aufbereite-
te) Seite angezeigt wird. Man kann auch die 80-Zeichen Textseite anzeigen
und eine oder beide Graphikseiten im Hintergrund aufbereiten. Durch abwec-
hselndes Umschalten der Arbeits- und Anzeigeseite kann dann der Eindruck
eines bewegten Bildes erzeugt werden. Um diesen Vorgang zu beschleunigen,
kann man die Graphikseiten auch auf dem Host vorbereiten und (im Hinter-
grund) an das Terminal senden (bei 19200 Baud dauert das pro Seite ca. 4.7
Sekunden). 
 
Die sichtbare und die Arbeitsseite können mit dem Kommando 
 
                         #ib(1)#<ESC> O 7#ie(1)# <n>    (Hex 1B 4F 37 <n>) 
 
gewählt werden. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 7. 
 
Bit 0 von <n> : Sichtbare Seite (0 oder 1) 
Bit 1 von <n> : Arbeitsseite (0 oder 1) 
Bit 2 von <n> : 1 = 80 Zeichen Textseite wird in den untersten 32 Graphik-
                zeilen eingeblendet. 0 = Nur Graphikmode. 
 
#on("u")#<n>     Sichtbar Arbeitsseite  Inhalt der untersten 32 Graphikzeilen#off("u")# 
 0      Seite 0  Seite 0       Graphik (Seite 0) 
 1      Seite 1  Seite 0       Graphik (Seite 1) 
 2      Seite 0  Seite 1       Graphik (Seite 0) 
 3      Seite 1  Seite 1       Graphik (Seite 1) 
 4      Seite 0  Seite 0       Text 
 5      Seite 1  Seite 0       Müll 
 6      Seite 0  Seite 1       Text 
 7      Seite 1  Seite 1       Müll 
 
 
#k("6.4.1.1", "80-Zeichen Text und Graphik")# 
 
Mit dem in 6.4.1 beschriebenen Kommando können, wie beschrieben, die unter-
sten 4 Zeilen der Textzeile (d.h. ggf. auch die Statuszeile) statt der un-
tersten 32 Graphikzeilen dargestellt werden. Da es nur eine Textseite gibt
und jeder Graphikseite eine eigene Textseite zugeordnet ist, ist die Mi-
schung von Text und Graphik in der Graphikseite 1 auf diese Weise nicht
sinnvoll, da dann in den unstersten 32 Graphikzeilen nur Müll erscheint. Das
Einblenden wird vom Terminal z.B. genutzt, wenn die Kommandozeile aktiviert
wird. Man kann zum Beispiel Benutzerhinweise in die untersten 4 Zeilen der
Textseite schreiben. Zeichenbefehle arbeiten in dem unsichtbaren (ausgeblen-
deten) Teil der Graphikseite weiter. Das Ergebnis kann man sich beim Wieder-
-Einblenden ansehen. 
 
 
#k("6.4.2", "Aufbau einer Graphikseite")# 
 
Eine Graphikseite besteht aus 8192 Bytes, von denen 7680 genutzt werden, 512
sind somit (in der Graphikseite verstreut) ungenutzt. Jedes Byte besteht aus
einem Farbbit (Bit 7) und 7 angezeigten Graphikbits. Ein gesetztes Bit ent-
spricht einem sichtbaren Punkt auf dem Bildschirm. Das niederwertigste Bit
eines Bytes wird am weitesten links angezeigt. 
Jede der 192 Graphikzeilen besteht also aus 40 Bytes. Jeweils 8 Graphikzei-
len sind zu Reihen zusammengefaßt. Es gibt also 24 Reihen. Jede erste Gra-
phikzeile einer Reihe hat eine Anfangsadresse, die in folgender Tabelle
aufgelistet ist: 
 
#on("u")#Reihe  Adresse  Hex  |  Reihe  Adresse  Hex  |  Reihe  Adresse  Hex#off("u")# 
  0        0    000  |    8      40     028  |   16      80     050 
  1      128    080  |    9     168     0A8  |   17     208     0D0 
  2      256    100  |   10     296     128  |   18     336     150 
  3      384    180  |   11     424     1A8  |   19     464     1D0 
  4      512    200  |   12     552     228  |   20     592     250 
  5      640    280  |   13     680     2A8  |   21     720     2D0 
  6      768    300  |   14     808     328  |   22     848     350 
  7      896    380  |   15     936     3A8  |   23     976     3D0 
 
Um den Offset den n. Graphikzeile in einer Reihe zu finden kann man folgen-
de Tabelle benutzen: 
 
#on("u")#n  Offset (Hex)#off("u")# 
0      0   0000 
1   1024   0400 
2   2048   0800 
3   3072   0C00 
4   4096   1000 
5   5120   1400 
6   6144   1800 
7   7168   1C00 
 
Beispiel: 
  Die Adresse des Punktes (123, 45) soll bestimmt werden. 
  45 DIV 8 = 5, d.h. Y liegt in Reihe 5 mit Adresse 640 (Dezimal). 45 MOD 8
                = 5, d.h. Y liegt in der n=5. Graphikzeile von Reihe 5. Der
                Y-Offset also 5120. 
  123 DIV 7 = 17 d.h. X liegt im Byte mit X-Offset 17. 
  Die Adresse des Punktes ist also im Byte 17 + 5120 + 640 = 5777. 
  123 MOD 7 = 4  d.h. Bit 4 in Byte 5777 ist der gesuchte Punkt. 
 
 
#k("6.4.3", "Operationen auf den Graphikseiten")# 
 
Hier sollen nur die Operationen erläutert werden, die nicht in andere Kate-
gorien (z.B. Löschen, Linien zeichnen etc.) passen. 
 
Es gibt ein universelles Kommando, mit dem zwei Graphikseiten invertiert,
kopiert, gemischt und miteinander logisch verknüpft werden können. Verän-
dert wird bei diesem Kommando nur die Arbeitsseite. 
 
Das Kommando lautet 
 
                         #ib(1)#<ESC> !#ie(1)# <n>    (Hex 1B 21 <n>) 
 
<n> ist dabei ein Byteparameter mit dem Wertebereich 0 bis 15 und hat fol-
gende Bedeutung: 
 
<n>   Bedeutung 
#linie ("16.2")# 
 0    Keine Veränderung. Kopiert die Arbeitsseite in sich selbst (Färbt die
      Arbeitsseite allerdings mit der aktuellen Farbe/Helligkeit). 
 1    Die Arbeitsseite wird invertiert. 
 2    Mischt beide Seiten zusammen (OR Verknüpfung). 
 3    Mischt beide Seiten zusammen (OR) und invertiert das Ergebnis. 
 6    Bildet den Durchschnitt beider Seiten (AND Verknüpfung). 
 7    Bildet den Durchschnitt beider Seite (AND) und invertiert das Ergebnis
10    Es sind die Punkte gesetzt, die in beiden Seiten verschieden sind (XOR
      Verknüpfung). 
11    Es sind die Punkte gesetzt, die in beiden Seiten gleich sind (d.h. das
      Inverse von <n>=10). 
14    Kopiert die andere Seite in die Arbeitsseite. 
15    Kopiert das Inverse von der anderen Seite in die Arbeitsseite. 
 
Andere Werte für <n> wiederholen sich in der Tabelle. Die ganze Arbeitssei-
te hat nach der Operation die gewählte Farbe/Helligkeit. 
 
 
#k("6.4.4", "Laden einer Graphikseite vom Host")# 
 
Graphikseiten können ganz oder teilweise vom Host geladen werden. Das kön-
nen auf dem Terminal erstellte und dann an den Host gesendete (Teil-)
Graphiken sein, aber auch auf dem Host erstellte. In diesem Fall ist das
Kapitel 6.4.2 (Aufbau einer Graphikseite) interessant. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> /#ie(1)# <ll> <lh> <al> <ah> <b...> 
                                                    (Hex 1B 2F ...) 
 
kann eine Seite oder ein Teil einer Seite in die Arbeitsseite geladen wer-
den. <lh>, <ll>, <ah>, <al> und <p...> sind Byteparameter (8 Bits). <ll> und
<lh> bilden zusammen die binäre Länge, d.h. die Anzahl der Datenbytes
<p...>, die die Graphik enthalten. Die Länge kann von 0 bis Hex 2000 (dezi-
mal 8192) reichen. Die Adresse, durch <al> und <ah> gebildet, darf von 0 bis
Hex 1FFF reichen. Zusätzlich gilt, daß die Summe von Länge und Adresse nicht
größer als Hex 2000 sein darf, da sonst außerhalb der Graphikseite geladen
würde. In einem dieser Fehlerfälle werden die folgenden Graphikdatenbytes
ignoriert. Die Datenbytes werden dann als Kommandos interpretiert, was zu
unvorhersehbaren Reaktionen des Terminals führt. 
 
 
#k("6.4.5", "Graphik auf Diskette speichern/laden")# 
 
Um Graphikseiten, zum Besipiel für Präsentationen, unabhängig vom Host auf
dem Bildschirm darstellen zu können, benutzt man das Kommando 
 
                         #ib(1)#<ESC> S#ie(1)# <n>    (Hex 1B 53 <n>). 
 
Man kann bis zu 8 verschiedene Graphikseiten vorbereiten, auf Diskette spei-
chern und zu einem späteren Zeitpunkt wieder in das Terminal zurückladen.
Dieses Kommando wird auch verwendet, um eine Textseite auf Diskette zu
schreiben oder von Diskette zu lesen. <n> ist ein Byteparameter mit dem
Wertebereich 0 bis 31, wobei die Bits folgendermaßen belegt sind: 
 
Bit 0..2 : "Fachnummer" der Graphikseite auf der Diskette (0 bs 7) 
Bit 3    : Bei Graphikseiten immer 1 (Bei Textseiten 0) 
Bit 4    : 0 heißt: die Graphikseite wird von der Diskette gelesen, 
           1 heißt: die Graphikseite wird auf die Diskette geschrieben. 
 
Wird die Graphikseite auf die Diskette geschrieben, dann wird eine eventuell
schon in diesem "Fach" vorhandene Graphikseite überschrieben. 
 
Wie bei allen Graphikkommandos, bezieht sich dieses Kommando nicht unbedingt
auf die sichtbare Graphikseite, sondern auf die Arbeitsseite. 
 
Beispiele: 
    <ESC> S <CTRL H> liest die Graphikseite in Fach 0 in die Arbeitsseite. 
    <ESC> S <CTRL X> schreibt die Arbeitsseite in Fach 0 der Diskette. 
 
Da das Lesen einer Graphikseite von Diskette mit ca. 1.1 Sekunden, um eini-
ges schneller als der Datentransfer vom Host ist, sollte man bewegte Graphi-
ken auf Diskette vorbereiten und sie dann mit verschränkter Arbeits- und
Sichtbarkeitsseite anzeigen. 
Z.B.: Seite 1 als Arbeitsseite wählen, Seite 0 als sichtbare Seite. Graphik
      von Diskette laden (wird in Seite 1 (= Arbeitsseite) geladen) Seite 1
      als sichtbare Seite wählen, Seite 0 jetzt als Arbeitsseite wählen. Die
      nächste Graphikseite wird von der Diskette in die Seite 1 geladen etc. 
      Bei dieser Vorgehensweise scheinen Übergänge kontinuierlich zu sein. 
 
Für Insider: Eine Graphikseite belegt zwei Tracks (8k). Die 8 Graphikseiten
             befinden sich auf den Tracks 10 bis 25 in aufsteigender Reihen-
             folge. 
 
 
#k("6.5", "Textdarstellung im Graphikmodus")# 
 
Nicht nur auf der 80-Zeichen Textseite können Buchstaben und Zeichen darge-
stellt werden, sondern auch auf den Graphikseiten. Die Auflösung ist zwar
nicht so groß wie auf der reinen Textseite, aber die Anzahl der verschiede-
nen Darstellungsmöglichkeiten ist sehr viel größer. Fast alle Kommandos, die
in der Textseite angewandt werden können, haben in der Graphikseite die
gleiche Funktion. 
 
Textdarstellung in der Graphikseite ist hauptsächlich zum Beschriften von
Graphiken oder zum Drucken von Überschriften etc. vorgesehen. Da aber fast
alle Textkommandos (Delete/Insert Line/Character fehlt) auch im Graphikmo-
dus zur Verfügung stehen, kann man auch im Graphikmodus Textverarbeitung
oder Editor benutzen. 
 
 
#k("6.5.1", "Zeichendarstellung")# 
 
Die normale Größe eines Zeichens ist 6 x 10 Punkte (x * y), damit lassen
sich 46 x 19 Zeichen (874 Zeichen) voll auf dem Bildschirm darstellen. Wenn
die Größe mit einem Kommando auf 5 x 8 Punkte verringert wird, dann lassen
sich 56 x 24 Zeichen (1344 Zeichen) auf dem Bildschirm darstellen. Komfor-
table Textverarbeitung läßt sich damit natürlich nicht machen, zumal die
Geschwindigkeit, mit der die Zeichen auf den Bildschirm geschrieben werden
gegenüber der der reinen Textseite langsamer ist. 
 
 
#k("6.5.1.1", "Zeichengröße und Schreibrichtung")# 
 
Die Zeichen können in verschiedenen Größen und unter verschiedenen Winkeln
auf den Bildschirm geschrieben werden. Damit ist auch ein Schreiben von
rechts nach links mit auf dem Kopf stehenden Zeichen möglich. 
Bei normaler Schreibrichtung (waagerecht von links nach rechts) befindet
sich die linke untere Ecke eines Zeichens an der Position des Graphikcur-
sors. Nach dem Zeichnen des Zeichens befindet sich der Graphikcursor hinter
der rechten unteren Ecke des Zeichens. Da sich die Zeichen aus Vektoren
(Linien) zusammensetzen und nicht aus einer festen Punktmatrix, können sie
schnell beliebig gedreht und vergrössert (und verkleinert) werden. Der Dreh-
winkel ist wie bei allen Graphikwinkelangaben in 5 Grad Schritten anzugeben.
Die Zuordnung der Winkel zu den Parameterwerten oder ASCII-Zeichen ist im
Anhang A angegeben. 
 
Das Kommando 
 
                         #ib(1)#<ESC> N#ie(1)# <b> <h> <w>    (Hex 1B 4E <b><h><w>) 
 
stellt Breite, Höhe und Drehwinkel der Zeichen ein. Alle Parameter sind
Byteparameter mit dem Wertebereich 0 bis 255. Mit einem Parameter Hex 00
kann der Defaultwert (Standardwert) für den jeweiligen Parameter eingestellt
werden. 
<b> bezeichnet die Zeichenbreite in Punkten. Standardwert ist 6. 
<h> bezeichnet die Zeichenhöhe in Punkten. Standardwert ist 10. 
<w> bezeichnet den Drehwinkel in 5 Grad Schritten. Standardwert ist 0. 
 
Einige ausgezeichnet Werte für <w> sind: 
<w>    Richtung 
#linie ("16.2")# 
 0     Waagerecht von links nach rechts (Ost) 
 9     Schräg nach unten rechts         (Süd-Ost) 
18     Senkrecht von oben nach unten    (Süd) 
27     Schräg nach unten links          (Süd-West) 
36     Waagerecht (auf dem Kopf stehend) von rechts nach links (West) 
45     Schräg nach oben links           (Nord-West) 
54     Senkrecht von unten nach oben    (Nord) 
63     Schräg von nach oben rechts (Aufwärts) (Nord-Ost) 
72...  Wie 0 ... 
 
 
#k("6.5.1.2", "Dicke, Farbe etc.")# 
 
Buchstaben werden mit Vektoren (Linien) gezeichnet. Die gleichen Parameter,
die für Striche eingestellt werden, wirken dann auch auf die Zeichen. Mög-
liche Parameter sind Farbe, Linientyp, Strichdicke und Bitverknüpfung. Mit
dem Kommando 
 
                         #ib(1)#<ESC> O 0#ie(1)#    (Hex 1B 4F 30) 
 
werden alle diese Parameter auf Standardwerte zurückgesetzt. Die Standard-
werte sind in Kapitel 6.3 erläutert. Die Beschreibung des Kommandos zur
Einstellung der Zeichenfarbe ist in Kapitel 6.3.2 beschrieben, das Einstel-
len der Zeichendicke in Kapitel 6.3.1, das Einstellen des Linientyps in
Kapitel 6.3.3 und das Einstellen der Bitverknüpfung ist in Kapitel 6.3.4
beschrieben. Auch für die Zeichendarstellung können mehrere dieser Parame-
ter zugleich mit einem Kommando eingestellt werden. Das Multiparameterkom-
mando ist in Kapitel 6.3.5 beschrieben. 
 
 
#k("6.5.1.3", "Zeichensätze und Attribute")# 
 
Ähnlich wie bei der 80-Zeichen Textdarstellung können Zeichensatz und Text-
attribute eingestellt werden. Mit dem Kommando 
 
                         #ib(1)#<ESC> z#ie(1)# <n>    (Hex 1B 7A <n>) 
 
kann einer der beiden Zeichensätze USA oder GER (ASCII und Deutsch) gewählt
werden. Ein griechischer Zeichensatz ist unabhängig von beiden immer vor-
handen. 
<n> ist ein Byteparameter mit dem Wertebereich 0 bis 15, im Graphikmodus
sind aber nur die beiden folgende Werte sinnvoll: 
 
#on("u")#<n>  Zeichensatz  Abweichende Zeichen#off("u")# 
 2   Deutsch      Ä Ö Ü ä ö ü ß 
 4   Ascii        [ \ ] { | } ~ 
 
Außerdem kann der Zeichensatz im ersten Feld der ersten Kommandozeile ein-
gestellt werden. Im amerikanischen Zeichensatz treten die deutschen Buch-
staben außerdem im Bereich von 214 bis 219 und 251 auf. Der Graphikzeichen-
satz ist im Anhang abgebildet. 
 
Wie im Textmodus können Attribute mit dem Kommando 
 
                         #ib(1)#<ESC> G#ie(1)# <n>    (Hex 1B 47 <n>) 
 
eingestellt werden. <n> ist ein Byteparameter mit dem Wertebereich 0, 1, 4
und 5. Die Werte von <n> sind folgendermaßen zugeordnet: 
 
#on("u")#<n>  Bedeutung                                       #off("u")#
 0   Normaler Text (sichtbar und aufrecht) 
 1   Unsichtbarer Text (Nur der Cursor wird bewegt) 
 4   Kursivschrift, die Zeichen werden schräggestellt 
 5   Wie 1 (unsichtbarer Text) 
 
Das Kommando 
 
                         #ib(1)#<ESC> )#ie(1)#   (Hex 1B 29) 
 
hat wie im Textmodus die gleiche Bedeutung wie <ESC> G 4. Damit wird im
Graphikmodus die Kursivschrift eingeschaltet. Mit dem Kommando 
 
                         #ib(1)#<ESC> (#ie(1)#   (hex 1B 28) 
 
wird die Kursivschrift wieder ausgeschaltet. Im Textmodus invers hervorge-
hobene Textstellen werden im Graphikmodus also durch Kursivschrift hervor-
gehoben. 
Steht rechts neben der Zeichenspalte mit einem Kursivzeichen ein nicht kur-
sives Zeichen, dann wird das rechte Zeichen möglicherweise etwas überschrie-
ben, da es in den oberen Teil des Kursivzeichens hineinragt. Das kann ver-
mieden werden, wenn nach dem Ausschalten der Kursivschrift ein Leerzeichen
ausgegeben wird. 
 
 
#k("6.5.1.4", "Zeichen überschreiben")# 
 
Im 80-Zeichen Textmodus kann man Zeichen einfach übereinandertippen, das
zweite Zeichen ersetzt dann das erste. Im Graphikmodus sollen Texte auch mit
in eine Zeichnung geschrieben werden können, ohne daß Teile von Linien even-
tuell gelöscht werden. Dieser Modus bringt außerdem eine etwas größere
Schreibgeschwindigkeit mit sich. Es ist aber auch möglich, daß die Fläche,
in die das Zeichen geschrieben werden soll, vorher gelöscht wird, um ein
sauberes Schriftbild zu erzielen. Mit dem Kommando 
 
                         #ib(1)#<ESC> &#ie(1)#   (Hex 1B 26) 
 
kann man das vorherige Löschen einschalten, mit dem Kommando 
 
                         #ib(1)#<ESC> '#ie(1)#   (Hex 1B 27) 
 
wird der Modus des Überschreibens ausgeschaltet. 
 
Bei Kursivzeichen wird eine rautenförmige Fläche gelöscht oder gefüllt (wenn
Bitverknüpfung AND eingeschaltet ist). Bei normalen Zeichen wird eine re-
chteckige Fläche, der mit #ib(1)#<ESC> N#ie(1)# eingestellten Breite und Höhe, gelöscht
oder gefüllt. Zu beachten ist, daß das Löschen/Füllen nur bei waagerechter
Schreibrichtung von links nach rechts funktioniert. 
 
Da die Größe der Zeichen in weiten Grenzen mit <ESC> N eingestellt werden
kann, ist es auch möglich mit dem durch <ESC> & eingeschalteten Ersetzungs-
modus schnell rechteckige Flächen zu füllen oder zu löschen, wenn nicht auf
das später beschriebene Füllkommando für beliebige Flächen zurückgegriffen
werden soll. Dazu schaltet man mit dem Kommando <ESC> O 4 1 die Bitverknü-
pfung AND (für Füllen) ein und gibt dann einfach ein Leerzeichen aus, das
dann invertiert dargestellt wird. 
 
 
#k("6.5.2", "Textkommandos im Graphikmodus")# 
 
Fast alle Textkommandos des 80-Zeichen Textmodus wirken auch im Graphikmo-
dus. Einige Kommandos, wie Zeichen senden, Zeile senden, Cursorposition
senden, haben im Graphikmodus andere Funktionen und haben deshalb andere
Escape-Sequenzen. Textkommandos, die nicht im Graphikmodus vorhanden sind:
<ESC> I (Backtab), <ESC> j (Reverse Linefeed), <ESC> E (Insert Line), <ESC>
Q (Insert Character), <ESC> R (Delete Line), <ESC> W (Delete Character). 
 
 
#k("6.5.2.1", "Die Cursorpositionierung")# 
 
Die Cursorpositionierungskommandos (UP, DOWN, LEFT, RIGHT) wirken im Gra-
phikmodus in die aktuelle Schreibrichtung. Beispiel: Wenn als Schreibwinkel
180 Grad eingestellt wurde (Winkel 36, also von rechts nach links auf dem
Kopf schreiben), dann muß man, um einen Backspace (d.h. ein Zeichen zurück)
auszuführen, nicht <RIGHT> sondern wie bei normaler Schreibrichtung üblich,
<LEFT> drücken. Die vier Cursorsteuertasten funktionieren für beliebige
Schreibrichtungen. Alle anderen Steuertasten beziehen sich immer auf waage-
rechte Schreibrichtung von links nach rechts. 
 
Alle Steuertasten berücksichtigen die Zeichengröße (Breite und Höhe). Auch
die Graphikseite wird am Ende der letzten Zeile um soviele Graphikzeilen
gescrollt, wie ein Zeichen hoch ist. 
 
Folgende Steuerkommandos/Tasten wirken im Graphikmodus: 
 
Basis-Taste    Apple-Taste  Hex-Code   Bedeutung 
#linie ("16.2")# 
#ib(1)#<TAB>#ie(1)#            <TAB>         09      Der Cursor wird an die nächste (re-
                                       chte) Tabulatorposition gesetzt.
                                       Tabulatorpositionen sind alle 8 Spal-
                                       ten (wie im Textmodus). Liegt die
                                       nächste Tabulatorposition außerhalb
                                       des sichtbaren Bereichs, dann steht
                                       der Cursor jetzt da. 
 
#ib(1)#<SHIFT CE>#ie(1)#       <OA CTRL X>    -      Kommandozeile aktivieren. 
                                       Einzelheiten zur Kommandozeile siehe
                                       Abschnitt 3.: Die Kommandozeilen. 
 
#ib(1)#<CE>#ie(1)#             <CTRL X>      18      u.a. Kommandozeile verlassen. 
 
#ib(1)#<RETURN>#ie(1)#         <RETURN>      0D      Zum Zeilenanfang ohne Zeilenvorschub. 
                                       Der Cursor steht dann in der ersten
                                       Spalte der Zeile. 
 
#ib(1)#<SHIFT RETURN>#ie(1)#   <OA RETURN>   8D      Zum Anfang der nächsten Zeile. Falls
                                       der Cursor in der letzten sichtbaren
                                       Bildschirmzeile war, wird der Bild-
                                       schirminhalt entweder nach oben ge-
                                       scrollt (SCROLL) oder in Homeposition
                                       gebracht (PAGE). 
 
#ib(1)#<UP>#ie(1)#             <UP>       8B/0B      Cursor eine Zeile höher (bzw. über
                                       die Zeile). War der Cursor in der
                                       ersten sichtbaren Bildschirmzeile,
                                       dann steht er jetzt im unsichtbaren
                                       Bereich. 
 
#ib(1)#<DOWN>#ie(1)#           <DOWN>     8A/0A      Cursor eine Zeile tiefer (bzw. "un-
                                       ter" die Zeile). War der Cursor in
                                       der letzten sichtbaren Zeile, dann
                                       wird der Inhalt des Graphikbild-
                                       schirms nach oben gescrollt, d.h. die
                                       obersten Zeilen werden gelöscht (im
                                       SCROLL-Modus) oder der Cursor in die
                                       erste Zeile gesetzt (im PAGE-Modus). 
 
#ib(1)#<CTRL V>#ie(1)#         <CTRL V>      16      Cursor eine Zeile tiefer (bzw. "un-
                                       ter" die Zeile). War der Cursor in
                                       der letzten Zeile, dann ändert er
                                       seine Position nicht. Die Spalte
                                       ändert sich nicht. 
 
#ib(1)#<LEFT>#ie(1)#           <LEFT>     88/08      Cursor eine Spalte nach links (bzw.
                                       entegegen der Schreibrichtung). War
                                       der Cursor in der ersten sichtbaren
                                       Bildschirmspalte, dann ist er jetzt
                                       unsichtbar "links" davon. 
 
#ib(1)#<RIGHT>#ie(1)#             -          95      Cursor eine Spalte nach rechts (bzw.
                                       in Schreibrichtung). War der Cursor
                                       in der letzten sichtbaren Spalte,
                                       dann befindet er sich jetzt außer-
                                       halb des Bildschirms. Im Gegensatz
                                       zum Textmodus wird kein Linefeed oder
                                       Scroll ausgeführt. 
 
#ib(1)#<HOME>#ie(1)#           <OA @>        C0      Der Cursor wird in die linke obere
                                       Bildschirmecke gebracht (Homeposi-
                                       tion). 
 
#ib(1)#<SHIFT HOME>#ie(1)#     <OA P>        D0      Bildschirm löschen und Cursor Home. 
 
#ib(1)#<DELETE>#ie(1)#         <DELETE>      7F      Dieses Zeichen wird auf dem Bild-
                                       schirm nicht dargestellt. Der Host
                                       interpretiert es in der Regel als
                                       Zeichenlöschbefehl. 
 
#ib(1)#<BOTTOMLEFT>#ie(1)#     <BACKSPACE>   08      Cursor eine Spalte nach links (bzw.
                                       entgegen der Schreibrichtung). Die
                                       Funktion ist mit der von <LEFT> iden-
                                       tisch. 
 
#ib(1)#<BOTTOMRIGHT>#ie(1)#    <RIGHT>       15      Apple: Cursor eine Spalte nach re-
                                       chts (bzw. in Schreibrichtung). Die
                                       Funktion ist mit der von <RIGHT>
                                       identisch. 
 
#ib(1)#<ESC>#ie(1)#            <ESC>         1B      Leitet eine Escape-Sequenz ein. 
 
#ib(1)#<SHIFT CTRL HOME>#ie(1)#<OA 0>         -      Local/Online umschalten 
 
#ib(1)#<CTRL HOME>#ie(1)#      <OA SPACE>   '00'     Sendet V24-Break (Hexcode 00 mit
                                       Rahmenfehler). Als Rahmenfehler wird
                                       das Fehlen des oder der Stopbits
                                       bezeichnet (Stopbitpegel ist norma-
                                       lerweise 1, bei Break dagegen 0). 
 
Unbelegte Funktionstasten erzeugen Graphikzeichen, die im Anhang A nachge-
sehen werden können. 
 
 
#k("6.5.2.2", "Löschbefehle")# 
 
Das Kommando (Clear to End Of Line) 
 
                         #ib(1)#<ESC> T#ie(1)#    (Hex 1B 54) 
 
löscht ab der aktuellen Cursorposition bis zum Zeilenende. Die Höhe des
gelöschten Balkens entspricht der Buchstabenhöhe. Der Balken wird unabhän-
gig von der Bitverknüpfung immer gelöscht. Der Balken wird unabhängig von
der Schreibrichtung immer waagerecht gelöscht. 
 
Das Kommando (Clear to End Of Page) 
 
                         #ib(1)#<ESC> Y#ie(1)#    (Hex 1B 59) 
 
löscht den Graphikbildschirm von der aktuellen Cursorposition an bis zum
Bildschirmende. Auch dieses Kommando löscht unabhängig von der gewählten
Bitverknüpfung und Schreibrichtung immer waagerecht. 
 
Die Kommandos 
 
                         #ib(1)#<ESC> *#ie(1)#    (Hex 1B 2A) 
                         #ib(1)#<ESC> ,#ie(1)#    (Hex 1B 2C) 
                         #ib(1)#<ESC> +#ie(1)#    (Hex 1B 2B) 
                         #ib(1)#<ESC> :#ie(1)#    (Hex 1B 3A) 
                         #ib(1)#<CTRL Z>#ie(1)#   (Hex 1A) 
 
löschen den Bildschirm und bringen den Graphikcursor in Homeposition, d.h.
eine Buchstabenhöhe unter dem oberen Bildschirmrand. 
 
Das Kommando 
 
                         #ib(1)#<ESC> y#ie(1)#    (Hex 1B 79) 
 
löscht den Bildschirm und bringt den Graphikcursor in die linke untere Ecke,
d.h. den Ursprung des Koordinatensystems. 
 
 
#k("6.6", "Die Graphikkommandos")# 
 
 
#k("6.6.1", "Draw's und Move's")# 
 
Draw's sind Zeichenbefehle, die eine Linie zeichnen und den Cursor an den
Endpunkt der Linie positionieren. Move's positionieren nur den Cursor und
zeichnen nicht. Bei allen Draw's ist der Anfangspunkt der Linie die aktuel-
le Cursorposition. Die Endposition kann relativ, absolut oder mit einem
relativen Winkel angegeben werden. Der Befehl zum Setzen/Löschen eines Punk-
tes wurde mit in diese Befehlskategorie aufgenommen. 
 
 
#k("6.6.1.1", "Punkt setzen")# 
 
Der Befehl zum Setzen eines Graphikpunktes ist ein absoluter Befehl, d.h.
die Koordinaten des Punktes folgen dem Kommando. Die Position des Graphik-
cursors wird durch diesen Befehl nicht verändert. 
 
Das Kommando 
 
                         #ib(1)#<ESC> m#ie(1)# <x, y;>    (Hex 1B 6D <x, y;>) 
 
setzt einen Punkt an die Position x/y, wenn diese innerhalb des sichtbaren
Bereichs liegt. <x, y;> sind dezimale oder binäre Koordinaten. Das Aussehen
des Punktes kann durch Farbe/Helligkeit oder Bitverknüpfung festgelegt wer-
den. Mit einer AND-Bitverknüpfung wird der angegebene Punkt gelöscht, mit
einer OR oder COPY Bitverknüpfung wird der angegebene Punkt gesetzt, mit
einer XOR Bitverknüpfung wird sein Zustand umgedreht (invertiert). 
Soll ein dicker Punkt gezeichnet werden, dann kann man den (relativen)
Draw-Befehl <ESC> r 0, 0; benutzen, der an die Position des Graphikcursors,
einen Punkt der eingestellten Dicke zeichnet. 
 
 
#k("6.6.1.2", "Move-Befehle")# 
 
Den Move-Befehl gibt es in zwei Versionen, einer relativen und einer abso-
luten. Das Kommando für einen absoluten Move lautet 
 
                         #ib(1)#<ESC> v#ie(1)# <x, y;>    (Hex 1B 76 <x, y;>) 
 
Dabei sind <x, y;> dezimale oder binäre Koordinaten, die die neue Position
des Graphikcursors bezeichnen. Diese Position muß nicht im sichtbaren Be-
reich liegen, sondern kann auch außerhalb des Fensters liegen. Der Wertebe-
reich von <x> und <y> ist -32768 bis 32767. 
 
Das Kommando für den relativen Move-Befehl lautet 
 
                         #ib(1)#<ESC> q#ie(1)# <x, y;>    (Hex 1B 71 <x, y;>) 
 
Bei diesem Befehl werden die Werte von <x> und <y>, die auch den gesamten
Wertebereich von -32768 bis 32767 überstreichen dürfen, zu den Koordinaten
des Graphikcursors addiert. Auch hier darf die neue Position des Graphik-
cursors außerhalb des sichtbaren Bereichs liegen. 
 
Die Move-Befehle setzen außerdem das Bitmuster für den Linientyp wieder auf
den Startwert zurück, damit der nächste Draw-Befehl auch mit einem Punkt
beginnt. 
 
 
#k("6.6.1.3", "Draw-Befehle")# 
 
Ebenso wie den Move-Befehl gibt es auch den Draw-Befehl in zwei Versionen,
einer relativen und einer absoluten. Das Kommando für einen absoluten Draw
lautet 
 
                         #ib(1)#<ESC> w#ie(1)# <x, y;>    (Hex 1B 77 <x, y;>) 
 
Dabei sind <x, y;> dezimale oder binäre Koordinaten, die die Endposition der
Linie bezeichnen. Diese Position muß nicht im sichtbaren Bereich liegen,
sondern kann auch außerhalb des Fensters liegen. Der unsichtbare Teil der
Linie wird dann "geclippt". Der Wertebereich von <x> und <y> ist -32768 bis
32767. 
 
Das Kommando für den relativen Draw-Befehl lautet 
 
                         #ib(1)#<ESC> r#ie(1)# <x, y;>    (Hex 1B 72 <x, y;>) 
 
Bei diesem Befehl werden die Werte von <x> und <y>, die auch den gesamten
Wertebereich von -32768 bis 32767 überstreichen dürfen, zu den Koordinaten
des Graphikcursors addiert, die dann die Endposition der Linie bilden. Auch
hier darf die Endposition der Linie außerhalb des sichtbaren Bereichs lie-
gen. 
 
 
#k("6.6.1.4", "Turtle-Graphik")# 
 
Turtle-Graphik (Schildkröten-Graphik, obwohl hier keine Schildkröte sicht-
bar ist) wird zur Erzeugung von "rekursiven" Graphiken, die mit Längen und
Winkelangaben, statt mit x/y-Koordinaten, arbeiten benötigt. Man stellt sich
dazu eine Schildkröte vor, die auf ihrem Weg über den Bildschirm eine sicht-
bare Spur zurücklassen kann (aber nicht muß). Die Schildkröte kann einen Weg
bestimmter Länge in ihre Blickrichtung gehen und bleibt dann stehen. Außer-
dem kann sie sich nach links oder rechts drehen, d.h. ihre Blickrichtung
ändert sich. Alles was man dazu braucht, ist ein Befehl, der die Richtung
der Schildkröte verändern kann und dann einen Weg bestimmter Länge in dieser
Richtung zurücklegt. Außerdem wird noch ein Befehl benötigt, der das "Spur-
verhalten" der Schildkröte ändert, also von "Spur sichtbar" auf "Spur un-
sichtbar" umschaltet und umgekehrt. Natürlich ist die Zeichengeschwindigkeit
nicht mit der Fortbewegungsgeschwindigkeit von Schildkröten zu vergleichen.
Das erste Kommando lautet 
 
                         #ib(1)#<ESC> n#ie(1)# <l, w;>    (Hex 1B 6E <l, w;>) 
 
<l> und <w> sind dezimale oder binäre Parameter. <l> ist die Länge der Spur
mit einem Wertebereich von 0 bis 511. <w> ist der relative Drehwinkel der
Schildkröte, also die Änderung von der ursprünglichen Blickrichtung aus. <w>
überstreicht den positiven und negativen Winkelbereich (0..71 entsprechen 0
bis 355 in 5 Grad Schritten. -1 entspricht z.B. 355 Grad). 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> o#ie(1)#    (Hex 1B 6F) 
 
kann von 'Draw' einer Spur auf 'Move' umgeschaltet werden und umgekehrt. 
 
Um die Sichtbarkeit der Spur am Programmamfang auf einen definierten Wert zu
setzen, kann man das Kommando 
 
                         #ib(1)#<ESC> O 8#ie(1)# <n>    (Hex 1B 4F 38 <n>) 
 
benutzen. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 3. 
 
#on("u")#Bit 0 hat folgende Bedeutung:                                    #off("u")# 
  0       Pendown. Die Schildkröte hinterläßt eine sichtbare Spur 
  1       Penup. Die Schildkröte hinterläßt keine Spur 
 
#on("u")#Bit 1 hat folgende Bedeutung:                                    #off("u")# 
  0       Drawer. Es wird eine weiße Linie gezeichnet. 
  1       Eraser. Es wird eine schwarze Linie gezeichnet (gelöscht) 
 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> O 9#ie(1)#    (Hex 1B 4F 39) 
 
wird die Turtle-Graphik initialisiert. Dieses Kommando muß nicht aufgerufen
werden bevor die Turtle-Graphik benutzt wird, sollte aber nach Möglichkeit
am Anfang eines Turtle-Graphik-Programmes benutzt werden. Das Kommando setzt
die Schildkröte in die Mitte des Bildschirms (140, 96) mit Blickrichtung
nach oben. Der Drawer wird eingeschaltet (zeichnen) und eine sichtbare Linie
wird voreingestellt (Pendown). 
 
 
#k("6.6.2", "Komplexere Zeichenkommandos")# 
 
Außer den Kommandos zum Zeichnen von Linien und zum Bewegen des Graphikcur-
sors gibt es noch verschiedene andere Zeichenkommandos. 
 
 
#k("6.6.2.1", "Kreise und Kreissegmente")# 
 
Der Mittelpunkt eines Kreises liegt immer an der aktuellen Cursorposition.
Der Radius eines Kreises ist in weiten Grenzen von 0 bis über 30000 Punkten
wählbar. Clipping wird ausserhalb des Bildschirmrandes durchgeführt. Ein
Kreis kann in 8 Segmente unterteilt werden, von denen alle oder nur einzel-
ne gezeichnet werden können. Damit ist es dann auch möglich, Halb- oder
Viertelkreise zu Zeichnen. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> K#ie(1)# <r, s;>   (Hex 1B 4B <r, s;>) 
 
wird ein Kreis mit dem Radius <r> um die aktuelle Cursorposition gezeichnet
(relative Kreise). <s> legt fest, welche Segmente gezeichnet werden sollen.
<r, s;> sind dezimale oder binäre Parameter. <s> hat den Wertebereich von 0
bis 255. 
Jedes Bit in <s> ist einem Kreissegment zugeordnet. Ist das Bit gesetzt (1),
dann wird das zugehörige Segment gezeichnet. Der Wert 0 entspricht dem Wert
255 (der ganze Kreis wird gezeichnet), ist aber etwas schneller, da keine
Abfrage der einzelnen Bits durchgeführt wird. 
 
Die Segmente sind folgendermaßen numeriert: 
 
                                  7  0 
                                6      1 
                                5      2 
                                  4  3 
 
Beispiele für <n> : 
 
#on("u")#<n>  Bedeutung                               #off("u")#
  0  Zeichnet einen ganzen Kreis 
 15  Zeichnet einen links offenen Halbkreis 
240  Zeichnet einen rechts offenen Halbkreis 
195  Zeichnet einen unten offenen Halbkreis 
 60  Zeichnet einen oben offenen Halbkreis 
  3  Zeichnet ein Kreisviertel rechts oben 
 12  Zeichnet ein Kreisviertel rechts unten 
 48  Zeichnet ein Kreisviertel links unten 
192  Zeichnet ein Kreisviertel links oben 
etc. 
 
Das Aussehen von Kreisen kann durch die Parameter Farbe/Helligkeit und die
Bitverknüpfung verändert werden. Der Linientyp (Punkt-, Strichlinie) und die
Strickdicke haben keinen Einfluß, d.h. der Kreis wird immer mit durchgehen-
der Linie und einfacher Dicke gezeichnet. Sollen diese beiden Parameter auch
verändert werden, sollte man den Befehl <ESC> s für Ellipsenbögen verwenden. 
 
 
#k("6.6.2.2", "Rechtecke")# 
 
Rechtecke werden ebenso wie Kreise relativ gezeichnet, d.h. die aktuelle
Cursorposition bildet eine Ecke des Rechtecks. Die Seiten des Rechtecks
liegen parallel zur X- und Y-Achse, gedrehte Rechtecke können aber aus 4
relativen Draw-Befehlen zusammengesetzt werden. 
 
Das Kommando 
 
                         #ib(1)#<ESC> J#ie(1)# <b, h;>    (Hex 1B 4A <b, h;>) 
 
zeichnet ein leeres Rechteck (Rahmen) an der aktuellen Cursorposition. <b,
h;> sind dezimale oder binäre Parameter. <b> ist die Breite des Rechtecks
und kann den ganzen Wertebereich von -32768 bis 32767 überstreichen, <h> ist
die Höhe des Rechtecks und kann ebenfalls diesen Wertebereich überstreichen.
Je nach Vorzeichen von <b> und <h> wird das Rechteck links/ rechts und
oben/unten von der aktuelle Cursorposition gezeichnet. 
 
<b> <h>  Cursorposition bildet die Ecke 
 +   +   unten links 
 +   -   oben links 
 -   +   unten rechts 
 -   -   oben rechts 
 
 
#k("6.6.2.3", "Bögen und Ellipsen")# 
 
Um die Zeichengeschwindigkeit eines Kreises zu vergrößern, wurde ein sepa-
rater Befehl für Kreise eingeführt (6.6.2.1). Da der Kreis ein Sonderfall
der Ellipse ist, kann man das in diesem Abschnitt beschriebene Kommando auch
benutzen, um Kreise mit anderen als den unter 6.6.2.1 beschriebenen Segmen-
ten oder Parametern (Dicke, Strichtyp) zu Zeichnen. 
 
Das Kommando 
 
                         #ib(1)#<ESC> s#ie(1)# <xr, yr,> <aw, ew;>    (Hex 1B 73 ...) 
 
zeichnet um die aktuelle Cursorposition (also relativ) einen Ellipsenbogen
mit Radius <xr> in X-Richtung und Radius <yr> in Y-Richtung, ausgehend vom
Anfangswinkel <aw> im Uhrzeigersinn, bis zum Endwinkel <ew>. Der Winkel 0
Grad ist dabei oben (Norden). 
 
Alle Parameter sind dezimale oder binäre Parameter. <aw> und <ew> haben den
Wertebereich von 0 bis 255, wobei eine ganze Ellipse einem Anfangswinkel von
0 und einem Endwinkel von 72 entspricht. Die Winkelangaben sind in 5 Grad
Schritten und können Anhang A entnommen werden.. <xr> und <yr> dürfen den
vollen Wertebereich von -32768 bis 32767 überstreichen. 
 
 
#k("6.6.2.4", "Gefüllte Flächen")# 
 
Rechteckige oder rautenförmige Flächen können, wie in Abschnitt 6.5.1.4
beschrieben, schnell gefüllt werden. Für beliebig geformte Flächen kann das
Kommando 
 
                         #ib(1)#<ESC> |#ie(1)#<n>    (Hex 1B 7C <n>) 
 
benutzt werden. Dies ist ein relatives Kommando, da um die aktuelle Cursor-
position herum gefüllt wird. <n> ist ein Byteparameter mit dem Wertebereich
0 bis 15, der die Nummer des Musters für die Füllung angibt. Der Fill-Befehl
arbeitet auf der aktuellen Arbeitsseite und füllt eine sichtbar begrenzte
Fläche mit einem angegebenen Muster aus. 
 
Ist die Bitverknüpfung OR eingestellt darf der Cursor nicht auf einem weißen
Punkt stehen und die Fläche muß von einer durchgehenden weißen Linie be-
grenzt sein. 
Ist die Bitverknüpfung AND eingestellt, darf der Cursor nicht auf einem
schwarzen Punkt stehen und die Fläche muß von einer durchgehenden schwarzen
Linie begrenzt sein. 
 
Außer den Parametern Bitverknüpfung und Helligkeit/Farbe werden keine be-
rücksichtigt. 
 
Bei sehr komplex geformten Figuren kann der Fall eintreten, daß die Fläche
nicht ganz gefüllt ist. Dies liegt daran, daß intern ein zu größer Spei-
cherplatz zum Merken von Rücksprungcursorpositionen benötigt wird (Stack-
Überlauf). In diesem Fall sollte man den Cursor nocheinmal auf die nicht
gefüllte Fläche setzen und das Kommando erneut geben. 
 
<n> kann folgende Werte annehmen (Werte Hexadezimal angegeben 0..F): 
<n>  Bedeutung 
#linie ("16.2")# 
 0   Fläche ganz gefüllt 
 1   Fläche halb gefüllt (grau) 
 2   Jede 4. Zeile wird durchgezogen 
 3   Jede 2. Zeile wird durchgezogen 
 4   Jede 4. Spalte wird durchgezogen 
 5   Jede 2. Spalte wird durchgezogen 
 6   Jede 4. Zeile und jede 4. Spalte wird durchgezogen (grobes Raster) 
 7   Jede 2. zeile und jede 2. Spalte wird durchgezogen (feines Raster) 
 8   Schraffur von links unten nach rechts oben 
 9   Schraffur von links oben nach rechts unten 
 A   Schräges Raster (Links- und Rechtsschraffur) 
 B   Feines Funktraster(jeder 2.Punkt in x- und y-Richtung wird gesetzt) 
 C   Mauerwerk 
 D   Feines Netzgeflecht 
 E   Feine Zickzacklinie 
 F   Benutzerdefinierbares Muster. Default: Grobe Zickzacklinie 
 
Ist die AND-Bitverknüpfung eingeschaltet, dann sind die Punkte schwarz und
weiß in den Mustern vertauscht und in der obigen Tabelle sind die Bezeich-
nungen 'gefüllt' und 'gelöscht' auszutauschen. 
 
 
#k("6.6.2.4.1", "Definition des Musters")# 
 
Das benutzerdefinierbare Muster des Fill-Befehls (Muster 15) kann mit dem
Kommando 
 
                         #ib(1)#<ESC> O :#ie(1)# <b1..b8>   (Hex 1B 4F 3A <b1..b8>) 
 
eingestellt werden. Das Defaultmuster wird dabei überschrieben, das neu
eingestellte Muster allerdings nicht beim Setup mitgesichert. 
<b1..b1> sind 8 Byteparameter mit dem gesamten Wertebereich 0 bis 255. Das
erste Byte wird im Füllmuster in Richtung der niedrigeren y-Positionen dar-
gestellt, das niederwertigste Bit jedes Bytes in Richtung der niedrigeren
x-Positionen. 
 
 
#k("6.7", "Graphikdaten zum Host")# 
 
Bisher wurden nur Kommandos beschrieben, die der Host an das Terminal sen-
den kann. Damit der Host über den Status des Terminals informiert werden
kann, sind auch Kommandos vorhanden, die Daten an den Host senden. Der Host
kann auch ganze Graphikseiten anfordern, so daß die auf dem Terminal er-
zeugten Graphiken nach dem Ausschalten nicht verloren sind, sondern vom Host
gespeichert werden können. 
 
 
#k("6.7.1", "Graphikseiten zum Host")# 
 
Graphikseiten können ganz oder teilweise übertragen werden. Da ein angefor-
dertes Datenpaket immer ganz übertragen wird, sollte der Host, wenn keine
Flußkontrolle eingeschaltet ist, nur so große Blöcke anfordern, die er puf-
fern kann (z.B. 256 Bytes). Selektives Lesen von Graphikseiten kann auch
verwendet werden, um Teile einer Graphik vom Host (und nicht vom Terminal)
verändern zu lassen. Mit dem Kommando <ESC> / ... kann der modifizierte Teil
dann wieder an das Terminal zurückgesendet werden. Zum Aufbau der Graphik-
seite findet man in Kapitel 6.4.2 Informationen. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> \#ie(1)# <ll> <lh> <al> <ah>   (Hex 1B 5C ...) 
 
kann eine Seite oder ein Teil einer Seite in an den Host gesendet werden.
<lh>, <ll>, <ah> und <al> sind Byteparameter (8 Bits). <ll> und <lh> bilden
zusammen die binäre Länge, d.h. die Anzahl der Datenbytes, die zum Host
gesendet werden. Die Länge kann von 0 bis Hex 2000 (dezimal 8192) reichen.
Die Adresse durch <al> und <ah> gebildet, darf von 0 bis Hex 1FFF reichen.
Zusätzlich gilt, daß die Summe von Länge und Adresse nicht größer als Hex
2000 sein darf, da sich die Endadresse dann ausserhalb der Graphikseite
befindet. In diesem Fehlerfall werden keine Daten gesendet. 
 
 
#k("6.7.2", "Cursorposition zum Host")# 
 
Da die Graphikcursorposition einen anderen Wertebereich überstreicht als die
Position des Textcursors, wurde zum Senden der Graphikcursorposition ein
weiteres Kommando eingeführt. Pro Koordinate werden dabei 2 Bytes, zusammen
also 4 Bytes, gesendet. Mit dem Kommando 
 
                         #ib(1)#<ESC> ;#ie(1)#    (Hex 1B 3B) 
 
kann der Host diese 4 Bytes anfordern. Die Reihenfolge der Bytes ist <xlow>
<xhigh> <ylow> <yhigh>. Im Gegensatz zu <ESC> ? (für die Textcursorposi-
tion) wird auch kein abschließendes <CR> gesendet. 
 
 
#k("6.7.3", "Einzelne Bits zum Host")# 
 
Außer ganzen Graphikseiten oder Blöcken daraus, kann der Host auch einzelne
Bytes oder Bits selektieren und empfangen. Dazu stehen zwei Kommandos zur
Verfügung. Mit dem Kommando 
 
                         #ib(1)#<ESC> _#ie(1)#    (Hex 1B 5F) 
 
kann das Byte angefordert werden, in dem sich der Graphikcursor gerade be-
findet. Das Bit 7 ist das Farb- oder Helligkeitsbit, das Bit (xpos MOD 7)
ist das Bit, das durch den Graphikcursor addressiert wird. Wenn der Cursor
außerhalb des sichtbaren Bereichs ist, wird ein Byte Hex 00 geliefert. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> -#ie(1)#    (Hex 1B 2D) 
 
kann das Bit, daß durch die Graphikcursorposition addressiert wird, abge-
fragt werden. Dieses Kommando liefert ein Byte, in dem die Bits folgende
Bedeutung haben: 
 
#on("u")#Bit 0 Dezimal   Bedeutung                            #off("u")# 
  0      0      Das adressierte Bit ist nicht gesetzt 
  1      1      Das adressierte Bit ist gesetzt 
 
#on("u")#Bit 1 Dezimal   Bedeutung                   #off("u")# 
  0      0      Die Farbe ist violett/dunkel 
  1      2      Die Farbe ist gelb/hell 
 
Bit 2 Dezimal   Bedeutung 
#linie ("16.2")# 
  0      0      Der Graphikcursor ist innerhalb des sichtabren Bereichs 
  1      4      Der Graphikcursor ist außerhalb des sichtbaren Bereichs. 
                Bit 0 und Bit 1 sind dann 0. 
 
Bit 4 und Bit 5 sind immer 1. Es werden also die ASCII-Ziffern "0" bis "4"
geliefert. 
 
 
#k("6.7.4", "Parameter zum Host")# 
 
Die eingestellten Draw-Parameter können auch abgefragt werden. Dazu exi-
stieren zwei Kommandos. Mit dem Kommando 
 
                         #ib(1)#<ESC> 4#ie(1)#    (Hex 1B 34) 
 
können die Nummer der sichtbaren und der Arbeitsseite, im gleichen Format
wie zum Einstellen der Seiten mit dem Kommando #ib(1)#<ESC> O 7#ie(1)# <n>, angefordert
werden. Es werden ASCII-Zeichen von "0" bis "?" geliefert. Die Bits 0 bis 2
sind folgendermaßen zugeordnet: 
 
#on("u")#Bit 0  Bedeutung                #off("u")# 
  0    Sichtbar ist Seite 0 
  1    Sichtbar ist Seite 1 
 
#on("u")#Bit 1  Bedeutung               #off("u")# 
  0    Arbeitsseite ist Seite 0 
  1    Arbeitsseite ist Seite 1 
 
#on("u")#Bit 2  Bedeutung               #off("u")# 
  0    Nur Graphik eingeschaltet 
  1    In den letzten 32 Graphikzeilen 
       sind 4 Textzeilen eingeblendet 
 
#on("u")#Bit 3  Bedeutung                         #off("u")# 
  0    Der Graphikmodus ist eingeschaltet 
  1    Der Textmodus ist eingeschaltet 
 
Sinnvoll sind die Werte der Bits 0 bis 2 nur dann, wenn Bit 3 = 0 ist. 
 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 5#ie(1)#    (Hex 1B 35) 
 
können die Linienparameter abgefragt werden. Es wird ein Byte mit dem Wer-
tebereich von 1 bis 127 geliefert. Die einzelnen Bits sind folgendermaßen
zugeordnet: 
 
Bit        Bedeutung 
#linie("16.2")# 
Bit 0..3 : Strichdicke 
Bit 4..5 : Bitverknüpfung (0 = OR, 16 = AND, 32 = XOR, 48 = COPY) 
Bit 6    : Aktuelle Farbe (0 = Violett/dunkel, 1 = Gelb/hell) 
 
Die Bitbelegung entspricht der des Parameters des Kommandos #ib(1)#<ESC> O 5#ie(1)# <n>. 
 
 
#k("6.8", "Graphikhardcopy")# 
 
Wie von der Textseite kann auch von den Graphikseiten ein Ausdruck angefer-
tigt werden. Dabei können keine verschiedene Helligkeitsstufen oder Farben
dargestellt werden. 
 
 
#k("6.8.1", "Der Druckertreiber")# 
 
Da das Ein- und Ausschalten des Graphikmodus nicht auf allen Druckern durch
gleiche Kommandos erreicht werden kann, muß das Terminal an den vorhandenen
Drucker angepaßt werden. Defaultmäßig werden die Epson-Modelle ab RX80 auf-
wärts, sowie kompatible (IBM, Panasonic etc.) unterstützt. Die Anpassung
wird in diesem Abschnitt beschrieben. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> ~#ie(1)# <n> <p...>    (Hex 1B 7E <n> <p...>) 
 
können Kommandosequenzen eingestellt werden, die folgende Aufgaben haben: 
 
<n> Default (Hex)   Aufgabe 
#linie ("16.2")# 
 0  0D              Einleiten der gesamten Hardcopy (Waagenrücklauf) 
 1  1B 2A 04 18 01  Einschalten des Graphikmodus. Es folgen 280 Graphikby-
                    tes (jeweils 8 Bit) 
 2  0D 1B 4A 17     Ausschalten des Graphikmodus. Zeilenvorschub ohne Zwi-
                    schenraum (Zeilenabstand ca. 8 Punkte) und Waagenrück-
                    lauf. 
 3     Nichts       Dieses Kommando wird nach der kompletten Hardcopy zum
                    Drucker gesendet. 
 
Wenn doppelte Punktbreite eingeschaltet ist, oder zwei Seiten nebeneinander
gedruckt werden, wird die Kommandosequenz 1 auch mehrmals in einer Zeile
gegeben. 
 
<n> ist dabei ein Byteparameter mit dem Wertebereich von 0 bis 3. <p...> ist
eine Folge von bis zu 16 Bytes. Das erste dieser 16 Bytes ist ein Längenby-
te, das die Länge der Kommandosequenz (oder die Anzahl der noch folgenden
Bytes) angibt. Für die nach dem Längenbyte folgenden Bytes sind alle Werte
von 0 bis 255 erlaubt. 
 
Die Druckertreiberstrings (Kommandosequenzen) werden beim Setup in der Kom-
mandozeile auch mit abgespeichert, so daß sie nur einmal (wenn überhaupt)
und dann nie wieder eingestellt werden müßen. 
 
 
#k("6.8.2", "Die Hardcopyparameter")# 
 
Im Gegensatz zur Hardcopy einer Textseite kann das Aussehen einer Graphik
beim Ausdruck noch verändert werden. Das Kommando 
 
                         #ib(1)#<ESC> ^#ie(1)# <n>    (Hex 1B 5E <n>) 
 
druckt eine Hardcopy mit dem Parameter <n>. <n> ist ein Byteparameter mit
dem Wertebereich von 0 bis 15. Jedes Bit in <n> legt eine Darstellungsweise
fest. Die Bits haben folgende Bedeutung: 
 
Invertieren: 
Bit 0 Dezimal Bedeutung 
#linie("16.2")# 
  0      0    Helle Punkte auf dem Bildschirm werden auf dem Drucker schwarz
              gedruckt, dunkle Punkte bleiben beim Ausdruck weiß. 
  1      1    Die Graphik wird invertiert, d.h. Ein dunkler Bildhintergrund
              bleibt auf dem Drucker dunkel (schwarz). 
 
Doppelte Breite: 
Bit 1 Dezimal Bedeutung 
#linie("16.2")# 
  0      0    Jeder Bildschirmpunkt wird in normaler Breite gedruckt. Es
              werden also 280 Punkte nebeneinander gedruckt. 
  1      2    Jeder Bildschirmpunkt wird in doppelter Breite gedruckt. In
              diesem Fall werden auf dem Drucker 560 Punkte nebeneinander
              gedruckt. 
 
Doppelte Höhe: 
Bit 2 Dezimal Bedeutung 
#linie("16.2")# 
  0      0    Jeder Bildschirmpunkt wird in normaler Höhe gedruckt. Es wer-
              den also 192 Punkte untereinander gedruckt. 
  1      4    Jeder Bildschirmpunkt wird in doppelter Höhe gedruckt. In
              diesem Fall werden also 384 Punkte untereinander gedruckt. 
 
Zwei Seiten nebeneinander drucken: 
Bit 3 Dezimal Bedeutung 
#linie("16.2")# 
  0      0    Es wird nur eine Graphikseite (linksbündig) gedruckt. 
  1      8    Die aktuelle (mit #ib(1)#<ESC> O 7#ie(1)# <n> eingestellte) Graphikseite
              wird linksbündig und die andere Graphikseite nahtlos rechts
              daneben gedruckt. 
 
Zur Kombination von Möglichkeiten (mehrere Bits sind gesetzt): 
 
- Eine Graphik mit doppelter Höhe und doppelter Breite hat ungefähr das
  Format des Bildschirms. Ein Ausdruck besteht dann aus 560 x 384 = 215040
  Punkten. Zusätzliches Invertieren macht die Graphik dem Bildschirmausse-
  hen noch ähnlicher. 
 
- Werden zwei Seiten mit doppelter Breite nebeneinander gedruckt, dann re-
  icht die Anzahl der Graphikspalten auf dem Drucker mit dem Defaultgra-
  phikmodus nicht mehr aus. In diesem Fall sollte man die Druckertreiber
  Kommandosequenz 1 temporär auf eine hohe (4-fache) Dichte umschalten.
  Solange kein Setup ausgeführt wird, ist diese Dichte nur solange gültig,
  bis das Terminal ausgeschaltet wird. 
 
#page# 
#h("7.", "Die Parameter der seriellen Schnittstelle")# 
 
 
Die Parameter der seriellen Schnittstelle können vom Host durch Escape-
Sequenzen gändert werden. Die Änderung der Parameter wird erst durchgeführt,
wenn die Parameterübergabe komplett ist (d.h das letzte Byte wurde übertra-
gen). Alle Übertragungsparameter wie Stopbits, Datenbits, Parität und Bau-
drate werden zusammen in einem 'Rutsch' eingestellt. Die Art der Flußkon-
trolle wird mit separaten Escape-Sequenzen eingestellt. 
Die Einstellung in der Kommandozeile ist im Kapitel 3 beschrieben. 
 
 
#k("7.1", "Das Übertragungsformat")# 
 
Das Übertragunsformat eines Datenbytes sieht folgendermaßen aus: 
(Beispiel für 8 Datenbits, 1 Paritätsbit und 1 Stopbit) 
 
        +---+---+---+---+---+---+---+---+---+---+---+ 
    ... |"0"| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | P |"1"| ... 
        +---+---+---+---+---+---+---+---+---+---+---+ 
       Start-  ----  D a t e n b i t s ---- Pari- Stop- 
        bit                                 täts- bit 
                                            bit 
     --------> Zeit 
 
Bei 7 Datenbits ist das Bit 7 "0". P bezeichnet das Paritätsbit. Wenn zwei
Stopbits übertragen werden steht an dieser Stelle das 1. Stopbit ("1"). 
 
 
#k("7.2", "Die Übertragungsparameter")# 
 
Alle vier Parameter werden zugleich verändert. Das Kommando lautet 
 
                         #ib(1)#<ESC> <SPACE> <SPACE>#ie(1)# <x>    (Hex 1B 20 20 <x>) 
 
<x> ist dabei ein Datenbyte, das wie folgt festgelegt wird: 
 
   Bit     7       6       5       4       3       2       1       0 
       +-------+-------+-------+-------+-------+-------+-------+-------+ 
       |Parity |Parity | Stop- | Daten-|            Baudrate           | 
       | even/ |on/off | bits  | bits  |       |       |       |       | 
       | odd   |       |       |       |       |       |       |       | 
       +-------+-------+-------+-------+-------+-------+-------+-------+ 
 
 
#k("7.2.1", "Baudrate")# 
 
Baudrate = Anzahl der pro Sekunde übertragenen Bits (Übertragungsgeschwin-
digkeit) . 
 
         Bits 
#on("u")#Dezimal 3 2 1 0    Neue Baudrate#off("u")# 
  0     0 0 0 0    Alte Baudrate (nicht verändern) 
  1     0 0 0 1      50 Baud 
  2     0 0 1 0      75 Baud 
  3     0 0 1 1     109.9 Baud 
  4     0 1 0 0     134.58 Baud 
  5     0 1 0 1     150 Baud 
  6     0 1 1 0     300 Baud 
  7     0 1 1 1     600 Baud 
  8     1 0 0 0    1200 Baud 
  9     1 0 0 1    1800 Baud 
 10     1 0 1 0    2400 Baud 
 11     1 0 1 1    3600 Baud 
 12     1 1 0 0    4800 Baud 
 13     1 1 0 1    7200 Baud 
 14     1 1 1 0    9600 Baud 
 15     1 1 1 1   19200 Baud 
 
Der Wert 0 kann gebraucht werden, wenn nur Datenbits, Stopbits und Pari-
tätsbit verändert werden sollen. 
 
 
#k("7.2.2", "Datenbits")# 
 
Bit 4 legt die Anzahl der gesendeten und empfangenen Datenbits fest. 
 
#on("u")#Dezimal Bit 4              #off("u")# 
   0      0     8 Datenbits 
  16      1     7 Datenbits 
 
Mit einem anschliessenden Kommando 
 
                         #ib(1)#<ESC> <SPACE> 6#ie(1)#    (Hex 1B 20 36) 
 
kann das 8. Datenbit ausmaskiert (d.h auf "0" gesetzt) werden. Dies kann
notwendig sein, wenn der Host nur 7 Bit ASCII verarbeitet und auf ein ge-
setztes 8. Datenbit falsch reagiert (Steuerbit oder ähnliches). 
 
Mit 
 
                         #ib(1)#<ESC> <SPACE> 7#ie(1)#    (Hex 1B 20 37) 
 
kann die Maskierung wieder aufgehoben werden. 
Zu beachten ist, daß bei 7 Bit Datentransfer zum Beispiel das Farbbit bei
Download einer Graphikseite nicht übertragen wird. 
 
 
#k("7.2.3", "Stopbits")# 
 
Bit 5 legt die Anzahl der Stopbits fest. 
 
#on("u")#Dezimal Bit 5            #off("u")# 
   0      0    1 Stopbit 
  32      1    2 Stopbits 
 
Zu beachten ist, daß bei eingeschaltetem Paritycheck und 8 Datenbits immer
ein Stopbit übertragen wird, auch wenn 2 Stopbits programmiert wurden. (Es
können maximal 11 Bits/Daten"byte" übertragen werden.) 
 
 
#k("7.2.4", "Paritätsbit")# 
 
Bit 6 legt fest, ob Paritätskontrolle erfolgen soll und ob ein Paritätsbit
vorhanden ist. 
 
Dezimal Bit 6 
#linie("16.2")# 
   0      0     Keine Paritätskontrolle/Kein Paritätsbit 
  64      1     Paritätskontrolle eingeschaltet. Parität mit Bit 7 gewählt 
 
Wenn Bit 6 = 1 ist legt Bit 7 fest, ob gerade oder ungerade Parität geprüft
werden soll. 
 
#on("u")#Dezimal Bit 7                   #off("u")# 
   0      0     Ungerade Parität 
 128      1     Gerade Parität 
 
 
#k("7.2.5", "Übertragungsfehler")# 
 
Wird ein Rahmenfehler (Stopbit fehlt) oder ein Paritätsfehler (mindestens
ein Bit verfälscht) entdeckt, dann wird statt des empfangenen Mülls ein Byte
Hex FF vom Terminal interpretiert. Steht dies im Text, kann man es als in-
vertiertes Punktraster erkennen. Dieses Zeichen richtet wenig Schaden an,
wenn es mitten in einer Escape-Sequenz empfangen wird. 
 
 
#k("7.3", "Die Flußkontrolle")# 
 
Damit keine Daten verloren gehen, wenn der Host oder das Terminal keine
solchen mehr empfangen kann, sollte eine Flußkontrolle eingeschaltet wer-
den. Das Terminal hat zwar einen Empfangspuffer von 4K Byte (4096 Zeichen),
aber auch dieser kann einmal voll sein. Der Sendepuffer von 2K Byte (2048
Zeichen) wird in Anspruch genommen, wenn der Host dem Terminal per Flußkon-
trolle mitgeteilt hat, daß er keine Zeichen mehr empfangen kann. Das Termi-
nal wartet dann nicht aktiv auf Freigabe vom Host, sondern kann weiter ar-
beiten (Spooler, Bildschirmausgabe, Localmodus etc.). 
 
Wenn das Terminal den Host "gestoppt" hat, kann man das an einem "B U S Y"
in der Statuszeile erkennen, sonst steht dort "R E A D Y". 
Wenn der Host das Terminal "gestoppt" hat, kann man das an einem "T X O F F"
in der Statuszeile erkennen, sonst steht dort "T X   O N". 
 
Da dieses Terminal einen großen Empfangspuffer hat, sollte man allerdings im
Notfall auch ohne Flußkontrolle auskommen, wenn nicht gerade umfangreiche
Graphikoperationen ausgeführt werden sollen, bei denen der Puffer nicht
schnell genug geleert werden kann. 
 
 
#k("7.3.1", "XON/XOFF")# 
 
XON/XOFF ist eine Softwareflußkontrolle. Als Stopzeichen wird 
 
                         #ib(1)#XOFF#ie(1)#    (#ib(1)#<CTRL S>#ie(1)# Hex 13) 
 
verwendet. Als Startzeichen wird 
 
                         #ib(1)#XON#ie(1)#    (#ib(1)#<CTRL Q>#ie(1)# Hex 11) 
 
verwendet. Diese Flußkontrolle sollte nur im Textmodus verwendet werden, da
Binärdaten möglicherweise Hex 11 oder Hex 13 enthalten, die dann nicht als
Protokollzeichen verwendet werden sollen. Der Vorteil dieser Art der Fluß-
kontrolle ist, daß man mit 3 Leitungen (Masse, TXD, RXD) an der seriellen
Schnittstelle auskommt. 
 
Das Terminal reagiert auf empfangene XON/XOFF-Zeichen sofort, d.h diese
Zeichen werden nicht in den Empfangspuffer gestellt. Diese beiden Zeichen
werden auch dann interpretiert, wenn das Terminal im Local-Modus ist. 
 
Die XON/XOFF Flußkontrolle kann in der 2. Kommandozeile ein- und ausgeschal-
tet werden, sowie mit dem Kommando 
 
                         #ib(1)#<CTRL O>#ie(1)#    (Hex 0F) 
 
eingeschaltet und mit 
 
                         #ib(1)#<CTRL N>#ie(1)#    (Hex 0E) 
 
ausgeschaltet werden. 
 
Zu beachten ist, daß der Sender vor dem Ausschalten noch im "TX OFF"-
Zustand sein kann. Man sollte deshalb direkt vor <CTRL N> noch <CTRL Q> (Hex
11), also XON senden, um den Sender wieder einzuschalten. Dies wird vom
Terminal nicht automatisch gemacht, da sonst ein <CTRL N> das im Datenstrom
vorkommt, auch noch ein Zeichen für Flußkontrolle wäre. 
 
 
#k("7.3.2", "DTR/DSR")# 
 
DTR/DSR ist eine Hardwareflußkontrolle bei der die Leitungen Pin 20 (DTR)
und Pin 6 (DSR) (in der Regel überkreuzt) angeschloßen sein müssen. 
Bei dieser Art der Flußkontrolle dürfen alle Zeichen übertragen werden, ohne
daß eines die Flußkontrolle steuert. Ausnahme: Wenn zusätzlich XON/ XOFF
Flußkontrolle eingeschaltet ist werden natürlich XON/XOFF als Steuerzeichen
interpretiert. 
 
DTR (Data Terminal Ready)/DSR (DataSet Ready) Flußkontrolle kann in der 2.
Kommandozeile ein- und ausgeschaltet werden. Der Host kann dies mit dem
Kommando 
 
                         #ib(1)#<ESC> <SPACE>#ie(1)# <n>    (Hex 1B 20 <n>) 
 
erreichen. Die Werte von <n> sind 
 
#on("u")#<n>  Hex    Bedeutung                                              #off("u")# 
 2    32    Weder RTS/CTS noch DSR/DTR Flußkontrolle 
 3    33    RTS/CTS Flußkontrolle, aber keine DSR/DTR Flußkontrolle 
 4    34    DSR/DTR Flußkontrolle, aber keine RTS/CTS Fluskontrolle 
 5    35    DSR/DTR und RTS/CTS Flußkontrolle 
 
DTR/DSR Flußkontrolle wird empfohlen, da hier alle Zeichen ohne Veränderung
empfangen werden können. RTS/CTS Flußkontrolle kann, hardwaremäßig bedingt,
beim Einschalten von RTS ein Bit "umkippen". 
 
 
#k("7.3.3", "RTS/CTS")# 
 
RTS/CTS ist eine Hardwareflußkontrolle bei der die Leitungen Pin 4 (RTS) und
Pin 5 (CTS) (in der Regel überkreuzt) angeschloßen sein müssen. 
Bei dieser Art der Flußkontrolle dürfen alle Zeichen übertragen werden, ohne
daß eines die Flußkontrolle steuert. Ausnahme: Wenn zusätzlich XON/ XOFF
Flußkontrolle eingeschaltet ist werden natürlich XON/XOFF als Steuerzeichen
interpretiert. 
 
RTS (Ready To Send)/CTS (Clear To Send) Flußkontrolle kann in der 2. Kom-
mandozeile ein- und ausgeschaltet werden. Der Host kann dies mit dem Kom-
mando <ESC> <SPACE> <n> erreichen. Die Werte von <n> sind im letzten Ab-
schnitt (7.3.2 DTR/DSR) angegeben. 
 
 
#k("7.4", "Echo und Local/Online")# 
 
In einigen Fällen verlangt der Host, daß das vom Terminal empfangene Zei-
chen zurückgesendet (geechoed) wird, um eventuelle Übertragungsfehler zu
erkennen. Dieser Modus wird mit dem Kommando 
 
                         #ib(1)#<ESC> D E#ie(1)#    (Hex 1B 44 45) 
 
eingeschaltet. Zusätzlich wird hiermit der Localmodus ausgeschaltet (d.h der
Online-Modus eingeschaltet), falls das Kommando am Terminal im Local-Modus
gegeben wurde. 
 
Der Echo-Modus wird mit dem Kommando 
 
                         #ib(1)#<ESC> D O#ie(1)#    (Hex 1B 44 4F) 
 
ausgeschaltet. Das Terminal befindet sich dann im Fullduplex Online-Modus.
Der Local-Modus wird auch hierbei verlassen. 
 
Der Local-Modus kann vom Host mit dem Kommando 
 
                         #ib(1)#<ESC> D L#ie(1)#    (Hex 1B 44 4C) 
 
eingeschaltet werden. Dabei ist zu beachten, daß der Host den Local-Modus
nicht ausschalten kann. Der Local-Modus kann vom Benutzer durch Drücken von
#ib(1)#<SHIFT CTRL HOME>#ie(1)# am Keyboard verlassen werden. 
 
Im Local-Modus werden Keyboardeingabe nicht mehr an den Host geschickt,
sondern auf dem Bildschirm angezeigt bzw. durch das Terminal interpretiert.
Funktionstastensequenzen werden auch nicht an den Host geschickt. Escape-
Sequenzen die allerdings Daten senden (z.B Download von Text und Graphik
oder die Abfrage der Cursorposition), werden wie im Online-Modus ausgeführt,
d.h. die Daten werden zum Host geschickt. 
 
#page# 
#h("8.", "Spezielle Kommandos im Textmodus")# 
 
 
In diesem Kapitel werden weitere Kommandos, die im Textmodus wirksam sind
und thematisch nicht in die anderen Kapitel passen, beschrieben. 
 
 
#k("8.1", "Weitere Cursorpositionierungskommandos")# 
 
Zusätzlich zu den im Graphikmodus und im Textmodus gültigen Cursorpositio-
nierungskommandos gibt es noch einige weitere. Die fünf Kommandos Zeile
löschen, Zeile einfügen, Zeichen löschen, Zeichen einfügen und Rückwärtsta-
bulator sind schon in Kapitel 5 beschrieben worden. 
 
Hier nur noch einmal die entsprechenden Kommandos: 
 
Funktion            Escape-Sequenz 
#linie("16.2")# 
Zeile einfügen      #ib(1)#<ESC> E#ie(1)#     oder #ib(1)#<ESC> L#ie(1)# 
Zeile löschen       #ib(1)#<ESC> R#ie(1)#     oder #ib(1)#<ESC> M#ie(1)# 
Zeichen einfügen    #ib(1)#<ESC> Q#ie(1)# 
Zeichen löschen     #ib(1)#<ESC> W#ie(1)# 
Rückwärtstabulator  #ib(1)#<ESC> I#ie(1)# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> j#ie(1)#    (Hex 1B 6A) 
 
kann ein umgekehrter Zeilenvorschub erreicht werden. Steht der Cursor in
Zeile 2 bis Zeile 24, dann wirkt dieses Kommando wie <UP>. Steht der Cursor
in Zeile 1, dann wird der Bildschirminhalt nach unten gescrollt und die
erste Bildschirmzeile gelöscht. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> =#ie(1)# <y+32> <x+32>    (Hex 1B 3D ...) 
 
kann der Cursor auf eine bestimmte Position auf dem Bildschirm gesetzt wer-
den. <x+32> und <y+32> sind dabei Byteparameter. <x+32> hat den Wertebe-
reich 32 (<SPACE>) bis 110 ("o"), <y+32> hat den Wertebereich 32 (<SPACE>)
bis 55 ("7"). <x+32> ist dabei die gewünschte x-Position + 32 (gezählt wird
von 0 bis 79), <y+32> ist die gewünschte y-Position + 32 (gezählt wird von 0
bis 23). Die Zuordnungen der ASCII-Zeichen zu den Cursorpositionen kann man
auch im Anhang A unter "Cursor" nachlesen. 
 
Dieser Befehl hat im Graphikmodus die gleiche Wirkung! 
 
 
#k("8.2", "Cursormodus")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> .#ie(1)# <n>    (Hex 1B 2E <n>) 
 
kann die Darstellung des Cursors verändert werden. Für <n> sind ASCII-Zei-
chen "0", "1" und "2" zugelassen. <n> hat folgende Bedeutung: 
 
#on("u")#<n>   Bedeutung                             #off("u")# 
 0    Cursor blinkt nicht und ist unsichtbar 
 1    Cursor blinkt und ist sichtbar 
 2    Cursor blinkt nicht und ist sichtbar 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> Z#ie(1)#    (Hex 1B 5A) 
 
kann der Zustand des Cursors von sichtbar auf unsichtbar und umgekehrt umge-
schaltet werden. 
 
 
#k("8.3", "Zeichensatz einstellen")# 
 
Da die Zeichensätze von Basis und Apple unterschiedlich sind, muß hier bei
den Parametern unterschieden werden. Das Kommando zur Einstellung des Zei-
chensatzes lautet in beiden Fällen 
 
                         #ib(1)#<ESC> z#ie(1)# <n>    (Hex 1B 7A <n>) 
 
wobei <n> ein Byteparameter ist. Beim Apple hat <n> folgende Bedeutung: 
 
<n>   Zeichensatz 
#linie("16.2")# 
 1    Full Ascii: 128 Zeichen, ASCII, normale, inverse und blinkende Zei-
 chen 
 4    Ascii: 128 Zeichen, ASCII, normale und blinkende Zeichen 
 
Beim Basis hat <n> folgende Bedeutung: 
 
<n>   Zeichensatz 
#linie("16.2")# 
 0 = Apple II: 64 Zeichen, ASCII, normale, inverse und blinkende Zeichen 
 1 = Full Ascii: 128 Zeichen, ASCII, normale, inverse und blinkende Zeichen 
 2 = Deutsch: 128 Zeichen, deutsch, normale und inverse Zeichen 
 4 = Ascii: 128 Zeichen, ASCII, normale und inverse Zeichen 
 6 = APL: 128 Zeichen, APL, normale und inverse Zeichen 
 
     Und mit blinkenden statt inversen Zeichen: 
 8 = Apple II: 64 Zeichen, ASCII, normale, blinkende und inverse Zeichen (!) 
 9 = Full Ascii: 128 Zeichen, ASCII, normale, blinkende und inv. Zeichen (!) 
10 = Deutsch: 128 Zeichen, deutsch, normale und blinkende Zeichen 
12 = Ascii: 128 zeichen, ASCII, normale und blinkende Zeichen 
14 = APL: 128 Zeichen, APL, normale und blinkende Zeichen 
 
Einige ausgewählte Zeichensätze können auch in der Kommandozeile eingestellt
werden. 
 
 
#k("8.4", "Texthardcopy")# 
 
Einen Ausdruck des Textbildschirminhaltes auf dem Drucker kann man mit dem
Kommando 
 
                         #ib(1)#<ESC> P#ie(1)#   (Hex 1B 50) 
 
erreichen. Der auf dem Drucker eingestellte Schrifttyp wird nicht verän-
dert. Es werden 24 Zeilen gedruckt, die Statuszeile wird nicht gedruckt,
sondern die "darunterliegende" 24. Textzeile. Nach jeder Zeile wird <CR> und
<LF> gedruckt, der Drucker sollte deshalb kein Autolinefeed bei <CR> durch-
führen. 
 
Inverse Bildschirmzeichen (80..FF) werden durch Doppeldruck (dunkler) her-
vorgehoben, Controlcharacter (00..1F und 80..9F) werden unterstrichen dar-
gestellt, das Punktraster (7F und FF) wird als unterstrichenes # darge-
stellt. 
 
 
#k("8.5", "Zeichen-Attribute")# 
 
Die Zeichenattribute werden mit dem Kommando 
 
                         #ib(1)#<ESC> G#ie(1)# <n>    (Hex 1B 47 <n>) 
 
eingestellt. <n> ist ein Byteparameter, der folgende Werte annehmen kann: 
 
#on("u")#<n>   Attribute                                                      #off("u")# 
 0    Sichtbare, normale Zeichen 
 1    Unsichtbare Zeichen, es werden Leerzeichen dargestellt 
 4    Sichtbare, inverse Zeichen 
 5    Unsichtbare Zeichen, es werden inverse Leerzeichen dargestellt. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> (#ie(1)#    (Hex 1B 28) 
 
kann auf normale Darstellung umgeschaltet werden (wirkt ähnlich <ESC> G 0,
schaltet aber nicht auf sichtbare Darstellung, falls unsichtbar). 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> )#ie(1)#    (Hex 1B 29) 
 
kann auf inverse Darstellung umgeschaltet werden (wirkt ähnlich <ESC> G 4,
schaltet aber nicht auf sichtbare Darstellung, falls unsichtbar). 
 
 
#k("8.6", "Bildhintergrund hell/dunkel")# 
 
Die Bildschirmdarstellung kann von heller Schrift auf dunklem Grund (be-
züglich eines gelöschten Bildschirms) umgeschaltet werden auf dunkle Schrift
auf hellem Grund. Die Darstellung "schwarz auf weiß" ist auf einigen Monito-
ren augenfreundlicher. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> b#ie(1)#    (Hex 1B 62) 
 
kann die dunkle Schrift auf weißem Grund eingeschaltet werden. Die Darstel-
lung von inverser und normaler Schrift wird vertauscht. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> d#ie(1)#    (Hex 1B 64) 
 
kann helle Schrift auf dunklem Grund eingeschaltet werden. 
 
 
#k("8.7", "Zeichentransfer zum Host")# 
 
Der Host kann Teile oder den ganzen Bildschirm vom Terminal lesen. Alle
Zeichen werden als Bytes gesendet, bei denen ein gesetztes Bit 7 Invers-
schrift anzeigt. 
 
 
#k("8.7.1", "Ein Zeichen senden")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 8#ie(1)#    (Hex 1B 38) 
 
wird nur das Zeichen an der Cursorposition gesendet. Die Cursorposition
ändert sich nicht. Der Cursor muß nicht sichtbar sein. 
 
 
#k("8.7.2", "Eine Zeile senden")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 6#ie(1)#    (Hex 1B 36) 
 
wird die Zeile, in der der Cursor steht (genauer: die Zeile der Cursorrow,
falls der Cursor unsichtbar ist) an den Host gesendet. Falls der Cursor in
Zeile 24 steht, wird nicht die Stauszeile, sondern die 24. Textzeile gesen-
det. Im Anschluß an die Zeile werden eventuell ein oder zwei eingestellte
Zeilenbegrenzer gesendet (Lineterminator). Die Programmierung der Begrenzer
ist in Abschnitt 8.7.4 beschrieben. Es werden also 80 bis 82 Zeichen gesen-
det. Die Cursorposition ändert sich durch das Kommando nicht. 
 
 
#k("8.7.3", "Eine Seite senden")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 7#ie(1)#    (Hex 1B 37) 
 
wird die gesamte Bildschirmseite an den Host gesendet. Im Anschluß an jede
Zeile werden (falls eingestellt) Zeilenbegrenzer gesendet. Im Anschluß an
die gesamte Seite wird ein (eingestellter) Seitenbegrenzer (Pageterminator)
gesendet. Es werden also je nach Zeilen- und Seitenbegrenzer 1920 bis 1969
Zeichen gesendet. Die Statuszeile wird nicht gesendet, sondern die "darun-
terliegende" 24. Textzeile. Die Programmierung der Zeilen- und Seitenbe-
grenzer ist in Abschnitt 8.7.4 beschrieben. Die Cursorposition ändert sich
durch dieses Kommando nicht. 
 
 
#k("8.7.4", "Terminatorzeichen definieren")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> x 1#ie(1)# <l1> <l2>    (Hex 1B 78 31 <l1><l2>) 
 
können die Zeilenbegrenzer der Sendekommandos festgelegt werden. <l1> und
<l2> sind dabei Byteparameter, die den Wertebereich 0 bis 255 überstrei-
chen. Ist ein Parameter Hex 00, dann wird dieses Zeichen nicht gesendet.
Wenn man also das Kommando (Hex) 1B 78 31 00 00 sendet, wird kein Begren-
zerzeichen nach der Zeile gesendet. 
Voreingestellt ist ein Begrenzerzeichen; und zwar US (Hex 1F). 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> x 4#ie(1)# <p>    (Hex 1B 78 34 <p>) 
 
kann der Seitenbegrenzer des Kommandos #ib(1)#<ESC> 7#ie(1)# festgelegt werden. <p> ist
ein Byteparameter, der den Wertebereich von 0 bis 255 überstreicht. Ist <p>
Hex 00, dann wird kein Seitenbegrenzer gesendet. 
Voreingestellt ist <p> = <CR> (Hex 0D). 
 
 
#k("8.7.5", "Cursorposition senden")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> ?#ie(1)#    (Hex 1B 3F) 
 
kann der Host die Position des Textcursors abfragen. Es wird eine Folge von
3 Bytes gesendet: <y+32> <x+32> <CR> 
 
<y+32> ist die y-Position + 32, <x+32> die x-Position + 32. Beide Parameter
können für den Befehl #ib(1)#<ESC> =#ie(1)# <y+32> <x+32> verwendet werden, da Sie den
gleichen Wertebereich überstreichen. 
 
 
#k("8.8", "Textseite auf Diskette speichern/laden")# 
 
Genau wie Graphikseiten kann auch die Textseite auf Diskette geschrieben und
zu einem späteren Zeitpunkt wieder zurückgeladen werden. Bei der Textseite
wird außerdem noch die aktuelle Cursorposition geladen/geschrieben. Man kann
sich zum Beispiel eine Datei Seitenweise auf dem Bildschirm anzeigen lassen
und diese Seiten auf Diskette abspeichern. Später kann man die Datei Offline
(im Localmodus) Seitenweise ansehen. 
 
Bis zu 8 Textseite lassen sich auf Diskette speichern und wieder abrufen.
Die "Fächer" für die Textseiten sind unabhängig von denen für die Graphik-
seiten. 
Die Seiten werden unabhängig von REVVID (Schwarz auf Weiß) immer NORVID
(also Weiß auf Schwarz) abgespeichert. Beim Laden der Seite wird sie je nach
REVVID/NORVID dargestellt. 
 
Das Kommando für diese Operationen lautet 
 
                         #ib(1)#<ESC> S#ie(1)# <n>    (Hex 1B 53 <n>). 
 
<n> ist ein Byteparameter mit dem Wertebereich 0 bis 31, wobei die Bits
folgendermaßen belegt sind: 
Bit 0..2 : "Fachnummer" der Textseite auf der Diskette (0 bis 7) 
Bit 3    : Bei Textseiten immer 0 (Bei Graphikseiten immer 1) 
Bit 4    : 0 heißt: die Textseite wird von der Diskette gelesen, 
           1 heißt: die Textseite wird auf die Diskette geschrieben. 
 
Wird die Textseite auf die Diskette geschrieben, dann wird eine eventuell
schon in diesem "Fach" vorhandene Textseite überschrieben. 
 
Für Insider: Jede Textseite belegt einen halben Track (2k). Die 8 Textseiten
             befindenden auf den Tracks 6 bis 9 in aufsteigender Reihenfol-
             ge. 
 
 
#page# 
#h("9.", "Verschiedene Steuerkommandos")# 
 
 
#k("9.1", "Signalton")# 
 
Mit 
                         #ib(1)#<CTRL G>#ie(1)#   (Hex 07) 
 
wird ein kurzer Signalton ausgegeben. Ein Warnton des Terminals ist schär-
fer (heller). 
 
 
#k("9.2", "Keyboardclick")# 
 
Der Tastaturclick wird für fast alle Tasten erzeugt. Ausnahmen sind die
<SHIFT> und die <CTRL> Tasten, sowie beim Apple die Apfeltasten. Der Tasta-
turclick kann in der ersten Kommandozeile abgeschaltet werden (CLK OFF) oder
mit dem Kommando 
 
                         #ib(1)#<ESC> <#ie(1)#    (Hex 1B 3C) 
 
vom Host. Mit dem Kommando 
 
                         #ib(1)#<ESC> >#ie(1)#    (Hex 1B 3E) 
 
kann der Keyboardclick wieder eingeschaltet werden. 
 
 
#k("9.3", "Bildschirmausgabe/Druckerausgabe")# 
 
Die Bildschirmausgabe, die ja normalerweise eingeschaltet ist, kann in der
Kommandozeile abgeschaltet werden (SCRNOFF) oder vom Host mit dem Kommando 
 
                         #ib(1)#<ESC> `#ie(1)#    (Hex 1B 60) 
 
abgeschaltet werden. Bis auf das Kommando 
 
                         #ib(1)#<ESC> a#ie(1)#    (Hex 1B 61) 
 
werden keine Escape-Squenzen oder Control-Codes interpretiert. Mit <ESC> a
wird die Bildschirmausgabe wieder zugelassen. 
 
Die Druckerausgabe kann mit dem Kommando 
 
                         #ib(1)#<ESC> @#ie(1)#    (Hex 1B 40) 
 
eingeschaltet werden. Man kann dann Texte parallel auf Drucker und Bild-
schirm ausgeben. In der ersten Kommandozeile kann die Druckerausgabe auch
ein- und ausgeschaltet werden. 
Man kann zum Beispiel den Schrifttyp des Druckers im Local-Modus umschal-
ten, wenn man in der Kommandozeile die Druckerausgabe (PRT ON) einschaltet.
Dazu kann man sich auch eine Funktionstaste belegen, die Bildschirmausgabe
abschaltet, Druckerausgabe einschaltet, den Schrifttyp umschaltet, Drucker-
ausgabe wieder ausschaltet und Bildschirmausgabe wieder einschaltet. 
 
Abgeschaltet wird die Druckerausgabe mit dem Kommando 
 
                         #ib(1)#<ESC> A#ie(1)#    (Hex 1B 41) 
 
 
#k("9.4", "Scroll/Page-Modus")# 
 
Steht der Cursor in der letzten Zeile und soll er in die nächst tiefere
gebracht werden (<DOWN>, <TAB>, <NEWLINE> etc.), dann gibt es entweder die
Möglichkeit, daß der Bildschirm nach oben gescrollt wird, d.h. die 1. Zeile
verschwindet und die 24. Zeile wird gelöscht, oder daß der Cursor in der
ersten Bildschirmzeile wieder auftaucht, ohne daß der Bildschirminhalt ver-
ändert wird. Die erste Möglichkeit heißt SCROLL-Modus, die zweite PAGE-
Modus. Die Umschaltung kann entweder in der ersten Kommandozeile erfolgen
oder mit dem Kommando 
 
                         #ib(1)#<ESC> H#ie(1)#    (Hex 1B 48). 
 
In der Kommandozeile hat man die Informationsmöglichkeit, welcher Modus
gerade aktiv ist. 
 
 
#k("9.5", "Belegung der Funktionstasten")# 
 
Eine nützliche Angelegenheit sind die programmierbaren Funktionstasten. Die
Codes der Funktionstasten sind unter anderem in Anhang A zu finden. Funk-
tionstasten können im Local-Modus aufgerufen werden, zum Beispiel für häu-
fig gebrauchte Terminalkommandos oder längere Kommandosequenzen (Graphikmo-
dus). Im Online-Modus kann man z.B. Betriebssystemkommandos auf Funktion-
stasten legen. 
 
Die Länge der Zeichen auf allen Funktionstasten darf zusammen nicht 4095
Zeichen überschreiten. Ein akustisches Warnsignal ertönt, wenn die Funk-
tionstastentabelle voll ist. Soll die Funktionstastendefinition auch noch
nach dem Abschalten des Terminals erhalten bleiben, dann muß in der Komman-
dozeile <SHIFT S> gegeben werden, damit der Setup samt Funktionstastende-
finitionen auf die Diskette geschrieben wird. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> e#ie(1)# <d...> <t>    (Hex 1B 65 <d...><t>) 
 
wird eine Taste belegt. <d...> und <t> sind Byteparameter. <d...> ist eine
Folge von Datenbytes, deren Bit 7 = 0 sein muß. <t> ist der Code der Funk-
tionstaste (Bit 7 = 1), auf die die Sequenz gelegt werden soll. Durch diese
Einschränkung sind keine rekursiven (sich selbst aufrufenden) Tastenkomman-
dos möglich, man kann allerdings z.B. auch nicht alle binären Parameter auf
Tasten legen (Man sollte dezimale Parameter benutzen). Die Cursortasten etc.
können nicht belegt werden. 
Um die Original-Tastencodes wieder zu benutzen, gibt es drei Möglichkeiten: 
 
- Die Tabelle der Tastendefinitionen wird ganz gelöscht (Abschnitt 9.6). 
- Die Definition auf einzelnen Tasten wird durch <ESC> e <t> gelöscht. <t>
  ist dabei der Code einer zu löschenden Taste. 
- In der ersten Kommandozeile wird F CODE eingeschaltet oder das Kommando 
 
                         #ib(1)#<ESC> c#ie(1)#    (Hex 1B 63) 
 
  gegeben. Dieses Kommando schaltet um, ob immer Tastencodes (A1..EF) oder,
  bei belegten Tasten, die programmierte Sequenz geliefert werden soll. Im
  Graphikmodus möchte man eventuell die griechischen Sonderzeichen auf den
  Funktionstasten benutzen (F CODE) und nicht die programmierten Tasten-
  strings (F STRG). 
 
 
#k("9.5.1", "Local-Escape")# 
 
Um Funktionstasten mit Terminalkommandos auch im Online-Modus benutzen zu
können (zum Beispiel ein Bildschirm Hardcopy) wird ein spezielles ESC-Zei-
chen statt <ESC> (Hex 1B) verwendet. 
Das Zeichen 
 
                         #ib(1)#<LOCESC>#ie(1)#    (Hex 9B) 
 
teilt dem Terminal mit, daß die nun folgende Escape-Sequenz nicht an den
Host gesendet wird (was bei <ESC> der Fall wäre), sondern vom Terminal in-
terpretiert werden muß. 
Im Local-Modus wirkt ein <LOCESC> wie ein normales <ESC>, d.h. das Kommando
wird sowieso vom Terminal interpretiert. 
 
 
#k("9.5.2", "Makrokommandos")# 
 
Ein Makrokommando hat (mindestens) drei Aufgaben: 
- Der Host kann dem Terminal neue ESC-Sequenzen (mit Parametern) definieren,
  z.B. um andere Terminals zu emulieren. 
- Nicht nur das Terminal kann Funktionstasten aufrufen, sondern auch der
  Host, wenn die Funkionstaste als Makro aufgerufen wird. 
- Der Datentransfer vom Host zum Terminal kann durch Makros als Abkürzungen
  häufig benutzter Zeichenfolgen beschleunigt werden. 
 
Ein Makro wird wie eine Funktionstaste mit dem Kommando 
 
 
                         #ib(1)#<ESC> e#ie(1)# <d...> <t>    (Hex 1B 65 <d...><t>) 
 
definiert. <d...> und <t> sind Byteparameter. <d...> ist eine Folge von
Datenbytes, deren Bit 7 = 0 sein muß. <t> ist der Code der Funktionstaste
(Bit 7 = 1) oder mit anderen Worten der Makroname. 
Es sind alle Codes für <t> zugelassen, die auch bei der Funktionstastende-
finition zugelassen sind. 
 
Ein Makro kann sowohl vom Terminal (auch im F CODE-Modus) als auch vom Host
mit 
 
                         #ib(1)#<ESC> <Macrocode>#ie(1)#    (Hex 1B <Makrocode>) 
 
aufgerufen werden. Dem Terminal wird die Zeichensequenz des Makros so vorge-
setzt, als käme sie von der Tastatur im Local-Modus. Wird das Makro also
bereits im Local-Modus aufgerufen, hat das immer noch den Vorteil, daß man
im F CODE-Modus weiterhin programmierte Funktionstasten benutzen kann. 
Anmerkung: Wird das <ESC> vor dem <Makrocode> weggelassen, dann wird der
           Code <Makrocode> ohne Makroausführung an das Terminal gesendet
           und i.d.R. als inverses Zeichen dargestellt. 
 
Sollen Byteparameter in die Zeichensequenz des Makros übernommen werden, die
zur Zeit der Makrodefinition noch nicht feststehen, dann kann man einen
Platzhalter mit dem Code Hex 81 an der Stelle einsetzen. Der Code Hex 81
kann auf der Tastatur durch <SHIFT DELETE> erzeugt werden. 
Wird bei der Makroausführung ein solcher Code gefunden, wartet das Terminal
auf ein Byte von Tastatur, wenn das Makro im Local-Modus aufgerufen wurde,
oder vom Host, wenn das Makro vom Host aufgerufen wurde. Es dürfen beliebig
viele Codes 81 in der Makrozeichensequenz vorhanden sein. Jeder Code wird
durch ein weiteres Zeichen von Host oder Tastatur ersetzt. 
 
 
#k("9.5.3", "Startup-Makro")# 
 
Ein besonderes Makro hat den Code Hex EF. Dieser Code kann auf der Tastatur
durch <SHIFT BOTTOMRIGHT> (beim Apple <OA RIGHT>) erzeugt werden. 
 
Dieses Makro wird bei einem RESET des Terminals (Hardwarereset oder <ESC> 0)
oder beim Einschalten des Terminals aufgerufen. Der Bildschirm und die Gra-
phikseiten werden vorher gelöscht. 


#k("9.6", "Tabellen und Puffer löschen")# 
 
Das Terminal enthält den Empfangspuffer, den Sendepuffer, den Druckerspoo-
ler und die Tabelle der Tastendefinitionen. Um einen der Puffer oder die
Tabelle zu löschen, kann das Kommando 
 
                         #ib(1)#<ESC> <DEL>#ie(1)# <n>    (Hex 1B 7F <n>) 
 
verwendet werden. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 15
und hat folgende Bedeutung: 
 
#on("u")#<n>    Gelöschte Tabelle oder Puffer#off("u")# 
 0     Keine 
 1     Tastendefinitionen 
 2     Druckerspooler 
 3     Empfangspuffer 
 4     Sendepuffer 
 
Zu beachten ist, daß zwar der Sendepuffer gelöscht wird, aber eine eventu-
ell gestoppte Übertragung (TX OFF) nicht wider gestartet wird. 
 
 
#k("9.7", "Zeitverzögerung")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 9#ie(1)# <n>    (Hex 1B 39 <n>) 
 
kann eine Zeitverzögerung aufgerufen werden. Man kann zum Beispiel ein Fa-
denkreuz darstellen, die Zeitverzögerung aufrufen und das Fadenkreuz wieder
löschen. <n> ist ein Byteparameter mit dem Wertebereich von 0 bis 255. Die
Verzögerung beträgt ca. <n> * 2 ms. 
 
 
#k("9.8", "Transparentmodi")# 
 
Der Monitor- und der Hexadezimalmodus sind zum Test von unbekannten Emp-
fangsdaten oder zum Analysieren der Steuerzeichenausgabe von unbekannten
Programmen gedacht. 
 
 
#k("9.8.1", "Monitor-Modus")# 
 
Im Monitor-Modus werden druckbare Zeichen wie normal dargestellt. Control-
zeichen (Hex 00..1F und 80..9F) werden invertiert dargestellt. Im APL-Zei-
chensatz kann man diese inversen Controlzeichen von den Zeichen mit Code Hex
A0..FF unterscheiden, die auch invers dargestellt werden. 
Der Monitormode kann in der ersten Kommandozeile ein- und ausgeschaltet
werden. Mit dem Kommando 
 
                         #ib(1)#<ESC> U#ie(1)#    (Hex 1B 55) 
 
kann der Monitormode eingeschaltet werden. Alle Zeichen werden ohne Inter-
pretation ausgegeben, Ausnahmen sind 
 
                         #ib(1)#<ESC> u#ie(1)#    (Hex 1B 75) 
 
und 
 
                         #ib(1)#<ESC> X#ie(1)#    (Hex 1B 58) 
 
die den Monitormodus ausschalten. 
 
 
#k("9.8.2", "Hexadezimal-Modus")# 
 
In diesem Modus werden nicht die Zeichen auf dem Bildschirm gedruckt, son-
dern ihr ASCII-Code in hexadezimaler Schreibweise mit zwei nachfolgenden
Blanks. Der Hexmode kann mit dem Kommando 
 
                         #ib(1)#<ESC> u#ie(1)#    (Hex 1B 75) 
 
ein- und ausgeschaltet werden. Alle Zeichen werden ohne Interpretation aus-
gegeben, außer #ib(1)#<ESC> u#ie(1)# und 
 
                         #ib(1)#<ESC> X#ie(1)#    (Hex 1B 58), 
 
die den Hexmodus wieder ausschalten. Auch der Hexmode kann in der ersten
Kommandozeile ein- und ausgeschaltet werden. 
 
 
#k("9.8.3", "Einzelne Control-Zeichen anzeigen")# 
 
Um nur einzelne Controlzeichen auf dem Bildschirm darzustellen, z.B. für den
unteren Teil des APL-Zeichensatzes (Codes 0 bis 31 oder 128 bis 159), gibt
es das Kommando 
 
                         #ib(1)#<ESC> F#ie(1)# <z>    (Hex 1B 46 <z>). 
 
<z> ist dabei ein Byteparameter mit dem Wertebereich 0 bis 255, vorzugswei-
se 0 bis 31. <z> wir mit invertiertem Bit 7 (normal/invers) in den Bild-
schirmspeicher an der aktuellen Cursorposition geschrieben. 
