#type ("elite")##limit (16.2)##block# 
#page##--------------------------------- Ende der Seite 0 -----------#
#text begin# 
 
#type ("8")##center##on("b")##on("u")#Bedienungshandbuch zum ruc - Graphikterminal#off("u")##off("b")##type ("elite")# 
 
#center#Version 1.1 
 
#center#Oktober 1986 
#free (16.0)# 
ruc - Rolf Uhlig Computer 
GmbH & Co Kommanditgesellschaft 
Sendenhorster Stra·e 82 
D - 4406 Drensteinfurt 1 
Telefon 02508/8500 
 
Michael Staubermann 
MorÑnenstra·e 29 
D - 4400 MÅnster-Hiltrup 
Telefon 02501/4320 
#pagenr (""224"", 1)#
#text end#
#free(2.2225)#
#page##--------------------------------- Ende der Seite 1 -----------#
#center##on("b")#1.  Einige Worte zuvor#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#text begin#
#type("8")##center##on("i")##on("u")##ib(3)#1.  Einige Worte zuvor#ie(3)##off("u")##off("i")##type("elite")# 
 
 
Dieses Terminalprogramm wird in zwei Versionen (fÅr den Basis 108 und den
Apple IIe) geliefert. Die Version ist in der Kommandozeile erkenntlich
(BASIS oder APPLE). 
 
Eigenschaften des Terminals: 
 
- Kommandozeilen fÅr schnelle Offline Parametereinstellung 
- Statuszeile fÅr spezielle BetriebzustÑnde 
- öber 70 programmierbare Funktionstasten 
- Druckerspooler 32k (4 ganze Graphikhardcopys und noch mehr) 
- 7935 Zeichen Empfangspuffer 
- Verschiedene Hardcopy Modi fÅr Text und Graphik 
- 192x280 Punkte auflîsender Graphikmodus mit zwei Helligkeitsstufen 
- Zwei Graphikseiten mit getrennter Anzeige/Bearbeitung 
- Viele Graphikroutinen (Bogen, FlÑchenfÅllung, Kreis, Rechteck...) 
- Graphikmodus fÅr Texte in verschieden Richtungen, Dicken, Grîssen 
- Griechische Graphikzeichen und Kursivschrift 
- Graphikseiten Scrollen, Mischen, vom Host laden, zum Host schicken 
 
 
Zum Handbuch 
 
Tasten werden durch Angabe ihres Aufdruckes in Grossbuchstaben angegeben und
in spitze Klammern gesetzt (z.B. <TAB>) in einigen FÑllen auch durch ihren
Namen (z.B. <DOWN> oder <TOPLEFT>). Eine zusÑtzlich zu betÑtigende Umschalt-
taste, wie SHIFT, CTRL, OPEN APPLE (kurz: OA) oder beide zusammen, wird in
der Klammer davorgestellt (z.B. <SHIFT RETURN>). 
 
Nicht druckbare Ascii-Codes (z.B. <ESC> oder <SPACE>), sowie Kommandopara-
meter (z.B. <n>) werden ebenfalls in spitze Klammern gesetzt. Komandopara-
meter werden mit Kleinbuchstaben bezeichnet. 
 
#text end#
#free(7.220185)#
 
 
 1 
#page##--------------------------------- Ende der Seite 1 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#2.  Die Hardware#ie(3)##off("u")##off("i")##type("elite")# 
 
 
UnterstÅtzt wird eine 80-Zeichen Textanzeige, ein Basiskeyboard oder ein
Applekeyboard mit Open-Apple Taste. Am Basis kann ein Drucker angeschlossen
werden. 
 
 
#type("8")##center##ib(3)#2.1  Die serielle Schnittstelle#ie(3)##type("elite")# 
 
Die Parameter der seriellen Schnittstelle kînnen vom Host oder vom Terminal
(LOCAL) eingestellt werden (Siehe Kommando <ESC> <SPACE> <SPACE>). Es wer-
den alle 15 gÑngigen Baudrates zwischen 50 und 19200 Baud unterstÅtzt. Pari-
tycheck kann mit gerader oder ungerader ParitÑt durchgefÅhrt werden. Flu·-
kontrolle ist in allen Kombinationen aus RTS/CTS, DTR/DSR, XON/XOFF mîglich.
Empfohlen wird DTR/DSR oder XON/XOFF. 
 
             Benîtigte Verdrahtung der seriellen Schnittstelle 
 
            Pin                                        PrioritÑt 
              2 : TXD Sendedaten    zum Host (RXD)         1 
              3 : RXD Empfangsdaten vom Host (TXD)         1 
              4 : RTS Ready To Send zum Host (CTS)         3 
              5 : CTS Clear To Send vom Host (RTS)         3 
              6 : DSR DataSet Ready vom Host (DTR)         2 
              7 : Masse an Host Masse                      1 
              8 : DCD Eingang, nicht benîtigt 
             20 : DTR Data Terminal Ready zum Host (DSR)   2 
 
PrioritÑt: 
 1 : Mu· verdrahtet werden 
 2 : Ist bei DSR/DTR Flu·kontrolle zu verdrahten 
 3 : Ist bei RTS/CTS Flu·kontrolle zu verdrahten 
 
Der Datentransfer geschieht in der Regel mit 8 Datenbits. Sollte der Host
nur Åber 7 Bit Datentransfer verfÅgen, mÅssen einige EinschrÑnkungen bei der
ParameterÅbergabe von Uploads/Downloads gemacht werden (Kein Farbbit). Die
Anzahl der Datenbits kann auch in der Kommandozeile verÑndert werden. 
 
 
#type("8")##center##ib(3)#2.2  Der Reset#ie(3)##type("elite")# 
 
Ein Reset bringt das Terminal in einen definierten Zustand. Alle Bildschirm-
seiten und Puffer, sowie der Druckerspooler werden gelîscht. Der Reset kann
vom Host durch 
 
                         #ib(1)#<ESC> 0#ie(1)#    (Hex 1B 30) 
 
initiiert werden, vom Basiskeyboard aus durch <SHIFT SHIFT CTRL>. Die Para-
meter in der Kommandozeile werden dem Setup entnommen. Nach dem Lîschen
aller Bildschirmseiten, wird das Makro mit dem Code Hex EF aufgerufen. Dies
ist die Funktionstaste <SHIFT BOTRIGHT>. 
#text end#
#free(02.351852e-2)#
 
 
#right#2 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 2 -----------#
#center##on("b")#3.  Die Kommandozeile#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#3.  Die Kommandozeile#ie(3)##off("u")##off("i")##type("elite")# 
 
 
Die wichtigsten Parameter des Terminals kînnen im laufenden Betrieb in den
beiden Kommandozeilen geÑndert werden. Die erste Kommandozeile erscheint
beim Basiskeyboard durch DrÅcken von <SHIFT CE> und beim Apple durch <OA
CTRL X>. 
 
Im Graphikmodus ersetzt die Kommandozeile die untersten 32 Graphikzeilen
(entspricht vier Textzeilen). Man hat also auch im Graphikmodus die Mîg-
lichkeit wichtige Parameter in der Kommandozeile zu Ñndern. 
 
Die angezeigten Einstellungen bieten au·erdem eine Informationsmîglichkeit
Åber die aktuellen Parameter der seriellen Schnittstelle u.s.w. Die zweite
Kommandozeile enthÑlt die Parameter der seriellen Schnittstelle. 
 
Alle in den Kommandozeilen angezeigten Parameter (bis auf BELL ON/BELL OFF)
kînnen auch durch ESC-Kommandos vom Host oder im Localmodus geÑndert wer-
den. 
Ein laufender Druckvorgang wird unterbrochen, solange die Kommandozeilen
sichtbar sind. 
 
 
#type("8")##center##ib(3)#3.1  Tastenfunktionen in der Kommandozeile#ie(3)##type("elite")# 
 
Folgende Tasten haben in der Kommandozeile eine Wirkung: 
 
Taste              Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
<UP> oder <DOWN>   Wechselt in die jeweils andere Kommandozeile 
 
<LEFT>             Springt zum vorherigen (linken) Parameter ohne etwas zu
                   verÑndern. 
 
<RIGHT>            Springt zum nÑchsten (rechten) Parameter ohne etwas zu
                   verÑndern. 
 
<SPACE>            éndert das selektierte Parameterfeld. Das selektierte
                   Parameterfeld ist durch Invertierung hervorgehoben. Die
                   mîglichen Parameter wiederholen sich zyklisch. 
 
<ESC>              Die Kommandozeile wird verlassen. Es werden keine énde-
                   rungen durchgefÅhrt. 
 
<SHIFT S>          Die Kommandozeile wird verlassen. Vorher werden alle
                   énderungen permanent auf die Diskette geschrieben. Wei-
                   tere Einzelheiten s.u. (Setup) 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
 3 
#page##--------------------------------- Ende der Seite 3 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")#
#text begin# 
<SHIFT R>          Alle Parameter werden auf ihre Defaultwerte zurÅckge-
                   setzt. Die Kommandozeile wird noch nicht verlassen, daher
                   kann dieser 'Reset' durch <ESC> wieder aufgehoben werden. 
                   <CE> oder <CTRL X> Die Kommandozeile wird verlassen. Die
                   énderungen werden nur im Speicher vermerkt. Nach dem
                   Ein-/Ausschalten des Rechners werden die alten Parameter
                   von der Diskette gelesen. Wird allerdings ein Hardware-
                   reset (s.o.) durchgefÅhrt, sind diese énderungen nicht
                   verloren. 
 
 
#type("8")##center##ib(3)#3.2  Setup#ie(3)##type("elite")# 
 
Beim Setup, der in der Kommandozeile durch <SHIFT S> ausgelîst werden kann,
werden wichtige Parameter auf die Diskette geschrieben. Sie werden dann
'permanent' und mÅssen nach dem Einschalten des Terminals nicht neu einge-
stellt werden. Diese Parameter sind die 
- Parameter der seriellen Schnittstelle (2. Kommandozeile) 
- anderen Parameter der Kommandozeilen 
- vom Benutzer programmierte Belegung der Funktionstasten 
- Druckerspezifischen Hardcopyparameter 
 
Vor dem Setup ist zu prÅfen, ob der Diskettenschreibschutz entfernt wurde
(Klebeschildchen an der Diskettenseite entfernen). Der Schreibschutz sollte
nach dem Setup wieder angebracht werden. Wurde der Schreibschutz nicht ent-
fernt, wird eine Meldung 'Diskettenschreibschutz entfernen !' angezeigt. In
diesem Falle erscheint nach dem DrÅcken einer Taste wieder die Kommando-
zeile. 
Wenn keine Diskette einliegt oder ein harter Schreibfehler auftritt, er-
scheint die Meldung 'Setup kann nicht geschrieben werden (Diskettenfeh-
ler)!'. Weitere Schreibversuche sind mîglicherweise erfolgreich. 
 
 
#type("8")##center##ib(3)#3.3  Die zweite Kommandozeile#ie(3)##type("elite")# 
 
Beim Basis (erste Zeile zeigt Defaultwerte fÅr <SHIFT R>) 
 
#type ("micron")# 
GER|BASIS|MON OFF|PRT OFF|SCRN ON |KEY CLK|NORVID|SCROLL|BELL ON |CUR FLH|F STRG 
USA  TVI  MON ON  PRT ON  SCRN OFF CLK OFF REVVID  PAGE  BELL OFF CUR STD F CODE 
APL       HEX ON                                                  CUR OFF 
UNI 
#type ("elite")# 
 
Beim Apple (erste Zeile zeigt Defaultwerte fÅr <SHIFT R>) 
 
#type ("micron")# 
USA|APPLE|MON OFF|PRT OFF|SCRN ON |KEY CLK|NORVID|SCROLL|BELL ON |CUR FLH|F STRG 
FLH  TVI  MON ON  PRT ON  SCRN OFF CLK OFF REVVID  PAGE  BELL OFF CUR STD F CODE 
          HEX ON                                                  CUR OFF 
#type ("elite")# 
 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
#right#4 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 4 -----------#
#center##on("b")#3.  Die Kommandozeile#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")#
#text begin# 
Default Andere   Funktion 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
Basis 
 GER    USA      Die Zeichensatzeinstellung ist fÅr die gebrÑuchlichsten 
        APL      vier ZeichensÑtze in der Kommandozeile mîglich. 
        UNI      GER = Deutsch Ascii, USA = US Ascii, APL = APL-Zeichensatz
                 UNI = Deutscher Zeichensatz mit inversen APL Zeichen. Der
                 APL-Zeichensatz entÑhlt auch die Zeichen [\]{|}~. öber
                 ESC-Kommandos lassen weitere Mîglichkeiten einstellen. 
 
 BASIS  TVI      Keyboard Emulation. BASIS sendet die Funktionstastencodes
                 mit Bit 7 = 1. TVI sendet fÅr jede Funktionstaste eine
                 Zeichenfolge <SOH> x <CR>. Die Cursortasten sowie DEL CHAR,
                 INS CHAR, DEL LINE, INS LINE werden wie bei TVI Åblich
                 gesendet. Weiter Einzelheiten s.u. (TVI-Emulation) 
 
Apple 
 USA    FLH      USA = US Ascii, FLH = Voller Ascii Zeichensatz mit Blinken
                 und Invers. 
 
 APPLE  TVI      Keyboard Emulation. APPLE fÅhrt keine Codeumsetzung durch.
                 Wird allerdings die <OPEN APPLE>-Taste mit einer anderen
                 Taste zusammen gedrÅckt, wird das Bit 7 im Code auf 1 ge-
                 setzt. Zur TVI-Emulation siehe oben. 
 
MON OFF MON ON   Der Monitor Modus wird mit MON ON eingeschaltet. In diesem 
        HEX ON   Modus werden alle Steuerzeichen auf dem Bildschirm mar-
                 kiert ausgegeben. Bis auf die Kommandos <ESC> u oder <ESC>
                 X (um den Monitormodus auszuschalten) werden keine Komman-
                 dos interpretiert. Alle anderen Zeichen werden unverÑndert
                 dargestellt. Der Monitormodus kann auch durch MON OFF aus-
                 geschaltet werden. 
                 Im Hexmodus werden keine Zeichen, sondern deren Ascii-
                 Codes in Hexadezimaldarstellung ausgegeben. 
 
PRT OFF PRT ON   Parallele Druckerausgabe. Ist PRT ON eingeschaltet, werden
                 alle Zeichen die von der seriellen Schnittstelle kommen,
                 auf dem Drucker ausgegeben bzw. in den Druckerspooler ge-
                 schrieben. Die Bildschirmausgabe wird hiervon nicht beein-
                 flu·t. 
 
SCRN ON SCR OFF  Bildschirmausgabe an/aus. Ist SCRN ON eingeschaltet, wer-
                 den alle Zeichen die von der seriellen Schnittstelle kom-
                 men, auf dem Bildschirm ausgegeben. SCR OFF und PRT ON kann
                 zum Beispiel benutzt werden, um Daten nur an den Drucker zu
                 schicken, ohne da· diese auch auf dem Bildschirm erschei-
                 nen. 
 
KEY CLK CLK OFF  Tastaturklick an/aus. Ist KEY CLK eingeschaltet, gibt jede
                 Taste (bis auf SHIFT, CTRL) bei ihrer BetÑtigung einen Ton
                 (Klick) von sich. CLK OFF schaltet dies ab. 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
 5 
#page##--------------------------------- Ende der Seite 5 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
NORVID  REVVID   Bildschirmdarstellung. NORVID stellt hellen Text auf
                 schwarzem Grund dar, REVVID stellt schwarzen Text auf hel-
                 lem Grund dar (Mîglicherweise angenehmer fÅr die Augen). 
 
SCROLL  PAGE     Ist SCROLL eingeschaltet, wird der Bildschirm um eine Zeile
                 nach oben geschoben, sobald der Cursor in der letzten Bild-
                 schirmzeile steht und ein Zeilenvorschub <LF> ausgefÅhrt
                 werden soll. Die erste Bildschirmzeile verschwindet. Ist
                 PAGE eingeschaltet, springt der Cursor in einer solchen
                 Situation in die erste Bildschirmzeile. Die Cursorspalte
                 wird dabei nicht verÑndert. 
 
BELL ON BELL OFF Normalerweise erzeugt jedes empfangene <CTRL G> einen kur-
                 zen Signalton. Wenn das stîrt, kann die Tonausgabe mit BELL
                 OFF abgeschaltet werden. 
 
CUR FLH CUR STD  Cursordarstellung. CUR FLH zeigt einen blinkenden CUR OFF
                 Cursorblock. CUR STD zeigt einen nichtblinkenden Cursor-
                 block. CUR OFF schaltet den Cursor ab (unsichtbar). 
 
F STRG  F CODE   Funktionstastenbelegung. Ist F STRG eingeschaltet, erzeugt
                 eine programmierte (belegte) Funktionstaste keinen Tasten-
                 code, sondern sendet die programmierten Zeichen. Eine unbe-
                 legte Funktionstaste sendet ihren Tastencode. Ist F CODE
                 eingeschaltet, erzeugen auch belegte Funktionstasten einen
                 Tastencode und senden keine programmierten Zeichen. 
 
 
#type("8")##center##ib(3)#3.4  Die zweite Kommandozeile#ie(3)##type("elite")# 
 
Die erste Zeile zeigt Defaultwerte fÅr <SHIFT R>: 
 
#type ("micron")# 
STATOFF|TXT| 9600|STOP 1|DATA 8|NO  PAR|NO XONOFF|NO RTSCTS|NO DTRDSR 
STAT ON GFX 19200 STOP 2 DATA 7 EVN PAR  XON/XOFF  RTS/CTS   DTR/DSR 
               50               ODD PAR 
               75 
            109.9 
            134.6 
              150 
              300 
              600 
             1200 
             1800 
             2400 
             3600 
             4800 
             7200 
#type ("elite")# 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
#right#6 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 6 -----------#
#center##on("b")#3.  Die Kommandozeile#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Default Andere   Funktion 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
STATOFF STAT ON  Anzeige der Statuszeile. Der Arbeitsbereich des Bildschirms
                 betrÑgt zwar immer 24 Zeilen, allerdings ist bei STAT ON
                 anstelle der 24. Textzeile die Statuszeile sichtbar. Bei
                 STATOFF wird der aktuelle Inhalt der 24. Textzeile sicht-
                 bar. Einzelheiten s.u. (Die Statuszeile) 
 
TXT     GFX      Textmodus/Graphikmodus. TXT schaltet in die 80x24 Zeichen
                 Textdarstellung um. GFX schaltet auf die aktuelle Graphik-
                 seite um. 
 
9600    19200    WÑhlt die Baudrate fÅr die serielle Schnittstelle. 
           50    Die Angabe erfolgt in Bits/Sekunde (Baud) 
           75 
          109.9 
          134.6 
          150 
          300 
          600 
         1200 
         1800 
         2400 
         3600 
         4800 
         7200 
 
STOP 1  STOP 2   WÑhlt die Anzahl der Stopbits fÅr die serielle Schnitt-
                 stelle. 
 
DATA 8  DATA 7   WÑhlt die Anzahl der Datenbits fÅr die serielle Schnitt-
                 stelle. 
 
NO PAR  EVN PAR  WÑhlt Parity Check Art. NO PAR = Kein ParitÑtsbit, keine 
        ODD PAR  ParitÑtsprÅfung. EVN PAR = Gerade ParitÑt, ODD PAR = Unge-
                 rade ParitÑt. 
 
NO XONOFF        WÑhlt XON (CTRL Q) und XOFF (CTRL S) als Protokoll fÅr die 
        XON/XOFF serielle Schnittstelle. Wird XOFF vom Host gesendet, kann
                 das Terminal noch 255 Zeichen empfangen, bis der Empfangs-
                 puffer ÅberlÑuft. Mit NO XONXOFF wird dieses Protokoll
                 ausgeschaltet. 
 
NO RTSCTS        WÑhlt RTS/CTS als Protokoll fÅr die serielle Schnittstel-
        RTS/CTS  le. Mit NO RTSCTS wird dieses Protokoll ausgeschaltet. 
 
NO DTRDSR        WÑhlt DTR/DSR als Protokoll fÅr die serielle Schnittstel-
        DTR/DSR  le. Mit NO DTRDSR wird dieses Protokoll ausgeschaltet. 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
 7 
#page##--------------------------------- Ende der Seite 7 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#4.  Die Statuszeile#ie(3)##off("u")##off("i")##type("elite")# 
 
 
Die Statuszeile enthÑlt 5 Felder, die Åber die wichtigsten BetriebszustÑnde
des Terminals Auskunft geben. Die Statuszeile ersetzt die (dann in den 'Hin-
tergrund' verlegte) 24. Zeile. Die Statuszeile kann in der Kommandozeile mit
STAT ON oder vom Host oder im Local Modus mit 
 
                         #ib(1)#<ESC> }#ie(1)#   (Hex 1B 7D) 
 
eingeschaltet werden. Ausschalten ebenso mit STATOFF oder 
 
                         #ib(1)#<ESC> {#ie(1)#   (Hex 1B 7B) 
 
Die Zuordnung der Felder: 
 
#type ("micron")# 
Spooler | EmpfÑngerpuffer | Senderpuffer | Bereit/BeschÑftigt | Local/Online
#type ("elite")# 
 
Kritische ZustÑnde werden invers markiert. Dies sind alle FÑlle, in denen
ein Puffer ÅberlÑuft. 
Ist dies beim Empfangspuffer der Fall (RX FULL), gehen Daten verloren. 
Sollte der Druckerpuffer voll sein (PR FULL) und das Terminal keine Eingabe
mehr annehmen, kann man durch lÑngeres DrÅcken von <SHIFT ESC> Zeichen aus
dem Druckerpuffer entfernen, damit wieder Platz frei wird. 
Sollte der Senderpuffer voll sein (TX FULL), so liegt das wahrscheinlich
daran, da· der Host kein XON gesendet hat oder dieses falsch Åbertragen
wurde. Durch DrÅcken von <SHIFT ESC> kann man den Transmitter wieder star-
ten. 
 
 
#type("8")##center##ib(3)#4.1  Spoolerstatus#ie(3)##type("elite")# 
 
- Ein leeres Feld bedeutet: Der Spooler (Druckerpuffer) ist leer, es ist
  nichts zum Drucken im Puffer. 
 
- PRINT zeigt an: Der Spooler ist gefÅllt. Das Terminal ist druckwillig oder
  der Drucker druckt. 
 
- PR FULL bedeutet: Der Druckerpuffer ist voll. Da das Terminal keine wei-
  teren Zeichen annimmt bis wieder Platz im Druckerpuffer ist, kann man
  einzelne Zeichen mit <SHIFT ESC> aus dem Druckerpuffer entfernen bis PRINT
  im Feld erscheint. 
 
 
#type("8")##center##ib(3)#4.2  EmpfÑngerstatus#ie(3)##type("elite")# 
 
- Ein leeres Feld bedeutet: Im EmpfÑngerpuffer ist noch Platz. 
 
- RX FULL zeigt an: Es gehen Empfangsdaten verloren, da der EmpfÑngerpuffer
  voll ist. 
 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#8 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 8 -----------#
#center##on("b")#4.  Die Statuszeile#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#4.3  Senderstatus#ie(3)##type("elite")# 
 
- TX ON bedeutet: Der Sender ist eingeschaltet. Wenn jetzt ein Zeichen ge-
  sendet werden mu·, wird es sofort auf die serielle Schnittstelle ge-
  schickt. 
  Ein > vor TX ON zeigt an, da· das Terminal auf Freiwerden der seriellen
  Schnittstelle wartet. 
 
- TX OFF bedeutet: Der Host hat entweder XOFF gesendet oder die Hardware-
  flu·kontrolle aktiviert, um das Terminal zu stoppen. 
 
- TX FULL zeigt an: Der Senderpuffer ist voll. Das Terminal nimmt keine
  Eingaben mehr an bis der Puffer wieder frei ist. Dies kann mit <SHIFT ESC>
  erzwungen werden. 
 
 
#type("8")##center##ib(3)#4.4  Busy - Anzeige#ie(3)##type("elite")# 
 
- READY bedeutet: Der EmpfÑnger ist empfangsbereit, d.h. im Empfangspuffer
  sind noch mindestens 256 Zeichen frei und das Terminal hat den Host nicht
  per Flu·kontrolle gestoppt. 
 
- BUSY bedeutet: Der EmpfÑnger hat dem Host per Flu·kontrolle angezeigt, da·
  nicht mehr genÅgend Platz im Empfangspuffer war. Die Flu·kontrolle wird
  wieder freigegeben, wenn nur noch 256 Bytes im Empfangspuffer sind. 
  (Warnung: Wenn BUSY angezeigt wird, eine Taste gedrÅckt wird und der Host
  #on("u")#nicht#off("u")# empfangsbereit ist, gerÑt das Terminal in eine
  "Deadlock-Situation", die (mit Datenverlust) nur durch einen Hardwarereset
  abgebrochen werden kann.) 
 
 
#type("8")##center##ib(3)#4.5  Online/Local - Anzeige#ie(3)##type("elite")# 
 
- ONLINE bedeutet: Das Terminal sendet Tasteneingaben an den Host und emp-
  fÑngt Zeichen und Kommandos vom Host. 
 
- LOCAL bedeutet: Keyboardeingaben erscheinen auf dem Bildschirm bzw. blei-
  ben innerhalb des Terminals. Escape-Kommandos wirken direkt auf das Ter-
  minal. 
 
#text end#
#clear pos# 
#free(5.103519)#
 
 
 9 
#page##--------------------------------- Ende der Seite 9 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#5.  Die Bedeutung der Tasten#ie(3)##off("u")##off("i")##type("elite")# 
 
 
ZusÑtzlich zu den normalerweise von der Tastatur gesendeten Tastencodes sind
einige weitere zur VerfÅgung gestellt worden. Beim Apple senden fast alle
Tasten mit Open-Apple zusammen einen Code mit Bit 7 = 1. Diese werden vom
Terminal als Funktions- oder Steuertasten interpretiert. Beim Basis wurden
einige bisher nur einfach belegte Tasten wie <RETURN>, <TAB>, <ESC>, <CE>
und der Zehnerblock mit Doppelfunktionen Åber <SHIFT> versehen. 
 
 
#type("8")##center##ib(3)#5.1  Die Funktions- und Steuertasten#ie(3)##type("elite")# 
 
Zuerst werden die Tastenfunktionen erlÑutert fÅr ein nicht emulierendes
Terminal. Die TVI-Emulation kann in der Kommandozeile abgeschaltet werden
(1. Zeile, 2. Feld) oder mit dem Kommando 
 
                         #ib(1)#<ESC> <SPACE> 0#ie(1)#    (Hex 1B 20 30) 
 
Die Cursortasten liefern beim Basiskeyboard andere Tastencodes als beim
Applekeyboard. Wird das Bit 7 ignoriert (ausgeblendet), stimmen die Codes
Åberein. <TOPLEFT> bezeichnet beim Basiskeyboard die linke obere Eckposi-
tion des Cursorblocks, <TOPRIGHT> die rechte obere etc. 
 
Basis-Taste    Apple-Taste  Hex-Code   Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
<TAB>            <TAB>         09      Der Cursor wird an die nÑchste (re-
                                       chte) Tabulatorposition gesetzt.
                                       Tabulatorpositionen sind alle 8 Spal-
                                       ten. Also 1, 9, 17, 25, 33, 41, 49,
                                       57, 65, 73. War der Cursor in Spalte
                                       73 bis 79, dann wird er in die erste
                                       Spalte der nÑchst tieferen Bild-
                                       schirmzeile gesetzt. War der Cursor
                                       vorher auch noch in Zeile 24, dann
                                       wird der Bildschirminhalt entweder
                                       nach oben gescrollt (SCROLL) oder in
                                       Homeposition gebracht (PAGE). 
 
<SHIFT TAB>      <OA TAB>      89      Back-Tab (RÅckwÑrtstabulator). Der
                                       Cursor wird in die nÑchste links vom
                                       Cursor befindliche Tabulatorposition
                                       gebracht. War der Cursor in Spalte 1,
                                       dann steht er jetzt in Spalte 73 der
                                       darÅberliegenden Zeile. War der Cur-
                                       sor in Homeposition, dann Ñndert sich
                                       seine Position nicht. 
 
<SHIFT CE>       <OA CTRL X>    -      Kommandozeile aktivieren. Einzelhei-
                                       ten zur Kommandozeile siehe Abschnitt
                                       3.: Die Kommandozeilen. 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#10 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 10 -----------#
#center##on("b")#5.  Die Bedeutung der Tasten#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
<CE>             <CTRL X>      18      U.a. Kommandozeile verlassen. 
 
<RETURN>         <RETURN>      0D      Zum Zeilenanfang ohne Zeilenvorschub.
                                       Der Cursor steht dann in der ersten
                                       Spalte der Zeile. 
 
<SHIFT RETURN>   <OA RETURN>   8D      Zum Anfang der nÑchsten Zeile. Falls
                                       der Cursor in der letzten (24.) Bild-
                                       schirmzeile war, wird der Bildschir-
                                       minhalt entweder nach oben gescrollt
                                       (SCROLL) oder in Homeposition ge-
                                       bracht (PAGE). 
 
<UP>             <UP>       8B/0B      Cursor eine Zeile hîher. War der
                                       Cursor in der ersten Bildschirmzei-
                                       le, Ñndert sich seine Position nicht. 
 
<DOWN>           <DOWN>     8A/0A      Cursor eine Zeile tiefer. War der
                                       Cursor in Zeile 24, dann wird der
                                       Bildschirminhalt entweder nach oben
                                       gescrollt (SCROLL) oder der Cursor in
                                       die erste Bildschirmzeile gesetzt
                                       (PAGE). 
 
<CTRL V>         <CTRL V>      16      Cursor eine Zeile tiefer. War der
                                       Cursor in Zeile 24, dann Ñndert er
                                       seine Position nicht. Die Spalte
                                       Ñndert sich nicht. 
 
<LEFT>           <LEFT>     88/08      Cursor eine Spalte nach links. War
                                       der Cursor in der ersten Bildschirm-
                                       spalte, dann steht er jetzt in der
                                       letzten Spalte der darÅberliegenden
                                       Bildschirmspalte. War der Cursor
                                       allerdings in Homeposition, Ñndert
                                       sich seine Position nicht. 
 
<RIGHT>             -          95      Cursor eine Spalte nach rechts. War
                                       der Cursor in Spalte 79, dann steht
                                       er jetzt in der ersten Spalte der
                                       folgenden Zeile. War der Cursor in
                                       der letzten Zeile, dann wird der
                                       Bildschirminhalt um eine Zeile nach
                                       oben gescrollt (SCROLL) oder der
                                       Cursor in Homeposition gebracht
                                       (PAGE). 
 
<HOME>           <OA @>        C0      Der Cursor wird in die linke obere
                                       Bildschirmecke gebracht (Homeposi-
                                       tion). 
 
<SHIFT HOME>     <OA P>        D0      Bildschirm lîschen und Cursor Home. 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
 11 
#page##--------------------------------- Ende der Seite 11 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
<DELETE>         <DELETE>      7F      Dieses Zeichen wird auf dem Bild-
                                       schirm als Punktraster dargestellt.
                                       Der Host interpretiert es in der
                                       Regel als Zeichenlîschbefehl. 
 
<TOPLEFT>        <OA CTRL N>   8E      Zeichen bei Cursorposition einfÅgen.
                                       Der Cursor Ñndert seine Position
                                       nicht. Unter dem Cursor steht dann
                                       ein Leerzeichen. Das Zeichen in Spal-
                                       te 79 geht verloren. 
 
<SHIFT TOPLEFT>  <OA CTRL B>   82      Zeichen unter Cursorposition lîschen.
                                       In Spalte 79 steht dann ein Leerzei-
                                       chen. 
 
<TOPRIGHT>       <OA CTRL O>   8F      Zeile bei Cursorposition einfÅgen.
                                       Die Cursorposition Ñndert sich nicht.
                                       Der Inhalt der letzten Bildschirmzei-
                                       le ist verloren. Die Zeile in der der
                                       Cursor steht wird mit Leerzeichen
                                       gefÅllt. 
 
<SHIFT TOPRIGHT> <OA CTRL C>   83      Zeile in der der Cursor steht lî-
                                       schen. Die Cursorposition Ñndert sich
                                       nicht. Der Inhalt der gelîschten
                                       Zeile ist verloren. Die letzte Bild-
                                       schirmzeile wird mit Leerzeichen
                                       aufgefÅllt. 
 
<BOTTOMLEFT>     <BACKSPACE>   08      Cursor eine Spalte nach links. Die
                                       Funktion ist mit der von <LEFT> iden-
                                       tisch. 
 
<BOTTOMRIGHT>    <RIGHT>       15      Apple: Cursor eine Spalte nach re-
                                       chts. Die Funktion ist mit der von
                                       <RIGHT> identisch. 
 
<SHIFT BOTTOMRIGHT> <OA RIGHT> EF      Diese Taste ist eine programmierbare
                                       Funktionstaste (siehe <ESC> e). 
 
<SHIFT DELETE>   <OA DELETE>   81      Diese das liefert den
                                       Makroparametercode (siehe <ESC> e). 
 
<ESC>            <ESC>         1B      Leitet eine Escape-Sequenz ein. 
 
<SHIFT ESC>      <OA ESC>      9B      WÑhrend der Funktionstastedefinition
                                       wirkt diese Taste wie ein Local
                                       Escape, sonst liefert sie den Code 9B.
                                       (siehe <ESC> e). 
                                       
<SHIFT CTRL HOME><OA 0>         -      Local/Online umschalten. 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#12 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 12 -----------#
#center##on("b")#5.  Die Bedeutung der Tasten#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
<CTRL HOME>      <OA SPACE>   '00'     Sendet V24-Break (Hexcode 00 mit
                                       Rahmenfehler). Als Rahmenfehler wird
                                       das Fehlen des oder der Stopbits
                                       bezeichnet (Stopbitpegel ist norma-
                                       lerweise 1, bei Break dagegen 0). 
 
#on("u")#Zehnerblock:#off("u")# 
 
<SHIFT 1> ...    <OA a> ...    E1 ...  programmierbare Funktionstasten 
<SHIFT 9>        <OA i>        E9             "               " 
<SHIFT 0>        <OA j>        EA             "               " 
<SHIFT .>        <OA k>        EB             "               " 
<SHIFT +>        <OA l>        EC             "               " 
<SHIFT ->        <OA m>        ED             "               " 
 
<SHIFT BOTRIGHT> <OA RIGHT>    EF             "               " 
 (Dieser Code wird beim RESET des 
 Terminals ausgefÅhrt. Der Benut- 
 zer kann damit das Terminal nach 
 seinen WÅnschen konfigurieren.) 
 
 
#on("u")#Funktionstasten:#off("u")# 
 
<F1> ...         <OA A> ...    C1             "               " 
<F15>            <OA O>        CF             "               " 
<SHIFT F1> ...   <OA Q> ...    D1             "               " 
<SHIFT F15>      <OA _>        DF             "               " 
<CTRL F1> ...    <OA !> ...    A1             "               " 
<CTRL F15>       <OA />        AF             "               " 
<SHIFT CTRL F1>..<OA 1> ...    B1             "               " 
<SHIFT CTRL F15> <OA ?>        BF             "               " 
 
Die Programmierung der Funktionstasten geschieht mit #ib(1)#<ESC> e#ie(1)#. 
 
 
#type("8")##center##ib(3)#5.2  Die TVI-Emulation#ie(3)##type("elite")# 
 
Wird das Terminal in den TVI-Emulationsmode gebracht, dann senden einige
Tasten andere Tastencodes oder Codesequenzen. Die Bedeutung der Escape-
Sequenzen Ñndert sich dadurch nicht. 
Der TVI-Modus kann in der Kommandozeile eingeschaltet werden (1. Zeile, 2.
Feld) oder durch 
 
                         #ib(1)#<ESC> <SPACE> 1#ie(1)#    (Hex 1B 20 31) 
 
An dieser Stelle erscheinen nur noch die Tastenbezeichnungen des Basiskey-
boards. Die entsprechenden Tasten, die beim Applekeyboard zu drÅcken sind,
kann man im letzten Abschnitt nachlesen. 
 
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
 13 
#page##--------------------------------- Ende der Seite 13 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Folgende Tasten senden andere Tastencodes: 
 
Taste       TVI-Code(sequenz)       Bemerkung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
<RIGHT>     0C    #ib(1)#<CTRL L>#ie(1)#          Cursor nach rechts 
 
<HOME>      1E    #ib(1)#<CTRL SHIFT ^>#ie(1)#    Cursor in Homeposition 
 
<CLEAR>     1A    #ib(1)#<CTRL Z>#ie(1)#          Durch DrÅcken von <SHIFT HOME> 
                                    Bildschirm lîschen und Cursor Home 
 
<DEL CHAR>  1B 57 #ib(1)#<ESC> W#ie(1)#           Durch DrÅcken von <SHIFT TOPLEFT> 
                                    Zeichen lîschen 
 
<DEL LINE>  1B 52 #ib(1)#<ESC> R#ie(1)#           Durch DrÅcken von <SHIFT TOPRIGHT> 
                                    Zeile lîschen 
 
<INS CHAR>  1B 51 #ib(1)#<ESC> Q#ie(1)#           Durch DrÅcken von <TOPLEFT> 
                                    Zeichen einfÅgen 
 
<INS LINE>  1B 45 #ib(1)#<ESC> E#ie(1)#           Durch DrÅcken von <TOPRIGHT> 
                                    Zeile einfÅgen 
 
<LEFT>      08    #ib(1)#<BACKSPACE>#ie(1)#       Cursor nach links 
 
<BACK TAB>  1B 49 #ib(1)#<ESC> I#ie(1)#           Durch DrÅcken von <SHIFT TAB> 
                                    RÅckwÑrtstabulator 
 
<DOWN>      0A    #ib(1)#<LF>#ie(1)#              Cursor nach unten 
 
<UP>        0B    #ib(1)#<CTRL K>#ie(1)#          Cursor nach oben 
 
<NEWLINE>   1F    #ib(1)#<CTRL SHIFT _>#ie(1)#    Durch DrÅcken von <SHIFT RETURN> 
                                    WaagenrÅcklauf und Zeilenvorschub 
 
 
#on("u")#Funktionstasten:#off("u")# 
 
FÅr jede Funktionstaste, die nicht belegt wurde wird eine Codesequenz der
Form <CTRL A> <code> <CR> also 01 <code> 0D gesendet. FÅr <code> gilt: 
 
Taste             <code>    Hex-Code 
<F1> ...            @ ...      40 ...   Diese Tasten sind auf fast allen 
<F11>               J          4A       TVI-Terminals vorhanden. 
<F12> ...           ` ...      60 ... 
<F15>               c          63 
 
<SHIFT F1> ...      K ...      4B ... 
<SHIFT F15>         Y          59 
 
 
#text end#
#clear pos# 
#free(04.468519e-1)#
 
 
#right#14 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 14 -----------#
#center##on("b")#5.  Die Bedeutung der Tasten#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#on("u")#Zehnerblock:#off("u")# 
 
<SHIFT 1> ...       d ...      64 ... 
<SHIFT 9>           l          6C 
<SHIFT 0>           m          6D 
<SHIFT .>           n          6E 
<SHIFT +>           o          6F 
<SHIFT ->           p          70 
 
<SHIFT BOTRIGHT>    r          72 
 
Alle nicht in dieser Tabelle aufgefÅhrten Funktionstasten senden den Basis-
tastencode. 
 
#text end#
#clear pos# 
#free(16.11019)#
 
 
 15 
#page##--------------------------------- Ende der Seite 15 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#6.  Der Graphikmodus#ie(3)##off("u")##off("i")##type("elite")# 
 
 
#type("8")##center##ib(3)#6.1  Allgemeines#ie(3)##type("elite")# 
 
Der Graphikmodus kann in der 2. Kommandozeile ein- und ausgeschaltet (Gra-
phik: GFX, Text: TXT) oder mit dem Kommando 
 
                         #ib(1)#<ESC> $#ie(1)#    (Hex 1B 24) 
 
eingeschaltet und mit dem Kommando 
 
                         #ib(1)#<ESC> %#ie(1)#    (Hex 1B 25) 
 
ausgeschaltet. 
 
Die Auflîsung betrÑgt in y-Richtung 280 Punkte und in x-Richtung 192 Punk-
te, das sind 53760 Punkte. 
 
 
#type("8")##center##ib(3)#6.2  Koordinaten und ParameterÅbergabe#ie(3)##type("elite")# 
 
Die Koordinaten fÅr die Graphikkommandos dÅrfen den Bereich von -32768 bis
32767 Åberstreichen. Der sichtbare Bereich ist fÅr die X-Koordinate 0..279
und fÅr die Y-Koordinate von 0..191. Der Ursprung (d.h. der Punkt (0,0) )
des Koordinatensystems ist die linke untere Ecke. Die Graphikroutinen zeic-
hnen nur innerhalb des sichtbaren Bereichs (Clipping). 
 
 
#type("8")##center##ib(3)#6.2.1  Cursorposition/Fadenkreuz#ie(3)##type("elite")# 
 
Der Graphikcursor ist ein gedachter unsichtbarer Punkt, der sich im gesam-
ten (auch unsichtbaren) Bereich des Koordinatensystems befinden kann. Wenn
sich der Cursor im sichtbaren Bereich befindet, dann kann man an der Posi-
tion ein Fadenkreuz darstellen. Das Fadenkreuz kann mit 
 
                         #ib(1)#<CTRL X>#ie(1)# oder #ib(1)#<CE>#ie(1)#    (Hex 18) 
 
ein- und ausgeschaltet werden. Das Fadenkreuz wird Exklusiv-Oder (XOR) ge-
zeichnet. Das hei·t, da· die Punkte an der Stelle des Fadenkreuzes inver-
tiert (umgedreht) werden. Das hat wiederum zur Folge, da· an der Graphik-
seite nichts verÑndert wird, wenn zweimal <CTRL X> gesendet wird. Solange
der Bereich oder die Position des Fadenkreuzes nicht verÑndert wird, kînnen
zwischen den beiden <CTRL X> Kommandos auch andere Graphikkommandos ausge-
fÅhrt werden. 
 
 
#text end#
#clear pos# 
#free(2.140185)#
 
 
#right#16 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 16 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.2.2  BinÑre oder dezimale Parameter#ie(3)##type("elite")# 
 
Die öbergabe der x/y Koordinaten, eines Radius oder relativer Koordinaten
und in einigen FÑllen auch anderer Parameter, kann auf zwei verschiedene
Arten erfolgen. Das Terminal erkennt die öbergabeart am ersten Parameterby-
te: 
Bei dezimalen Parametern ist dies entweder <SPACE>, +, - oder eine Zahl. Bei
BinÑren Parametern liegt das Hîherwertige Byte (das erste!) im Bereich von
00..1F oder 3A..FF. Die Festlegung auf dezimale oder binÑre Parameter gilt
fÅr beide (X und Y) Koordinaten. 
 
 
#type("8")##center##ib(3)#6.2.2.1  BinÑre Parameter#ie(3)##type("elite")# 
 
BinÑre Parameter sind eine Folge von vier Bytes (mit 8 Bits). Die ersten
beiden Bytes stellen die X-Koordinate dar, die anderen beiden Bytes die
Y-Koordinate. Negative Koordinaten oder negative relative Koordinaten wer-
den durch Bilden des Zweierkomplements dargestellt. 
Zu beachten ist, da· zuerst das hîherwertige (Highbyte) und dann das nie-
derwertige (Lowbyte) gesendet werden mu·. 
 
Der Vorteil der binÑren Parameter ist, da· die ParameterÅbergabe schneller
ist als bei dezimalen Parametern, da weder Host noch Terminal eine Konver-
tierung vornehmen mÅssen und die Anzahl der Parameterbytes in der Regel
geringer ist als bei dezimaler ParameterÅbergabe. 
 
Der Nachteil ist, da· bei XON/XOFF Flu·kontrolle einige Zahlen als XON oder
XOFF interpretiert werden kînnen und da· diese Parameter nicht auf Funk-
tionstasten gelegt werden kînnen, wenn sie Zeichen > Hex 7F enthalten. 
 
 
#type("8")##center##ib(3)#6.2.2.2  Dezimale Parameter#ie(3)##type("elite")# 
 
Dezimale Parameter bestehen aus einer Folge von ASCII-Zeichen. Die beiden
Koordinaten werden durch einen Separator (Komma, CR, Semikolon o.Ñ.) ge-
trennt. Nach dem 2. Parameter steht ein weiterer Separator. An beliebiger
Stelle in und vor den Zahlen dÅrfen Leerzeichen (<SPACE>) oder Pluszeichen
(+) stehen, die keine énderung des Ergebnisses bewirken. Ein Minuszeichen
vor einer Zahl negiert sie. 
 
Der Vorteil der dezimalen Parameter ist, da· sie in hîheren Programmier-
sprachen bequem und lesbar in ein Programm geschrieben werden kînnen und da·
keine Steuerzeichen vorkommen, die die XON/XOFF - Flu·kontrolle stîren kînn-
ten. Au·erdem kînnen diese Parameter immer auf Funktionstasten gelegt wer-
den, da sie keine Codes > Hex 7F enthalten. 
 
Der Nachteil ist wie unter 6.2.2.1 geschrieben, die Zeitdauer der zweima-
liegen Konvertierung (Host, Terminal) und die in der Regel lÑngeren Parame-
ter. 
 
 
#text end#
#clear pos# 
#free(04.468519e-1)#
 
 
 17 
#page##--------------------------------- Ende der Seite 17 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.2.3  Absolute oder relative Koordinaten#ie(3)##type("elite")# 
 
Bei den Move- und Drawbefehlen hat man die Wahl zwischen relativen und abso-
luten Koordinaten. 
 
Absolute Koordinaten setzen den Graphikcursor direkt auf die als Parameter
angegebene Position. Z.B. <ESC> v 200, 100; setzt den Cursor direkt auf die
Position X=200, Y=100. Die meisten Programme unterstÅtzen nur absolute Koor-
dinaten. 
 
Relative Koordinaten werden zur aktuellen Position des Graphikcursors ad-
diert. Das hat den Vorteil, da· eine Routine nicht zu wissen braucht, wo der
Graphikcursor gerade steht. Man kann sich zum Beispiel Folgen von relativen
Move's und Draw's auf Funktionstasten legen, die dann im Localmodus an der
aktuellen Cursorposition irgendwelche Symbole oder Sonderzeichen zeichnen.
Z.B. <ESC> q -4, 3; bewegt den Graphikcursor 4 Punkte nach links und 3 Punk-
te nach oben. 
 
 
#type("8")##center##ib(3)#6.2.4  Byteparameter#ie(3)##type("elite")# 
 
Byteparameter sind solche, die nur aus einem Byte bestehen. Die Werte kîn-
nen also normalerweise von 0 bis 255 oder Hex 00 bis Hex FF. In den FÑllen,
in denen nicht der ganze Wertebereich genutzt wird, werden nur die nieder-
wertigsten Bits ausaskiert, die hîherwertigen werden ignoriert, wenn nicht
ausdrÅcklich etwas anderes angegeben ist. Im Bereich von 0 bis 7 sind Wert
und ASCII-Ziffer identisch. Bei Werten gro·er als 9 geht das allerdings
nicht mehr. Sind zum Beispiel die Werte von 0 bis 15 erlaubt, dann kann man
folgende Tabelle benutzen: 
 
#on("u")#Wert   ASCII (Hex) oder BinÑr#off("u")# 
  0      0     30        00 
  1      1     31        01 
  2      2     32        02 
  3      3     33        03 
  4      4     34        04 
  5      5     35        05 
  6      6     36        06 
  7      7     37        07 
  8      8     38        08 
  9      9     39        09 
 10      :     3A        0A 
 11      ;     3B        0B 
 12      <     3C        0C 
 13      =     3D        0D 
 14      >     3E        0E 
 15      ?     3F        0F 
 
FÅr Werte zwischen 0 und 31 benutzt man dann besser die Buchstaben (Gro·-
buchstaben und [\]^_ oder Kleinbuchstaben und {|}~ und <DEL>). Die Zuord-
nung entnimmt man der ASCII-Tabelle in Anhang A. 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#18 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 18 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.3  Die Graphikparameter#ie(3)##type("elite")# 
 
FÅr die Linien und Zeichen in der Graphik gibt es verschiedene Darstellungs-
weisen. Man kann die Strichdicke, die Farbe (auf einem Monochrommonitor die
Helligkeit), den Linientyp (durchgehend, gepunktet, gestrichelt etc.) und
die BitverknÅpfungen (lîschen, invertieren...) festlegen. Diese Parameter
werden mit einem Kommando <ESC> O <n> ... verÑndert. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> O 0#ie(1)#    (Hex 1B 4F 30) 
 
werden all diese Parameter auf Defaultwerte zurÅckgesetzt. Diese Default-
werte sind: Strichdicke 1, durchgehende Linie, OR-BitverknÅpfung (Punkte
setzen), helle Farbe (gelb). Ausserdem wird die Seite 0 als sichtbare und
als Arbeitsseite gewÑhlt. Es wird auf ganzseitige Graphik geschaltet (falls
im Graphikmodus). 
 
 
#type("8")##center##ib(3)#6.3.1  Strichdicke#ie(3)##type("elite")# 
 
Die Strichdicke einer Linie ist normalerweise 1. Die Strichdicke 2 zeichnet
parallel zur ursprÅnglichen Linie auf beiden Seiten jeweils eine weitere
Linie der gleichen LÑnge. Die Strichdicke 3 zeichnet dann auf beiden Seiten
jeweils zwei parallele Linien usw. Die Strichdicke kann von 1 bis 15 ge-
wÑhlt werden. Sie wird mit dem Kommando 
 
                         #ib(1)#<ESC> O 1#ie(1)# <dicke>   (Hex 1B 4F 31 <dicke>) 
 
eingestellt. <dicke> ist ein Byteparameter (Kapitel 6.2.4) mit dem Wertebe-
reich 1 bis 15. 
 
 
#type("8")##center##ib(3)#6.3.2  Farbe/Helligkeit#ie(3)##type("elite")# 
 
Normalerweise ist Gelb (hell) eingestellt. Die Alternative ist Violett (dun-
kel). Jeweils 7 nebeneinanderliegene Graphikpunkte haben die gleiche Farbe.
Auf einem Farbmonitor kann die Farbe auch noch durch den Inhalt dieser 7
Graphikpunkte bestimmt werden. Der Farbmodus wird von diesem Terminalpro-
gramm allerdings nicht unterstÅtzt, da sich dann die Auflîsung in X-Richtung
halbiert (also nur noch 140 x 192 Punkte). 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> O 2#ie(1)# <n>    (Hex 1B 4F 32 <n>) 
 
kann die Helligkeit eingestellt werden. <n> ist ein Byteparameter bei dem
nur das Bit 0 wichtig ist: 
 
Bit 0   Bedeutung 
  0     dunkel/Violett     <n> ist eine gerade Zahl 
  1     hell/Gelb          <n> ist eine ungerade Zahl 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
 19 
#page##--------------------------------- Ende der Seite 19 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.3.3  Linientyp#ie(3)##type("elite")# 
 
Der Linientyp ist das "Muster" der Striche. Es gibt 7 vordefinierte Strich-
muster und ein vom Benutzer definiertes. Der Linientyp (im folgenden auch
Pattern genannt) wird mit dem Kommando 
 
                         #ib(1)#<ESC> O 3#ie(1)# <n>    (Hex 1B 4F 33 <n>) 
 
eingestellt. <n> ist ein Byteparameter mit dem Wertebereich von 0 bis 7. Die
Strichtypen sind <n> folgenderma·en zugeordnet: 
 
#on("u")#<n>  Bitmuster (16 Bit)  Name                    #off("u")# 
 0                       unsichtbare Linie 
 1   ----------------    durchgehende Linie 
 2   - - - - - - - -     gepunktete Linie 
 3   ----    ----        kurz gestrichelte Linie 
 4   --------            lang gestrichelte Linie 
 5   --------    -       Strichpunktlinie 
 6   -   -   -----       Strich-Punkt-Punkt Linie 
 7   - - - -  - - - -    Benutzerdefinierte Linie 
                         (Hier Defaultangabe) 
 
Die Bitmuster sind immer 16 Bit lang. Nach einem Movebefehl startet der
nÑchste Draw-Befehl mit dem linkesten (niederwertigsten!) Bit des Bitmu-
sters. Das Muster wiederholt sich bei lÑngeren Linien zyklisch. Wird zwi-
schen zwei Draw-Befehlen kein Move-Befehl gegeben, dann setzt der zweite
Draw-Befehl im Bitmuster nach der gleichen Stelle fort, an der der erste
Draw-Befehl aufgehîrt hat. Auch dicke Linien behalten das Linienmuster bei,
man sollte dann allerdings von gepunkteter auf lang gestrichelte Linie Åber-
gehen, wenn man eine gepunktete dicke Linie haben will. 
 
 
#type("8")##center##ib(3)#6.3.3.1  Selbstdefinierte Linientypen (Pattern)#ie(3)##type("elite")# 
 
Wie in 6.3.3 angemerkt kann ein Linientyp auch vom Benutzer selbst definiert
werden. Da die LÑnge 16 Bit ist, kann man mit den relativen Move's und
Draw's zusammen gut kleine Bildchen (Icons) zusammenstellen. Eine Hilfe ist
dabei auch die BitverknÅpfung COPY, die im nÑchsten Abschnitt erlÑutert
wird. Man legt dazu zuerst das 16 Bit-Pattern als jeweils eine Zeile des
Icons fest und zieht dann von links nach rechts eine 16 Punkte lange Linie
mit dem benutzerdefinierten Pattern. Nach einem relativen Move (-16, -1)
kann der Vorgang fÅr die nÑchste Zeile fortgesetzt werden. 
 
Das benutzerdefinierbare Pattern wird mit dem Kommando 
 
                         #ib(1)#<ESC> O 6#ie(1)# <l> <h>    (Hex 1B 4F 36 <l> <h>) 
 
festgelegt. <l> ist dabei das niederwertige (Lowbyte) des Bitmusters, <h>
ist das hîherwertige (Highbyte) des Bitmusters. Wenn das Pattern als Muster
fÅr Linien (und nicht fÅr Icons) benutzt wird, dann sollte man darauf ach-
ten, da· das Bit 0 im Lowbyte 1 ist, damit man bei kurzen Linien, denen ein
Move vorangegangen ist, zumindestes einen Punkt sieht. 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#20 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 20 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.3.4  BitverknÅpfungen#ie(3)##type("elite")# 
 
öber BitverknÅpfungen werden die Punkte auf der Graphikseite verÑndert. Das
Linienmuster wird dazu zyklisch punktweise abgetastet und jenachdem ob das
aktuelle Bit im Linienbitmuster 0 oder 1 ist eine VerÑnderung der Graphik-
seite durchgefÅhrt. 
Bis auf die COPY-Funktion wirken die BitverknÅpfungen nur auf die Graphik-
seite, wenn der aktuelle Punkt im Linientyp-Bitmuster 1 ist. 
 
- Das Zeichnen einer sichtbaren Linie mit wei·en Punkten geschieht zum Bei-
  spiel durch eine OR- (Oder-) VerknÅpfung. 
 
- Das Lîschen einer Linie (also das Zeichnen von "schwarzen" Punkten) ge-
  schieht mit einer AND- (Und-) VerknÅpfung (Genau genommen eine NAND-, d.h.
  negierte AND-VerknÅpfung). 
 
- Das Invertieren (d.h. Wei·er Punkt wird schwarz, schwarzer Punkt wird
  wei·) kann man mit einer XOR- (Exklusiv-Oder-) VerknÅpfung erreichen. 
 
- FÅr Icons (siehe 6.3.3.1) und andere Zwecke, gibt es noch die COPY-Funk-
  tion, die eigentlich keine einzelne BitverknÅpfung ist. Ist im Linientyp
  das aktuelle Bit 0, dann wird in der Graphikseite eine AND-VerknÅpfung
  durchgefÅhrt (d.h. der Punkt wird gelîscht) ist das aktuelle Bit im Li-
  nientyp 1, dann wird eine OR-VerknÅpfung durchgefÅhrt (d.h. der Punkt wird
  gelîscht). Der Effekt ist, da· genau das Bitmuster des Linientyps in der
  Graphikseite erscheint ("kopiert" wird), egal was vorher da stand, wo die
  Linie gezeichnet wurde. 
 
Die BitverknÅpfung kann mit dem Kommando 
 
                         #ib(1)#<ESC> O 4#ie(1)# <n>    (Hex 1B 4F 34 <n>) 
 
festgelegt werden. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 3. 
<n> hat folgende Bedeutung: 
 
<n>  BitverknÅpfung         Verwendung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0   OR (Oder)              Wei· (auf schwarzem Grund) zeichnen 
 1   AND (Und)              Schwarz (auf wei·em Grund) zeichnen 
 2   XOR (Exklusiv Oder)    Schwarze und Wei·e Punkte umdrehen (invertie-
 ren) 
 3   COPY (kopieren)        Icons zeichnen oder Bilduntergrund Åberschrei-
 ben 
 
 
#text end#
#clear pos# 
#free(2.986852)#
 
 
 21 
#page##--------------------------------- Ende der Seite 21 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.3.5  Multiparametereinstellung#ie(3)##type("elite")# 
 
Die obigen Parameter (bis auf Linientyp) kînnen alle zugleich mit einem
Kommando gesetzt werden. Das Kommando lautet 
 
                         #ib(1)#<ESC> O 5#ie(1)# <n>    (Hex 1B 4F 35 <n>) 
 
<n> ist ein Byteparameter mit dem Wertebereich 0 bis 127. Die Bits sind
folgenderma·en zugeordnet: 
 
   Bit     Bedeutung        Werte 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0 .. 3  : Strickdicke      1 .. 15 
 4 .. 5  : BitverknÅpfung   0 = OR, 16 = AND, 32 = XOR, 48 = COPY 
      6  : Farbe/Helligkeit 0 = Violett (dunkel), 64 = Gelb (hell) 
 
Standardeinstellung ist also '<ESC> O 5 A'. 
 
 
#type("8")##center##ib(3)#6.4  Graphikseiten#ie(3)##type("elite")# 
 
Das Terminal verwaltet zwei Graphikseiten mit einer Grî·e von jeweils 8k
Byte (d.h. 8192 Bytes). 
 
 
#type("8")##center##ib(3)#6.4.1  Die sichtbare Seite und die Arbeitsseite#ie(3)##type("elite")# 
 
Die beiden Graphikseiten kînnen (mÅssen aber nicht) getrennt voneinander
angezeigt und bearbeitet werden. Das kann sinnvoll sein, wenn eine Seite "im
Hintergrund" aufbereitet werden soll, wÑhrend die andere (schon aufbereite-
te) Seite angezeigt wird. Man kann auch die 80-Zeichen Textseite anzeigen
und eine oder beide Graphikseiten im Hintergrund aufbereiten. Durch abwec-
hselndes Umschalten der Arbeits- und Anzeigeseite kann dann der Eindruck
eines bewegten Bildes erzeugt werden. Um diesen Vorgang zu beschleunigen,
kann man die Graphikseiten auch auf dem Host vorbereiten und (im Hinter-
grund) an das Terminal senden (bei 19200 Baud dauert das pro Seite ca. 4.7
Sekunden). 
 
Die sichtbare und die Arbeitsseite kînnen mit dem Kommando 
 
                         #ib(1)#<ESC> O 7#ie(1)# <n>    (Hex 1B 4F 37 <n>) 
 
gewÑhlt werden. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 7. 
 
Bit 0 von <n> : Sichtbare Seite (0 oder 1) 
Bit 1 von <n> : Arbeitsseite (0 oder 1) 
Bit 2 von <n> : 1 = 80 Zeichen Textseite wird in den untersten 32 Graphik-
                zeilen eingeblendet. 0 = Nur Graphikmode. 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
#right#22 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 22 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#on("u")#<n>     Sichtbar Arbeitsseite  Inhalt der untersten 32 Graphikzeilen#off("u")# 
 0      Seite 0  Seite 0       Graphik (Seite 0) 
 1      Seite 1  Seite 0       Graphik (Seite 1) 
 2      Seite 0  Seite 1       Graphik (Seite 0) 
 3      Seite 1  Seite 1       Graphik (Seite 1) 
 4      Seite 0  Seite 0       Text 
 5      Seite 1  Seite 0       MÅll 
 6      Seite 0  Seite 1       Text 
 7      Seite 1  Seite 1       MÅll 
 
 
#type("8")##center##ib(3)#6.4.1.1  80-Zeichen Text und Graphik#ie(3)##type("elite")# 
 
Mit dem in 6.4.1 beschriebenen Kommando kînnen, wie beschrieben, die unter-
sten 4 Zeilen der Textzeile (d.h. ggf. auch die Statuszeile) statt der un-
tersten 32 Graphikzeilen dargestellt werden. Da es nur eine Textseite gibt
und jeder Graphikseite eine eigene Textseite zugeordnet ist, ist die Mi-
schung von Text und Graphik in der Graphikseite 1 auf diese Weise nicht
sinnvoll, da dann in den unstersten 32 Graphikzeilen nur MÅll erscheint. Das
Einblenden wird vom Terminal z.B. genutzt, wenn die Kommandozeile aktiviert
wird. Man kann zum Beispiel Benutzerhinweise in die untersten 4 Zeilen der
Textseite schreiben. Zeichenbefehle arbeiten in dem unsichtbaren (ausgeblen-
deten) Teil der Graphikseite weiter. Das Ergebnis kann man sich beim Wieder-
-Einblenden ansehen. 
 
 
#type("8")##center##ib(3)#6.4.2  Aufbau einer Graphikseite#ie(3)##type("elite")# 
 
Eine Graphikseite besteht aus 8192 Bytes, von denen 7680 genutzt werden, 512
sind somit (in der Graphikseite verstreut) ungenutzt. Jedes Byte besteht aus
einem Farbbit (Bit 7) und 7 angezeigten Graphikbits. Ein gesetztes Bit ent-
spricht einem sichtbaren Punkt auf dem Bildschirm. Das niederwertigste Bit
eines Bytes wird am weitesten links angezeigt. 
Jede der 192 Graphikzeilen besteht also aus 40 Bytes. Jeweils 8 Graphikzei-
len sind zu Reihen zusammengefa·t. Es gibt also 24 Reihen. Jede erste Gra-
phikzeile einer Reihe hat eine Anfangsadresse, die in folgender Tabelle
aufgelistet ist: 
 
#on("u")#Reihe  Adresse  Hex  |  Reihe  Adresse  Hex  |  Reihe  Adresse  Hex#off("u")# 
  0        0    000  |    8      40     028  |   16      80     050 
  1      128    080  |    9     168     0A8  |   17     208     0D0 
  2      256    100  |   10     296     128  |   18     336     150 
  3      384    180  |   11     424     1A8  |   19     464     1D0 
  4      512    200  |   12     552     228  |   20     592     250 
  5      640    280  |   13     680     2A8  |   21     720     2D0 
  6      768    300  |   14     808     328  |   22     848     350 
  7      896    380  |   15     936     3A8  |   23     976     3D0 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
 23 
#page##--------------------------------- Ende der Seite 23 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Um den Offset den n. Graphikzeile in einer Reihe zu finden kann man folgen-
de Tabelle benutzen: 
 
#on("u")#n  Offset (Hex)#off("u")# 
0      0   0000 
1   1024   0400 
2   2048   0800 
3   3072   0C00 
4   4096   1000 
5   5120   1400 
6   6144   1800 
7   7168   1C00 
 
Beispiel: 
  Die Adresse des Punktes (123, 45) soll bestimmt werden. 
  45 DIV 8 = 5, d.h. Y liegt in Reihe 5 mit Adresse 640 (Dezimal). 45 MOD 8
                = 5, d.h. Y liegt in der n=5. Graphikzeile von Reihe 5. Der
                Y-Offset also 5120. 
  123 DIV 7 = 17 d.h. X liegt im Byte mit X-Offset 17. 
  Die Adresse des Punktes ist also im Byte 17 + 5120 + 640 = 5777. 
  123 MOD 7 = 4  d.h. Bit 4 in Byte 5777 ist der gesuchte Punkt. 
 
 
#type("8")##center##ib(3)#6.4.3  Operationen auf den Graphikseiten#ie(3)##type("elite")# 
 
Hier sollen nur die Operationen erlÑutert werden, die nicht in andere Kate-
gorien (z.B. Lîschen, Linien zeichnen etc.) passen. 
 
Es gibt ein universelles Kommando, mit dem zwei Graphikseiten invertiert,
kopiert, gemischt und miteinander logisch verknÅpft werden kînnen. VerÑn-
dert wird bei diesem Kommando nur die Arbeitsseite. 
 
Das Kommando lautet 
 
                         #ib(1)#<ESC> !#ie(1)# <n>    (Hex 1B 21 <n>) 
 
#text end#
#clear pos# 
#free(6.796852)#
 
 
#right#24 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 24 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
<n> ist dabei ein Byteparameter mit dem Wertebereich 0 bis 15 und hat fol-
gende Bedeutung: 
 
<n>   Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0    Keine VerÑnderung. Kopiert die Arbeitsseite in sich selbst (FÑrbt die
      Arbeitsseite allerdings mit der aktuellen Farbe/Helligkeit). 
 1    Die Arbeitsseite wird invertiert. 
 2    Mischt beide Seiten zusammen (OR VerknÅpfung). 
 3    Mischt beide Seiten zusammen (OR) und invertiert das Ergebnis. 
 6    Bildet den Durchschnitt beider Seiten (AND VerknÅpfung). 
 7    Bildet den Durchschnitt beider Seite (AND) und invertiert das Ergebnis
10    Es sind die Punkte gesetzt, die in beiden Seiten verschieden sind (XOR
      VerknÅpfung). 
11    Es sind die Punkte gesetzt, die in beiden Seiten gleich sind (d.h. das
      Inverse von <n>=10). 
14    Kopiert die andere Seite in die Arbeitsseite. 
15    Kopiert das Inverse von der anderen Seite in die Arbeitsseite. 
 
Andere Werte fÅr <n> wiederholen sich in der Tabelle. Die ganze Arbeitssei-
te hat nach der Operation die gewÑhlte Farbe/Helligkeit. 
 
 
#type("8")##center##ib(3)#6.4.4  Laden einer Graphikseite vom Host#ie(3)##type("elite")# 
 
Graphikseiten kînnen ganz oder teilweise vom Host geladen werden. Das kîn-
nen auf dem Terminal erstellte und dann an den Host gesendete (Teil-)
Graphiken sein, aber auch auf dem Host erstellte. In diesem Fall ist das
Kapitel 6.4.2 (Aufbau einer Graphikseite) interessant. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> /#ie(1)# <ll> <lh> <al> <ah> <b...> 
                                                    (Hex 1B 2F ...) 
 
kann eine Seite oder ein Teil einer Seite in die Arbeitsseite geladen wer-
den. <lh>, <ll>, <ah>, <al> und <p...> sind Byteparameter (8 Bits). <ll> und
<lh> bilden zusammen die binÑre LÑnge, d.h. die Anzahl der Datenbytes
<p...>, die die Graphik enthalten. Die LÑnge kann von 0 bis Hex 2000 (dezi-
mal 8192) reichen. Die Adresse, durch <al> und <ah> gebildet, darf von 0 bis
Hex 1FFF reichen. ZusÑtzlich gilt, da· die Summe von LÑnge und Adresse nicht
grî·er als Hex 2000 sein darf, da sonst au·erhalb der Graphikseite geladen
wÅrde. In einem dieser FehlerfÑlle werden die folgenden Graphikdatenbytes
ignoriert. Die Datenbytes werden dann als Kommandos interpretiert, was zu
unvorhersehbaren Reaktionen des Terminals fÅhrt. 
 
 
#text end#
#clear pos# 
#free(2.140185)#
 
 
 25 
#page##--------------------------------- Ende der Seite 25 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.4.5  Graphik auf Diskette speichern/laden#ie(3)##type("elite")# 
 
Um Graphikseiten, zum Besipiel fÅr PrÑsentationen, unabhÑngig vom Host auf
dem Bildschirm darstellen zu kînnen, benutzt man das Kommando 
 
                         #ib(1)#<ESC> S#ie(1)# <n>    (Hex 1B 53 <n>). 
 
Man kann bis zu 8 verschiedene Graphikseiten vorbereiten, auf Diskette spei-
chern und zu einem spÑteren Zeitpunkt wieder in das Terminal zurÅckladen.
Dieses Kommando wird auch verwendet, um eine Textseite auf Diskette zu
schreiben oder von Diskette zu lesen. <n> ist ein Byteparameter mit dem
Wertebereich 0 bis 31, wobei die Bits folgenderma·en belegt sind: 
 
Bit 0..2 : "Fachnummer" der Graphikseite auf der Diskette (0 bs 7) 
Bit 3    : Bei Graphikseiten immer 1 (Bei Textseiten 0) 
Bit 4    : 0 hei·t: die Graphikseite wird von der Diskette gelesen, 
           1 hei·t: die Graphikseite wird auf die Diskette geschrieben. 
 
Wird die Graphikseite auf die Diskette geschrieben, dann wird eine eventuell
schon in diesem "Fach" vorhandene Graphikseite Åberschrieben. 
 
Wie bei allen Graphikkommandos, bezieht sich dieses Kommando nicht unbedingt
auf die sichtbare Graphikseite, sondern auf die Arbeitsseite. 
 
Beispiele: 
    <ESC> S <CTRL H> liest die Graphikseite in Fach 0 in die Arbeitsseite. 
    <ESC> S <CTRL X> schreibt die Arbeitsseite in Fach 0 der Diskette. 
 
Da das Lesen einer Graphikseite von Diskette mit ca. 1.1 Sekunden, um eini-
ges schneller als der Datentransfer vom Host ist, sollte man bewegte Graphi-
ken auf Diskette vorbereiten und sie dann mit verschrÑnkter Arbeits- und
Sichtbarkeitsseite anzeigen. 
Z.B.: Seite 1 als Arbeitsseite wÑhlen, Seite 0 als sichtbare Seite. Graphik
      von Diskette laden (wird in Seite 1 (= Arbeitsseite) geladen) Seite 1
      als sichtbare Seite wÑhlen, Seite 0 jetzt als Arbeitsseite wÑhlen. Die
      nÑchste Graphikseite wird von der Diskette in die Seite 1 geladen etc. 
      Bei dieser Vorgehensweise scheinen öbergÑnge kontinuierlich zu sein. 
 
FÅr Insider: Eine Graphikseite belegt zwei Tracks (8k). Die 8 Graphikseiten
             befinden sich auf den Tracks 10 bis 25 in aufsteigender Reihen-
             folge. 
 
 
#type("8")##center##ib(3)#6.5  Textdarstellung im Graphikmodus#ie(3)##type("elite")# 
 
Nicht nur auf der 80-Zeichen Textseite kînnen Buchstaben und Zeichen darge-
stellt werden, sondern auch auf den Graphikseiten. Die Auflîsung ist zwar
nicht so gro· wie auf der reinen Textseite, aber die Anzahl der verschiede-
nen Darstellungsmîglichkeiten ist sehr viel grî·er. Fast alle Kommandos, die
in der Textseite angewandt werden kînnen, haben in der Graphikseite die
gleiche Funktion. 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#26 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 26 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Textdarstellung in der Graphikseite ist hauptsÑchlich zum Beschriften von
Graphiken oder zum Drucken von öberschriften etc. vorgesehen. Da aber fast
alle Textkommandos (Delete/Insert Line/Character fehlt) auch im Graphikmo-
dus zur VerfÅgung stehen, kann man auch im Graphikmodus Textverarbeitung
oder Editor benutzen. 
 
 
#type("8")##center##ib(3)#6.5.1  Zeichendarstellung#ie(3)##type("elite")# 
 
Die normale Grî·e eines Zeichens ist 6 x 10 Punkte (x * y), damit lassen
sich 46 x 19 Zeichen (874 Zeichen) voll auf dem Bildschirm darstellen. Wenn
die Grî·e mit einem Kommando auf 5 x 8 Punkte verringert wird, dann lassen
sich 56 x 24 Zeichen (1344 Zeichen) auf dem Bildschirm darstellen. Komfor-
table Textverarbeitung lÑ·t sich damit natÅrlich nicht machen, zumal die
Geschwindigkeit, mit der die Zeichen auf den Bildschirm geschrieben werden
gegenÅber der der reinen Textseite langsamer ist. 
 
 
#type("8")##center##ib(3)#6.5.1.1  Zeichengrî·e und Schreibrichtung#ie(3)##type("elite")# 
 
Die Zeichen kînnen in verschiedenen Grî·en und unter verschiedenen Winkeln
auf den Bildschirm geschrieben werden. Damit ist auch ein Schreiben von
rechts nach links mit auf dem Kopf stehenden Zeichen mîglich. 
Bei normaler Schreibrichtung (waagerecht von links nach rechts) befindet
sich die linke untere Ecke eines Zeichens an der Position des Graphikcur-
sors. Nach dem Zeichnen des Zeichens befindet sich der Graphikcursor hinter
der rechten unteren Ecke des Zeichens. Da sich die Zeichen aus Vektoren
(Linien) zusammensetzen und nicht aus einer festen Punktmatrix, kînnen sie
schnell beliebig gedreht und vergrîssert (und verkleinert) werden. Der Dreh-
winkel ist wie bei allen Graphikwinkelangaben in 5 Grad Schritten anzugeben.
Die Zuordnung der Winkel zu den Parameterwerten oder ASCII-Zeichen ist im
Anhang A angegeben. 
 
Das Kommando 
 
                         #ib(1)#<ESC> N#ie(1)# <b> <h> <w>    (Hex 1B 4E <b><h><w>) 
 
stellt Breite, Hîhe und Drehwinkel der Zeichen ein. Alle Parameter sind
Byteparameter mit dem Wertebereich 0 bis 255. Mit einem Parameter Hex 00
kann der Defaultwert (Standardwert) fÅr den jeweiligen Parameter eingestellt
werden. 
<b> bezeichnet die Zeichenbreite in Punkten. Standardwert ist 6. 
<h> bezeichnet die Zeichenhîhe in Punkten. Standardwert ist 10. 
<w> bezeichnet den Drehwinkel in 5 Grad Schritten. Standardwert ist 0. 
 
#text end#
#clear pos# 
#free(2.986852)#
 
 
 27 
#page##--------------------------------- Ende der Seite 27 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Einige ausgezeichnet Werte fÅr <w> sind: 
<w>    Richtung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0     Waagerecht von links nach rechts (Ost) 
 9     SchrÑg nach unten rechts         (SÅd-Ost) 
18     Senkrecht von oben nach unten    (SÅd) 
27     SchrÑg nach unten links          (SÅd-West) 
36     Waagerecht (auf dem Kopf stehend) von rechts nach links (West) 
45     SchrÑg nach oben links           (Nord-West) 
54     Senkrecht von unten nach oben    (Nord) 
63     SchrÑg von nach oben rechts (AufwÑrts) (Nord-Ost) 
72...  Wie 0 ... 
 
 
#type("8")##center##ib(3)#6.5.1.2  Dicke, Farbe etc.#ie(3)##type("elite")# 
 
Buchstaben werden mit Vektoren (Linien) gezeichnet. Die gleichen Parameter,
die fÅr Striche eingestellt werden, wirken dann auch auf die Zeichen. Mîg-
liche Parameter sind Farbe, Linientyp, Strichdicke und BitverknÅpfung. Mit
dem Kommando 
 
                         #ib(1)#<ESC> O 0#ie(1)#    (Hex 1B 4F 30) 
 
werden alle diese Parameter auf Standardwerte zurÅckgesetzt. Die Standard-
werte sind in Kapitel 6.3 erlÑutert. Die Beschreibung des Kommandos zur
Einstellung der Zeichenfarbe ist in Kapitel 6.3.2 beschrieben, das Einstel-
len der Zeichendicke in Kapitel 6.3.1, das Einstellen des Linientyps in
Kapitel 6.3.3 und das Einstellen der BitverknÅpfung ist in Kapitel 6.3.4
beschrieben. Auch fÅr die Zeichendarstellung kînnen mehrere dieser Parame-
ter zugleich mit einem Kommando eingestellt werden. Das Multiparameterkom-
mando ist in Kapitel 6.3.5 beschrieben. 
 
 
#type("8")##center##ib(3)#6.5.1.3  ZeichensÑtze und Attribute#ie(3)##type("elite")# 
 
éhnlich wie bei der 80-Zeichen Textdarstellung kînnen Zeichensatz und Text-
attribute eingestellt werden. Mit dem Kommando 
 
                         #ib(1)#<ESC> z#ie(1)# <n>    (Hex 1B 7A <n>) 
 
kann einer der beiden ZeichensÑtze USA oder GER (ASCII und Deutsch) gewÑhlt
werden. Ein griechischer Zeichensatz ist unabhÑngig von beiden immer vor-
handen. 
<n> ist ein Byteparameter mit dem Wertebereich 0 bis 15, im Graphikmodus
sind aber nur die beiden folgende Werte sinnvoll: 
 
#on("u")#<n>  Zeichensatz  Abweichende Zeichen#off("u")# 
 2   Deutsch      é ô ö Ñ î Å · 
 4   Ascii        [ \ ] { | } ~ 
 
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
#right#28 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 28 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Au·erdem kann der Zeichensatz im ersten Feld der ersten Kommandozeile ein-
gestellt werden. Im amerikanischen Zeichensatz treten die deutschen Buch-
staben au·erdem im Bereich von 214 bis 219 und 251 auf. Der Graphikzeichen-
satz ist im Anhang abgebildet. 
 
Wie im Textmodus kînnen Attribute mit dem Kommando 
 
                         #ib(1)#<ESC> G#ie(1)# <n>    (Hex 1B 47 <n>) 
 
eingestellt werden. <n> ist ein Byteparameter mit dem Wertebereich 0, 1, 4
und 5. Die Werte von <n> sind folgenderma·en zugeordnet: 
 
#on("u")#<n>  Bedeutung                                       #off("u")#
 0   Normaler Text (sichtbar und aufrecht) 
 1   Unsichtbarer Text (Nur der Cursor wird bewegt) 
 4   Kursivschrift, die Zeichen werden schrÑggestellt 
 5   Wie 1 (unsichtbarer Text) 
 
Das Kommando 
 
                         #ib(1)#<ESC> )#ie(1)#   (Hex 1B 29) 
 
hat wie im Textmodus die gleiche Bedeutung wie <ESC> G 4. Damit wird im
Graphikmodus die Kursivschrift eingeschaltet. Mit dem Kommando 
 
                         #ib(1)#<ESC> (#ie(1)#   (hex 1B 28) 
 
wird die Kursivschrift wieder ausgeschaltet. Im Textmodus invers hervorge-
hobene Textstellen werden im Graphikmodus also durch Kursivschrift hervor-
gehoben. 
Steht rechts neben der Zeichenspalte mit einem Kursivzeichen ein nicht kur-
sives Zeichen, dann wird das rechte Zeichen mîglicherweise etwas Åberschrie-
ben, da es in den oberen Teil des Kursivzeichens hineinragt. Das kann ver-
mieden werden, wenn nach dem Ausschalten der Kursivschrift ein Leerzeichen
ausgegeben wird. 
 
 
#type("8")##center##ib(3)#6.5.1.4  Zeichen Åberschreiben#ie(3)##type("elite")# 
 
Im 80-Zeichen Textmodus kann man Zeichen einfach Åbereinandertippen, das
zweite Zeichen ersetzt dann das erste. Im Graphikmodus sollen Texte auch mit
in eine Zeichnung geschrieben werden kînnen, ohne da· Teile von Linien even-
tuell gelîscht werden. Dieser Modus bringt au·erdem eine etwas grî·ere
Schreibgeschwindigkeit mit sich. Es ist aber auch mîglich, da· die FlÑche,
in die das Zeichen geschrieben werden soll, vorher gelîscht wird, um ein
sauberes Schriftbild zu erzielen. Mit dem Kommando 
 
                         #ib(1)#<ESC> &#ie(1)#   (Hex 1B 26) 
 
kann man das vorherige Lîschen einschalten, mit dem Kommando 
 
                         #ib(1)#<ESC> '#ie(1)#   (Hex 1B 27) 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
 29 
#page##--------------------------------- Ende der Seite 29 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
wird der Modus des öberschreibens ausgeschaltet. 
 
Bei Kursivzeichen wird eine rautenfîrmige FlÑche gelîscht oder gefÅllt (wenn
BitverknÅpfung AND eingeschaltet ist). Bei normalen Zeichen wird eine re-
chteckige FlÑche, der mit #ib(1)#<ESC> N#ie(1)# eingestellten Breite und Hîhe, gelîscht
oder gefÅllt. Zu beachten ist, da· das Lîschen/FÅllen nur bei waagerechter
Schreibrichtung von links nach rechts funktioniert. 
 
Da die Grî·e der Zeichen in weiten Grenzen mit <ESC> N eingestellt werden
kann, ist es auch mîglich mit dem durch <ESC> & eingeschalteten Ersetzungs-
modus schnell rechteckige FlÑchen zu fÅllen oder zu lîschen, wenn nicht auf
das spÑter beschriebene FÅllkommando fÅr beliebige FlÑchen zurÅckgegriffen
werden soll. Dazu schaltet man mit dem Kommando <ESC> O 4 1 die BitverknÅ-
pfung AND (fÅr FÅllen) ein und gibt dann einfach ein Leerzeichen aus, das
dann invertiert dargestellt wird. 
 
 
#type("8")##center##ib(3)#6.5.2  Textkommandos im Graphikmodus#ie(3)##type("elite")# 
 
Fast alle Textkommandos des 80-Zeichen Textmodus wirken auch im Graphikmo-
dus. Einige Kommandos, wie Zeichen senden, Zeile senden, Cursorposition
senden, haben im Graphikmodus andere Funktionen und haben deshalb andere
Escape-Sequenzen. Textkommandos, die nicht im Graphikmodus vorhanden sind:
<ESC> I (Backtab), <ESC> j (Reverse Linefeed), <ESC> E (Insert Line), <ESC>
Q (Insert Character), <ESC> R (Delete Line), <ESC> W (Delete Character). 
 
 
#type("8")##center##ib(3)#6.5.2.1  Die Cursorpositionierung#ie(3)##type("elite")# 
 
Die Cursorpositionierungskommandos (UP, DOWN, LEFT, RIGHT) wirken im Gra-
phikmodus in die aktuelle Schreibrichtung. Beispiel: Wenn als Schreibwinkel
180 Grad eingestellt wurde (Winkel 36, also von rechts nach links auf dem
Kopf schreiben), dann mu· man, um einen Backspace (d.h. ein Zeichen zurÅck)
auszufÅhren, nicht <RIGHT> sondern wie bei normaler Schreibrichtung Åblich,
<LEFT> drÅcken. Die vier Cursorsteuertasten funktionieren fÅr beliebige
Schreibrichtungen. Alle anderen Steuertasten beziehen sich immer auf waage-
rechte Schreibrichtung von links nach rechts. 
 
Alle Steuertasten berÅcksichtigen die Zeichengrî·e (Breite und Hîhe). Auch
die Graphikseite wird am Ende der letzten Zeile um soviele Graphikzeilen
gescrollt, wie ein Zeichen hoch ist. 
 
#text end#
#clear pos# 
#free(4.256852)#
 
 
#right#30 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 30 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Folgende Steuerkommandos/Tasten wirken im Graphikmodus: 
 
Basis-Taste    Apple-Taste  Hex-Code   Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
#ib(1)#<TAB>#ie(1)#            <TAB>         09      Der Cursor wird an die nÑchste (re-
                                       chte) Tabulatorposition gesetzt.
                                       Tabulatorpositionen sind alle 8 Spal-
                                       ten (wie im Textmodus). Liegt die
                                       nÑchste Tabulatorposition au·erhalb
                                       des sichtbaren Bereichs, dann steht
                                       der Cursor jetzt da. 
 
#ib(1)#<SHIFT CE>#ie(1)#       <OA CTRL X>    -      Kommandozeile aktivieren. 
                                       Einzelheiten zur Kommandozeile siehe
                                       Abschnitt 3.: Die Kommandozeilen. 
 
#ib(1)#<CE>#ie(1)#             <CTRL X>      18      u.a. Kommandozeile verlassen. 
 
#ib(1)#<RETURN>#ie(1)#         <RETURN>      0D      Zum Zeilenanfang ohne Zeilenvorschub. 
                                       Der Cursor steht dann in der ersten
                                       Spalte der Zeile. 
 
#ib(1)#<SHIFT RETURN>#ie(1)#   <OA RETURN>   8D      Zum Anfang der nÑchsten Zeile. Falls
                                       der Cursor in der letzten sichtbaren
                                       Bildschirmzeile war, wird der Bild-
                                       schirminhalt entweder nach oben ge-
                                       scrollt (SCROLL) oder in Homeposition
                                       gebracht (PAGE). 
 
#ib(1)#<UP>#ie(1)#             <UP>       8B/0B      Cursor eine Zeile hîher (bzw. Åber
                                       die Zeile). War der Cursor in der
                                       ersten sichtbaren Bildschirmzeile,
                                       dann steht er jetzt im unsichtbaren
                                       Bereich. 
 
#ib(1)#<DOWN>#ie(1)#           <DOWN>     8A/0A      Cursor eine Zeile tiefer (bzw. "un-
                                       ter" die Zeile). War der Cursor in
                                       der letzten sichtbaren Zeile, dann
                                       wird der Inhalt des Graphikbild-
                                       schirms nach oben gescrollt, d.h. die
                                       obersten Zeilen werden gelîscht (im
                                       SCROLL-Modus) oder der Cursor in die
                                       erste Zeile gesetzt (im PAGE-Modus). 
 
#ib(1)#<CTRL V>#ie(1)#         <CTRL V>      16      Cursor eine Zeile tiefer (bzw. "un-
                                       ter" die Zeile). War der Cursor in
                                       der letzten Zeile, dann Ñndert er
                                       seine Position nicht. Die Spalte
                                       Ñndert sich nicht. 
 
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
 31 
#page##--------------------------------- Ende der Seite 31 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#ib(1)#<LEFT>#ie(1)#           <LEFT>     88/08      Cursor eine Spalte nach links (bzw.
                                       entegegen der Schreibrichtung). War
                                       der Cursor in der ersten sichtbaren
                                       Bildschirmspalte, dann ist er jetzt
                                       unsichtbar "links" davon. 
 
#ib(1)#<RIGHT>#ie(1)#             -          95      Cursor eine Spalte nach rechts (bzw.
                                       in Schreibrichtung). War der Cursor
                                       in der letzten sichtbaren Spalte,
                                       dann befindet er sich jetzt au·er-
                                       halb des Bildschirms. Im Gegensatz
                                       zum Textmodus wird kein Linefeed oder
                                       Scroll ausgefÅhrt. 
 
#ib(1)#<HOME>#ie(1)#           <OA @>        C0      Der Cursor wird in die linke obere
                                       Bildschirmecke gebracht (Homeposi-
                                       tion). 
 
#ib(1)#<SHIFT HOME>#ie(1)#     <OA P>        D0      Bildschirm lîschen und Cursor Home. 
 
#ib(1)#<DELETE>#ie(1)#         <DELETE>      7F      Dieses Zeichen wird auf dem Bild-
                                       schirm nicht dargestellt. Der Host
                                       interpretiert es in der Regel als
                                       Zeichenlîschbefehl. 
 
#ib(1)#<BOTTOMLEFT>#ie(1)#     <BACKSPACE>   08      Cursor eine Spalte nach links (bzw.
                                       entgegen der Schreibrichtung). Die
                                       Funktion ist mit der von <LEFT> iden-
                                       tisch. 
 
#ib(1)#<BOTTOMRIGHT>#ie(1)#    <RIGHT>       15      Apple: Cursor eine Spalte nach re-
                                       chts (bzw. in Schreibrichtung). Die
                                       Funktion ist mit der von <RIGHT>
                                       identisch. 
 
#ib(1)#<ESC>#ie(1)#            <ESC>         1B      Leitet eine Escape-Sequenz ein. 
 
#ib(1)#<SHIFT CTRL HOME>#ie(1)#<OA 0>         -      Local/Online umschalten 
 
#ib(1)#<CTRL HOME>#ie(1)#      <OA SPACE>   '00'     Sendet V24-Break (Hexcode 00 mit
                                       Rahmenfehler). Als Rahmenfehler wird
                                       das Fehlen des oder der Stopbits
                                       bezeichnet (Stopbitpegel ist norma-
                                       lerweise 1, bei Break dagegen 0). 
 
Unbelegte Funktionstasten erzeugen Graphikzeichen, die im Anhang A nachge-
sehen werden kînnen. 
 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
#right#32 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 32 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.5.2.2  Lîschbefehle#ie(3)##type("elite")# 
 
Das Kommando (Clear to End Of Line) 
 
                         #ib(1)#<ESC> T#ie(1)#    (Hex 1B 54) 
 
lîscht ab der aktuellen Cursorposition bis zum Zeilenende. Die Hîhe des
gelîschten Balkens entspricht der Buchstabenhîhe. Der Balken wird unabhÑn-
gig von der BitverknÅpfung immer gelîscht. Der Balken wird unabhÑngig von
der Schreibrichtung immer waagerecht gelîscht. 
 
Das Kommando (Clear to End Of Page) 
 
                         #ib(1)#<ESC> Y#ie(1)#    (Hex 1B 59) 
 
lîscht den Graphikbildschirm von der aktuellen Cursorposition an bis zum
Bildschirmende. Auch dieses Kommando lîscht unabhÑngig von der gewÑhlten
BitverknÅpfung und Schreibrichtung immer waagerecht. 
 
Die Kommandos 
 
                         #ib(1)#<ESC> *#ie(1)#    (Hex 1B 2A) 
                         #ib(1)#<ESC> ,#ie(1)#    (Hex 1B 2C) 
                         #ib(1)#<ESC> +#ie(1)#    (Hex 1B 2B) 
                         #ib(1)#<ESC> :#ie(1)#    (Hex 1B 3A) 
                         #ib(1)#<CTRL Z>#ie(1)#   (Hex 1A) 
 
lîschen den Bildschirm und bringen den Graphikcursor in Homeposition, d.h.
eine Buchstabenhîhe unter dem oberen Bildschirmrand. 
 
Das Kommando 
 
                         #ib(1)#<ESC> y#ie(1)#    (Hex 1B 79) 
 
lîscht den Bildschirm und bringt den Graphikcursor in die linke untere Ecke,
d.h. den Ursprung des Koordinatensystems. 
 
 
#type("8")##center##ib(3)#6.6  Die Graphikkommandos#ie(3)##type("elite")# 
 
 
#type("8")##center##ib(3)#6.6.1  Draw's und Move's#ie(3)##type("elite")# 
 
Draw's sind Zeichenbefehle, die eine Linie zeichnen und den Cursor an den
Endpunkt der Linie positionieren. Move's positionieren nur den Cursor und
zeichnen nicht. Bei allen Draw's ist der Anfangspunkt der Linie die aktuel-
le Cursorposition. Die Endposition kann relativ, absolut oder mit einem
relativen Winkel angegeben werden. Der Befehl zum Setzen/Lîschen eines Punk-
tes wurde mit in diese Befehlskategorie aufgenommen. 
 
 
#text end#
#clear pos# 
#free(04.468519e-1)#
 
 
 33 
#page##--------------------------------- Ende der Seite 33 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.6.1.1  Punkt setzen#ie(3)##type("elite")# 
 
Der Befehl zum Setzen eines Graphikpunktes ist ein absoluter Befehl, d.h.
die Koordinaten des Punktes folgen dem Kommando. Die Position des Graphik-
cursors wird durch diesen Befehl nicht verÑndert. 
 
Das Kommando 
 
                         #ib(1)#<ESC> m#ie(1)# <x, y;>    (Hex 1B 6D <x, y;>) 
 
setzt einen Punkt an die Position x/y, wenn diese innerhalb des sichtbaren
Bereichs liegt. <x, y;> sind dezimale oder binÑre Koordinaten. Das Aussehen
des Punktes kann durch Farbe/Helligkeit oder BitverknÅpfung festgelegt wer-
den. Mit einer AND-BitverknÅpfung wird der angegebene Punkt gelîscht, mit
einer OR oder COPY BitverknÅpfung wird der angegebene Punkt gesetzt, mit
einer XOR BitverknÅpfung wird sein Zustand umgedreht (invertiert). 
Soll ein dicker Punkt gezeichnet werden, dann kann man den (relativen)
Draw-Befehl <ESC> r 0, 0; benutzen, der an die Position des Graphikcursors,
einen Punkt der eingestellten Dicke zeichnet. 
 
 
#type("8")##center##ib(3)#6.6.1.2  Move-Befehle#ie(3)##type("elite")# 
 
Den Move-Befehl gibt es in zwei Versionen, einer relativen und einer abso-
luten. Das Kommando fÅr einen absoluten Move lautet 
 
                         #ib(1)#<ESC> v#ie(1)# <x, y;>    (Hex 1B 76 <x, y;>) 
 
Dabei sind <x, y;> dezimale oder binÑre Koordinaten, die die neue Position
des Graphikcursors bezeichnen. Diese Position mu· nicht im sichtbaren Be-
reich liegen, sondern kann auch au·erhalb des Fensters liegen. Der Wertebe-
reich von <x> und <y> ist -32768 bis 32767. 
 
Das Kommando fÅr den relativen Move-Befehl lautet 
 
                         #ib(1)#<ESC> q#ie(1)# <x, y;>    (Hex 1B 71 <x, y;>) 
 
Bei diesem Befehl werden die Werte von <x> und <y>, die auch den gesamten
Wertebereich von -32768 bis 32767 Åberstreichen dÅrfen, zu den Koordinaten
des Graphikcursors addiert. Auch hier darf die neue Position des Graphik-
cursors au·erhalb des sichtbaren Bereichs liegen. 
 
Die Move-Befehle setzen au·erdem das Bitmuster fÅr den Linientyp wieder auf
den Startwert zurÅck, damit der nÑchste Draw-Befehl auch mit einem Punkt
beginnt. 
 
 
#text end#
#clear pos# 
#free(2.140185)#
 
 
#right#34 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 34 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.6.1.3  Draw-Befehle#ie(3)##type("elite")# 
 
Ebenso wie den Move-Befehl gibt es auch den Draw-Befehl in zwei Versionen,
einer relativen und einer absoluten. Das Kommando fÅr einen absoluten Draw
lautet 
 
                         #ib(1)#<ESC> w#ie(1)# <x, y;>    (Hex 1B 77 <x, y;>) 
 
Dabei sind <x, y;> dezimale oder binÑre Koordinaten, die die Endposition der
Linie bezeichnen. Diese Position mu· nicht im sichtbaren Bereich liegen,
sondern kann auch au·erhalb des Fensters liegen. Der unsichtbare Teil der
Linie wird dann "geclippt". Der Wertebereich von <x> und <y> ist -32768 bis
32767. 
 
Das Kommando fÅr den relativen Draw-Befehl lautet 
 
                         #ib(1)#<ESC> r#ie(1)# <x, y;>    (Hex 1B 72 <x, y;>) 
 
Bei diesem Befehl werden die Werte von <x> und <y>, die auch den gesamten
Wertebereich von -32768 bis 32767 Åberstreichen dÅrfen, zu den Koordinaten
des Graphikcursors addiert, die dann die Endposition der Linie bilden. Auch
hier darf die Endposition der Linie au·erhalb des sichtbaren Bereichs lie-
gen. 
 
 
#type("8")##center##ib(3)#6.6.1.4  Turtle-Graphik#ie(3)##type("elite")# 
 
Turtle-Graphik (Schildkrîten-Graphik, obwohl hier keine Schildkrîte sicht-
bar ist) wird zur Erzeugung von "rekursiven" Graphiken, die mit LÑngen und
Winkelangaben, statt mit x/y-Koordinaten, arbeiten benîtigt. Man stellt sich
dazu eine Schildkrîte vor, die auf ihrem Weg Åber den Bildschirm eine sicht-
bare Spur zurÅcklassen kann (aber nicht mu·). Die Schildkrîte kann einen Weg
bestimmter LÑnge in ihre Blickrichtung gehen und bleibt dann stehen. Au·er-
dem kann sie sich nach links oder rechts drehen, d.h. ihre Blickrichtung
Ñndert sich. Alles was man dazu braucht, ist ein Befehl, der die Richtung
der Schildkrîte verÑndern kann und dann einen Weg bestimmter LÑnge in dieser
Richtung zurÅcklegt. Au·erdem wird noch ein Befehl benîtigt, der das "Spur-
verhalten" der Schildkrîte Ñndert, also von "Spur sichtbar" auf "Spur un-
sichtbar" umschaltet und umgekehrt. NatÅrlich ist die Zeichengeschwindigkeit
nicht mit der Fortbewegungsgeschwindigkeit von Schildkrîten zu vergleichen.
Das erste Kommando lautet 
 
                         #ib(1)#<ESC> n#ie(1)# <l, w;>    (Hex 1B 6E <l, w;>) 
 
<l> und <w> sind dezimale oder binÑre Parameter. <l> ist die LÑnge der Spur
mit einem Wertebereich von 0 bis 511. <w> ist der relative Drehwinkel der
Schildkrîte, also die énderung von der ursprÅnglichen Blickrichtung aus. <w>
Åberstreicht den positiven und negativen Winkelbereich (0..71 entsprechen 0
bis 355 in 5 Grad Schritten. -1 entspricht z.B. 355 Grad). 
 
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
 35 
#page##--------------------------------- Ende der Seite 35 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Mit dem Kommando 
 
                         #ib(1)#<ESC> o#ie(1)#    (Hex 1B 6F) 
 
kann von 'Draw' einer Spur auf 'Move' umgeschaltet werden und umgekehrt. 
 
Um die Sichtbarkeit der Spur am Programmamfang auf einen definierten Wert zu
setzen, kann man das Kommando 
 
                         #ib(1)#<ESC> O 8#ie(1)# <n>    (Hex 1B 4F 38 <n>) 
 
benutzen. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 3. 
 
#on("u")#Bit 0 hat folgende Bedeutung:                                    #off("u")# 
  0       Pendown. Die Schildkrîte hinterlÑ·t eine sichtbare Spur 
  1       Penup. Die Schildkrîte hinterlÑ·t keine Spur 
 
#on("u")#Bit 1 hat folgende Bedeutung:                                    #off("u")# 
  0       Drawer. Es wird eine wei·e Linie gezeichnet. 
  1       Eraser. Es wird eine schwarze Linie gezeichnet (gelîscht) 
 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> O 9#ie(1)#    (Hex 1B 4F 39) 
 
wird die Turtle-Graphik initialisiert. Dieses Kommando mu· nicht aufgerufen
werden bevor die Turtle-Graphik benutzt wird, sollte aber nach Mîglichkeit
am Anfang eines Turtle-Graphik-Programmes benutzt werden. Das Kommando setzt
die Schildkrîte in die Mitte des Bildschirms (140, 96) mit Blickrichtung
nach oben. Der Drawer wird eingeschaltet (zeichnen) und eine sichtbare Linie
wird voreingestellt (Pendown). 
 
 
#type("8")##center##ib(3)#6.6.2  Komplexere Zeichenkommandos#ie(3)##type("elite")# 
 
Au·er den Kommandos zum Zeichnen von Linien und zum Bewegen des Graphikcur-
sors gibt es noch verschiedene andere Zeichenkommandos. 
 
 
#type("8")##center##ib(3)#6.6.2.1  Kreise und Kreissegmente#ie(3)##type("elite")# 
 
Der Mittelpunkt eines Kreises liegt immer an der aktuellen Cursorposition.
Der Radius eines Kreises ist in weiten Grenzen von 0 bis Åber 30000 Punkten
wÑhlbar. Clipping wird ausserhalb des Bildschirmrandes durchgefÅhrt. Ein
Kreis kann in 8 Segmente unterteilt werden, von denen alle oder nur einzel-
ne gezeichnet werden kînnen. Damit ist es dann auch mîglich, Halb- oder
Viertelkreise zu Zeichnen. 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
#right#36 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 36 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Mit dem Kommando 
 
                         #ib(1)#<ESC> K#ie(1)# <r, s;>   (Hex 1B 4B <r, s;>) 
 
wird ein Kreis mit dem Radius <r> um die aktuelle Cursorposition gezeichnet
(relative Kreise). <s> legt fest, welche Segmente gezeichnet werden sollen.
<r, s;> sind dezimale oder binÑre Parameter. <s> hat den Wertebereich von 0
bis 255. 
Jedes Bit in <s> ist einem Kreissegment zugeordnet. Ist das Bit gesetzt (1),
dann wird das zugehîrige Segment gezeichnet. Der Wert 0 entspricht dem Wert
255 (der ganze Kreis wird gezeichnet), ist aber etwas schneller, da keine
Abfrage der einzelnen Bits durchgefÅhrt wird. 
 
Die Segmente sind folgenderma·en numeriert: 
 
                                  7  0 
                                6      1 
                                5      2 
                                  4  3 
 
Beispiele fÅr <n> : 
 
#on("u")#<n>  Bedeutung                               #off("u")#
  0  Zeichnet einen ganzen Kreis 
 15  Zeichnet einen links offenen Halbkreis 
240  Zeichnet einen rechts offenen Halbkreis 
195  Zeichnet einen unten offenen Halbkreis 
 60  Zeichnet einen oben offenen Halbkreis 
  3  Zeichnet ein Kreisviertel rechts oben 
 12  Zeichnet ein Kreisviertel rechts unten 
 48  Zeichnet ein Kreisviertel links unten 
192  Zeichnet ein Kreisviertel links oben 
etc. 
 
Das Aussehen von Kreisen kann durch die Parameter Farbe/Helligkeit und die
BitverknÅpfung verÑndert werden. Der Linientyp (Punkt-, Strichlinie) und die
Strickdicke haben keinen Einflu·, d.h. der Kreis wird immer mit durchgehen-
der Linie und einfacher Dicke gezeichnet. Sollen diese beiden Parameter auch
verÑndert werden, sollte man den Befehl <ESC> s fÅr Ellipsenbîgen verwenden. 
 
 
#type("8")##center##ib(3)#6.6.2.2  Rechtecke#ie(3)##type("elite")# 
 
Rechtecke werden ebenso wie Kreise relativ gezeichnet, d.h. die aktuelle
Cursorposition bildet eine Ecke des Rechtecks. Die Seiten des Rechtecks
liegen parallel zur X- und Y-Achse, gedrehte Rechtecke kînnen aber aus 4
relativen Draw-Befehlen zusammengesetzt werden. 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
 37 
#page##--------------------------------- Ende der Seite 37 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Das Kommando 
 
                         #ib(1)#<ESC> J#ie(1)# <b, h;>    (Hex 1B 4A <b, h;>) 
 
zeichnet ein leeres Rechteck (Rahmen) an der aktuellen Cursorposition. <b,
h;> sind dezimale oder binÑre Parameter. <b> ist die Breite des Rechtecks
und kann den ganzen Wertebereich von -32768 bis 32767 Åberstreichen, <h> ist
die Hîhe des Rechtecks und kann ebenfalls diesen Wertebereich Åberstreichen.
Je nach Vorzeichen von <b> und <h> wird das Rechteck links/ rechts und
oben/unten von der aktuelle Cursorposition gezeichnet. 
 
<b> <h>  Cursorposition bildet die Ecke 
 +   +   unten links 
 +   -   oben links 
 -   +   unten rechts 
 -   -   oben rechts 
 
 
#type("8")##center##ib(3)#6.6.2.3  Bîgen und Ellipsen#ie(3)##type("elite")# 
 
Um die Zeichengeschwindigkeit eines Kreises zu vergrî·ern, wurde ein sepa-
rater Befehl fÅr Kreise eingefÅhrt (6.6.2.1). Da der Kreis ein Sonderfall
der Ellipse ist, kann man das in diesem Abschnitt beschriebene Kommando auch
benutzen, um Kreise mit anderen als den unter 6.6.2.1 beschriebenen Segmen-
ten oder Parametern (Dicke, Strichtyp) zu Zeichnen. 
 
Das Kommando 
 
                         #ib(1)#<ESC> s#ie(1)# <xr, yr,> <aw, ew;>    (Hex 1B 73 ...) 
 
zeichnet um die aktuelle Cursorposition (also relativ) einen Ellipsenbogen
mit Radius <xr> in X-Richtung und Radius <yr> in Y-Richtung, ausgehend vom
Anfangswinkel <aw> im Uhrzeigersinn, bis zum Endwinkel <ew>. Der Winkel 0
Grad ist dabei oben (Norden). 
 
Alle Parameter sind dezimale oder binÑre Parameter. <aw> und <ew> haben den
Wertebereich von 0 bis 255, wobei eine ganze Ellipse einem Anfangswinkel von
0 und einem Endwinkel von 72 entspricht. Die Winkelangaben sind in 5 Grad
Schritten und kînnen Anhang A entnommen werden.. <xr> und <yr> dÅrfen den
vollen Wertebereich von -32768 bis 32767 Åberstreichen. 
 
 
#text end#
#clear pos# 
#free(4.256852)#
 
 
#right#38 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 38 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#6.6.2.4  GefÅllte FlÑchen#ie(3)##type("elite")# 
 
Rechteckige oder rautenfîrmige FlÑchen kînnen, wie in Abschnitt 6.5.1.4
beschrieben, schnell gefÅllt werden. FÅr beliebig geformte FlÑchen kann das
Kommando 
 
                         #ib(1)#<ESC> |#ie(1)#<n>    (Hex 1B 7C <n>) 
 
benutzt werden. Dies ist ein relatives Kommando, da um die aktuelle Cursor-
position herum gefÅllt wird. <n> ist ein Byteparameter mit dem Wertebereich
0 bis 15, der die Nummer des Musters fÅr die FÅllung angibt. Der Fill-Befehl
arbeitet auf der aktuellen Arbeitsseite und fÅllt eine sichtbar begrenzte
FlÑche mit einem angegebenen Muster aus. 
 
Ist die BitverknÅpfung OR eingestellt darf der Cursor nicht auf einem wei·en
Punkt stehen und die FlÑche mu· von einer durchgehenden wei·en Linie be-
grenzt sein. 
Ist die BitverknÅpfung AND eingestellt, darf der Cursor nicht auf einem
schwarzen Punkt stehen und die FlÑche mu· von einer durchgehenden schwarzen
Linie begrenzt sein. 
 
Au·er den Parametern BitverknÅpfung und Helligkeit/Farbe werden keine be-
rÅcksichtigt. 
 
Bei sehr komplex geformten Figuren kann der Fall eintreten, da· die FlÑche
nicht ganz gefÅllt ist. Dies liegt daran, da· intern ein zu grî·er Spei-
cherplatz zum Merken von RÅcksprungcursorpositionen benîtigt wird (Stack-
öberlauf). In diesem Fall sollte man den Cursor nocheinmal auf die nicht
gefÅllte FlÑche setzen und das Kommando erneut geben. 
 
<n> kann folgende Werte annehmen (Werte Hexadezimal angegeben 0..F): 
<n>  Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0   FlÑche ganz gefÅllt 
 1   FlÑche halb gefÅllt (grau) 
 2   Jede 4. Zeile wird durchgezogen 
 3   Jede 2. Zeile wird durchgezogen 
 4   Jede 4. Spalte wird durchgezogen 
 5   Jede 2. Spalte wird durchgezogen 
 6   Jede 4. Zeile und jede 4. Spalte wird durchgezogen (grobes Raster) 
 7   Jede 2. zeile und jede 2. Spalte wird durchgezogen (feines Raster) 
 8   Schraffur von links unten nach rechts oben 
 9   Schraffur von links oben nach rechts unten 
 A   SchrÑges Raster (Links- und Rechtsschraffur) 
 B   Feines Funktraster(jeder 2.Punkt in x- und y-Richtung wird gesetzt) 
 C   Mauerwerk 
 D   Feines Netzgeflecht 
 E   Feine Zickzacklinie 
 F   Benutzerdefinierbares Muster. Default: Grobe Zickzacklinie 
 
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
 39 
#page##--------------------------------- Ende der Seite 39 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Ist die AND-BitverknÅpfung eingeschaltet, dann sind die Punkte schwarz und
wei· in den Mustern vertauscht und in der obigen Tabelle sind die Bezeich-
nungen 'gefÅllt' und 'gelîscht' auszutauschen. 
 
 
#type("8")##center##ib(3)#6.6.2.4.1  Definition des Musters#ie(3)##type("elite")# 
 
Das benutzerdefinierbare Muster des Fill-Befehls (Muster 15) kann mit dem
Kommando 
 
                         #ib(1)#<ESC> O :#ie(1)# <b1..b8>   (Hex 1B 4F 3A <b1..b8>) 
 
eingestellt werden. Das Defaultmuster wird dabei Åberschrieben, das neu
eingestellte Muster allerdings nicht beim Setup mitgesichert. 
<b1..b1> sind 8 Byteparameter mit dem gesamten Wertebereich 0 bis 255. Das
erste Byte wird im FÅllmuster in Richtung der niedrigeren y-Positionen dar-
gestellt, das niederwertigste Bit jedes Bytes in Richtung der niedrigeren
x-Positionen. 
 
 
#type("8")##center##ib(3)#6.7  Graphikdaten zum Host#ie(3)##type("elite")# 
 
Bisher wurden nur Kommandos beschrieben, die der Host an das Terminal sen-
den kann. Damit der Host Åber den Status des Terminals informiert werden
kann, sind auch Kommandos vorhanden, die Daten an den Host senden. Der Host
kann auch ganze Graphikseiten anfordern, so da· die auf dem Terminal er-
zeugten Graphiken nach dem Ausschalten nicht verloren sind, sondern vom Host
gespeichert werden kînnen. 
 
 
#type("8")##center##ib(3)#6.7.1  Graphikseiten zum Host#ie(3)##type("elite")# 
 
Graphikseiten kînnen ganz oder teilweise Åbertragen werden. Da ein angefor-
dertes Datenpaket immer ganz Åbertragen wird, sollte der Host, wenn keine
Flu·kontrolle eingeschaltet ist, nur so gro·e Blîcke anfordern, die er puf-
fern kann (z.B. 256 Bytes). Selektives Lesen von Graphikseiten kann auch
verwendet werden, um Teile einer Graphik vom Host (und nicht vom Terminal)
verÑndern zu lassen. Mit dem Kommando <ESC> / ... kann der modifizierte Teil
dann wieder an das Terminal zurÅckgesendet werden. Zum Aufbau der Graphik-
seite findet man in Kapitel 6.4.2 Informationen. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> \#ie(1)# <ll> <lh> <al> <ah>   (Hex 1B 5C ...) 
 
kann eine Seite oder ein Teil einer Seite in an den Host gesendet werden.
<lh>, <ll>, <ah> und <al> sind Byteparameter (8 Bits). <ll> und <lh> bilden
zusammen die binÑre LÑnge, d.h. die Anzahl der Datenbytes, die zum Host
gesendet werden. Die LÑnge kann von 0 bis Hex 2000 (dezimal 8192) reichen.
Die Adresse durch <al> und <ah> gebildet, darf von 0 bis Hex 1FFF reichen.
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
#right#40 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 40 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin#
ZusÑtzlich gilt, da· die Summe von LÑnge und Adresse nicht grî·er als Hex
2000 sein darf, da sich die Endadresse dann ausserhalb der Graphikseite
befindet. In diesem Fehlerfall werden keine Daten gesendet. 
 
 
#type("8")##center##ib(3)#6.7.2  Cursorposition zum Host#ie(3)##type("elite")# 
 
Da die Graphikcursorposition einen anderen Wertebereich Åberstreicht als die
Position des Textcursors, wurde zum Senden der Graphikcursorposition ein
weiteres Kommando eingefÅhrt. Pro Koordinate werden dabei 2 Bytes, zusammen
also 4 Bytes, gesendet. Mit dem Kommando 
 
                         #ib(1)#<ESC> ;#ie(1)#    (Hex 1B 3B) 
 
kann der Host diese 4 Bytes anfordern. Die Reihenfolge der Bytes ist <xlow>
<xhigh> <ylow> <yhigh>. Im Gegensatz zu <ESC> ? (fÅr die Textcursorposi-
tion) wird auch kein abschlie·endes <CR> gesendet. 
 
 
#type("8")##center##ib(3)#6.7.3  Einzelne Bits zum Host#ie(3)##type("elite")# 
 
Au·er ganzen Graphikseiten oder Blîcken daraus, kann der Host auch einzelne
Bytes oder Bits selektieren und empfangen. Dazu stehen zwei Kommandos zur
VerfÅgung. Mit dem Kommando 
 
                         #ib(1)#<ESC> _#ie(1)#    (Hex 1B 5F) 
 
kann das Byte angefordert werden, in dem sich der Graphikcursor gerade be-
findet. Das Bit 7 ist das Farb- oder Helligkeitsbit, das Bit (xpos MOD 7)
ist das Bit, das durch den Graphikcursor addressiert wird. Wenn der Cursor
au·erhalb des sichtbaren Bereichs ist, wird ein Byte Hex 00 geliefert. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> -#ie(1)#    (Hex 1B 2D) 
 
kann das Bit, da· durch die Graphikcursorposition addressiert wird, abge-
fragt werden. Dieses Kommando liefert ein Byte, in dem die Bits folgende
Bedeutung haben: 
 
#on("u")#Bit 0 Dezimal   Bedeutung                            #off("u")# 
  0      0      Das adressierte Bit ist nicht gesetzt 
  1      1      Das adressierte Bit ist gesetzt 
 
#on("u")#Bit 1 Dezimal   Bedeutung                   #off("u")# 
  0      0      Die Farbe ist violett/dunkel 
  1      2      Die Farbe ist gelb/hell 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
 41 
#page##--------------------------------- Ende der Seite 41 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Bit 2 Dezimal   Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
  0      0      Der Graphikcursor ist innerhalb des sichtabren Bereichs 
  1      4      Der Graphikcursor ist au·erhalb des sichtbaren Bereichs. 
                Bit 0 und Bit 1 sind dann 0. 
 
Bit 4 und Bit 5 sind immer 1. Es werden also die ASCII-Ziffern "0" bis "4"
geliefert. 
 
 
#type("8")##center##ib(3)#6.7.4  Parameter zum Host#ie(3)##type("elite")# 
 
Die eingestellten Draw-Parameter kînnen auch abgefragt werden. Dazu exi-
stieren zwei Kommandos. Mit dem Kommando 
 
                         #ib(1)#<ESC> 4#ie(1)#    (Hex 1B 34) 
 
kînnen die Nummer der sichtbaren und der Arbeitsseite, im gleichen Format
wie zum Einstellen der Seiten mit dem Kommando #ib(1)#<ESC> O 7#ie(1)# <n>, angefordert
werden. Es werden ASCII-Zeichen von "0" bis "?" geliefert. Die Bits 0 bis 2
sind folgenderma·en zugeordnet: 
 
#on("u")#Bit 0  Bedeutung                #off("u")# 
  0    Sichtbar ist Seite 0 
  1    Sichtbar ist Seite 1 
 
#on("u")#Bit 1  Bedeutung               #off("u")# 
  0    Arbeitsseite ist Seite 0 
  1    Arbeitsseite ist Seite 1 
 
#on("u")#Bit 2  Bedeutung               #off("u")# 
  0    Nur Graphik eingeschaltet 
  1    In den letzten 32 Graphikzeilen 
       sind 4 Textzeilen eingeblendet 
 
#on("u")#Bit 3  Bedeutung                         #off("u")# 
  0    Der Graphikmodus ist eingeschaltet 
  1    Der Textmodus ist eingeschaltet 
 
Sinnvoll sind die Werte der Bits 0 bis 2 nur dann, wenn Bit 3 = 0 ist. 
 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 5#ie(1)#    (Hex 1B 35) 
 
kînnen die Linienparameter abgefragt werden. Es wird ein Byte mit dem Wer-
tebereich von 1 bis 127 geliefert. Die einzelnen Bits sind folgenderma·en
zugeordnet: 
 
#text end#
#clear pos# 
#free(08.701852e-1)#
 
 
#right#42 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 42 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Bit        Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
Bit 0..3 : Strichdicke 
Bit 4..5 : BitverknÅpfung (0 = OR, 16 = AND, 32 = XOR, 48 = COPY) 
Bit 6    : Aktuelle Farbe (0 = Violett/dunkel, 1 = Gelb/hell) 
 
Die Bitbelegung entspricht der des Parameters des Kommandos #ib(1)#<ESC> O 5#ie(1)# <n>. 
 
 
#type("8")##center##ib(3)#6.8  Graphikhardcopy#ie(3)##type("elite")# 
 
Wie von der Textseite kann auch von den Graphikseiten ein Ausdruck angefer-
tigt werden. Dabei kînnen keine verschiedene Helligkeitsstufen oder Farben
dargestellt werden. 
 
 
#type("8")##center##ib(3)#6.8.1  Der Druckertreiber#ie(3)##type("elite")# 
 
Da das Ein- und Ausschalten des Graphikmodus nicht auf allen Druckern durch
gleiche Kommandos erreicht werden kann, mu· das Terminal an den vorhandenen
Drucker angepa·t werden. DefaultmÑ·ig werden die Epson-Modelle ab RX80 auf-
wÑrts, sowie kompatible (IBM, Panasonic etc.) unterstÅtzt. Die Anpassung
wird in diesem Abschnitt beschrieben. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> ~#ie(1)# <n> <p...>    (Hex 1B 7E <n> <p...>) 
 
kînnen Kommandosequenzen eingestellt werden, die folgende Aufgaben haben: 
 
<n> Default (Hex)   Aufgabe 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0  0D              Einleiten der gesamten Hardcopy (WaagenrÅcklauf) 
 1  1B 2A 04 18 01  Einschalten des Graphikmodus. Es folgen 280 Graphikby-
                    tes (jeweils 8 Bit) 
 2  0D 1B 4A 17     Ausschalten des Graphikmodus. Zeilenvorschub ohne Zwi-
                    schenraum (Zeilenabstand ca. 8 Punkte) und WaagenrÅck-
                    lauf. 
 3     Nichts       Dieses Kommando wird nach der kompletten Hardcopy zum
                    Drucker gesendet. 
 
Wenn doppelte Punktbreite eingeschaltet ist, oder zwei Seiten nebeneinander
gedruckt werden, wird die Kommandosequenz 1 auch mehrmals in einer Zeile
gegeben. 
 
<n> ist dabei ein Byteparameter mit dem Wertebereich von 0 bis 3. <p...> ist
eine Folge von bis zu 16 Bytes. Das erste dieser 16 Bytes ist ein LÑngenby-
te, das die LÑnge der Kommandosequenz (oder die Anzahl der noch folgenden
Bytes) angibt. FÅr die nach dem LÑngenbyte folgenden Bytes sind alle Werte
von 0 bis 255 erlaubt. 
 
#text end#
#clear pos# 
#free(04.468519e-1)#
 
 
 43 
#page##--------------------------------- Ende der Seite 43 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Die Druckertreiberstrings (Kommandosequenzen) werden beim Setup in der Kom-
mandozeile auch mit abgespeichert, so da· sie nur einmal (wenn Åberhaupt)
und dann nie wieder eingestellt werden mÅ·en. 
 
 
#type("8")##center##ib(3)#6.8.2  Die Hardcopyparameter#ie(3)##type("elite")# 
 
Im Gegensatz zur Hardcopy einer Textseite kann das Aussehen einer Graphik
beim Ausdruck noch verÑndert werden. Das Kommando 
 
                         #ib(1)#<ESC> ^#ie(1)# <n>    (Hex 1B 5E <n>) 
 
druckt eine Hardcopy mit dem Parameter <n>. <n> ist ein Byteparameter mit
dem Wertebereich von 0 bis 15. Jedes Bit in <n> legt eine Darstellungsweise
fest. Die Bits haben folgende Bedeutung: 
 
Invertieren: 
Bit 0 Dezimal Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
  0      0    Helle Punkte auf dem Bildschirm werden auf dem Drucker schwarz
              gedruckt, dunkle Punkte bleiben beim Ausdruck wei·. 
  1      1    Die Graphik wird invertiert, d.h. Ein dunkler Bildhintergrund
              bleibt auf dem Drucker dunkel (schwarz). 
 
Doppelte Breite: 
Bit 1 Dezimal Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
  0      0    Jeder Bildschirmpunkt wird in normaler Breite gedruckt. Es
              werden also 280 Punkte nebeneinander gedruckt. 
  1      2    Jeder Bildschirmpunkt wird in doppelter Breite gedruckt. In
              diesem Fall werden auf dem Drucker 560 Punkte nebeneinander
              gedruckt. 
 
Doppelte Hîhe: 
Bit 2 Dezimal Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
  0      0    Jeder Bildschirmpunkt wird in normaler Hîhe gedruckt. Es wer-
              den also 192 Punkte untereinander gedruckt. 
  1      4    Jeder Bildschirmpunkt wird in doppelter Hîhe gedruckt. In
              diesem Fall werden also 384 Punkte untereinander gedruckt. 
 
Zwei Seiten nebeneinander drucken: 
Bit 3 Dezimal Bedeutung 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
  0      0    Es wird nur eine Graphikseite (linksbÅndig) gedruckt. 
  1      8    Die aktuelle (mit #ib(1)#<ESC> O 7#ie(1)# <n> eingestellte) Graphikseite
              wird linksbÅndig und die andere Graphikseite nahtlos rechts
              daneben gedruckt. 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
#right#44 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 44 -----------#
#center##on("b")#6.  Der Graphikmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Zur Kombination von Mîglichkeiten (mehrere Bits sind gesetzt): 
 
- Eine Graphik mit doppelter Hîhe und doppelter Breite hat ungefÑhr das
  Format des Bildschirms. Ein Ausdruck besteht dann aus 560 x 384 = 215040
  Punkten. ZusÑtzliches Invertieren macht die Graphik dem Bildschirmausse-
  hen noch Ñhnlicher. 
 
- Werden zwei Seiten mit doppelter Breite nebeneinander gedruckt, dann re-
  icht die Anzahl der Graphikspalten auf dem Drucker mit dem Defaultgra-
  phikmodus nicht mehr aus. In diesem Fall sollte man die Druckertreiber
  Kommandosequenz 1 temporÑr auf eine hohe (4-fache) Dichte umschalten.
  Solange kein Setup ausgefÅhrt wird, ist diese Dichte nur solange gÅltig,
  bis das Terminal ausgeschaltet wird. 
 
#text end#
#clear pos# 
#free(16.11019)#
 
 
 45 
#page##--------------------------------- Ende der Seite 45 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#7.  Die Parameter der seriellen Schnittstelle#ie(3)##off("u")##off("i")##type("elite")# 
 
 
Die Parameter der seriellen Schnittstelle kînnen vom Host durch Escape-
Sequenzen gÑndert werden. Die énderung der Parameter wird erst durchgefÅhrt,
wenn die ParameterÅbergabe komplett ist (d.h das letzte Byte wurde Åbertra-
gen). Alle öbertragungsparameter wie Stopbits, Datenbits, ParitÑt und Bau-
drate werden zusammen in einem 'Rutsch' eingestellt. Die Art der Flu·kon-
trolle wird mit separaten Escape-Sequenzen eingestellt. 
Die Einstellung in der Kommandozeile ist im Kapitel 3 beschrieben. 
 
 
#type("8")##center##ib(3)#7.1  Das öbertragungsformat#ie(3)##type("elite")# 
 
Das öbertragunsformat eines Datenbytes sieht folgenderma·en aus: 
(Beispiel fÅr 8 Datenbits, 1 ParitÑtsbit und 1 Stopbit) 
 
        +---+---+---+---+---+---+---+---+---+---+---+ 
    ... |"0"| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | P |"1"| ... 
        +---+---+---+---+---+---+---+---+---+---+---+ 
       Start-  ----  D a t e n b i t s ---- Pari- Stop- 
        bit                                 tÑts- bit 
                                            bit 
     --------> Zeit 
 
Bei 7 Datenbits ist das Bit 7 "0". P bezeichnet das ParitÑtsbit. Wenn zwei
Stopbits Åbertragen werden steht an dieser Stelle das 1. Stopbit ("1"). 
 
 
#type("8")##center##ib(3)#7.2  Die öbertragungsparameter#ie(3)##type("elite")# 
 
Alle vier Parameter werden zugleich verÑndert. Das Kommando lautet 
 
                         #ib(1)#<ESC> <SPACE> <SPACE>#ie(1)# <x>    (Hex 1B 20 20 <x>) 
 
<x> ist dabei ein Datenbyte, das wie folgt festgelegt wird: 
 
   Bit     7       6       5       4       3       2       1       0 
       +-------+-------+-------+-------+-------+-------+-------+-------+ 
       |Parity |Parity | Stop- | Daten-|            Baudrate           | 
       | even/ |on/off | bits  | bits  |       |       |       |       | 
       | odd   |       |       |       |       |       |       |       | 
       +-------+-------+-------+-------+-------+-------+-------+-------+ 
 
 
#text end#
#clear pos# 
#free(2.986852)#
 
 
#right#46 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 46 -----------#
#center##on("b")#7.  Die Parameter der seriellen Schnittstelle#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#7.2.1  Baudrate#ie(3)##type("elite")# 
 
Baudrate = Anzahl der pro Sekunde Åbertragenen Bits (öbertragungsgeschwin-
digkeit) . 
 
         Bits 
#on("u")#Dezimal 3 2 1 0    Neue Baudrate#off("u")# 
  0     0 0 0 0    Alte Baudrate (nicht verÑndern) 
  1     0 0 0 1      50 Baud 
  2     0 0 1 0      75 Baud 
  3     0 0 1 1     109.9 Baud 
  4     0 1 0 0     134.58 Baud 
  5     0 1 0 1     150 Baud 
  6     0 1 1 0     300 Baud 
  7     0 1 1 1     600 Baud 
  8     1 0 0 0    1200 Baud 
  9     1 0 0 1    1800 Baud 
 10     1 0 1 0    2400 Baud 
 11     1 0 1 1    3600 Baud 
 12     1 1 0 0    4800 Baud 
 13     1 1 0 1    7200 Baud 
 14     1 1 1 0    9600 Baud 
 15     1 1 1 1   19200 Baud 
 
Der Wert 0 kann gebraucht werden, wenn nur Datenbits, Stopbits und Pari-
tÑtsbit verÑndert werden sollen. 
 
 
#type("8")##center##ib(3)#7.2.2  Datenbits#ie(3)##type("elite")# 
 
Bit 4 legt die Anzahl der gesendeten und empfangenen Datenbits fest. 
 
#on("u")#Dezimal Bit 4              #off("u")# 
   0      0     8 Datenbits 
  16      1     7 Datenbits 
 
Mit einem anschliessenden Kommando 
 
                         #ib(1)#<ESC> <SPACE> 6#ie(1)#    (Hex 1B 20 36) 
 
kann das 8. Datenbit ausmaskiert (d.h auf "0" gesetzt) werden. Dies kann
notwendig sein, wenn der Host nur 7 Bit ASCII verarbeitet und auf ein ge-
setztes 8. Datenbit falsch reagiert (Steuerbit oder Ñhnliches). 
 
Mit 
 
                         #ib(1)#<ESC> <SPACE> 7#ie(1)#    (Hex 1B 20 37) 
 
kann die Maskierung wieder aufgehoben werden. 
Zu beachten ist, da· bei 7 Bit Datentransfer zum Beispiel das Farbbit bei
Download einer Graphikseite nicht Åbertragen wird. 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
 47 
#page##--------------------------------- Ende der Seite 47 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#7.2.3  Stopbits#ie(3)##type("elite")# 
 
Bit 5 legt die Anzahl der Stopbits fest. 
 
#on("u")#Dezimal Bit 5            #off("u")# 
   0      0    1 Stopbit 
  32      1    2 Stopbits 
 
Zu beachten ist, da· bei eingeschaltetem Paritycheck und 8 Datenbits immer
ein Stopbit Åbertragen wird, auch wenn 2 Stopbits programmiert wurden. (Es
kînnen maximal 11 Bits/Daten"byte" Åbertragen werden.) 
 
 
#type("8")##center##ib(3)#7.2.4  ParitÑtsbit#ie(3)##type("elite")# 
 
Bit 6 legt fest, ob ParitÑtskontrolle erfolgen soll und ob ein ParitÑtsbit
vorhanden ist. 
 
Dezimal Bit 6 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
   0      0     Keine ParitÑtskontrolle/Kein ParitÑtsbit 
  64      1     ParitÑtskontrolle eingeschaltet. ParitÑt mit Bit 7 gewÑhlt 
 
Wenn Bit 6 = 1 ist legt Bit 7 fest, ob gerade oder ungerade ParitÑt geprÅft
werden soll. 
 
#on("u")#Dezimal Bit 7                   #off("u")# 
   0      0     Ungerade ParitÑt 
 128      1     Gerade ParitÑt 
 
 
#type("8")##center##ib(3)#7.2.5  öbertragungsfehler#ie(3)##type("elite")# 
 
Wird ein Rahmenfehler (Stopbit fehlt) oder ein ParitÑtsfehler (mindestens
ein Bit verfÑlscht) entdeckt, dann wird statt des empfangenen MÅlls ein Byte
Hex FF vom Terminal interpretiert. Steht dies im Text, kann man es als in-
vertiertes Punktraster erkennen. Dieses Zeichen richtet wenig Schaden an,
wenn es mitten in einer Escape-Sequenz empfangen wird. 
 
 
#type("8")##center##ib(3)#7.3  Die Flu·kontrolle#ie(3)##type("elite")# 
 
Damit keine Daten verloren gehen, wenn der Host oder das Terminal keine
solchen mehr empfangen kann, sollte eine Flu·kontrolle eingeschaltet wer-
den. Das Terminal hat zwar einen Empfangspuffer von 4K Byte (4096 Zeichen),
aber auch dieser kann einmal voll sein. Der Sendepuffer von 2K Byte (2048
Zeichen) wird in Anspruch genommen, wenn der Host dem Terminal per Flu·kon-
trolle mitgeteilt hat, da· er keine Zeichen mehr empfangen kann. Das Termi-
nal wartet dann nicht aktiv auf Freigabe vom Host, sondern kann weiter ar-
beiten (Spooler, Bildschirmausgabe, Localmodus etc.). 
 
#text end#
#clear pos# 
#free(04.468519e-1)#
 
 
#right#48 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 48 -----------#
#center##on("b")#7.  Die Parameter der seriellen Schnittstelle#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Wenn das Terminal den Host "gestoppt" hat, kann man das an einem "B U S Y"
in der Statuszeile erkennen, sonst steht dort "R E A D Y". 
Wenn der Host das Terminal "gestoppt" hat, kann man das an einem "T X O F F"
in der Statuszeile erkennen, sonst steht dort "T X   O N". 
 
Da dieses Terminal einen gro·en Empfangspuffer hat, sollte man allerdings im
Notfall auch ohne Flu·kontrolle auskommen, wenn nicht gerade umfangreiche
Graphikoperationen ausgefÅhrt werden sollen, bei denen der Puffer nicht
schnell genug geleert werden kann. 
 
 
#type("8")##center##ib(3)#7.3.1  XON/XOFF#ie(3)##type("elite")# 
 
XON/XOFF ist eine Softwareflu·kontrolle. Als Stopzeichen wird 
 
                         #ib(1)#XOFF#ie(1)#    (#ib(1)#<CTRL S>#ie(1)# Hex 13) 
 
verwendet. Als Startzeichen wird 
 
                         #ib(1)#XON#ie(1)#    (#ib(1)#<CTRL Q>#ie(1)# Hex 11) 
 
verwendet. Diese Flu·kontrolle sollte nur im Textmodus verwendet werden, da
BinÑrdaten mîglicherweise Hex 11 oder Hex 13 enthalten, die dann nicht als
Protokollzeichen verwendet werden sollen. Der Vorteil dieser Art der Flu·-
kontrolle ist, da· man mit 3 Leitungen (Masse, TXD, RXD) an der seriellen
Schnittstelle auskommt. 
 
Das Terminal reagiert auf empfangene XON/XOFF-Zeichen sofort, d.h diese
Zeichen werden nicht in den Empfangspuffer gestellt. Diese beiden Zeichen
werden auch dann interpretiert, wenn das Terminal im Local-Modus ist. 
 
Die XON/XOFF Flu·kontrolle kann in der 2. Kommandozeile ein- und ausgeschal-
tet werden, sowie mit dem Kommando 
 
                         #ib(1)#<CTRL O>#ie(1)#    (Hex 0F) 
 
eingeschaltet und mit 
 
                         #ib(1)#<CTRL N>#ie(1)#    (Hex 0E) 
 
ausgeschaltet werden. 
 
Zu beachten ist, da· der Sender vor dem Ausschalten noch im "TX OFF"-
Zustand sein kann. Man sollte deshalb direkt vor <CTRL N> noch <CTRL Q> (Hex
11), also XON senden, um den Sender wieder einzuschalten. Dies wird vom
Terminal nicht automatisch gemacht, da sonst ein <CTRL N> das im Datenstrom
vorkommt, auch noch ein Zeichen fÅr Flu·kontrolle wÑre. 
 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
 49 
#page##--------------------------------- Ende der Seite 49 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#7.3.2  DTR/DSR#ie(3)##type("elite")# 
 
DTR/DSR ist eine Hardwareflu·kontrolle bei der die Leitungen Pin 20 (DTR)
und Pin 6 (DSR) (in der Regel Åberkreuzt) angeschlo·en sein mÅssen. 
Bei dieser Art der Flu·kontrolle dÅrfen alle Zeichen Åbertragen werden, ohne
da· eines die Flu·kontrolle steuert. Ausnahme: Wenn zusÑtzlich XON/ XOFF
Flu·kontrolle eingeschaltet ist werden natÅrlich XON/XOFF als Steuerzeichen
interpretiert. 
 
DTR (Data Terminal Ready)/DSR (DataSet Ready) Flu·kontrolle kann in der 2.
Kommandozeile ein- und ausgeschaltet werden. Der Host kann dies mit dem
Kommando 
 
                         #ib(1)#<ESC> <SPACE>#ie(1)# <n>    (Hex 1B 20 <n>) 
 
erreichen. Die Werte von <n> sind 
 
#on("u")#<n>  Hex    Bedeutung                                              #off("u")# 
 2    32    Weder RTS/CTS noch DSR/DTR Flu·kontrolle 
 3    33    RTS/CTS Flu·kontrolle, aber keine DSR/DTR Flu·kontrolle 
 4    34    DSR/DTR Flu·kontrolle, aber keine RTS/CTS Fluskontrolle 
 5    35    DSR/DTR und RTS/CTS Flu·kontrolle 
 
DTR/DSR Flu·kontrolle wird empfohlen, da hier alle Zeichen ohne VerÑnderung
empfangen werden kînnen. RTS/CTS Flu·kontrolle kann, hardwaremÑ·ig bedingt,
beim Einschalten von RTS ein Bit "umkippen". 
 
 
#type("8")##center##ib(3)#7.3.3  RTS/CTS#ie(3)##type("elite")# 
 
RTS/CTS ist eine Hardwareflu·kontrolle bei der die Leitungen Pin 4 (RTS) und
Pin 5 (CTS) (in der Regel Åberkreuzt) angeschlo·en sein mÅssen. 
Bei dieser Art der Flu·kontrolle dÅrfen alle Zeichen Åbertragen werden, ohne
da· eines die Flu·kontrolle steuert. Ausnahme: Wenn zusÑtzlich XON/ XOFF
Flu·kontrolle eingeschaltet ist werden natÅrlich XON/XOFF als Steuerzeichen
interpretiert. 
 
RTS (Ready To Send)/CTS (Clear To Send) Flu·kontrolle kann in der 2. Kom-
mandozeile ein- und ausgeschaltet werden. Der Host kann dies mit dem Kom-
mando <ESC> <SPACE> <n> erreichen. Die Werte von <n> sind im letzten Ab-
schnitt (7.3.2 DTR/DSR) angegeben. 
 
 
#text end#
#clear pos# 
#free(3.833519)#
 
 
#right#50 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 50 -----------#
#center##on("b")#7.  Die Parameter der seriellen Schnittstelle#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#7.4  Echo und Local/Online#ie(3)##type("elite")# 
 
In einigen FÑllen verlangt der Host, da· das vom Terminal empfangene Zei-
chen zurÅckgesendet (geechoed) wird, um eventuelle öbertragungsfehler zu
erkennen. Dieser Modus wird mit dem Kommando 
 
                         #ib(1)#<ESC> D E#ie(1)#    (Hex 1B 44 45) 
 
eingeschaltet. ZusÑtzlich wird hiermit der Localmodus ausgeschaltet (d.h der
Online-Modus eingeschaltet), falls das Kommando am Terminal im Local-Modus
gegeben wurde. 
 
Der Echo-Modus wird mit dem Kommando 
 
                         #ib(1)#<ESC> D O#ie(1)#    (Hex 1B 44 4F) 
 
ausgeschaltet. Das Terminal befindet sich dann im Fullduplex Online-Modus.
Der Local-Modus wird auch hierbei verlassen. 
 
Der Local-Modus kann vom Host mit dem Kommando 
 
                         #ib(1)#<ESC> D L#ie(1)#    (Hex 1B 44 4C) 
 
eingeschaltet werden. Dabei ist zu beachten, da· der Host den Local-Modus
nicht ausschalten kann. Der Local-Modus kann vom Benutzer durch DrÅcken von
#ib(1)#<SHIFT CTRL HOME>#ie(1)# am Keyboard verlassen werden. 
 
Im Local-Modus werden Keyboardeingabe nicht mehr an den Host geschickt,
sondern auf dem Bildschirm angezeigt bzw. durch das Terminal interpretiert.
Funktionstastensequenzen werden auch nicht an den Host geschickt. Escape-
Sequenzen die allerdings Daten senden (z.B Download von Text und Graphik
oder die Abfrage der Cursorposition), werden wie im Online-Modus ausgefÅhrt,
d.h. die Daten werden zum Host geschickt. 
 
#text end#
#clear pos# 
#free(7.643519)#
 
 
 51 
#page##--------------------------------- Ende der Seite 51 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#8.  Spezielle Kommandos im Textmodus#ie(3)##off("u")##off("i")##type("elite")# 
 
 
In diesem Kapitel werden weitere Kommandos, die im Textmodus wirksam sind
und thematisch nicht in die anderen Kapitel passen, beschrieben. 
 
 
#type("8")##center##ib(3)#8.1  Weitere Cursorpositionierungskommandos#ie(3)##type("elite")# 
 
ZusÑtzlich zu den im Graphikmodus und im Textmodus gÅltigen Cursorpositio-
nierungskommandos gibt es noch einige weitere. Die fÅnf Kommandos Zeile
lîschen, Zeile einfÅgen, Zeichen lîschen, Zeichen einfÅgen und RÅckwÑrtsta-
bulator sind schon in Kapitel 5 beschrieben worden. 
 
Hier nur noch einmal die entsprechenden Kommandos: 
 
Funktion            Escape-Sequenz 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
Zeile einfÅgen      #ib(1)#<ESC> E#ie(1)#     oder #ib(1)#<ESC> L#ie(1)# 
Zeile lîschen       #ib(1)#<ESC> R#ie(1)#     oder #ib(1)#<ESC> M#ie(1)# 
Zeichen einfÅgen    #ib(1)#<ESC> Q#ie(1)# 
Zeichen lîschen     #ib(1)#<ESC> W#ie(1)# 
RÅckwÑrtstabulator  #ib(1)#<ESC> I#ie(1)# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> j#ie(1)#    (Hex 1B 6A) 
 
kann ein umgekehrter Zeilenvorschub erreicht werden. Steht der Cursor in
Zeile 2 bis Zeile 24, dann wirkt dieses Kommando wie <UP>. Steht der Cursor
in Zeile 1, dann wird der Bildschirminhalt nach unten gescrollt und die
erste Bildschirmzeile gelîscht. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> =#ie(1)# <y+32> <x+32>    (Hex 1B 3D ...) 
 
kann der Cursor auf eine bestimmte Position auf dem Bildschirm gesetzt wer-
den. <x+32> und <y+32> sind dabei Byteparameter. <x+32> hat den Wertebe-
reich 32 (<SPACE>) bis 110 ("o"), <y+32> hat den Wertebereich 32 (<SPACE>)
bis 55 ("7"). <x+32> ist dabei die gewÅnschte x-Position + 32 (gezÑhlt wird
von 0 bis 79), <y+32> ist die gewÅnschte y-Position + 32 (gezÑhlt wird von 0
bis 23). Die Zuordnungen der ASCII-Zeichen zu den Cursorpositionen kann man
auch im Anhang A unter "Cursor" nachlesen. 
 
Dieser Befehl hat im Graphikmodus die gleiche Wirkung! 
 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
#right#52 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 52 -----------#
#center##on("b")#8.  Spezielle Kommandos im Textmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#8.2  Cursormodus#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> .#ie(1)# <n>    (Hex 1B 2E <n>) 
 
kann die Darstellung des Cursors verÑndert werden. FÅr <n> sind ASCII-Zei-
chen "0", "1" und "2" zugelassen. <n> hat folgende Bedeutung: 
 
#on("u")#<n>   Bedeutung                             #off("u")# 
 0    Cursor blinkt nicht und ist unsichtbar 
 1    Cursor blinkt und ist sichtbar 
 2    Cursor blinkt nicht und ist sichtbar 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> Z#ie(1)#    (Hex 1B 5A) 
 
kann der Zustand des Cursors von sichtbar auf unsichtbar und umgekehrt umge-
schaltet werden. 
 
 
#type("8")##center##ib(3)#8.3  Zeichensatz einstellen#ie(3)##type("elite")# 
 
Da die ZeichensÑtze von Basis und Apple unterschiedlich sind, mu· hier bei
den Parametern unterschieden werden. Das Kommando zur Einstellung des Zei-
chensatzes lautet in beiden FÑllen 
 
                         #ib(1)#<ESC> z#ie(1)# <n>    (Hex 1B 7A <n>) 
 
wobei <n> ein Byteparameter ist. Beim Apple hat <n> folgende Bedeutung: 
 
<n>   Zeichensatz 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 1    Full Ascii: 128 Zeichen, ASCII, normale, inverse und blinkende Zei-
 chen 
 4    Ascii: 128 Zeichen, ASCII, normale und blinkende Zeichen 
 
Beim Basis hat <n> folgende Bedeutung: 
 
<n>   Zeichensatz 
#rpos(16.2)##fillchar(" ")##table# 
#on("u")# #off("u")# 
#table end# 
 0 = Apple II: 64 Zeichen, ASCII, normale, inverse und blinkende Zeichen 
 1 = Full Ascii: 128 Zeichen, ASCII, normale, inverse und blinkende Zeichen 
 2 = Deutsch: 128 Zeichen, deutsch, normale und inverse Zeichen 
 4 = Ascii: 128 Zeichen, ASCII, normale und inverse Zeichen 
 6 = APL: 128 Zeichen, APL, normale und inverse Zeichen 
 
#text end#
#clear pos# 
#free(1.716852)#
 
 
 53 
#page##--------------------------------- Ende der Seite 53 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
     Und mit blinkenden statt inversen Zeichen: 
 8 = Apple II: 64 Zeichen, ASCII, normale, blinkende und inverse Zeichen (!) 
 9 = Full Ascii: 128 Zeichen, ASCII, normale, blinkende und inv. Zeichen (!) 
10 = Deutsch: 128 Zeichen, deutsch, normale und blinkende Zeichen 
12 = Ascii: 128 zeichen, ASCII, normale und blinkende Zeichen 
14 = APL: 128 Zeichen, APL, normale und blinkende Zeichen 
 
Einige ausgewÑhlte ZeichensÑtze kînnen auch in der Kommandozeile eingestellt
werden. 
 
 
#type("8")##center##ib(3)#8.4  Texthardcopy#ie(3)##type("elite")# 
 
Einen Ausdruck des Textbildschirminhaltes auf dem Drucker kann man mit dem
Kommando 
 
                         #ib(1)#<ESC> P#ie(1)#   (Hex 1B 50) 
 
erreichen. Der auf dem Drucker eingestellte Schrifttyp wird nicht verÑn-
dert. Es werden 24 Zeilen gedruckt, die Statuszeile wird nicht gedruckt,
sondern die "darunterliegende" 24. Textzeile. Nach jeder Zeile wird <CR> und
<LF> gedruckt, der Drucker sollte deshalb kein Autolinefeed bei <CR> durch-
fÅhren. 
 
Inverse Bildschirmzeichen (80..FF) werden durch Doppeldruck (dunkler) her-
vorgehoben, Controlcharacter (00..1F und 80..9F) werden unterstrichen dar-
gestellt, das Punktraster (7F und FF) wird als unterstrichenes # darge-
stellt. 
 
 
#type("8")##center##ib(3)#8.5  Zeichen-Attribute#ie(3)##type("elite")# 
 
Die Zeichenattribute werden mit dem Kommando 
 
                         #ib(1)#<ESC> G#ie(1)# <n>    (Hex 1B 47 <n>) 
 
eingestellt. <n> ist ein Byteparameter, der folgende Werte annehmen kann: 
 
#on("u")#<n>   Attribute                                                      #off("u")# 
 0    Sichtbare, normale Zeichen 
 1    Unsichtbare Zeichen, es werden Leerzeichen dargestellt 
 4    Sichtbare, inverse Zeichen 
 5    Unsichtbare Zeichen, es werden inverse Leerzeichen dargestellt. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> (#ie(1)#    (Hex 1B 28) 
 
kann auf normale Darstellung umgeschaltet werden (wirkt Ñhnlich <ESC> G 0,
schaltet aber nicht auf sichtbare Darstellung, falls unsichtbar). 
 
#text end#
#clear pos# 
#free(04.468519e-1)#
 
 
#right#54 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 54 -----------#
#center##on("b")#8.  Spezielle Kommandos im Textmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Mit dem Kommando 
 
                         #ib(1)#<ESC> )#ie(1)#    (Hex 1B 29) 
 
kann auf inverse Darstellung umgeschaltet werden (wirkt Ñhnlich <ESC> G 4,
schaltet aber nicht auf sichtbare Darstellung, falls unsichtbar). 
 
 
#type("8")##center##ib(3)#8.6  Bildhintergrund hell/dunkel#ie(3)##type("elite")# 
 
Die Bildschirmdarstellung kann von heller Schrift auf dunklem Grund (be-
zÅglich eines gelîschten Bildschirms) umgeschaltet werden auf dunkle Schrift
auf hellem Grund. Die Darstellung "schwarz auf wei·" ist auf einigen Monito-
ren augenfreundlicher. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> b#ie(1)#    (Hex 1B 62) 
 
kann die dunkle Schrift auf wei·em Grund eingeschaltet werden. Die Darstel-
lung von inverser und normaler Schrift wird vertauscht. 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> d#ie(1)#    (Hex 1B 64) 
 
kann helle Schrift auf dunklem Grund eingeschaltet werden. 
 
 
#type("8")##center##ib(3)#8.7  Zeichentransfer zum Host#ie(3)##type("elite")# 
 
Der Host kann Teile oder den ganzen Bildschirm vom Terminal lesen. Alle
Zeichen werden als Bytes gesendet, bei denen ein gesetztes Bit 7 Invers-
schrift anzeigt. 
 
 
#type("8")##center##ib(3)#8.7.1  Ein Zeichen senden#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 8#ie(1)#    (Hex 1B 38) 
 
wird nur das Zeichen an der Cursorposition gesendet. Die Cursorposition
Ñndert sich nicht. Der Cursor mu· nicht sichtbar sein. 
 
 
#text end#
#clear pos# 
#free(2.563519)#
 
 
 55 
#page##--------------------------------- Ende der Seite 55 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#8.7.2  Eine Zeile senden#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 6#ie(1)#    (Hex 1B 36) 
 
wird die Zeile, in der der Cursor steht (genauer: die Zeile der Cursorrow,
falls der Cursor unsichtbar ist) an den Host gesendet. Falls der Cursor in
Zeile 24 steht, wird nicht die Stauszeile, sondern die 24. Textzeile gesen-
det. Im Anschlu· an die Zeile werden eventuell ein oder zwei eingestellte
Zeilenbegrenzer gesendet (Lineterminator). Die Programmierung der Begrenzer
ist in Abschnitt 8.7.4 beschrieben. Es werden also 80 bis 82 Zeichen gesen-
det. Die Cursorposition Ñndert sich durch das Kommando nicht. 
 
 
#type("8")##center##ib(3)#8.7.3  Eine Seite senden#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 7#ie(1)#    (Hex 1B 37) 
 
wird die gesamte Bildschirmseite an den Host gesendet. Im Anschlu· an jede
Zeile werden (falls eingestellt) Zeilenbegrenzer gesendet. Im Anschlu· an
die gesamte Seite wird ein (eingestellter) Seitenbegrenzer (Pageterminator)
gesendet. Es werden also je nach Zeilen- und Seitenbegrenzer 1920 bis 1969
Zeichen gesendet. Die Statuszeile wird nicht gesendet, sondern die "darun-
terliegende" 24. Textzeile. Die Programmierung der Zeilen- und Seitenbe-
grenzer ist in Abschnitt 8.7.4 beschrieben. Die Cursorposition Ñndert sich
durch dieses Kommando nicht. 
 
 
#type("8")##center##ib(3)#8.7.4  Terminatorzeichen definieren#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> x 1#ie(1)# <l1> <l2>    (Hex 1B 78 31 <l1><l2>) 
 
kînnen die Zeilenbegrenzer der Sendekommandos festgelegt werden. <l1> und
<l2> sind dabei Byteparameter, die den Wertebereich 0 bis 255 Åberstrei-
chen. Ist ein Parameter Hex 00, dann wird dieses Zeichen nicht gesendet.
Wenn man also das Kommando (Hex) 1B 78 31 00 00 sendet, wird kein Begren-
zerzeichen nach der Zeile gesendet. 
Voreingestellt ist ein Begrenzerzeichen; und zwar US (Hex 1F). 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> x 4#ie(1)# <p>    (Hex 1B 78 34 <p>) 
 
kann der Seitenbegrenzer des Kommandos #ib(1)#<ESC> 7#ie(1)# festgelegt werden. <p> ist
ein Byteparameter, der den Wertebereich von 0 bis 255 Åberstreicht. Ist <p>
Hex 00, dann wird kein Seitenbegrenzer gesendet. 
Voreingestellt ist <p> = <CR> (Hex 0D). 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#56 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 56 -----------#
#center##on("b")#8.  Spezielle Kommandos im Textmodus#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##ib(3)#8.7.5  Cursorposition senden#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> ?#ie(1)#    (Hex 1B 3F) 
 
kann der Host die Position des Textcursors abfragen. Es wird eine Folge von
3 Bytes gesendet: <y+32> <x+32> <CR> 
 
<y+32> ist die y-Position + 32, <x+32> die x-Position + 32. Beide Parameter
kînnen fÅr den Befehl #ib(1)#<ESC> =#ie(1)# <y+32> <x+32> verwendet werden, da Sie den
gleichen Wertebereich Åberstreichen. 
 
 
#type("8")##center##ib(3)#8.8  Textseite auf Diskette speichern/laden#ie(3)##type("elite")# 
 
Genau wie Graphikseiten kann auch die Textseite auf Diskette geschrieben und
zu einem spÑteren Zeitpunkt wieder zurÅckgeladen werden. Bei der Textseite
wird au·erdem noch die aktuelle Cursorposition geladen/geschrieben. Man kann
sich zum Beispiel eine Datei Seitenweise auf dem Bildschirm anzeigen lassen
und diese Seiten auf Diskette abspeichern. SpÑter kann man die Datei Offline
(im Localmodus) Seitenweise ansehen. 
 
Bis zu 8 Textseite lassen sich auf Diskette speichern und wieder abrufen.
Die "FÑcher" fÅr die Textseiten sind unabhÑngig von denen fÅr die Graphik-
seiten. 
Die Seiten werden unabhÑngig von REVVID (Schwarz auf Wei·) immer NORVID
(also Wei· auf Schwarz) abgespeichert. Beim Laden der Seite wird sie je nach
REVVID/NORVID dargestellt. 
 
Das Kommando fÅr diese Operationen lautet 
 
                         #ib(1)#<ESC> S#ie(1)# <n>    (Hex 1B 53 <n>). 
 
<n> ist ein Byteparameter mit dem Wertebereich 0 bis 31, wobei die Bits
folgenderma·en belegt sind: 
Bit 0..2 : "Fachnummer" der Textseite auf der Diskette (0 bis 7) 
Bit 3    : Bei Textseiten immer 0 (Bei Graphikseiten immer 1) 
Bit 4    : 0 hei·t: die Textseite wird von der Diskette gelesen, 
           1 hei·t: die Textseite wird auf die Diskette geschrieben. 
 
Wird die Textseite auf die Diskette geschrieben, dann wird eine eventuell
schon in diesem "Fach" vorhandene Textseite Åberschrieben. 
 
FÅr Insider: Jede Textseite belegt einen halben Track (2k). Die 8 Textseiten
             befindenden auf den Tracks 6 bis 9 in aufsteigender Reihenfol-
             ge. 
 
 
#text end#
#clear pos# 
#free(1.293519)#
 
 
 57 
#page##--------------------------------- Ende der Seite 57 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
#type("8")##center##on("i")##on("u")##ib(3)#9.  Verschiedene Steuerkommandos#ie(3)##off("u")##off("i")##type("elite")# 
 
 
#type("8")##center##ib(3)#9.1  Signalton#ie(3)##type("elite")# 
 
Mit 
                         #ib(1)#<CTRL G>#ie(1)#   (Hex 07) 
 
wird ein kurzer Signalton ausgegeben. Ein Warnton des Terminals ist schÑr-
fer (heller). 
 
 
#type("8")##center##ib(3)#9.2  Keyboardclick#ie(3)##type("elite")# 
 
Der Tastaturclick wird fÅr fast alle Tasten erzeugt. Ausnahmen sind die
<SHIFT> und die <CTRL> Tasten, sowie beim Apple die Apfeltasten. Der Tasta-
turclick kann in der ersten Kommandozeile abgeschaltet werden (CLK OFF) oder
mit dem Kommando 
 
                         #ib(1)#<ESC> <#ie(1)#    (Hex 1B 3C) 
 
vom Host. Mit dem Kommando 
 
                         #ib(1)#<ESC> >#ie(1)#    (Hex 1B 3E) 
 
kann der Keyboardclick wieder eingeschaltet werden. 
 
 
#type("8")##center##ib(3)#9.3  Bildschirmausgabe/Druckerausgabe#ie(3)##type("elite")# 
 
Die Bildschirmausgabe, die ja normalerweise eingeschaltet ist, kann in der
Kommandozeile abgeschaltet werden (SCRNOFF) oder vom Host mit dem Kommando 
 
                         #ib(1)#<ESC> `#ie(1)#    (Hex 1B 60) 
 
abgeschaltet werden. Bis auf das Kommando 
 
                         #ib(1)#<ESC> a#ie(1)#    (Hex 1B 61) 
 
werden keine Escape-Squenzen oder Control-Codes interpretiert. Mit <ESC> a
wird die Bildschirmausgabe wieder zugelassen. 
 
Die Druckerausgabe kann mit dem Kommando 
 
                         #ib(1)#<ESC> @#ie(1)#    (Hex 1B 40) 
 
eingeschaltet werden. Man kann dann Texte parallel auf Drucker und Bild-
schirm ausgeben. In der ersten Kommandozeile kann die Druckerausgabe auch
ein- und ausgeschaltet werden. 
#text end#
#clear pos# 
#free(1.293519)#
 
 
#right#58 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 58 -----------#
#center##on("b")#9.  Verschiedene Steuerkommandos#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Man kann zum Beispiel den Schrifttyp des Druckers im Local-Modus umschal-
ten, wenn man in der Kommandozeile die Druckerausgabe (PRT ON) einschaltet.
Dazu kann man sich auch eine Funktionstaste belegen, die Bildschirmausgabe
abschaltet, Druckerausgabe einschaltet, den Schrifttyp umschaltet, Drucker-
ausgabe wieder ausschaltet und Bildschirmausgabe wieder einschaltet. 
 
Abgeschaltet wird die Druckerausgabe mit dem Kommando 
 
                         #ib(1)#<ESC> A#ie(1)#    (Hex 1B 41) 
 
 
#type("8")##center##ib(3)#9.4  Scroll/Page-Modus#ie(3)##type("elite")# 
 
Steht der Cursor in der letzten Zeile und soll er in die nÑchst tiefere
gebracht werden (<DOWN>, <TAB>, <NEWLINE> etc.), dann gibt es entweder die
Mîglichkeit, da· der Bildschirm nach oben gescrollt wird, d.h. die 1. Zeile
verschwindet und die 24. Zeile wird gelîscht, oder da· der Cursor in der
ersten Bildschirmzeile wieder auftaucht, ohne da· der Bildschirminhalt ver-
Ñndert wird. Die erste Mîglichkeit hei·t SCROLL-Modus, die zweite PAGE-
Modus. Die Umschaltung kann entweder in der ersten Kommandozeile erfolgen
oder mit dem Kommando 
 
                         #ib(1)#<ESC> H#ie(1)#    (Hex 1B 48). 
 
In der Kommandozeile hat man die Informationsmîglichkeit, welcher Modus
gerade aktiv ist. 
 
 
#type("8")##center##ib(3)#9.5  Belegung der Funktionstasten#ie(3)##type("elite")# 
 
Eine nÅtzliche Angelegenheit sind die programmierbaren Funktionstasten. Die
Codes der Funktionstasten sind unter anderem in Anhang A zu finden. Funk-
tionstasten kînnen im Local-Modus aufgerufen werden, zum Beispiel fÅr hÑu-
fig gebrauchte Terminalkommandos oder lÑngere Kommandosequenzen (Graphikmo-
dus). Im Online-Modus kann man z.B. Betriebssystemkommandos auf Funktion-
stasten legen. 
 
Die LÑnge der Zeichen auf allen Funktionstasten darf zusammen nicht 4095
Zeichen Åberschreiten. Ein akustisches Warnsignal ertînt, wenn die Funk-
tionstastentabelle voll ist. Soll die Funktionstastendefinition auch noch
nach dem Abschalten des Terminals erhalten bleiben, dann mu· in der Komman-
dozeile <SHIFT S> gegeben werden, damit der Setup samt Funktionstastende-
finitionen auf die Diskette geschrieben wird. 
 
#text end#
#clear pos# 
#free(3.410185)#
 
 
 59 
#page##--------------------------------- Ende der Seite 59 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Mit dem Kommando 
 
                         #ib(1)#<ESC> e#ie(1)# <d...> <t>    (Hex 1B 65 <d...><t>) 
 
wird eine Taste belegt. <d...> und <t> sind Byteparameter. <d...> ist eine
Folge von Datenbytes, deren Bit 7 = 0 sein mu·. <t> ist der Code der Funk-
tionstaste (Bit 7 = 1), auf die die Sequenz gelegt werden soll. Durch diese
EinschrÑnkung sind keine rekursiven (sich selbst aufrufenden) Tastenkomman-
dos mîglich, man kann allerdings z.B. auch nicht alle binÑren Parameter auf
Tasten legen (Man sollte dezimale Parameter benutzen). Die Cursortasten etc.
kînnen nicht belegt werden. 
Um die Original-Tastencodes wieder zu benutzen, gibt es drei Mîglichkeiten: 
 
- Die Tabelle der Tastendefinitionen wird ganz gelîscht (Abschnitt 9.6). 
- Die Definition auf einzelnen Tasten wird durch <ESC> e <t> gelîscht. <t>
  ist dabei der Code einer zu lîschenden Taste. 
- In der ersten Kommandozeile wird F CODE eingeschaltet oder das Kommando 
 
                         #ib(1)#<ESC> c#ie(1)#    (Hex 1B 63) 
 
  gegeben. Dieses Kommando schaltet um, ob immer Tastencodes (A1..EF) oder,
  bei belegten Tasten, die programmierte Sequenz geliefert werden soll. Im
  Graphikmodus mîchte man eventuell die griechischen Sonderzeichen auf den
  Funktionstasten benutzen (F CODE) und nicht die programmierten Tasten-
  strings (F STRG). 
 
 
#type("8")##center##ib(3)#9.5.1  Local-Escape#ie(3)##type("elite")# 
 
Um Funktionstasten mit Terminalkommandos auch im Online-Modus benutzen zu
kînnen (zum Beispiel ein Bildschirm Hardcopy) wird ein spezielles ESC-Zei-
chen statt <ESC> (Hex 1B) verwendet. 
Das Zeichen 
 
                         #ib(1)#<LOCESC>#ie(1)#    (Hex 9B) 
 
teilt dem Terminal mit, da· die nun folgende Escape-Sequenz nicht an den
Host gesendet wird (was bei <ESC> der Fall wÑre), sondern vom Terminal in-
terpretiert werden mu·. 
Im Local-Modus wirkt ein <LOCESC> wie ein normales <ESC>, d.h. das Kommando
wird sowieso vom Terminal interpretiert. 
 
 
#type("8")##center##ib(3)#9.5.2  Makrokommandos#ie(3)##type("elite")# 
 
Ein Makrokommando hat (mindestens) drei Aufgaben: 
- Der Host kann dem Terminal neue ESC-Sequenzen (mit Parametern) definieren,
  z.B. um andere Terminals zu emulieren. 
- Nicht nur das Terminal kann Funktionstasten aufrufen, sondern auch der
  Host, wenn die Funkionstaste als Makro aufgerufen wird. 
- Der Datentransfer vom Host zum Terminal kann durch Makros als AbkÅrzungen
  hÑufig benutzter Zeichenfolgen beschleunigt werden. 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#60 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 60 -----------#
#center##on("b")#9.  Verschiedene Steuerkommandos#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
Ein Makro wird wie eine Funktionstaste mit dem Kommando 
 
 
                         #ib(1)#<ESC> e#ie(1)# <d...> <t>    (Hex 1B 65 <d...><t>) 
 
definiert. <d...> und <t> sind Byteparameter. <d...> ist eine Folge von
Datenbytes, deren Bit 7 = 0 sein mu·. <t> ist der Code der Funktionstaste
(Bit 7 = 1) oder mit anderen Worten der Makroname. 
Es sind alle Codes fÅr <t> zugelassen, die auch bei der Funktionstastende-
finition zugelassen sind. 
 
Ein Makro kann sowohl vom Terminal (auch im F CODE-Modus) als auch vom Host
mit 
 
                         #ib(1)#<ESC> <Macrocode>#ie(1)#    (Hex 1B <Makrocode>) 
 
aufgerufen werden. Dem Terminal wird die Zeichensequenz des Makros so vorge-
setzt, als kÑme sie von der Tastatur im Local-Modus. Wird das Makro also
bereits im Local-Modus aufgerufen, hat das immer noch den Vorteil, da· man
im F CODE-Modus weiterhin programmierte Funktionstasten benutzen kann. 
Anmerkung: Wird das <ESC> vor dem <Makrocode> weggelassen, dann wird der
           Code <Makrocode> ohne MakroausfÅhrung an das Terminal gesendet
           und i.d.R. als inverses Zeichen dargestellt. 
 
Sollen Byteparameter in die Zeichensequenz des Makros Åbernommen werden, die
zur Zeit der Makrodefinition noch nicht feststehen, dann kann man einen
Platzhalter mit dem Code Hex 81 an der Stelle einsetzen. Der Code Hex 81
kann auf der Tastatur durch <SHIFT DELETE> erzeugt werden. 
Wird bei der MakroausfÅhrung ein solcher Code gefunden, wartet das Terminal
auf ein Byte von Tastatur, wenn das Makro im Local-Modus aufgerufen wurde,
oder vom Host, wenn das Makro vom Host aufgerufen wurde. Es dÅrfen beliebig
viele Codes 81 in der Makrozeichensequenz vorhanden sein. Jeder Code wird
durch ein weiteres Zeichen von Host oder Tastatur ersetzt. 
 
 
#type("8")##center##ib(3)#9.5.3  Startup-Makro#ie(3)##type("elite")# 
 
Ein besonderes Makro hat den Code Hex EF. Dieser Code kann auf der Tastatur
durch <SHIFT BOTTOMRIGHT> (beim Apple <OA RIGHT>) erzeugt werden. 
 
Dieses Makro wird bei einem RESET des Terminals (Hardwarereset oder <ESC> 0)
oder beim Einschalten des Terminals aufgerufen. Der Bildschirm und die Gra-
phikseiten werden vorher gelîscht. 


#text end#
#clear pos# 
#free(2.986852)#
 
 
 61 
#page##--------------------------------- Ende der Seite 61 -----------#
#center##on("b")#Bedienungshandbuch zum ruc - Graphikterminal#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin#
#type("8")##center##ib(3)#9.6  Tabellen und Puffer lîschen#ie(3)##type("elite")# 
 
Das Terminal enthÑlt den Empfangspuffer, den Sendepuffer, den Druckerspoo-
ler und die Tabelle der Tastendefinitionen. Um einen der Puffer oder die
Tabelle zu lîschen, kann das Kommando 
 
                         #ib(1)#<ESC> <DEL>#ie(1)# <n>    (Hex 1B 7F <n>) 
 
verwendet werden. <n> ist ein Byteparameter mit dem Wertebereich 0 bis 15
und hat folgende Bedeutung: 
 
#on("u")#<n>    Gelîschte Tabelle oder Puffer#off("u")# 
 0     Keine 
 1     Tastendefinitionen 
 2     Druckerspooler 
 3     Empfangspuffer 
 4     Sendepuffer 
 
Zu beachten ist, da· zwar der Sendepuffer gelîscht wird, aber eine eventu-
ell gestoppte öbertragung (TX OFF) nicht wider gestartet wird. 
 
 
#type("8")##center##ib(3)#9.7  Zeitverzîgerung#ie(3)##type("elite")# 
 
Mit dem Kommando 
 
                         #ib(1)#<ESC> 9#ie(1)# <n>    (Hex 1B 39 <n>) 
 
kann eine Zeitverzîgerung aufgerufen werden. Man kann zum Beispiel ein Fa-
denkreuz darstellen, die Zeitverzîgerung aufrufen und das Fadenkreuz wieder
lîschen. <n> ist ein Byteparameter mit dem Wertebereich von 0 bis 255. Die
Verzîgerung betrÑgt ca. <n> * 2 ms. 
 
 
#type("8")##center##ib(3)#9.8  Transparentmodi#ie(3)##type("elite")# 
 
Der Monitor- und der Hexadezimalmodus sind zum Test von unbekannten Emp-
fangsdaten oder zum Analysieren der Steuerzeichenausgabe von unbekannten
Programmen gedacht. 
 
 
#type("8")##center##ib(3)#9.8.1  Monitor-Modus#ie(3)##type("elite")# 
 
Im Monitor-Modus werden druckbare Zeichen wie normal dargestellt. Control-
zeichen (Hex 00..1F und 80..9F) werden invertiert dargestellt. Im APL-Zei-
chensatz kann man diese inversen Controlzeichen von den Zeichen mit Code Hex
A0..FF unterscheiden, die auch invers dargestellt werden. 
Der Monitormode kann in der ersten Kommandozeile ein- und ausgeschaltet
werden. Mit dem Kommando 
 
                         #ib(1)#<ESC> U#ie(1)#    (Hex 1B 55) 
 
#text end#
#clear pos# 
#free(02.351852e-2)#
 
 
#right#62 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#page##--------------------------------- Ende der Seite 62 -----------#
#center##on("b")#9.  Verschiedene Steuerkommandos#off("b")# 
 
 
 
#type("elite")##limit(16.2)##linefeed(01.0)# 
#clearpos#
#rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")##rpos(16.2)##fillchar(" ")#
#text begin# 
kann der Monitormode eingeschaltet werden. Alle Zeichen werden ohne Inter-
pretation ausgegeben, Ausnahmen sind 
 
                         #ib(1)#<ESC> u#ie(1)#    (Hex 1B 75) 
 
und 
 
                         #ib(1)#<ESC> X#ie(1)#    (Hex 1B 58) 
 
die den Monitormodus ausschalten. 
 
 
#type("8")##center##ib(3)#9.8.2  Hexadezimal-Modus#ie(3)##type("elite")# 
 
In diesem Modus werden nicht die Zeichen auf dem Bildschirm gedruckt, son-
dern ihr ASCII-Code in hexadezimaler Schreibweise mit zwei nachfolgenden
Blanks. Der Hexmode kann mit dem Kommando 
 
                         #ib(1)#<ESC> u#ie(1)#    (Hex 1B 75) 
 
ein- und ausgeschaltet werden. Alle Zeichen werden ohne Interpretation aus-
gegeben, au·er #ib(1)#<ESC> u#ie(1)# und 
 
                         #ib(1)#<ESC> X#ie(1)#    (Hex 1B 58), 
 
die den Hexmodus wieder ausschalten. Auch der Hexmode kann in der ersten
Kommandozeile ein- und ausgeschaltet werden. 
 
 
#type("8")##center##ib(3)#9.8.3  Einzelne Control-Zeichen anzeigen#ie(3)##type("elite")# 
 
Um nur einzelne Controlzeichen auf dem Bildschirm darzustellen, z.B. fÅr den
unteren Teil des APL-Zeichensatzes (Codes 0 bis 31 oder 128 bis 159), gibt
es das Kommando 
 
                         #ib(1)#<ESC> F#ie(1)# <z>    (Hex 1B 46 <z>). 
 
<z> ist dabei ein Byteparameter mit dem Wertebereich 0 bis 255, vorzugswei-
se 0 bis 31. <z> wir mit invertiertem Bit 7 (normal/invers) in den Bild-
schirmspeicher an der aktuellen Cursorposition geschrieben. 
#text end#
#clear pos# 
#free(5.103519)#
 
 
 63 
#page##--------------------------------- Ende der Seite 63 -----------#
