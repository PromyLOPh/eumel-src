#block##pageblock# 
#pagenr("%",1)##setcount(1)##count per page# 
#headeven# 
gs-Menu-Generator 
#center#____________________________________________________________ 
 
#end# 
#headodd# 
#right#gs-Menu-Generator 
#center#____________________________________________________________ 
 
#end# 
#bottomeven# 
#center#____________________________________________________________ 
5 - % #right#ERGOS 
#end# 
#bottomodd# 
#center#____________________________________________________________ 
ERGOS #right# 5 - % 
#end# 
#ib#5  Dialoge innerhalb des Menus#ie# 
 
 
In Kapitel 4 haben Sie erfahren, wie Sie eine eigene Menukarte entwickeln können;
sicher haben Sie das schon ausprobiert und sich Ihr selbstgestaltetes Menu auf dem
Bildschirm angesehen. Bislang erscheint aber noch der Hinweis 'unbekanntes Kom­
mando', wenn Sie eine Menufunktion aktivieren - denn die Prozeduren, die Sie bei
der Aktivierung der Menufunktion aufrufen, sind ja noch nicht fertiggestellt! 
Bei vielen Menufunktionen ist es notwendig, mit dem Benutzer noch einen Dialog zu
führen: z.B. muß ein Dateiname erfragt, eine Information ausgegeben und bestätigt,
eine Auswahl oder eine Entscheidung getroffen werden. In diesem Kapitel sollen
Ihnen nun die Möglichkeiten vorgestellt werden, die Ihnen zur Verfügung stehen, um
einen solchen Dialog mit dem Benutzer zu führen. Dieser Dialog wird innerhalb des
Menus geführt. Alle Prozeduren, die sich auf diesen Menu-Dialog beziehen, enthalten
deshalb den Wortbestandteil 'menu'. 
 
Hier noch einige Tips! Damit Sie Ihre Menu-Dialoge testen können, empfiehlt
sich folgendes Vorgehen: Sie erstellen zuerst Ihre Menukarte und tragen schon die
Namen für die jeweils aufzurufenden Prozeduren ein - wie wir es in Kapitel 4 ge­
macht haben. Mit 'testinstallation' installieren Sie dann in Ihrer Task die neue Menu­
karte. 
Nun schreiben Sie Ihre Prozeduren, die Sie unter das Menu legen wollen. Ist eine
Prozedur "testreif", so müssen Sie sie zunächst insertieren, denn das Menusystem gs-
DIALOG kann nur auf insertierte Prozeduren zugreifen. Anschließend rufen Sie das
Menu (z.B. 'SCRIPT') aus der Menukarte mit dem Befehl 'handle menu ("SCRIPT")'
(Hier ist der jeweilige Menuname einzusetzen!) auf. Wenn Sie den entsprechenden
Menupunkt aktivieren, müßte Ihr Programm ablaufen. 
Es ist günstig, eine eigene Task zum Testen der Prozeduren anzulegen, damit diese
hin und wieder gelöscht werden kann. 
 
 
#ib#5.1  Eingabe eines Textes/Namens#ie# ('#ib#menuanswer#ie#') 
 
Wenn der Benutzer in unserem Beispiel die Menufunktion 'Neu erstellen' aktiviert
hat, muß der Name der Datei erfragt werden, die neu erstellt werden soll. Dafür steht
die Prozedur 'menuanswer' zur Verfügung. Die in die Menukarte eingetragene Proze­
dur 'neue datei editieren' (Siehe Kapitel 4.1) könnte dann folgendermaßen aussehen: 
 
 
PROC neue datei editieren: 
  TEXT VAR dateiname := menuanswer ("Bitte den gewünschten Dateinamen:", 
                                    "", 5); 
  IF dateiname <> "" AND NOT exists (dateiname) 
     THEN command dialogue (FALSE); #ib#cursor on#ie#; 
          edit (dateiname); 
          #ib#cursor off#ie#; command dialogue (TRUE); 
          regenerate menuscreen      (* sehen Sie dazu Kapitel 5.10 *) 
  FI 
END PROC neue datei editieren; 
 
 
Schauen wir uns zuerst die Prozedur 'menuanswer' an. Die Prozedur hat drei Para­
meter. Mit dem ersten Parameter legen Sie den Text fest, der innerhalb der Box
ausgegeben wird, die auf dem Bildschirm erscheint. Der Text dient ausschließlich der
Information des Anwenders. 
Mit dem zweiten Parameter können Sie dem Benutzer einen Vorschlag für die Einga­
be machen, der zum Editieren ausgegeben wird. Da eine solche Vorgabe aber in die­
ser Situation sinnlos wäre, verzichten wir darauf (""). 
 
Die auf dem Bildschirm erscheinende Box hat folgendes Aussehen: 
 
       +-------------------------------------+ 
       I  Bitte den gewünschten Dateinamen:  I 
       I                                     I 
       I                                     I 
       I  Eingabe:                           I 
       +-------------------------------------+ 
 
 
Die Boxbreite und -höhe wird vom System automatisch anhand des von Ihnen als
ersten Parameter übergebenen Textes festgelegt. Sie haben noch verschiedene Mög­
lichkeiten, diesen Text zu gestalten (mehrere Zeilen, Inversdarstellung etc.) - auf
diese Möglichkeiten gehen wir in Kapitel 5.13 detailliert ein. 
In unserem Beispiel erscheint die Box in der Mitte des Menubildschirms. Diese
Festlegung treffen wir durch die Angabe der Position '5' als dritten Parameter. Sie
können hier zwischen 5 verschiedenen Positionen wählen: 1 - oben links, 2 - oben
rechts, 3 - unten links, 4 - unten rechts, 5 - zentral im Menubildschirm - mehr dazu
in Kapitel 5.12. 
 
Mit dem Erscheinen der obigen Box auf dem Bildschirm ändert sich automatisch
auch die Fußzeile im Menu, über die der Benutzer Informationen zur Bedienung
erhält. Hier erscheint der Hinweis: 'Fertig: <RETURN>  Abbruch: <ESC><h>'.
Um diese Hinweise brauchen Sie sich aber nicht zu kümmern , da sie alle automa­
tisch gesetzt werden. 
Die Prozedur 'menuanswer' hat noch folgende Besonderheit: Es ist nicht möglich,
den Namen 'break' einzugeben! Diese Eingabe wird automatisch abgefangen. Es hat
sich gezeigt, daß Anwender manchmal versuchen, über <ESC><q> die Eingabe
zu verlassen. In diesem Falle entstünde hier eine Datei mit Namen 'break' - was aber
nicht sinnvoll wäre. 
Nach der Eingabe liefert die Prozedur 'menuanswer' als Wert den vom Benutzer
eingegebenen Text - dabei sind führende und folgende Leerzeichen schon abgeschnit­
ten ('compress'). Wurde die Prozedur mit <ESC><h> verlassen, so wird niltext
geliefert. 
 
Wird in obiger Prozedur die Eingabe mit <ESC><h> abgebrochen oder existiert
bereits eine Datei mit dem eingegebenen Namen, so verschwindet die Box, und der
Menubildschirm wird automatisch in den alten Zustand gebracht. 
Wenn schon eine Datei mit dem Namen existiert, dann wäre es sinnvoll, den Benutzer
darauf aufmerksam zu machen. Wie ein solcher Hinweis in das Menu eingeblendet
werden kann, erklären wir im Kapitel 5.2. 
 
gs-DIALOG ist so geschrieben, daß der Cursor möglichst wenig störend wirkt. Aus
diesem Grunde wird der Cursor immer an einer Stelle "geparkt". Sofern Ihr System es
zuläßt und eine entsprechende Anpassung vorliegt, wird der Cursor ganz ausgeschal­
tet. Denken Sie bitte daran, auch wenn er auf Ihrem Bildschirm ständig sichtbar ist! 
Wenn also jetzt eine Eingabe erfolgen soll, ist es notwendig, den Cursor anzuschalten.
Wenn Sie wieder in das Menu zurückkehren, sollte der Cursor wieder ausgeschal­
tet werden, damit er dort nicht stört. 
Wenn Sie die Prozedur 'edit' mit einem neuen Namen als Parameter aufrufen, erfragt
das System, ob die Datei neu eingerichtet werden soll. Diese Anfrage muß hier unter­
drückt werden, damit nicht irgendwelche Texte in den Menubildschirm geschrieben
werden. Das Unterdrücken der Abfrage erreichen Sie durch Ausschalten des Kom­
mandodialoges. Nach Einrichten der Datei muß der Kommandodialog aber wieder
eingeschaltet werden, da gs-DIALOG das Eingeschaltetsein für eine fehlerfreie Funk­
tion voraussetzt! 
 
Mit dem Befehl '#ib#regenerate menuscreen#ie#' (sehen Sie dazu auch Kapitel 5.10) wird der
aktuelle Menubildschirm erneut vollständig auf den Bildschirm geschrieben (repro­
duziert). Das ist notwendig, weil die Prozedur 'edit' den Bildschirm benutzt hat.
Durch diesen Befehl wird der Menubildschirm exakt in der Form hergestellt, wie er
zuletzt ausgesehen hat. Auch wenn Sie geschachtelte Menubildschirme haben, wer­
den diese durch den einen Befehl reproduziert. So können Sie in Ihren Verarbei­
tungsfunktionen mit dem Bildschirm "machen was Sie wollen" - Sie kehren mit dem
letztgenannten Befehl immer wieder so in das Menu zurück, wie Sie es verlassen
haben. 
 
 
#ib#5.2  Ausgabe einer Information#ie# ('#ib#menuinfo#ie#') 
 
In der Prozedur 'neue datei editieren' (Kapitel 5.1) wäre es sinnvoll, den Benutzer zu
informieren, wenn bereits eine Datei mit dem eingegebenen Namen existiert. Hierfür
steht die Prozedur 'menuinfo' zur Verfügung. 
 
Beispiel: 
 
menuinfo (" Eine Datei mit dem Namen "13"     existiert schon!"); 
 
Dadurch wird folgende Box ins Menu geschrieben: 
 
          +----------------------------+ 
          I                            I 
          I  Eine Datei mit dem Namen  I 
          I      existiert schon       I 
          I                            I 
          +----------------------------+ 
 
Die Box erscheint in der Mitte des Menus (Position 5); in der Fußzeile wird der Hin­
weis ausgegeben 'Zum Weitermachen bitte irgendeine Taste tippen!'. Dann wartet das
System so lange, bis eine Taste gedrückt wird. Anschließend wird der aktuelle Menu­
schirm wiederhergestellt. 
Die Prozedur 'menuinfo' gibt es noch in zwei weiteren Versionen, nämlich mit zwei
bzw. drei Parametern. Im ersten Fall kann über den zweiten Parameter noch die
Position (1, 2, 3, 4, 5) innerhalb des Menubildschirmes  festgelegt werden (sehen Sie
dazu Kapitel 5.12). Mit dem dritten Parameter kann ggf. noch die Wartezeit festgelegt
werden, die das System maximal verstreichen läßt, bevor es von sich aus das Pro­
gramm fortsetzt. 
 
'menuinfo (" Eine Datei mit dem Namen "13" existiert schon!", 3, 40)' 
 
gibt die oben gezeigte Box aus, aber links unten in der Ecke des Menubildschirms
(Position 3). Das System wartet (maximal) 4 Sekunden (40 Zehntel) und setzt dann -
auch ohne Tastendruck - das Programm fort. Diese Prozedur mit gesondert angege­
bener Wartezeit verwendet man dann, wenn man nicht unbedingt die Kenntnisnahme
der Information durch den Benutzer bestätigt haben möchte. 
 
 
#ib#5.3  Auswahl eines Namen durch Ankreuzen#ie# ('#ib#menuone#ie#') 
 
Während bei der Neuerstellung einer Datei ein Name neu erfragt werden muß, kann
man beim Menupunkt 'Ansehen/Ändern' auf schon vorhandene Dateien zugreifen.
Sie können dem Benutzer z.B. alle Dateien in der Task zur Auswahl anbieten. Sobald
der Benutzer einen Namen angekreuzt hat, soll die entsprechende Datei geöffnet wer­
den. Dafür steht der Befehl 'menuone' zur Verfügung: 
 
 
PROC alte datei editieren: 
  TEXT CONST kopf      :: "Textdatei ansehen/ändern", 
             hinweis   :: "Bitte gewünschte Datei ankreuzen"; 
  TEXT VAR   dateiname := menuone (ALL myself, kopf, hinweis, FALSE); 
  IF dateiname <> "" 
     THEN #ib#cursor on#ie#; 
          edit (dateiname); 
          #ib#cursor off#ie#; 
  FI; 
  regenerate menuscreen 
END PROC alte datei editieren; 
 
 
Die Prozedur 'menuone' hat 4 Parameter: Als erster Parameter ist ein Thesaurus zu
übergeben, in dem die zur Auswahl stehenden Namen enthalten sind. Zum Thesau­
rushandling werden noch einige zusätzliche Funktionen zur Verfügung gestellt (z.B.
daß nur Dateien eines bestimmten Typs zur Auswahl angeboten werden können) -
diese Funktionen werden in Kapitel 5.14 erläutert. In unserem Beispiel werden alle
Dateien zur Auswahl angeboten, die in der Task zur Verfügung stehen. 
Die beiden Texte, die als 2. und 3. Parameter übergeben werden, erscheinen zur
Kennzeichnung im Kopf der Auswahlliste. Der als zweiter Parameter übergebene Text
erscheint zentriert und invers dargestellt auf dem Bildschirm, der als dritter Parame­
ter übergebene Text nur zentriert. Es ist sinnvoll, mit dem ersten Text (2.Parame­
ter) die zur Zeit aktivierte Menufunktion anzuzeigen, denn der Menubildschirm wird
ja durch die Auswahlliste überschrieben. So kann sich der Benutzer besser im Menu­
system orientieren. 
Mit dem 4. Parameter wird festgelegt, ob der Bildschirm nach der Auswahl "ge­
reinigt", d.h. der alte Menubildschirm wiederhergestellt werden soll. Da in unserem
Falle normalerweise im Anschluß an die Auswahl eine Datei auf dem Bildschirm
editiert wird, verzichten wir auf die "automatische Regenerierung" des Menubild­
schirms. Dieses besorgen wir nach dem Editieren durch das Kommando 'regenerate
menuscreen' "von Hand". 
Auf das Fenster, das für die Auswahl auf dem Bildschirm angezeigt wird, können Sie
keinen Einfluß nehmen - es wird vom System selbständig festgelegt. Dadurch können
Sie die Auswahl, wie auch die anderen Dialogkomponenten ebenso in geschachteleten
Menus aufrufen, ohne daß es zu Problemen kommt. 
 
 
#ib#5.4  Auswahl mehrerer Namen durch Ankreuzen#ie# ('#ib#menusome#ie#') 
 
Es ist nicht immer sinnvoll, daß der Benutzer nur einen Namen auswählen, d.h.
ankreuzen kann. Bei der Zeilenformatierung könnte man z.B. zulassen, daß gleich
mehrere Dateinamen angekreuzt werden können. Im Anschluß an die Auswahl sollen
dann alle angekreuzten Dateien mit 'lineform' bearbeitet werden. Für diesen Zweck
steht die Prozedur 'menusome' zur Verfügung. Sie hat die gleichen Parameter wie die
in 5.3 erläuterte Prozedur 'menuone' - nur daß hier die Auswahl mehrerer Namen
möglich ist. Verläßt der Benutzer die Auswahl durch <ESC><q>, so wird ein
Thesaurus mit allen angekreuzten Namen geliefert; bei Verlassen mit <ESC><h>
ein leerer Thesaurus. Beispiel: 
 
 
PROC zeilen formatieren: 
  TEXT CONST kopf          :: "Textdateien zeilenweise formatieren", 
             hinweis       :: "Bitte gewünschte Dateien ankreuzen"; 
  THESAURUS VAR dateinamen := menusome (ALL myself, kopf, hinweis,
  FALSE); 
  cursor on; 
  formatiere dateien; 
  cursor off; 
  regenerate menuscreen. 
 
  formatiere dateien: 
    INT VAR zaehler; 
    FOR zaehler FROM 1 UPTO highest entry (dateinamen) REP 
      IF name (dateinamen, zaehler) <> "" 
         THEN lineform (name (dateinamen, zaehler)) 
      FI 
    PER 
END PROC zeilen formatieren; 
 
 
 
#ib#5.5  Eingabe eines Textes/Namens - alternativ: Auswahl 
     durch Ankreuzen#ie# ('#ib#menuanswerone#ie#','#ib#menuanswersome#ie#') 
 
Sehr häufig kommt es vor, daß der Benutzer auf die zuletzt bearbeitete Datei zurück­
greifen will. In Kapitel 5.3 haben wir dem Benutzer bei der Menufunktion 'Anse­
hen/Ändern' gleich alle Dateien zur Auswahl angeboten. Hier wäre es vielleicht gün­
stiger gewesen, ihm die zuletzt bearbeitete Datei anzubieten und erst auf Wunsch die
Liste aller Dateien zum Ankreuzen. Das läßt sich auf verschiedene Weise realisieren -
wir werden Ihnen in diesem und in den folgenden Kapiteln verschiedene Möglich­
keiten aufzeigen: 
 
Sie können z.B. mit der Prozedur 'menuanswerone' arbeiten. Wie Sie schon aus dem
Namen entnehmen können, handelt es sich dabei um eine Prozedur, die eigentlich
aus zwei Prozeduren, nämlich 'menuanswer' und 'menuone' zusammengesetzt ist. 
Stellen Sie sich vor, sie führen den Namen der zuletzt bearbeiteten Datei in Ihrem
Programm unter der Variablen 'letzte datei'. Dann könnte die Prozedur 'alte datei
editieren' aus Kapitel 5.3 auch folgendermaßen geschrieben werden: 
 
 
TEXT VAR letzte datei; 
... 
 
 
PROC alte datei editieren: 
  TEXT CONST hinweis letzte :: "Zuletzt bearbeitete Datei:", 
             kopf           :: "Textdatei ansehen/ändern", 
             hinweis        :: "Bitte gewünschte Datei ankreuzen"; 
  TEXT VAR   dateiname      :=  menuanswerone (hinweis letzte, 
                                               letzte datei, 
                                               ALL myself, kopf, 
                                               hinweis, FALSE); 
  IF dateiname <> "" 
     THEN cursor on; 
          edit (dateiname); 
          letzte datei := dateiname; 
          cursor off; 
  FI; 
  regenerate menuscreen 
END PROC alte datei editieren; 
 
 
Insgesamt hat die Prozedur 6 Parameter: Die ersten beiden Parameter beziehen sich
auf die Eingabe ('menuanswer'). Wie dort kann auch hier der Text festgelegt werden,
der in der Box auf dem Bildschirm erscheint. 
Der zweite Parameter ist der Text, der dem Benutzer zum Editieren angeboten wird -
hier der zuletzt benutzte Dateiname. Möchte der Benutzer auf die Datei mit dem an­
gebotenen Namen zugreifen, braucht er nur mit <RETURN> zu bestätigen. 
Möchte er die Auswahl zum Ankreuzen angeboten bekommen, so braucht er nur die
Tastenfolge <ESC><z> (für 'Zeigen') zu tippen. Auf diese Auswahl beziehen sich
die letzten 4 Parameter, die die gleiche Bedeutung haben wie bei der Prozedur
'menuone'. Auf die Möglichkeit, durch <ESC><z> eine Auswahl angeboten zu
bekommen, wird in der Fußzeile des Menus hingewiesen. 
 
Aber Achtung! Sie sollten sich einer "Gefahr" bei diesem Vorgehen bewußt sein. Der
Benutzer hat natürlich so die Möglichkeit, auch einen anderen Namen als den vorge­
schlagenen anzugeben - einen Namen, der noch nicht in der Dateiliste enthalten ist.
In einem solchen Falle würde Ihnen bei obiger Prozedur der Menubildschirm "ka­
puttgeschrieben", denn das System fragt (bei eingeschaltetem Kommandodialog) an,
ob eine Datei mit dem Namen eingerichtet werden soll. Für diesen Fall sollten Sie also
unbedingt eine Vorsorge treffen (z.B. indem Sie den Benutzer darauf hinweisen, daß
der eingegebene Name nicht akzeptiert wird)! 
 
Sie vermuten sicher schon ganz richtig, daß es entsprechend auch die Prozedur
'menuanswersome' gibt, die zunächst einen Dateinamen erfragt und auf Wunsch
eine Auswahl anbietet, in der mehrere Dateinamen angekreuzt werden können. Die
Prozedur hat ebenfalls 6 Parameter, die identisch zur Prozedur 'menuanswerone'
sind. Allerdings liefert die Prozedur 'menuanswersome' in jedem Fall einen Thesau­
rus; wurde die Auswahl mit <ESC><h> abgebrochen, so liefert sie einen leeren
Thesaurus. 
 
 
#ib# 5.6  Die Ja/Nein - Entscheidung#ie# ('#ib#menuyes#ie#','#ib#menuno#ie#') 
 
In Kapitel 5.5 trat das Problem auf, daß der Benutzer einen "unzulässigen" Namen
eingeben konnte. Dieses Problem können wir umgehen: Wir fragen den Benutzer ein­
fach, ob er mit der zuletzt bearbeiteten Datei arbeiten will und lassen Ihm nur die
Chance, mit 'Ja' oder 'Nein' zu antworten. Im ersten Fall bieten wir ihm eben diese
Datei an - ansonsten die Auswahl zum Ankreuzen. 
 
Hierfür stehen die Prozeduren 'menuyes' und 'menuno' zur Verfügung, die von Ihrer
Funktion her den Ihnen bekannten Prozeduren 'yes' und 'no' gleichen. Die beiden
Menu-Prozeduren haben jeweils zwei Parameter: 
 
 
TEXT VAR letzte datei; 
... 
 
PROC alte datei editieren: 
  TEXT CONST kopf    :: "Textdatei ansehen/ändern", 
             hinweis :: "Bitte gewünschte Datei ankreuzen"; 
  TEXT VAR dateiname; 
  IF menuyes (" Wollen Sie mit der Datei "13"" + 
              " '" +letzte datei+ "'"13" arbeiten", 5) 
     THEN editiere letzte datei 
     ELSE dateiname  :=  menuone (ALL myself, kopf, hinweis, FALSE); 
          editiere ausgewaehlte datei 
  FI; 
  regenerate menuscreen. 
 
  editiere letzte datei: 
    cursor on; edit (letzte datei); cursor off. 
 
  editiere ausgewaehlte datei: 
    IF dateiname <> "" 
       THEN cursor on; edit (dateiname); cursor off; 
            letzte datei := dateiname 
    FI 
END PROC alte datei editieren; 
 
 
Über den zweiten Parameter legen Sie die Position auf dem Bildschirm innerhalb des
Menus fest (1, 2, 3, 4, 5; sehen Sie auch Kapitel 5.12). Der erste Parameter ist ein
Text, welcher der gs-DIALOG-Syntax gehorchen muß (die Codes "13" bewirken
einen Zeilenvorschub; sehen Sie auch Kapitel 5.13). Er wird in einer Box auf den
Bildschirm geschrieben und durch 'Ja  Nein' ergänzt: 
 
 
          +-----------------------------+ 
          I                             I 
          I   Wollen Sie mit der Datei  I 
          I   'Dateiname'               I 
          I   arbeiten?                 I 
          I                             I 
          I          Ja    Nein         I 
          I                             I 
          +-----------------------------+ 
 
Für 'Dateiname' ist auf Ihrem Bildschirm dann natürlich der aktuelle Inhalt von
'letzte datei' eingetragen. 
Die Prozedur 'menuyes' liefert TRUE, wenn mit 'Ja' geantwortet wurde und FALSE,
wenn mit 'Nein' geantwortet wurde. Die Prozedur 'menuno' wirkt wie 'NOT menuyes'.
Nach Eingabe von 'Ja', 'Nein' (durch Tippen der Anfangsbuchstaben oder Positionie­
rung auf die Antwort und anschließendem <RETURN>) wird der Menubildschirm
automatisch regeneriert. Auch die entsprechenden Hinweise in der Fußzeile werden
natürlich automatisch gesetzt. 
 
 
#ib#5.7  Die Alternativentscheidung#ie# ('#ib#menualternative#ie#') 
 
Im letzten Kapitel haben wir Ihnen die Prozeduren 'menuyes' und 'menuno' in Ihrer
Wirkungsweise erläutert. Eigentlich sind die beiden Prozeduren nur ein (häufig
benötigter) Spezialfall der Prozedur 'menualternative'. Die Funktionsweise der Proze­
dur 'menualternative' dürfte Ihnen schon aus dem 'Archivmenu' bekannt sein: Wenn
Sie eine neue Zieltask einstellen, werden Ihnen nämlich vier Alternativen zur Auswahl
angeboten (Archiv, Vatertask, PUBLIC, Sonstige Task). 
Auf unsere Textverarbeitung bezogen könnten wir z.B. vor der Zeilenformatierung
(lineform) über die Alternativentscheidung den gewünschten Schrifttyp abfragen. Wir
wollen dem Benutzer in diesem Beispiel fünf Schrifttypen (schmal, elite, pica, letter,
groß) zur Auswahl anbieten: 
 
 
 
TEXT VAR schrifttyp; 
... 
 
PROC schrifttyp waehlen: 
  TEXT CONST info :: "        Auswahl der Schrifttypen: "13""13"" 
                   + "    s ... schmal (17 Zeichen pro Zoll) "13"" 
                   + "    e ... elite  (12 Zeichen pro Zoll) "13"" 
                   + "    p ... pica   (10 Zeichen pro Zoll) "13"" 
                   + "    l ... letter (Proportionalschrift) "13"" 
                   + "    g ... groß   ( 5 Zeichen pro Zoll)   ", 
 
           liste  :: "schmal"13"elite"13"pica"13"letter"13"groß", 
           tasten :: "seplgSEPLG"; 
 
  INT VAR auswahl := menualternative (info, liste, tasten, 5, TRUE); 
  SELECT auswahl OF 
     CASE 1, 101, 106: schrifttyp := "17" 
     CASE 2, 102, 107: schrifttyp := "12" 
     CASE 3, 103, 108: schrifttyp := "10" 
     CASE 4, 104, 109: schrifttyp := "prop" 
     CASE 5, 105, 110: schrifttyp := "5" 
     OTHERWISE (* behalte alten Schrifttyp bei *) 
  END SELECT 
END PROC schrifttyp waehlen; 
 
 
Hätten wir diese Prozedur in unsere Prozedur 'zeilen formatieren' eingebunden, so
zeigte sich bei Aktivierung folgende Einblendung in den Menubildschirm: 
 
 
 
    +---------------------------------------+ 
    I                                       I 
    I       Auswahl der Schrifttypen:       I 
    I                                       I 
    I   s ... schmal (17 Zeichen pro Zoll)  I 
    I   e ... elite  (12 Zeichen pro Zoll)  I 
    I   p ... pica   (10 Zeichen pro Zoll)  I 
    I   l ... letter (Proportionalschrift)  I 
    I   g ... groß   ( 5 Zeichen pro Zoll)  I 
    I                                       I 
    I schmal   elite   pica   letter   groß I 
    I                                       I 
    +---------------------------------------+ 
 
Die Prozedur 'menualternative' besitzt insgesamt 5 Parameter. Wie Ihnen schon von
von anderen Prozeduren bekannt ist, wird mit dem vorletzten (4.) Parameter die
Position innerhalb des Menubildschirms bestimmt - hier also die Plazierung in die
Mitte des Menubildschirms. 
Mit dem 5. Parameter können Sie noch festlegen, ob der Benutzer die Möglichkeit
haben soll, die Alternativauswahl mit <ESC><h> abzubrechen (bei TRUE, wie im
Beispiel) oder eben nicht. 
 
Mit dem 1. Parameter wird der Informationstext festgelegt, der auf dem Bildschirm
innerhalb der Box erscheinen soll. Für die Funktion der Alternativauswahl ist die­
ser Inhalt völlig belanglos - er dient ausschließlich der Information des Benutzers.
Der Text kann - wie hier - z.B. durch eine Einteilung in Zeilen gestaltet werden
(durch den Code "13"). 
Der Text in den Zeilen sollte nicht zu breit sein, da er noch in eine Box innerhalb des
Menubildschirms hineinpassen muß! Damit es auch bei geschachtelten Menus zu
keinen Problemen kommt, sollte eine Zeile nicht breiter als 64 Zeichen sein. Aber
keine Angst: Sie können gs-DIALOG durch zu lange Texte nicht durcheinanderbrin­
gen - wenn Ihr Text zu breit ist, wird er rigoros abgeschnitten und einfach nicht
angezeigt. 
 
Mit dem 2. Parameter übergeben Sie die Auswahlliste, die in der letzten Zeile der Box
dargestellt wird. Hier dürfen insgesamt bis zu 10 Alternativen angegeben werden -
bedenken Sie dabei aber unbedingt, daß diese Liste ebenfalls nicht zu lang werden
darf (ebenfalls höchstens 64 Zeichen). 
Zwischen jeder von Ihnen notierten Alternative muß zur Kennung der Code "13"
eingetragen werden - wie oben im Beispiel gezeigt. Da nachher in der Box zwischen
den einzelnen Alternativen je drei Leerzeichen eingefügt werden, können Sie sich
immer an der von Ihnen übergebenen Zeichenkette orientieren. Hat Ihre Auswahlliste
nicht mehr als 64 Zeichen, dann ist sie in jedem Falle auf dem Bildschirm darstell­
bar. 
Über diese Auswahlliste erfolgt normalerweise die Auswahl. Mit den Cursortasten links
und rechts kann der Benutzer auf die gewünschte Alternative positionieren (auf dem
Bildschirm invers dargestellt) und dann die <RETURN>-Taste tippen. 
Die Prozedur 'menualternative liefert dann einen Zahlenwert, nämlich die Position
der gewählten Alternative in der als 2. Parameter übergebenen Liste (wird in unse­
rem Beispiel die Alternative 'letter' gewählt, so liefert die Prozedur den Wert 4).
Haben Sie den Abbruch durch <ESC><h> zugelassen (5. Parameter), so wird im
Falle eines solchen Abbruchs der Wert '0' geliefert. 
 
Mit dem 3. Parameter können Sie noch festlegen, über welche Tasten eine Auswahl
erfolgen soll. Wenn Sie hier niltext ("") angeben, ist eine Auswahl über die Tasten
nicht möglich. Im Beispiel haben wir hier die Anfangsbuchstaben der im Text ge­
nannten Schrifttypen gewählt und als Eingabe sowohl Klein- als auch Großbuchsta­
ben gestattet. Erfolgt nun die Auswahl über das Tippen einer zugelassenen Taste,
dann wird Ihre Position in der im 3. Parameter übergebenen Zeichenkette ermittelt
und der Wert '100' dazuaddiert. Tippt in unserem Falle der Benutzer die Taste
<L>, wird der Wert '109' geliefert. 
 
Es erfolgt übrigens kein Hinweis in der Fußzeile, ob eine Auswahl über das Tippen
einer Taste möglich ist! Wenn Sie von der Möglichkeit Gebrauch machen, sollten Sie
dieses durch die Gestaltung Ihres Informationstextes andeuten - wie wir es im Bei­
spiel auch getan haben. 
 
 
#ib#5.8  Die Menunotiz#ie# ('#ib#write menunotice#ie#', '#ib#erasemenunotice#ie#') 
 
Innerhalb des Menus können Sie für den Benutzer auch eine Notiz ablegen. Wir
machen z.B. bei der Archivverwaltung Gebrauch davon. Dort wird nämlich ständig
angezeigt, mit welcher Task kommuniziert wird und - sofern es sich um einen Ar­
chivmanager handelt - wie die (angemeldete) Diskette heißt. Wenn Sie z.B. dem
Benutzer das aktuelle Datum im Menu anzeigen wollen, insertieren Sie die folgende
Prozedur: 
 
 
PROC datum anzeigen: 
  write menunotice ("Datum: " + date, 4) 
END PROC datum anzeigen; 
 
 
Die Prozedur 'write menunotice' besitzt zwei Parameter. Mit dem ersten Parameter
wird der Text übergeben, der in der Box ausgegeben werden soll. Er unterliegt eben­
falls der gs-DIALOG-Syntax für Texte. Durch den zweiten Parameter wird wieder die
Position innerhalb des Menus festgelegt (hier rechts unten: Position 4). 
 
Wenn Sie jetzt in Ihrer Menukarte die Prozedur 'oberbegriff  ("Bearbeiten")' in fol­
gender Weise abändern: 
 
 
   oberbegriff ("Bearbeiten", "datum anzeigen", "erase menunotice") 
 
 
dann wird jedesmal, wenn das Pull-Down-Menu unter dem Oberbegriff 'Bearbeiten'
aufgefaltet wird, unten rechts (Position 4) das aktuelle Datum in einer Box ange­
zeigt. Diese Notiz verschwindet, wenn in ein anderes Pull-Down-Menu gewechselt
wird. 
 
Auf den ersten Eindruck scheinen die Prozeduren 'write menunotice' und 'menuinfo'
gleich zu sein - das ist aber nicht der Fall: Bei 'menuinfo' wird der Text in einer Box
ausgegeben und so lange gewartet, bis der Benutzer eine Taste getippt hat (oder die
angegebene Zeit verstrichen ist). Bei 'write menunotice' wird ebenfalls ein Text in
einer Box auf den Menubildschirm geschrieben. Diese Box bleibt aber über längere
Zeit bestehen (auf Erscheinen und Verschwinden kann der Benutzer selbst keinen
Einfluß nehmen!) - und zwar solange, bis die Notiz gelöscht wird (mit 'erase menu­
notice'; in unserem Beispiel, wenn das Pull-Down-Menu gewechselt wird) oder durch
ein neues 'write menunotice' überschrieben wird. In einem Menu kann nämlich zu
einem Zeitpunkt nur eine Menunotiz abgelegt werden. 
Wenn der Bildschirm durch gs-DIALOG-Prozeduren überschrieben wird, wird die
Menunotiz ebenfalls ständig mitaufgefrischt, und auch, wenn Sie den Befehl 'regene­
rate menuscreen' oder 'refresh submenu' geben. 
 
 
#ib#5.9  Fußzeilen im Menu#ie# ('#ib#menufootnote#ie#', '#ib#oldmenufootnote#ie#') 
 
In den Fußzeilen innerhalb des Menus werden dem Benutzer Bedienhinweise ange­
zeigt. Die Fußzeile wird aber auch dazu benutzt, den Benutzer über Prozesse zu
informieren, die im Hintergrund ablaufen - erst recht dann, wenn Sie einige Zeit in
Anspruch nehmen. Sie zeigen dem Benutzer an, daß er nicht "unruhig" zu werden
braucht, sondern das System "mit sich" beschäftigt ist. 
Im allgemeinen braucht sich der Programmierer um diese Fußnoten nicht zu küm­
mern, denn sie werden von den einzelnen Komponenten des Systems automatisch
gesetzt. Wir können aber z.B. dem Benutzer einen Hinweis geben, wenn unter dem
Menupunkt 'Verzeichnis' eine Liste erstellt wird. Die Prozedur könnte dann folgen­
dermaßen notiert werden: 
 
 
PROC verzeichnis ausgeben: 
  menufootnote ("Bitte warten... Ich erstelle eine Dateiliste"); 
  FILE VAR f :: sequential file (output, "Dateiliste"); 
  list (f); modify (f); 
  old menufootnote; 
  entferne eigenen namen; 
  zeige liste an; 
  forget ("Dateiliste", quiet). 
 
  entferne eigenen namen: 
    TEXT VAR zeile :: ""; INT VAR i; 
    FOR i FROM lines (f) DOWNTO 1 REP 
      to line (f, i); 
      read record (f, zeile); 
    UNTIL pos (zeile, "Dateiliste") > 0 PER; 
    delete record (f). 
 
  zeige liste an: 
    to line (f, 1); 
    menuwindowshow (f)         (* Sehen Sie Kapitel 5.11.1*) 
END PROC verzeichnis ausgeben; 
 
 
Beachten Sie, daß der Text nicht länger als 64 Zeichen ist, damit er auch bei ge­
schachtelten Menus vollständig ausgegeben werden kann. Sollte der Text dennoch zu
lang sein, wird er vom System auf die entsprechende Länge gestutzt. 
Haben Sie mit 'menufootnote' eine eigene Fußzeile gesetzt, so können Sie die da­
durch gelöschte Zeile durch den Befehl 'old menufootnote' wieder hinschreiben.
Ansonsten wird Ihre Fußzeile von der nächsten automatisch (d.h. vom System) ge­
setzten Fußnote überschrieben. In dem obigen Beispiel hätten Sie also gut auf den
Befehl 'old menufootnote' verzichten können. 
 
Durch 'old menufootnote' wird die letzte Fußnote, die automatisch vom System ge­
setzt wurde, reproduziert. Der in der obigen Prozedur verwendete Befehl 'menuwin­
dowshow' ist bisher noch nicht erläutert. Sehen Sie dazu bitte das Kapitel 5.11.1. 
 
 
#ib#5.10  Wiederherstellung des Menubildschirms#ie# ('#ib#regenerate
      menuscreen#ie#','#ib#refresh submenu#ie#') 
 
Der Befehl 'regenerate menuscreen' ist Ihnen schon aus diversen Beispielprogram­
men dieses Handbuches bekannt. Ist der Menubildschirm "kaputtgeschrieben" oder
der Bildschirm für andere Zwecke benutzt worden, so läßt sich durch diesen Befehl
der Menubildschirm in seinem letzten Zustand reproduzieren (auch bei geschachtel­
ten Menus!). Durch den Befehl wird der Bildschirm gelöscht und komplett neu
aufgebaut. 
 
Ein vollständiger Bildschirmaufbau ist aber gar nicht immer nötig. Wenn Sie sicher
sind, daß durch Ihre Operationen nur der Bereich zwischen den beiden durchgezo­
genen Linien, die die Kopf- und Fußzeile abtrennen, betroffen ist, brauchen Sie nur
den Befehl 'refresh submenu' zu geben. Hierdurch wird das aktuelle Pull-Down-
Menu neu aufgebaut und - sofern gesetzt - die Menunotiz. Wenn möglich, ist er dem
Befehl 'regenerate menuscreen vorzuziehen, da hierfür weniger Zeit benötigt wird
und weniger "Unruhe" auf dem Bildschirm entsteht. 
Sorgen Sie aber unbedingt dafür, daß der von Ihnen benutzte Bildschirmbereich
zuvor "gereinigt" wird, denn das besorgt 'refresh subnmenu' nicht! 
 
 
#ib#5.11  Arbeiten im Menufenster#ie# 
 
Neben den vorab aufgezeigten Möglichkeiten können Sie innerhalb des Menus auch
noch ein Fenster öffnen. Innerhalb dieses Fensters stehen Ihnen alle Möglichkei­
ten zur Verfügung, die Sie auch sonst zum Beschreiben des gesamten Bildschirms
haben - und noch einiges mehr. 
Wir machen z.B. intensiv beim Archivhandling Gebrauch davon. So werden Ihnen
Verzeichnisse angezeigt, Sie können verfolgen, wie die einzelnen Dateien vom Archiv
geholt werden oder dorthin geschrieben werden und einiges mehr. In diesem Kapitel
wollen wir Ihnen die Möglichkeiten aufzeigen, die Sie innerhalb des Menufensters
haben. 
 
Auf die Größe des Menufensters haben Sie keinen Einfluß, sie wird vom System ge­
setzt ("normales" Menu: 77 Zeichen breit und 20 Zeichen hoch; geschachteltes
Menu: 71 Zeichen breit und 16 Zeichen hoch). Hierdurch ist sichergestellt, daß alle
Operationen auch in geschachtelten Menus ohne Probleme ausführbar sind. Alle
Prozeduren, die sich auf Aktionen im Menufenster beziehen, enthalten die Silbe
'menuwindow'. 
Sie können mit den hier beschriebenen Prozeduren ähnlich arbeiten, wie mit den
entsprechenden Prozeduren ohne den Wortbestandteil 'menuwindow' auf dem
ganzen Bildschirm. Allerdings gibt es einige Unterschiede, auf die Sie achten sollten! 
 
 
5.11.1  Datei anzeigen/editieren 
        ('#ib#menuwindowshow#ie#', '#ib#menuwindowedit#ie#') 
 
Von der Prozedur 'menuwindowshow (FILE VAR f)' haben wir im letzten Kapitel
schon Gebrauch gemacht, um das Verzeichnis der Dateien in der Task innerhalb des
Menus anzuzeigen. Die Prozedur gibt es in zwei Versionen mit je einem Parameter. 
Einmal kann, wie im vorigen Kapitel, ein FILE angegeben werden, andererseits kann
auch der Name der anzuzeigenden Datei als Text übergeben werden ('menuwindow­
show (TEXT CONST dateiliste)'). Durch den Befehl wird innerhalb des Menus ein
umrandetes Fenster geöffnet, in der das angegebene File/die Datei angezeigt wird. Bei
'menuwindowshow' kann die Datei nur eingesehen, nicht aber schreibend verändert
werden. 
Die Prozedur 'menuwindowedit' gibt es ebenfalls in den zwei Ausprägungen. Sie
verhält sich zur vorgenannten identisch - nur kann hier auch die Datei schreibend
verändert werden. 
 
 
5.11.2  Menufenster öffnen/anzeigen ('#ib#show menuwindow#ie#') 
 
Wenn Sie eigene Operationen in einem Fenster im Menu ausführen lassen wollen,
muß dieses Fenster zunächst auf dem Bildschirm angezeigt werden. Durch den
Befehl 'show menuwindow' wird ein entsprechender Rahmen innerhalb des Menus
ausgegeben und der Bereich innerhalb dieses Rahmens (das Fenster) gelöscht. 
Auf die Größe des Fensters innerhalb des aktuellen Menus können Sie - wie bereits
eingangs gesagt - keinen Einfluß nehmen. 
Zu einem Zeitpunkt kann immer nur ein Menufenster geöffnet sein, da das Fenster
schon den größtmöglichen sinnvollen Bereich des aktuellen Menus belegt. Ein er­
neutes 'show menuwindow' hätte die gleiche Wirkung wie das nachfolgend beschrie­
bene 'menuwindowpage' - nur wird hier zusätzlich noch der Rahmen des Fensters
mitausgegeben. 
 
 
5.11.3  Menufenster löschen (putzen) ('#ib#menuwindowpage#ie#') 
 
Durch den Befehl 'menuwindowpage' wird das Fenster innerhalb des aktuellen
Menus gelöscht; der Rahmen des Fensters bleibt bestehen, da er nicht mit zum ei­
gentlichen Fenster gehört. Durch den Befehl wird der Menubildschirm nicht(!)
rekonstruiert! 
 
 
5.11.4  Positionierungen im Menufenster 
        ('#ib#menuwindowline#ie#', '#ib#menuwindowcursor#ie#') 
 
Mit 'menuwindowline' wird, wie auch sonst auf dem Bildschirm, an den Anfang der
nächsten Zeile positioniert. Diesen Befehl gibt es, ebenso wie den Befehl 'line' (der
auf dem Gesamtbildschirm operiert) ohne und mit einem Parameter. Durch 'menu­
windowline (3)' wird an den Anfang der "drittnächsten" Zeile innerhalb des Menu­
fensters positioniert. 
 
Aber Achtung! Der Befehl 'menuwindowline' weist einen deutlichen Unterschied zum
Ihnen bekannten Befehl 'line' auf. Wird nämlich die untere Fenstergrenze überschrit­
ten, so rollt (scrollt) der Bildschirm nicht um die entsprechenden Zeilen nach oben,
wie Sie es von 'line' gewohnt sind - statt dessen wird der Fensterinhalt gelöscht und
wieder oben im Fenster zu schreiben begonnen. Es erscheint, als ob auf ein neues
Fenster positioniert würde. 
Innerhalb des Fensters können Sie auch den Cursor positionieren, wie Sie es vom
Bildschirm gewohnt sind - allerdings nur innerhalb der aktuell gültigen Grenzen. In
einem Menu ist das Fenster 77 Zeichen breit und 20 Zeichen hoch; in einem ge­
schachtelten Menu 71 Zeichen breit und 16 Zeichen hoch. 
Wird außerhalb des aktuellen Menufensters positioniert, wird das Fenster gelöscht
und die Fensterposition (1, 1) angenommen. 
 
 
5.11.5  Informationen über die aktuelle Menu-Fenster position ('#ib#get
menuwindowcursor#ie#', '#ib#remaining menuwindowlines#ie#') 
 
Mit der Prozedur 'get menuwindowcursor (INT VAR spalte, zeile)' kann die aktuelle
Position des Cursors innerhalb des Menufensters erfragt werden. Die Prozedur hat
zwei Parameter, die als 'INT VAR' deklariert sein müssen. Der erste Parameter enthält
anschließend die aktuelle Spalte, der zweite die aktuelle Zeile. 
 
Mit der werteliefernden Prozedur 'remaining menuwindowlines' kann die Anzahl der
noch verbleibenden Zeilen innerhalb des aktuellen Menufensters erfragt werden. Die
Prozedur wurde deshalb zur Verfügung gestellt, weil der Fensterinhalt - im Gegensatz
zum normalen Bildschirm - nicht gescrollt werden kann. So können Sie sich vorab
informieren, ob der Text, der von Ihnen ausgegeben werden soll, noch Platz findet, so
daß während der Ausgabe nicht plötzlich der Fensterinhalt gelöscht wird. 
 
 
5.11.6  Ausgabe/Eingabe innerhalb des Menufensters 
        ('#ib#menuwindowout#ie#', '#ib#menuwindowget#ie#', 
         '#ib#menuwindoweditget#ie#', '#ib#menuwindowyes#ie#', 
         '#ib#menuwindowno#ie#') 
 
Innerhalb des Menufensters können mit der Prozedur 'menuwindowout' Texte ausge­
geben werden - die Prozedur hat einen TEXT-Parameter. Sollen INTEGER- oder REAL-
Werte ausgegeben werden, so müssen diese Werte zuerst in Texte konvertiert werden. 
Bitte beachten Sie unbedingt, daß innerhalb des Fensters nicht gescrollt wird und
auch kein Zeilenumbruch stattfindet! Ist ein Text länger als die verbleibende Restzei­
le, so wird der Text bis zum Fensterende ausgegeben und die Ausgabe am Anfang der
nächsten Zeile fortgesetzt. So ist sichergestellt, daß in keinem Falle die Fenstergren­
zen überschritten werden. 
Sobald die letzte Position des aktuellen Menufensters beschrieben ist (unten rechts in
der Fensterecke), wird der Fensterinhalt komplett gelöscht und die Ausgabe in der
ersten Zeile des "neuen" Fensters fortgesetzt. Auf Zeilenumbruch und Scrolling wurde
verzichtet, da der Realisierungsaufwand dafür zu hoch gewesen wäre. 
 
Mit der Prozedur 'menuwindowget (TEXT VAR text)' können Sie auch Texte innerhalb
des Menufensters einlesen - INTEGER-/ REAL-Werte müssen ggf. von Hand konvertiert
werde. Die Eingabe wird durch <RETURN> abgeschlossen. Es muß mindestens ein
Zeichen (ungleich Leerzeichen) eingegeben werden. Von der Eingabe werden die
führenden Leerzeichen abgeschnitten. 
Ist der einzugebende Text länger als die noch verbleibende Restzeile, so wird der Text
in der Restzeile gescrollt. Sind in der aktuellen Zeile weniger als 7 Zeichen für die
Eingabe vorhanden, so wird automatisch für die Eingabe an den Anfang der nächsten
Zeile positioniert. 
 
Ab gs-DIALOG-Version 1.1 steht auch die Prozedur 'menuwindoweditget (TEXT VAR
text)' zur Verfügung, durch die ein Text zum Editieren vorgegeben werden kann. Es
ist allerdings darauf zu achten, daß der Text in jedem Falle initialisiert wird! 
 
Die beiden Prozeduren 'menuwindowyes' und 'menuwindowno' ähneln den Ihnen
bekannten Prozeduren 'yes' und 'no'. Sie operieren nur auf dem Menufenster. Be­
denken Sie aber bitte, daß, wenn bei der Ausgabe des Textes die Fenstergrenze über­
schritten wird, der Resttext in der nächsten Zeile ausgegeben wird. Wird dabei sogar
die untere Fenstergrenze überschritten, so wird der komplette Fensterinhalt gelöscht
und die Ausgabe in der linken oberen Ecke des "neuen Fensters" fortgesetzt! 
 
 
5.11.7  Weiter Prozeduren  ('#ib#menuwindowcenter#ie#', 
                            '#ib#menuwindowstop#ie#') 
 
Es werden noch zwei weitere Prozeduren für das Menufenster zur Verfügung gestellt,
die bei der Programmentwicklung ganz nützlich sein können. 
Mit 'menuwindowcenter (TEXT CONST text)' werden vor und hinter dem übergebe­
nen Text so viele Leerzeichen angefügt, daß der Text zentriert in der Menufenster-Zei­
le ausgegeben wird. Bevor Sie den Text mit 'menuwindowout' ausgeben, müssen Sie
an den Anfang einer Zeile positionieren, denn die Anzahl der vorangestellten Blanks
wird unter Annahme dieser Zeilenposition ermittelt! Innerhalb der Zeile werden ggf.
vorhandene Texte überschrieben. 
 
Durch die Prozedur 'menuwindowstop' wird an den Anfang der übernächsten Zeile
positionert und der Text 'Zum Weitermachen bitte irgendeine Taste tippen!' ausgege­
ben. Danach wird so lange gewartet, bis eine Taste getippt wird. Mit 'menuwindow­
stop (INT CONST zeilenzahl) kann auch noch die Anzahl der Zeilen bestimmt wer­
den, die vorwärtspositioniert werden soll (Standard: 2 Zeilen). 
 
 
#ib#5.12  Festlegung der Boxpositionen innerhalb des Menus#ie# 
 
In vielen Fällen kann der Programmierer noch entscheiden, an welcher Position
innerhalb des Menus die Box erscheinen soll (z. B. bei 'menuanswer', 'menuinfo',
'menuyes', 'menuno', 'menunotice' etc.). Die Positionen sind von 1 bis 5 durchnu­
meriert und haben folgende Bedeutung: 
 
+----------------------------------------+ 
I                                        I 
+----------------------------------------+ 
I                                        I 
I   +-----+                   +-----+    I 
I   I  1  I                   I  2  I    I 
I   +-----+                   +-----+    I 
I                                        I 
I                +-----+                 I 
I                I  5  I                 I 
I                +-----+                 I 
I                                        I 
I   +-----+                   +-----+    I 
I   I  3  I                   I  4  I    I 
I   +-----+                   +-----+    I 
I                                        I 
+----------------------------------------+ 
I                                        I 
+----------------------------------------+ 
#page# 
#ib#5.13 gs-DIALOG-Syntax (Regeln zur Erstellung von Texten)#ie# 
 
Werden Texte als Parameter übergeben, die in einer Box ausgegeben werden sollen,
so kann dieser Text durch Einfügen von Steuerzeichen noch gestaltet werden, z.B.
kann der Programmierer so den Zeilenaufbau bestimmen. 
Das System analysiert den eingegebenen Text. Jedesmal, wenn innerhalb des Textes
der Code "13" erscheint, wird innerhalb der Box auf den nächsten Zeilenanfang
positioniert. So ist eine Einteilung eines Textes in Zeilen leicht möglich. Soll eine
Leerzeile eingefügt werden, so geben Sie einfach zweimal den Code "13" ("13""13"). 
Bei der Textanalyse wird die jeweilige Zeilenlänge vermerkt. Die Box wird vom System
gerade so breit gewählt, daß die längste vorkommende "Zeile" im Text gerade noch in
die Box paßt. 
Aber Vorsicht! Die jeweilige Box kann innerhalb des Menus nur eine Maximalgröße
annehmen (64 Zeichen breit und 14 Zeilen hoch). Wird von einer "Zeile" diese
Maximalgröße überschritten, so wird die Zeile abgeschnitten und nur bis zur Maxi­
malbreite der Box ausgegeben. 
 
Ein Text für eine solche Box könnte z.B. so aussehen: 
 
 
menuinfo ("  Informationstexte  "13"      sind meist"13"       zu
lang!") 
 
 
das ergibt folgende Ausgabe in der Box: 
 
 
           +-----------------------+ 
           I                       I 
           I   Informationstexte   I 
           I       sind meist      I 
           I        zu lang        I 
           I                       I 
           +-----------------------+ 
 
Es ist auch möglich, in solchen Texten Textpassagen invers darzustellen. Dazu wer­
den in den Text die Codes zum Ein- ("15") und Ausschalten ("14") der Markierung
eingefügt. Solche markierten Textpassagen dürfen aber nicht über interne Zeilen­
grenzen (Code "13") hinausgehen. Sie müßten dann am Zeilenende aus- und am
nächsten Zeilenanfang wiedereingeschaltet werden. 
Soll in der obigen Box das Wort 'Informationstexte' invers dargestellt werden, so wäre
z.B. folgendes Kommando zu geben: 
 
 
menuinfo (" "15"Informationstexte"14" "13"" + 
          "      sind meist"13"       zu lang!") 
 
 
#ib#5.14  Thesaurushandling#ie# 
 
Neben den allgemein zur Verfügung gestellten Thesaurusoperationen stellt
gs-DIALOG einige weitere bereit. Mit der Prozedur 'THESAURUS PROC #ib#infix namen#ie#
(THESAURUS CONST thes, TEXT CONST infix)' werden aus allen Dateinamen des
angegebenen Thesaurus die herausgefiltert, die den Wortbestandteil 'infix' enthalten -
und zwar gleichgültig, an welcher Position! Die herausgefilterten Dateinamen werden
in einem Thesaurus geliefert. Im Programmsystem 'gs-Herbert und Robbi' mach­
en wir z.B. Gebrauch davon, wenn wir nur die Landschaften der eigenen Task zur
Auswahl anbieten wollen: 
 
 
THESAURUS VAR thes :: infix namen (ALL myself, "Flaeche:") 
 
 
Daneben gibt es eine ähnliche Prozedur, mit der man die Dateien eines bestimmten
Dateityps herausfiltern kann. Mit 
 
 
THESAURUS VAR thes :: infix namen (ALL myself, 1003) 
 
 
werden alle Dateien mit dem Typ '1003' (normale Textfiles) herausgefiltert. Neben
den beiden gibt es auch noch eine Prozedur, die beide Fälle miteinander koppelt: 
 
 
THESAURUS VAR thes :: infix namen (ALL myself, "gs-MENUKARTE:", 1954) 
 
 
Mit der folgenden Prozedur: 
 
 
THESAURUS VAR thes :: #ib#ohne praefix#ie# (ALL myself, "Flaeche:") 
 
 
wird aus den Dateinamen im angegebenen Thesaurus jeweils der führende Wortbe­
standteil entfernt. Wir machen z.B. in gs-Herbert und Robbi davon Gebrauch, um
die Landschaften/Arbeitsfelder anbieten zu können, ohne jeweils den Wortbestandteil
'Flaeche:' miterscheinen zu lassen. 
 
Ganz nützlich ist auch noch die folgende Informationsprozedur '#ib#not empty#ie#
(THESAURUS CONST thes)', mit der man z.B. feststellen kann, ob eine Auswahl ohne
Ankreuzen oder mit <ESC><h> abgebrochen wurde: 
 
 
 
PROC zeilen formatieren: 
  TEXT CONST kopf          :: "Textdateien zeilenweise formatieren", 
             hinweis       :: "Bitte gewünschte Dateien ankreuzen"; 
  THESAURUS VAR dateinamen := menusome (ALL myself, kopf, hinweis,
  FALSE); 
 
  IF not empty (dateinamen) 
     THEN cursor on; 
          formatiere dateien; 
          cursor off; 
  FI; 
  regenerate menuscreen. 
 
  formatiere dateien: 
    INT VAR zaehler; 
    FOR zaehler FROM 1 UPTO highest entry (dateinamen) REP 
      IF name (dateinamen, zaehler) <> "" 
         THEN lineform (name (dateinamen, zaehler)) 
      FI 
    PER 
END PROC zeilen formatieren; 
 
 
 
#ib#5.15  Aktivieren und Deaktivieren von Menupunkten#ie# 
 
Daß Verarbeitungsfunktionen aktiviert und deaktiviert werden können, haben Sie
schon in unserem Archiv-Pull-Down-Menu gesehen. Deaktivierte Menupunkte sind
durch ein vorgestelltes '-'-Zeichen gekennzeichnet; diese Menufunktionen werden
übersprungen, wenn Sie versuchen, darauf zu positionieren. 
 
Zur Aktivierung und Deaktivierung von Menupunkten stehen die Prozeduren '#ib#activate#ie#
(TEXT CONST menupunktname)' und '#ib#deactivate#ie# (TEXT CONST menupunktname)'
zur Verfügung. Zu beachten ist, daß diese Prozeduren nicht ständig aufrufbar sind -
der jeweils angegebene 'menupunktname' muß sich nämlich auf das aktuelle Pull-
Down-Menu beziehen! Als Menupunktname muß jeweils der Name angegeben wer­
den, der bei der entsprechenden Menufunktion als 2. Parameter übergeben wurde.
Ist der angegebene 'menupunktname' im aktuellen Pull-Down-Menu nicht enthalten,
so wird die Anweisung ignoriert! 
 
Auch bei den Prozeduren' activate (INT CONST punktnummer)' und 'deactivate (INT
CONST punktnummer)' gilt diese Einschränkung. Die beiden Prozeduren arbeiten
schneller als die eben aufgezeigten, denn es muß im aktuellen Pull-Down-menu
nicht mehr nach der jeweiligen Position gesucht werden. Die Positionen werden von
oben nach unten durchgezählt. Beachten Sie aber unbedingt, daß die Trennlinien
mitgezählt werden müssen! 
Die Prozeduren "zeigen nur dann Wirkung", wenn sie von einer Verarbeitungsfunk­
tion des aktuell entfalteten Pull-Down-Menus aus aufgerufen werden (das geschieht
im Archivmenu z.B. aus den beiden Menufunktionen 'Reservieren' und 'Initialisieren'
heraus) oder wenn Sie beim Einstieg in ein Pull-Down-Menu bzw. beim Ausstieg
daraus aufgerufen werden; d.h. aus einer Prozedur heraus, die bei 'oberbegriff' als
2./3. Parameter in das Menukarten-Generierungsprogramm eingetragen ist. Beim
Archiv-Pull-Down-Menu besorgt das die Prozedur 'menu archiv grundeinstellung'
(sehen Sie dazu auch Kapitel 6.1). 
 

