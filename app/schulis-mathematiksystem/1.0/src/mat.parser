PACKETparserDEFINESneuefunktion,funktionsaufruf,funktionsstring,formel,gibnamen,loescheunreferenzierteabbildung,referenziertefunktion,funktionsnamenthesaurus,standardfunktionsthesaurus:LETniltext="",blank=" ",ifsymbol="<",fuersymbol=":",elifsymbol=";",endifsymbol=">",undsymbol="UND",odersymbol="ODER",zuweisungssymbol="->",kleinersymbol="<",kleinergleichsymbol="<=",groessersymbol=">",groessergleichsymbol=">=",gleichsymbol="=",ungleichsymbol="<>",plussymbol="+",minussymbol="-",divisionssymbol="/",multiplikationssymbol="*",speziellespotenzsymbol="^",allgemeinespotenzsymbol="**",strichsymbol="'",klammeraufsymbol="(",klammerzusymbol=")",doppelpunktsymbol=":",dezimalpunktsymbol=".",esymbol="e",pisymbol="pi",betragssymbol="abs",signumsymbol="sign",gaussklammersymbol="gauss",rundsymbol="rund",intsymbol="ganz",fracsymbol="frak",funktionsklammeraufsymbol="[",funktionsklammerzusymbol="]",punktsymbol=".",kommasymbol=",",verkettungssymbol="O",differenziersymbol="D",selektionssymbol="S",bruchsymbol="/",unsichtbareklammerauf=" (: ",unsichtbareklammerzu=" :) ",selektionsklammeraufsymbol=" {{ ",selektionsklammerzusymbol=" }} ",selektionsfuersymbol=" :: ",selektionselifsymbol=" ;; ",funktionsauswertungssymbol=" A ",diffklammeraufsymbol=" D: ",diffklammerzusymbol=" :D ",bezeichnertyp=1,konstantentyp=3,begrenzertyp=6,defaultfuerkomponentenindex=1,defaultfuervariablenindex=1,defaultstdfktvarname="x";TEXT VARsymbol,symbolspeicher,aktuellerabbildungsname;INT VARsymboltyp,speichertyp;LISTE VARlistedervariablen,listederterme;TERM VARknoten;BOOL VAReliferwartet:=FALSE;ABBILDUNG PROCneuefunktion(TEXT CONSTfunktionsstring):enablestop;TEXT VARfehlzeichen:=niltext;IFfunktionsstring=niltextTHENerrorstop(anwendungstext(58))ELIFfehlerhaftebuchstabenvorhanden(funktionsstring,fehlzeichen)THENerrorstop(anwendungstext(170)+fehlzeichen)END IF;listedervariablen:=neueliste(nil,nil);listederterme:=neueliste(nil,nil);aktuellerabbildungsname:=niltext;knoten:=nil;IFebene=1THENparseeinfachefunktion(funktionsstring)ELSEsymbolspeicher:=niltext;speichertyp:=0;parsekomplexefunktion(funktionsstring)END IF END PROCneuefunktion;ABBILDUNG PROCparseeinfachefunktion(TEXT CONSTfunktionsstring):initialisieredenscanvorgang;verarbeitenderlinkenhaelfte;verarbeitezuweisungssymbol;verarbeitendesfunktionsterms;eintragenderfunktion;abbildung(aktuellerabbildungsname).initialisieredenscanvorgang:scan(funktionsstring);nextsymbol(symbol,symboltyp).verarbeitenderlinkenhaelfte:testegueltigkeit;IFlistenposition(eigenefunktionen,symbol)<>nilTHENerrorstop(hinweisaufungueltigennamen)END IF;aktuellerabbildungsname:=symbol;nextsymbol(symbol,symboltyp);IFsymbol<>doppelpunktsymbolTHENerrorstop(anwendungstext(15))END IF;nextsymbol(symbol,symboltyp);testegueltigkeit;anhaengen(listedervariablen,newvariable(1,symbol));nextsymbol(symbol,symboltyp).verarbeitezuweisungssymbol:IFsymbol<>minussymbolTHENerrorstop(anwendungstext(32))END IF;nextsymbol(symbol,symboltyp);IFsymbol<>groessersymbolTHENerrorstop(anwendungstext(32))END IF.verarbeitendesfunktionsterms:nextsymbol(symbol,symboltyp);IFsymboltyp>6THENerrorstop(anwendungstext(33))ELIFsymbol=ifsymbolTHENeliferwartet:=FALSE;nextsymbol(symbol,symboltyp);abschnittweisedefinierteeinfachefunktion(listederterme)ELSEeinfacherausdruck(listederterme)END IF;IFsymboltyp<7THENerrorstop(hinweisauffehlerhaftessymbol)END IF END PROCparseeinfachefunktion;PROCabschnittweisedefinierteeinfachefunktion(LISTE VARtermliste):knoten:=naechsteeinfacheklausel;IFknoten=nilTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;anhaengen(termliste,newterm(knoten));IFsymbol<>endifsymbolTHENerrorstop(anwendungstext(39))END IF;nextsymbol(symbol,symboltyp)END PROCabschnittweisedefinierteeinfachefunktion;TERM PROCnaechsteeinfacheklausel:TERM VARthenzeiger,bedingungszeiger;IFsymbol=endifsymbolTHENnilELSE IFeliferwartetTHEN IFsymbol<>elifsymbolTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;nextsymbol(symbol,symboltyp);ELSEeliferwartet:=TRUE END IF;einfacherarithmetischerausdruck;thenzeiger:=knoten;
IFsymbol<>fuersymbolTHENerrorstop(anwendungstext(38))END IF;nextsymbol(symbol,symboltyp);einfachebedingung;bedingungszeiger:=knoten;newselektion(bedingungszeiger,thenzeiger,naechsteeinfacheklausel)END IF END PROCnaechsteeinfacheklausel;PROCeinfachebedingung:TEXT VARoperator;TERM VARlinkszeiger;einfacheslogischeselement;WHILEsymbol=undsymbolCORsymbol=odersymbolREPlinkszeiger:=knoten;operator:=symbol;nextsymbol(symbol,symboltyp);einfacheslogischeselement;knoten:=newlogischedyade(linkszeiger,knoten,operator)END REP END PROCeinfachebedingung;PROCeinfacheslogischeselement:TEXT VARoperator;TERM VARlinkszeiger;IFsymbol=klammeraufsymbolTHENverarbeitegeklammertenausdruckELSEverarbeitevergleichEND IF.verarbeitegeklammertenausdruck:nextsymbol(symbol,symboltyp);einfachebedingung;IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))END IF;nextsymbol(symbol,symboltyp).verarbeitevergleich:einfacherarithmetischerausdruck;IF(symbol<>kleinersymbol)CAND(symbol<>kleinergleichsymbol)CAND(symbol<>groessersymbol)CAND(symbol<>groessergleichsymbol)CAND(symbol<>ungleichsymbol)CAND(symbol<>gleichsymbol)THENerrorstop(anwendungstext(40))END IF;operator:=symbol;linkszeiger:=knoten;nextsymbol(symbol,symboltyp);einfacherarithmetischerausdruck;knoten:=newvergleich(linkszeiger,knoten,operator)END PROCeinfacheslogischeselement;PROCeinfacherausdruck(LISTE VARtermliste):einfacherarithmetischerausdruck;anhaengen(termliste,newterm(knoten))END PROCeinfacherausdruck;PROCeinfacherarithmetischerausdruck:TEXT VARoperator;TERM VARlinkszeiger;IFsymbol=plussymbolCORsymbol=minussymbolTHENoperator:=symbol;nextsymbol(symbol,symboltyp);einfacherterm;knoten:=newmonade(knoten,operator)ELSEeinfachertermEND IF;WHILEsymbol=plussymbolCORsymbol=minussymbolREPlinkszeiger:=knoten;operator:=symbol;nextsymbol(symbol,symboltyp);einfacherterm;knoten:=newdyade(linkszeiger,knoten,operator)END REP END PROCeinfacherarithmetischerausdruck;PROCeinfacherterm:TEXT VARoperator;TERM VARlinkszeiger;einfacherfaktor;WHILEsymbol=multiplikationssymbolCORsymbol=divisionssymbolREPlinkszeiger:=knoten;operator:=symbol;nextsymbol(symbol,symboltyp);einfacherfaktor;knoten:=newdyade(linkszeiger,knoten,operator)END REP END PROCeinfacherterm;PROCeinfacherfaktor:TERM VARbasiszeiger;TEXT VARpotenzsymbol;einfacheselement;WHILEsymbol=allgemeinespotenzsymbolCORsymbol=speziellespotenzsymbolREPbasiszeiger:=knoten;nextsymbol(symbol,symboltyp);einfacheselement;IFganzzahligerexponentTHENpotenzsymbol:=speziellespotenzsymbolELSEpotenzsymbol:=allgemeinespotenzsymbolEND IF;knoten:=newdyade(basiszeiger,knoten,potenzsymbol)END REP END PROCeinfacherfaktor;PROCeinfacheselement:TERM VARobjektzeiger;LISTE VARlistederargumente;IFsymboltyp=konstantentypCORsymbol=esymbolCORsymbol=pisymbolTHENverarbeitekonstanteELIFsymbol=klammeraufsymbolTHENverarbeitegeklammertenausdruckELIFsymboltyp=bezeichnertypTHENverarbeitebezeichnerELSEerrorstop(hinweisauffehlerhaftessymbol)END IF.verarbeitekonstante:knoten:=newkonstante(wert,symbol);nextsymbol(symbol,symboltyp).verarbeitegeklammertenausdruck:nextsymbol(symbol,symboltyp);einfacherarithmetischerausdruck;IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))END IF;nextsymbol(symbol,symboltyp).verarbeitebezeichner:IFsymbol=aktuellerabbildungsnameTHENerrorstop(hinweisaufungueltigennamen)ELIFelementarefunktionTHENverarbeiteabbildungsausdruckELSEverarbeitevariableEND IF.elementarefunktion:objektzeiger:=listenposition(standardfunktionen,symbol);objektzeiger<>nil.verarbeiteabbildungsausdruck:TEXT VARfunktionsname:=symbol;nextsymbol(symbol,symboltyp);IFsymbol=strichsymbolCAND(funktionsname=betragssymbolCORfunktionsname=signumsymbolCORfunktionsname=gaussklammersymbolCORfunktionsname=rundsymbolCORfunktionsname=intsymbolCORfunktionsname=fracsymbol)THENerrorstop(anwendungstext(56))END IF;WHILEsymbol=strichsymbolREPobjektzeiger:=newableitungsoperation(objektzeiger,defaultfuervariablenindex,defaultfuerkomponentenindex,strichsymbol);nextsymbol(symbol,symboltyp)END REP;knoten:=newfunktionsauswertung(
objektzeiger,argumentzeiger,defaultfuerkomponentenindex).argumentzeiger:IFsymbol<>klammeraufsymbolTHENerrorstop(anwendungstext(37))END IF;nextsymbol(symbol,symboltyp);listederargumente:=neueliste(nil,nil);einfacherausdruck(listederargumente);IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))END IF;nextsymbol(symbol,symboltyp);newtermliste(listenanfang(listederargumente),listenende(listederargumente),1).verarbeitevariable:knoten:=listenposition(listedervariablen,symbol);IFknoten=nilTHENknoten:=alphasort(listedervariablen,symbol)END IF;nextsymbol(symbol,symboltyp)END PROCeinfacheselement;ABBILDUNG PROCparsekomplexefunktion(TEXT CONSTfunktionsstring):initialisieredenscanvorgang;linkehaelfte;verarbeitezuweisungssymbol;verarbeitenderfunktionsterme;eintragenderfunktion;abbildung(aktuellerabbildungsname).initialisieredenscanvorgang:scan(funktionsstring);nimmsymbol.linkehaelfte:testegueltigkeit;IFlistenposition(eigenefunktionen,symbol)<>nilTHENerrorstop(hinweisaufungueltigennamen)END IF;aktuellerabbildungsname:=symbol;nimmsymbol;IFsymbol<>doppelpunktsymbolTHENerrorstop(anwendungstext(15))END IF;nimmsymbol;variablenliste.verarbeitezuweisungssymbol:IFsymbol<>minussymbolTHENerrorstop(anwendungstext(32))END IF;nimmsymbol;IFsymbol<>groessersymbolTHENerrorstop(anwendungstext(32))END IF.verarbeitenderfunktionsterme:komplexeausdruecke(listederterme);IFsymboltyp<>7THENerrorstop(hinweisauffehlerhaftessymbol)END IF END PROCparsekomplexefunktion;PROCvariablenliste:testegueltigkeit;WHILEsymboltyp=bezeichnertypREPanhaengen(listedervariablen,newvariable(laenge(listedervariablen)+1,symbol));nimmsymbol;IFsymbol=kommasymbolTHENnimmsymbol;testegueltigkeitEND IF END REP END PROCvariablenliste;PROCkomplexeausdruecke(LISTE VARtermliste):REPnimmsymbol;IFsymbol=ifsymbolTHENeliferwartet:=FALSE;nimmsymbol;abschnittweisedefinierterkomplexertermELSEkomplexerarithmetischerausdruckEND IF;anhaengen(termliste,newterm(knoten))UNTILsymbol<>kommasymbolEND REP END PROCkomplexeausdruecke;PROCabschnittweisedefinierterkomplexerterm:knoten:=naechstekomplexeklausel;IFknoten=nilTHENerrorstop(hinweisauffehlerhaftessymbol)ELIFsymbol<>endifsymbolTHENerrorstop(anwendungstext(39))END IF;nimmsymbolEND PROCabschnittweisedefinierterkomplexerterm;TERM PROCnaechstekomplexeklausel:TERM VARbedingungszeiger,thenzeiger;IFsymbol=endifsymbolTHENnilELSE IFeliferwartetTHEN IFsymbol<>elifsymbolTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;nimmsymbolELSEeliferwartet:=TRUE END IF;komplexerarithmetischerausdruck;thenzeiger:=knoten;IFsymbol<>fuersymbolTHENerrorstop(anwendungstext(38))END IF;nimmsymbol;komplexebedingung;bedingungszeiger:=knoten;newselektion(bedingungszeiger,thenzeiger,naechstekomplexeklausel)END IF END PROCnaechstekomplexeklausel;PROCkomplexebedingung:TEXT VARoperator;TERM VARlinks;komplexeslogischeselement;WHILEsymbol=undsymbolCORsymbol=odersymbolREPlinks:=knoten;operator:=symbol;nimmsymbol;komplexeslogischeselement;knoten:=newlogischedyade(links,knoten,operator)END REP END PROCkomplexebedingung;PROCkomplexeslogischeselement:IFsymbol=klammeraufsymbolTHENverarbeitegeklammertenausdruckELSEverarbeitevergleichEND IF.verarbeitegeklammertenausdruck:nimmsymbol;komplexebedingung;IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))END IF;nimmsymbol.verarbeitevergleich:TERM VARlinks;TEXT VARoperator;komplexerarithmetischerausdruck;IFsymbol<>kleinersymbolCANDsymbol<>kleinergleichsymbolCANDsymbol<>groessersymbolCANDsymbol<>groessergleichsymbolCANDsymbol<>ungleichsymbolCANDsymbol<>gleichsymbolTHENerrorstop(anwendungstext(40))END IF;operator:=symbol;links:=knoten;nimmsymbol;komplexerarithmetischerausdruck;knoten:=newvergleich(links,knoten,operator).END PROCkomplexeslogischeselement;PROCkomplexerarithmetischerausdruck:TEXT VARoperator;TERM VARlinks;IFsymbol=plussymbolCORsymbol=minussymbolTHENoperator:=symbol;nimmsymbol;komplexerterm;knoten:=newmonade(knoten,operator)ELSEkomplexerterm;END IF;WHILEsymbol=plussymbolCORsymbol=minussymbolREPlinks:=knoten;operator:=symbol;nimmsymbol;
komplexerterm;knoten:=newdyade(links,knoten,operator)END REP END PROCkomplexerarithmetischerausdruck;PROCkomplexerterm:TEXT VARoperator;TERM VARlinks;komplexerfaktor;WHILEsymbol=multiplikationssymbolCORsymbol=divisionssymbolREPlinks:=knoten;operator:=symbol;nimmsymbol;komplexerfaktor;knoten:=newdyade(links,knoten,operator)END REP END PROCkomplexerterm;PROCkomplexerfaktor:TERM VARbasis;TEXT VARpotenzsymbol;komplexeselement;WHILEsymbol=allgemeinespotenzsymbolCORsymbol=speziellespotenzsymbolREPbasis:=knoten;nimmsymbol;komplexeselement;IFganzzahligerexponentTHENpotenzsymbol:=speziellespotenzsymbolELSEpotenzsymbol:=allgemeinespotenzsymbolEND IF;knoten:=newdyade(basis,knoten,potenzsymbol)END REP END PROCkomplexerfaktor;PROCkomplexeselement:IFsymboltyp=konstantentypCORsymbol=esymbolCORsymbol=pisymbolTHENverarbeitekonstanteELIFsymbol=klammeraufsymbolTHENverarbeitegeklammertenausdruckELIFvariablenbezeichnerTHENverarbeitevariablenbezeichnerELSEverarbeitefunktionsauswertungEND IF.verarbeitekonstante:knoten:=newkonstante(wert,symbol);nimmsymbol.verarbeitegeklammertenausdruck:nimmsymbol;komplexerarithmetischerausdruck;IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))END IF;nimmsymbol.variablenbezeichner:symboltyp=bezeichnertypCANDbezeichnerfuervariable.bezeichnerfuervariable:knoten:=listenposition(listedervariablen,symbol);knoten<>nil.verarbeitevariablenbezeichner:nimmsymbol.verarbeitefunktionsauswertung:INT VARtermzahl,variablenzahl,komponentenindex;TERM VARausdruckzeiger;abbildungsobjekt(termzahl,variablenzahl);ausdruckzeiger:=knoten;komponentenindex:=komponente(termzahl);argumentliste(variablenzahl);knoten:=newfunktionsauswertung(ausdruckzeiger,knoten,komponentenindex)END PROCkomplexeselement;BOOL VARelementeinerfunktionsverknuepfunggefunden;TEXT VARerlaubtervariablenname;PROCabbildungsobjekt(INT VARanzahlterme,anzahlvariablen):IFsymboltyp=bezeichnertypTHENverarbeitebezeichner;IFanzahlterme=1CANDanzahlvariablen=1THENeinfachesableitungsformatEND IF ELIFsymbol=funktionsklammeraufsymbolTHENverarbeitegeklammertenausdruck;einfachesableitungsformatELIFsymbol=differenziersymbolTHENverarbeiteallgemeinesableitungsformatELSEerrorstop(hinweisauffehlerhaftessymbol)END IF.verarbeitebezeichner:IFelementarefunktionCORselbstdefiniertefunktionTHENverarbeiteabbildungELSEerrorstop(hinweisauffehlerhaftessymbol)END IF.elementarefunktion:knoten:=listenposition(standardfunktionen,symbol);knoten<>nil.selbstdefiniertefunktion:knoten:=listenposition(eigenefunktionen,symbol);IFknoten<>nilCANDselektionshaltigetermliste(LISTENANFANG TERME DEFINITIONknoten)THENerrorstop(anwendungstext(188))END IF;knoten<>nil.verarbeiteabbildung:anzahlterme:=termanzahl(knoten);anzahlvariablen:=variablenanzahl(knoten);nimmsymbol.verarbeitegeklammertenausdruck:elementeinerfunktionsverknuepfunggefunden:=FALSE;nimmsymbol;abbildungsausdruck;IFsymbol<>funktionsklammerzusymbolTHENerrorstop(anwendungstext(35))END IF;anzahlterme:=1;anzahlvariablen:=1;nimmsymbol.verarbeiteallgemeinesableitungsformat:allgemeinesableitungsformat(anzahlvariablen);anzahlterme:=1.END PROCabbildungsobjekt;PROCeinfachesableitungsformat:WHILEsymbol=strichsymbolREP IFableitungsverbot(knoten)THENerrorstop(anwendungstext(56))END IF;knoten:=newableitungsoperation(knoten,defaultfuervariablenindex,defaultfuerkomponentenindex,strichsymbol);nimmsymbolEND REP END PROCeinfachesableitungsformat;PROCallgemeinesableitungsformat(INT VARvariablenzahl):INT VARableitungsgrad,komponentenindex,termzahl;ABBILDUNG VARvergleichsabbildung;bestimmeableitungsgrad;bestimmeobjektderableitungsoperation;überlesebruchsymbol;bestimmevariablenundallokiereableitungspointer.bestimmeableitungsgrad:nimmsymbol;IFsymboltyp=konstantentypTHEN IFpos(symbol,dezimalpunktsymbol)<>0THENerrorstop(anwendungstext(47))END IF;ableitungsgrad:=int(symbol);IFableitungsgrad<1THENerrorstop(anwendungstext(47))END IF;nimmsymbolELSEableitungsgrad:=1END IF.bestimmeobjektderableitungsoperation:abbildungsobjekt(termzahl,variablenzahl);IFableitungsverbot(knoten)THEN
errorstop(anwendungstext(56))END IF;vergleichsabbildung:=vergleichsfunktion(knoten);komponentenindex:=komponente(termzahl).überlesebruchsymbol:IFsymbol<>bruchsymbolTHENerrorstop(anwendungstext(43))END IF;nimmsymbol.bestimmevariablenundallokiereableitungspointer:INT VARzaehler,variablenindex;FORzaehlerFROM1UPTOableitungsgradREPbestimmeabzuleitendevariable;trageableitungein;nimmsymbolEND REP;loeschetemporaereabbildung(vergleichsabbildung).bestimmeabzuleitendevariable:TERM VARvergleichszeiger;IFsymbol<>differenziersymbolTHENerrorstop(anwendungstext(44))END IF;nimmsymbol;vergleichszeiger:=listenposition(abbildungsvariablen(vergleichsabbildung),symbol);IFvergleichszeiger=nilTHENerrorstop(hinweisaufungueltigennamen)END IF;variablenindex:=PLATZvergleichszeiger.trageableitungein:TERM VARpruefterm;IFknotenISeigenefunktionTHENpruefterm:=(TERME DEFINITIONknoten)ELEMENTkomponentenindexELSEpruefterm:=knotenEND IF;knoten:=newableitungsoperation(knoten,variablenindex,komponentenindex,differenziersymbol).END PROCallgemeinesableitungsformat;PROCabbildungsausdruck:TEXT VARoperator;TERM VARlinks;IFsymbol=plussymbolCORsymbol=minussymbolTHENoperator:=symbol;nimmsymbol;abbildungsterm;knoten:=newabbildungsmonade(knoten,operator)ELSEabbildungstermEND IF;WHILEsymbol=plussymbolCORsymbol=minussymbolREPlinks:=knoten;operator:=symbol;nimmsymbol;abbildungsterm;knoten:=newabbildungsdyade(links,knoten,operator)END REP END PROCabbildungsausdruck;PROCabbildungsterm:TEXT VARoperator;TERM VARlinks;abbildungsverkettung;WHILE(symbol=multiplikationssymbol)COR(symbol=divisionssymbol)REPlinks:=knoten;operator:=symbol;nimmsymbol;abbildungsverkettung;knoten:=newabbildungsdyade(links,knoten,operator)END REP END PROCabbildungsterm;PROCabbildungsverkettung:TERM VARlinks;abbildungselement;WHILEsymbol=verkettungssymbolREPlinks:=knoten;nimmsymbol;abbildungselement;knoten:=newabbildungsdyade(links,knoten,verkettungssymbol)END REP END PROCabbildungsverkettung;PROCabbildungselement:IFsymboltyp=bezeichnertypTHENverarbeitebezeichner;einfachesableitungsformatELIFsymbol=klammeraufsymbolTHENverarbeitegeklammertenausdruck;einfachesableitungsformatELIFsymbol=differenziersymbolTHEN INT VARanzahlvariablen:=1;allgemeinesableitungsformat(anzahlvariablen)ELSEerrorstop(hinweisauffehlerhaftessymbol)END IF.verarbeitebezeichner:TEXT VARneuervariablenname;IFelementarefunktionTHEN IF NOTelementeinerfunktionsverknuepfunggefundenTHENerlaubtervariablenname:=defaultstdfktvarname;elementeinerfunktionsverknuepfunggefunden:=TRUE ELIFerlaubtervariablenname<>defaultstdfktvarnameTHENerrorstop(anwendungstext(45))END IF ELIFselbstdefiniertefunktionTHEN IF(termanzahl(knoten)<>1)COR(variablenanzahl(knoten)<>1)THENerrorstop(anwendungstext(45))ELIFselektionshaltigetermliste(LISTENANFANG TERME DEFINITIONknoten)THENerrorstop(anwendungstext(188))END IF;neuervariablenname:=NAMElistenanfang(abbildungsvariablen(abbildung(symbol)));IF NOTelementeinerfunktionsverknuepfunggefundenTHENerlaubtervariablenname:=neuervariablenname;elementeinerfunktionsverknuepfunggefunden:=TRUE ELIFneuervariablenname<>erlaubtervariablennameTHENerrorstop(anwendungstext(45))END IF ELSEerrorstop(hinweisauffehlerhaftessymbol)END IF;nimmsymbol.elementarefunktion:knoten:=listenposition(standardfunktionen,symbol);knoten<>nil.selbstdefiniertefunktion:knoten:=listenposition(eigenefunktionen,symbol);IFselektionshaltigetermliste(LISTENANFANG TERME DEFINITIONknoten)THENerrorstop(anwendungstext(188))END IF;knoten<>nil.verarbeitegeklammertenausdruck:nimmsymbol;abbildungsausdruck;IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))END IF;nimmsymbolEND PROCabbildungselement;INT PROCkomponente(INT CONSTtermzahl):INT VARkompwert:=defaultfuerkomponentenindex;IFtermzahl>1THEN IFsymbol<>selektionssymbolTHENerrorstop(anwendungstext(42))END IF;nimmsymbol;IFsymboltyp<>konstantentypCORpos(symbol,dezimalpunktsymbol)<>0THENerrorstop(anwendungstext(42))END IF;kompwert:=int(symbol);IFkompwert>termzahlCORkompwert<1THENerrorstop(anwendungstext(42))END IF;nimmsymbol
END IF;kompwertEND PROCkomponente;PROCargumentliste(INT CONSTnotwendigeargumentanzahl):LISTE VARlistederargumente;IFsymbol<>klammeraufsymbolTHENerrorstop(anwendungstext(37))END IF;listederargumente:=neueliste(nil,nil);REPnimmsymbol;komplexerarithmetischerausdruck;anhaengen(listederargumente,newterm(knoten))UNTILsymbol<>kommasymbolEND REP;IFsymbol<>klammerzusymbolTHENerrorstop(anwendungstext(35))ELIFlaenge(listederargumente)<>notwendigeargumentanzahlTHENerrorstop(anwendungstext(46))END IF;nimmsymbol;knoten:=newtermliste(listenanfang(listederargumente),listenende(listederargumente),laenge(listederargumente))END PROCargumentliste;BOOL PROCganzzahligerexponent:REAL VARhilfswert;IF(knotenISkonstante)COR((knotenISmonadisch)CAND(OPERANDknotenISkonstante))THEN IFknotenISkonstanteTHENhilfswert:=WERTknotenELSEhilfswert:=WERT OPERANDknotenEND IF;IFhilfswert>32767.0CORhilfswert<-32768.0THEN FALSE ELSEhilfswert=floor(hilfswert)END IF ELSE FALSE END IF END PROCganzzahligerexponent;PROCtestegueltigkeit:IFsymboltyp<>bezeichnertypCORlistenposition(standardfunktionen,symbol)<>nilCORsymbol=esymbolCORsymbol=pisymbolCORsymbol=aktuellerabbildungsnameTHENerrorstop(hinweisaufungueltigennamen)ELIFebene=2CAND(listenposition(listedervariablen,symbol)<>nil)THENerrorstop(anwendungstext(41))END IF END PROCtestegueltigkeit;REAL PROCwert:IFsymbol=esymbolTHENeELIFsymbol=pisymbolTHENpiELSEreal(symbol)END IF END PROCwert;PROCeintragenderfunktion:anhaengenaneigenefunktionen(neweigenefunktion(newfunktionsdefinition(newvariablenliste(listenanfang(listedervariablen),listenende(listedervariablen),laenge(listedervariablen)),newtermliste(listenanfang(listederterme),listenende(listederterme),laenge(listederterme))),aktuellerabbildungsname))END PROCeintragenderfunktion;ABBILDUNG PROCfunktionsaufruf(TEXT CONSTaufrufstring):TEXT VARfehlzeichen:=niltext;ABBILDUNG VARarbeitsobjekt;enablestop;scan(aufrufstring);symbolspeicher:=niltext;nimmsymbol;IFsymbol=niltextTHENerrorstop(anwendungstext(33))ELIFfehlerhaftebuchstabenvorhanden(aufrufstring,fehlzeichen)THENerrorstop(anwendungstext(170)+fehlzeichen)END IF;arbeitsobjekt:=funktionsterm;IFsymbol<>niltextTHENloeschetemporaereabbildung(arbeitsobjekt);errorstop(hinweisauffehlerhaftessymbol)END IF;arbeitsobjektEND PROCfunktionsaufruf;ABBILDUNG PROCfunktionsterm:TEXT VARoperator;ABBILDUNG VARlinks,rechts,result;IFsymbol=plussymbolTHENnimmsymbol;result:=funktionsfaktorELIFsymbol=minussymbolTHENnimmsymbol;result:=-funktionsfaktorELSEresult:=funktionsfaktorEND IF;WHILEsymbol=plussymbolCORsymbol=minussymbolREPlinks:=result;operator:=symbol;nimmsymbol;rechts:=funktionsfaktor;IF NOTvariablenidentitaet(links,rechts)CORlaenge(abbildungsterme(links))<>laenge(abbildungsterme(rechts))THENloeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts);errorstop(anwendungstext(45))END IF;IFoperator=plussymbolTHENresult:=links+rechtsELSEresult:=links-rechtsEND IF;loeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts)END REP;resultEND PROCfunktionsterm;ABBILDUNG PROCfunktionsfaktor:TEXT VARoperator;ABBILDUNG VARlinks,rechts,result:=funktionsverkettung;WHILEsymbol=multiplikationssymbolCORsymbol=divisionssymbolREPoperator:=symbol;links:=result;nimmsymbol;rechts:=funktionsverkettung;IF NOTvariablenidentitaet(links,rechts)COR(laenge(abbildungsterme(rechts))<>laenge(abbildungsterme(links)))THENloeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts);errorstop(anwendungstext(45))END IF;IFoperator=multiplikationssymbolTHENresult:=links*rechtsELSE IFebene=2CANDlaenge(abbildungsterme(links))<>1THENloeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts);errorstop(anwendungstext(45))END IF;result:=links/rechtsEND IF;loeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts)END REP;resultEND PROCfunktionsfaktor;ABBILDUNG PROCfunktionsverkettung:ABBILDUNG VARlinks,rechts,result:=funktionselement;WHILEsymbol=verkettungssymbolREPlinks:=result;nimmsymbol;rechts:=funktionselement;IFlaenge(abbildungsvariablen(
links))<>laenge(abbildungsterme(rechts))THENloeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts);errorstop(anwendungstext(45))END IF;result:=linksOrechts;loeschetemporaereabbildung(links);loeschetemporaereabbildung(rechts)END REP;resultEND PROCfunktionsverkettung;ABBILDUNG PROCfunktionselement:ABBILDUNG VARelement;IF(listenposition(standardfunktionen,symbol)<>nil)COR(listenposition(eigenefunktionen,symbol)<>nil)THENverarbeitebezeichnerELIFsymbol=klammeraufsymbolTHENverarbeitegeklammertenausdruckELIFebene=2CANDsymbol=differenziersymbolTHENelement:=komplexefunktionsableitungELSEerrorstop(hinweisauffehlerhaftessymbol)END IF;element.verarbeitebezeichner:element:=abbildung(symbol);IFebene=1COR(laenge(abbildungsterme(element))=1CANDlaenge(abbildungsvariablen(element))=1CAND NOTableitungsverbot(adresse(element)))THENelement:=einfachefunktionsableitung(element)ELSEnimmsymbolEND IF.verarbeitegeklammertenausdruck:nimmsymbol;element:=funktionsterm;IFsymbol<>klammerzusymbolTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;IFebene=1COR(laenge(abbildungsterme(element))=1CANDlaenge(abbildungsvariablen(element))=1CAND NOTableitungsverbot(adresse(element)))THENelement:=einfachefunktionsableitung(element)ELSEnimmsymbolEND IF END PROCfunktionselement;ABBILDUNG PROCeinfachefunktionsableitung(ABBILDUNG VARelement):ABBILDUNG VARobjekt;nimmsymbol;WHILEsymbol=strichsymbolREPobjekt:=element;element:=ableitung(objekt,1,1);loeschetemporaereabbildung(objekt);nimmsymbolEND REP;elementEND PROCeinfachefunktionsableitung;ABBILDUNG PROCkomplexefunktionsableitung:ABBILDUNG VARelement,objekt;INT VARableitungsgrad,komponentenindex,variablenindex,i;bestimmeableitungsgrad;bestimmeobjektderableitung;leiteab;element.bestimmeableitungsgrad:nimmsymbol;IFpos(symbol,punktsymbol)<>0THENerrorstop(hinweisauffehlerhaftessymbol)ENDIF;ableitungsgrad:=int(symbol);IFlastconversionokTHEN IFableitungsgrad<1THENerrorstop(hinweisauffehlerhaftessymbol)END IF;nimmsymbolELSEableitungsgrad:=1END IF.bestimmeobjektderableitung:IF(listenposition(standardfunktionen,symbol)<>nil)COR(listenposition(eigenefunktionen,symbol)<>nil)THENobjekt:=abbildung(symbol);IFlaenge(abbildungsvariablen(objekt))=1CANDlaenge(abbildungsterme(objekt))=1CAND NOTableitungsverbot(adresse(objekt))THENobjekt:=einfachefunktionsableitung(objekt)ELSEnimmsymbolEND IF ELIFsymbol=funktionsklammeraufsymbolTHENnimmsymbol;objekt:=funktionsterm;IFsymbol<>funktionsklammerzusymbolTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;IFlaenge(abbildungsvariablen(objekt))=1CANDlaenge(abbildungsterme(objekt))=1CAND NOTableitungsverbot(adresse(objekt))THENobjekt:=einfachefunktionsableitung(objekt)ELSEnimmsymbolEND IF ELIFsymbol=differenziersymbolTHENobjekt:=komplexefunktionsableitungELSEerrorstop(hinweisauffehlerhaftessymbol)END IF;IFlaenge(abbildungsterme(objekt))>1THEN IFsymbol<>selektionssymbolTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;nimmsymbol;komponentenindex:=int(symbol);IF NOTlastconversionokTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;nimmsymbolELSEkomponentenindex:=1END IF;IFableitungsverbot(adresse(objekt))THENerrorstop(anwendungstext(56))END IF.leiteab:TERM VARsuchterm;INT VARtempkompindex:=komponentenindex;IFsymbol<>bruchsymbolTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;nimmsymbol;FORiFROM1UPTOableitungsgradREP IFi>1THENtempkompindex:=1END IF;IFsymbol<>differenziersymbolTHENerrorstop(anwendungstext(43))END IF;nimmsymbol;suchterm:=listenposition(abbildungsvariablen(objekt),symbol);IFsuchterm=nilTHENerrorstop(hinweisauffehlerhaftessymbol)END IF;variablenindex:=PLATZsuchterm;element:=ableitung(objekt,tempkompindex,variablenindex);loeschetemporaereabbildung(objekt);objekt:=element;nimmsymbolEND REP END PROCkomplexefunktionsableitung;PROCnimmsymbol:TEXT VARsym1,sym2;INT VARtyp1,typ2;besorgedaserstesymbol;besorgegegebenenfallseinzweitessymbol;reichesymbolundtypnachaussen.besorgedaserstesymbol:IFspeichergefuelltTHENverarbeitespeicher;loeschespeicherELSEnextsymbol(sym1,typ1);END IF.
speichergefuellt:symbolspeicher<>niltext.verarbeitespeicher:sym1:=symbolspeicher;typ1:=speichertyp.loeschespeicher:symbolspeicher:=niltext;speichertyp:=0.besorgegegebenenfallseinzweitessymbol:IFsym1=klammeraufsymbolTHENnextsymbol(sym2,typ2);IFsym2=punktsymbolTHENsym1:=funktionsklammeraufsymbol;typ1:=begrenzertypELSEfuellespeicherEND IF ELIFsym1=punktsymbolTHENnextsymbol(sym2,typ2);IFsym2=klammerzusymbolTHENsym1:=funktionsklammerzusymbol;typ1:=begrenzertypELSEfuellespeicherEND IF END IF.fuellespeicher:symbolspeicher:=sym2;speichertyp:=typ2.reichesymbolundtypnachaussen:symbol:=sym1;symboltyp:=typ1END PROCnimmsymbol;BOOL PROCfehlerhaftebuchstabenvorhanden(TEXT CONSTt,TEXT VARz):LETanzahlfehler=8;ROWanzahlfehlerTEXT CONSTungueltigezeichen:=ROWanzahlfehlerTEXT:("ä","ö","ü","ß","{","}","(*","*)");INT VARi;z:=niltext;FORiFROM1UPTOanzahlfehlerREP IFpos(t,ungueltigezeichen(i))<>0THENzCATungueltigezeichen(i)END IF END REP;z<>niltextEND PROCfehlerhaftebuchstabenvorhanden;TEXT PROChinweisauffehlerhaftessymbol:anwendungstext(36)+strichsymbol+symbol+strichsymbolEND PROChinweisauffehlerhaftessymbol;TEXT PROChinweisaufungueltigennamen:anwendungstext(31)+strichsymbol+symbol+strichsymbolEND PROChinweisaufungueltigennamen;BOOL VARlinear;FILE VARfktdat;TEXT PROCfunktionsstring(ABBILDUNG CONSTfkt):linear:=TRUE;fktstring(fkt)END PROCfunktionsstring;TEXT PROCformel(ABBILDUNG CONSTfkt):linear:=FALSE;fktstring(fkt)END PROCformel;TEXT PROCfktstring(ABBILDUNG CONSTfunktion):enablestop;pruefeparameter;erstellefunktionsstring;reichetextnachaussen.pruefeparameter:TERM VARsuchterm:=adresse(funktion);IFsuchterm=nilTHENerrorstop(anwendungstext(48))END IF.erstellefunktionsstring:sammletextbestandteileindatei;wandledateiintextum.sammletextbestandteileindatei:TEXT CONSTdatname:=scratchdateiname;fktdat:=sequentialfile(output,datname);disablestop;darstellung(suchterm);IFiserrorTHENclearerror;enablestop;forget(datname,quiet);errorstop(anwendungstext(49))END IF;enablestop.wandledateiintextum:TEXT VARstring:=niltext,zeile;input(fktdat);WHILE NOTeof(fktdat)REPgetline(fktdat,zeile);stringCATzeileEND REP;forget(datname,quiet).reichetextnachaussen:stringEND PROCfktstring;PROCdarstellung(TERM CONSTterm):enablestop;IFtermISeigenefunktionTHENgibfunktionsnamenausEND IF;variablenausgabe;gibzuweisungssymbolaus;gibtermlisteaus.gibfunktionsnamenaus:write(fktdat,NAMEterm);write(fktdat,doppelpunktsymbol).variablenausgabe:giberstevariableaus;IFebene=2THENgibweiterevariablenausEND IF.giberstevariableaus:TERM VARlaufterm:=LISTENANFANG VARIABLEN DEFINITIONterm;write(fktdat,NAMElaufterm).gibweiterevariablenaus:laufterm:=nachfolger(laufterm);WHILElaufterm<>nilREPwrite(fktdat,kommasymbol);write(fktdat,NAMElaufterm);laufterm:=nachfolger(laufterm)END REP.gibzuweisungssymbolaus:put(fktdat,blank+zuweisungssymbol).gibtermlisteaus:ausgabederterme(LISTENANFANG TERME DEFINITIONterm)END PROCdarstellung;PROCausgabederterme(TERM CONSTlaufterm):IFlaufterm<>nilTHENausgabe(AUSDRUCKlaufterm);IFnachfolger(laufterm)<>nilTHENput(fktdat,kommasymbol);ausgabederterme(nachfolger(laufterm))END IF END IF END PROCausgabederterme;PROCausgabe(TERM CONSTterm):TEXT VARoperator;TERM VARoperand;BOOL VARunsichtbareklammernnoetig;IF(termISstandardfunktion)COR(termISeigenefunktion)COR(termISvariable)THENgibnamenausELIFtermISkonstanteTHENgibkonstanteausELIFtermISdyadischTHENgibdyadeausELIFtermISmonadischTHENgibmonadeausELIFtermISfunktionsauswertungTHENgibfunktionsauswertungausELIFtermISableitungsoperationTHENgibableitungsoperationausELIFtermISabbildungsdyadeTHENgibabbildungsdyadeausELIFtermISabbildungsmonadeTHENgibabbildungsmonadeausELIFtermISselektionTHENgibselektionausELIFtermISlogischedyadeTHENgiblogischedyadeausELIFtermISvergleichTHENgibvergleichausELSEerrorstop(anwendungstext(49))END IF.gibnamenaus:write(fktdat,NAMEterm).gibkonstanteaus:REAL VARwert:=WERTterm;IF(NAMEterm=esymbol)COR(NAMEterm=pisymbol)THENwrite(fktdat,NAMEterm)ELIFwert=floor(wert)CANDwert<=32767.0CANDwert>=-32768.0THENwrite(fktdat,text(int(wert)))ELSE
write(fktdat,text(wert))END IF.gibdyadeaus:operator:=OPERATIONterm;operand:=LINKSterm;unsichtbareklammernnoetig:=NOTlinearCAND(operator=divisionssymbolCORoperator=allgemeinespotenzsymbolCORoperator=speziellespotenzsymbol);IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerauf)END IF;IFlinkeklammernnoetig(operand,operator)THENwrite(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol)ELSEausgabe(operand)END IF;IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerzu)END IF;IFoperator=allgemeinespotenzsymbolTHENput(fktdat,blank+speziellespotenzsymbol)ELSEput(fktdat,blank+operator)END IF;IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerauf)END IF;operand:=RECHTSterm;IFrechteklammernnoetig(operand,operator)THENwrite(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol)ELSEausgabe(operand)END IF;IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerzu)END IF.gibmonadeaus:operator:=OPERATIONterm;write(fktdat,operator);operand:=OPERANDterm;IFrechteklammernnoetig(operand,operator)THENwrite(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol)ELSEausgabe(operand)END IF.gibfunktionsauswertungaus:operand:=ABBILDUNGSAUSDRUCKterm;IF(operandISabbildungsdyade)COR(operandISabbildungsmonade)THENwrite(fktdat,funktionsklammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,funktionsklammerzusymbol)ELSEausgabe(operand)END IF;IF(operandISeigenefunktion)CANDlaenge(abbildungsterme(abbildung(NAMEoperand)))>1THENput(fktdat,selektionssymbol+text(KOMPONENTEterm))END IF;IF NOTlinearTHENwrite(fktdat,funktionsauswertungssymbol)END IF;write(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabederterme(LISTENANFANG ARGUMENTEterm);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol).gibableitungsoperationaus:bestimmeanzahlderableitungen;operator:=OPERATIONterm;IFoperator=strichsymbolTHENgibeinfachesableitungsformatausELSEgibkomplexesableitungsformatausEND IF.bestimmeanzahlderableitungen:INT VARableitungsgrad:=1,komponentenindex:=KOMPONENTEterm;operand:=ABBILDUNGSAUSDRUCKterm;WHILEoperandISableitungsoperationREPkomponentenindex:=KOMPONENTEoperand;operand:=ABBILDUNGSAUSDRUCKoperand;ableitungsgradINCR1END REP.gibeinfachesableitungsformataus:IF(operandISeigenefunktion)COR(operandISstandardfunktion)THENausgabe(operand)ELSEwrite(fktdat,funktionsklammeraufsymbol);ausgabe(operand);write(fktdat,funktionsklammerzusymbol)END IF;write(fktdat,ableitungsgrad*strichsymbol).gibkomplexesableitungsformataus:ABBILDUNG VARvergleichsabbildung;IF NOTlinearTHENwrite(fktdat,unsichtbareklammerauf);write(fktdat,diffklammeraufsymbol)END IF;write(fktdat,differenziersymbol);IFableitungsgrad<>1THENwrite(fktdat,text(ableitungsgrad))END IF;write(fktdat,blank);IF(operandISabbildungsdyade)COR(operandISabbildungsmonade)THENwrite(fktdat,funktionsklammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,funktionsklammerzusymbol)ELSEausgabe(operand);IF NOT((operandISstandardfunktion)COR(laenge(abbildungsterme(abbildung(NAMEoperand)))=1))THENwrite(fktdat,selektionssymbol+text(komponentenindex))END IF END IF;IFlinearTHENwrite(fktdat,bruchsymbol);ELSEwrite(fktdat,unsichtbareklammerzu);write(fktdat,bruchsymbol+blank)END IF;vergleichsabbildung:=vergleichsfunktion(operand);ableitungsvariablenausgabe(term,abbildungsvariablen(vergleichsabbildung));IF NOTlinearTHENwrite(fktdat,diffklammerzusymbol)END IF;loeschetemporaereabbildung(vergleichsabbildung).gibabbildungsdyadeaus:operator:=OPERATIONterm;operand:=LINKSterm;unsichtbareklammernnoetig:=NOTlinearCANDoperator=divisionssymbol;
IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerauf)END IF;IFlinkeklammernnoetig(operand,operator)THENwrite(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol)ELSEausgabe(operand)END IF;IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerzu)END IF;put(fktdat,blank+operator);operand:=RECHTSterm;IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerauf)END IF;IFrechteklammernnoetig(operand,operator)THENwrite(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol)ELSEausgabe(operand)END IF;IFunsichtbareklammernnoetigTHENwrite(fktdat,unsichtbareklammerzu)END IF.gibabbildungsmonadeaus:operator:=OPERATIONterm;write(fktdat,operator);operand:=OPERANDterm;IFrechteklammernnoetig(operand,operator)THENwrite(fktdat,klammeraufsymbol);IF NOTlinearTHENwrite(fktdat,blank)END IF;ausgabe(operand);IF NOTlinearTHENwrite(fktdat,blank)END IF;write(fktdat,klammerzusymbol)ELSEausgabe(operand)END IF.gibselektionaus:IFlinearTHENput(fktdat,ifsymbol);ausgabe(AKTIONterm);put(fktdat,blank+fuersymbol);ausgabe(BEDINGUNGterm);operand:=ALTERNATIVEterm;WHILEoperand<>nilREPput(fktdat,blank+elifsymbol);ausgabe(AKTIONoperand);put(fktdat,blank+fuersymbol);ausgabe(BEDINGUNGoperand);operand:=ALTERNATIVEoperandEND REP;write(fktdat,blank+endifsymbol)ELSEwrite(fktdat,selektionsklammeraufsymbol);ausgabe(AKTIONterm);write(fktdat,selektionsfuersymbol);ausgabe(BEDINGUNGterm);operand:=ALTERNATIVEterm;WHILEoperand<>nilREPwrite(fktdat,selektionselifsymbol);ausgabe(AKTIONoperand);write(fktdat,selektionsfuersymbol);ausgabe(BEDINGUNGoperand);operand:=ALTERNATIVEoperandEND REP;write(fktdat,selektionsklammerzusymbol)END IF.giblogischedyadeaus:ausgabe(LINKSterm);put(fktdat,blank+OPERATIONterm);IF(RECHTSterm)ISlogischedyadeTHENwrite(fktdat,klammeraufsymbol);ausgabe(RECHTSterm);write(fktdat,klammerzusymbol)ELSEausgabe(RECHTSterm)END IF.gibvergleichaus:ausgabe(LINKSterm);put(fktdat,blank+OPERATIONterm);ausgabe(RECHTSterm)END PROCausgabe;PROCableitungsvariablenausgabe(TERM CONSTterm,LISTE CONSTvglvariablenliste):IF(ABBILDUNGSAUSDRUCKterm)ISableitungsoperationTHENableitungsvariablenausgabe(ABBILDUNGSAUSDRUCKterm,vglvariablenliste)END IF;write(fktdat,differenziersymbol+NAME(auswahl(vglvariablenliste,INDEXterm)))END PROCableitungsvariablenausgabe;BOOL PROClinkeklammernnoetig(TERM CONSToperand,TEXT CONSToperator):IF NOTlinearCANDoperator=divisionssymbolTHEN FALSE ELSEregel1CORregel2END IF.regel1:((operandISdyadisch)COR(operandISabbildungsdyade))CAND(prioritaet(OPERATIONoperand)<prioritaet(operator)).regel2:((operandISmonadisch)COR(operandISabbildungsmonade))CAND(operator=speziellespotenzsymbolCORoperator=allgemeinespotenzsymbol)END PROClinkeklammernnoetig;BOOL PROCrechteklammernnoetig(TERM CONSToperand,TEXT CONSToperator):IF NOTlinearCANDoperator=divisionssymbolTHEN FALSE ELIF NOTlinearCAND(operator=allgemeinespotenzsymbolCORoperator=speziellespotenzsymbol)THEN(operandISdyadisch)CAND((OPERATIONoperand=allgemeinespotenzsymbol)COR(OPERATIONoperand=speziellespotenzsymbol))ELSEregel1CORregel2CORregel3END IF.regel1:(operandISmonadisch)COR(operandISabbildungsmonade).regel2:((operandISdyadisch)COR(operandISabbildungsdyade))CAND(fall1CORfall2CORfall3).fall1:prioritaet(OPERATIONoperand)<prioritaet(operator).fall2:prioritaet(OPERATIONoperand)=prioritaet(operator)CAND(operator=minussymbolCORoperator=divisionssymbolCORoperator=speziellespotenzsymbolCORoperator=allgemeinespotenzsymbolCORoperator=verkettungssymbol).fall3:TERM VARt:=LINKSoperand;WHILE(tISdyadisch)COR(tISabbildungsdyade)REPt:=LINKStEND REP;(tISmonadisch)COR(tISabbildungsmonade)COR((tISkonstante)CAND(WERTt<0.0)).regel3:(operandISkonstante)CAND(WERToperand<0.0)END PROCrechteklammernnoetig;INT PROCprioritaet(TEXT CONSToperator):IFoperator=undsymbolCORoperator=odersymbolTHEN4ELIFoperator=verkettungssymbolTHEN3
ELIFoperator=speziellespotenzsymbolCORoperator=allgemeinespotenzsymbolTHEN2ELIFoperator=multiplikationssymbolCORoperator=divisionssymbolTHEN1ELSE0END IF END PROCprioritaet;PROCgibnamen(ABBILDUNG CONSTf,TEXT VARname):enablestop;testeparameter;fuehreaktionaus.testeparameter:ueberpruefeexistenzderabbildung;ueberpruefesyntaxdesnamens;ueberpruefegueltigkeitdesnamens.ueberpruefeexistenzderabbildung:TERM VAReintrag:=adresse(f);IF NOT(eintragIStemporaerefunktion)THENerrorstop(anwendungstext(59))END IF.ueberpruefesyntaxdesnamens:TEXT VARsymbol;INT VARsymboltyp;changeall(name,blank,niltext);scan(name);nextsymbol(symbol,symboltyp);IFsymboltyp<>bezeichnertypTHENerrorstop(anwendungstext(31))END IF;nextsymbol(symbol);IFsymbol<>niltextTHENerrorstop(anwendungstext(31))END IF.ueberpruefegueltigkeitdesnamens:TEXT VARzk;IFfehlerhaftebuchstabenvorhanden(name,zk)COR(name=esymbol)COR(name=pisymbol)COR(listenposition(standardfunktionen,name)<>nil)THENerrorstop(anwendungstext(31))ELIFlistenposition(abbildungsvariablen(f),name)<>nilTHENerrorstop(anwendungstext(3))ELIFlistenposition(eigenefunktionen,name)<>nilTHENerrorstop(anwendungstext(60))END IF.fuehreaktionaus:anhaengenaneigenefunktionen(neweigenefunktion(DEFINITIONeintrag,name));entfernenaustemporaerenfunktionen(eintrag);LOESCHEeintragEND PROCgibnamen;PROCloescheunreferenzierteabbildung(TEXT CONSTfunktionsname):enablestop;TERM VAReintrag:=listenposition(eigenefunktionen,funktionsname);IFreferenziertefunktion(eintrag)THENerrorstop(NAMEeintrag+anwendungstext(71))END IF;loeschebenannteabbildung(funktionsname)END PROCloescheunreferenzierteabbildung;BOOL PROCreferenziertefunktion(TERM CONSTeintrag):TERM VARlaufterm:=listenanfang(eigenefunktionen);BOOL VARreferenziert:=FALSE;WHILE(laufterm<>nil)CAND NOTreferenziertREP IFlaufterm<>eintragTHENreferenziert:=durchsuchteliste(LISTENANFANG TERME DEFINITIONlaufterm,eintrag)END IF;laufterm:=nachfolger(laufterm)END REP;IF NOTreferenziertTHENlaufterm:=listenanfang(temporaerefunktionen);WHILE(laufterm<>nil)CAND NOTreferenziertREPreferenziert:=durchsuchteliste(LISTENANFANG TERME DEFINITIONlaufterm,eintrag);laufterm:=nachfolger(laufterm);END REP END IF;referenziertEND PROCreferenziertefunktion;BOOL PROCdurchsuchteliste(TERM CONSTterm,eintrag):durchsuchterterm(AUSDRUCKterm,eintrag)COR((nachfolger(term)<>nil)CANDdurchsuchteliste(nachfolger(term),eintrag))END PROCdurchsuchteliste;BOOL PROCdurchsuchterterm(TERM CONSTterm,eintrag):IFtermISeigenefunktionTHENterm=eintragELIF(termISdyadisch)COR(termISlogischedyade)COR(termISvergleich)COR(termISabbildungsdyade)THENdurchsuchterterm(LINKSterm,eintrag)CORdurchsuchterterm(RECHTSterm,eintrag)ELIF(termISmonadisch)COR(termISabbildungsmonade)THENdurchsuchterterm(OPERANDterm,eintrag)ELIFtermISfunktionsauswertungTHEN((ABBILDUNGSAUSDRUCKterm)=eintrag)CORdurchsuchterterm(ABBILDUNGSAUSDRUCKterm,eintrag)CORdurchsuchteliste(LISTENANFANG ARGUMENTEterm,eintrag)ELIFtermISableitungsoperationTHENdurchsuchterterm(ABBILDUNGSAUSDRUCKterm,eintrag)ELIFtermISselektionTHENdurchsuchterterm(BEDINGUNGterm,eintrag)CORdurchsuchterterm(AKTIONterm,eintrag)CORdurchsuchterterm(ALTERNATIVEterm,eintrag)ELSE FALSE END IF END PROCdurchsuchterterm;THESAURUS PROCfunktionsnamenthesaurus:THESAURUS VARthes:=emptythesaurus;TERM VARfunktion:=listenanfang(eigenefunktionen);WHILEfunktion<>nilREPinsert(thes,NAMEfunktion);funktion:=nachfolger(funktion)END REP;thesEND PROCfunktionsnamenthesaurus;THESAURUS PROCstandardfunktionsthesaurus:THESAURUS VARthes:=emptythesaurus;TERM VARfunktion:=listenanfang(standardfunktionen);WHILEfunktion<>nilREPinsert(thes,NAMEfunktion);funktion:=nachfolger(funktion)END REP;thesEND PROCstandardfunktionsthesaurus;END PACKETparser

