PACKETmenufunktionenDEFINESeingang1,eingang2,funktionsverwaltungseingang,ausgang,eingabe,ausgabe,zeigen,beseitigen,sichern,laden,bestimmenachkommastellen,bestimmehalbgraphiczeichen,bestimmeformeleditoreinsatz,bestimmeformeleditorzeichensatz,bestimmedruckseitenformat,verfahren,verfahrensende,formeleditoraktiv,liefereformeleditorformat,raeumeauf:LETzentral=5,mitreinigung=TRUE,ohnereinigung=FALSE,ohneabbruch=FALSE,niltext="",bell="�",del="�",blank=" ",unterstrichzeichen="_",doppelpunkt=":",trennzeichen="!",maxfunktionen=10,maxfelder=100,menupunktende="m",zusatztasten="fsm",eingabeprocname="eingeben",ladeprocname="laden",loeschprocname="löschen",ausgabeprocname="ausgeben",sicherungsprocname="sichern",niveau="Ebene ",fktdatname="Funktionendatei",maximalanzahlfunktionen=200,PARAMETER=ROWmaxfelderTEXT,allesok=5,fetaskname="FORMELEDITOR",formelindateischreiben=1,zeichensatzumstellen=2,formeleditieren=3;ROWmaxfunktionenTEXT VARfkttext;TEXT VARletztesescapezeichen;INT VARletztearbeitsfkt:=2;TEXT CONSTlangerstrich:=100*unterstrichzeichen;BOOL VARausgabeaktiviert:=FALSE,eingabeaktiviert:=FALSE;THESAURUS VARverzeichnisderstandardfunktionen,archivinhalt;TASK VARformeleditor;PROCeingang1:disablestop;lowlevel;initialisierefunktionentextunddeaktiviereggfEND PROCeingang1;PROCeingang2:disablestop;highlevel;initialisierefunktionentextunddeaktiviereggfEND PROCeingang2;PROCinitialisierefunktionentextunddeaktiviereggf:INT VARi;tagsankoppeln;IFexiststask(fetaskname)THENformeleditor:=/fetasknameELSEformeleditor:=niltaskEND IF;ausgabeaktiviert:=laenge(eigenefunktionen)>0;eingabeaktiviert:=laenge(eigenefunktionen)<maximalanzahlfunktionen;IF NOTausgabeaktiviertTHENdeaktiviereELSEaktiviereEND IF;IF NOTeingabeaktiviertTHENdeactivate(eingabeprocname);deactivate(ladeprocname)END IF;verzeichnisderstandardfunktionen:=standardfunktionsthesaurus;FORiFROM1UPTOmaxfunktionenREPfkttext(i):=langerstrichEND REP;letztearbeitsfkt:=2END PROCinitialisierefunktionentextunddeaktiviereggf;PROCfunktionsverwaltungseingang:disablestop;IFausgabeaktiviertTHENaktiviereEND IF;IF NOTeingabeaktiviertTHENdeactivate(eingabeprocname);deactivate(ladeprocname)END IF END PROCfunktionsverwaltungseingang;PROCausgang:disablestop;THESAURUS VARth:=all;TEXT VARdsname;INT VARn:=laenge(temporaerefunktionen),i;FORiFROM1UPTOnREPloescheabbildung(abbildung(DEFINITIONlistenanfang(temporaerefunktionen)));END REP;i:=0;get(th,dsname,i);WHILEi<>0REP IFdsname<>"mathematikobjekte 1"CANDdsname<>"mathematikobjekte 2"CANDdsname<>"mathe formulare"THENforget(dsname,quiet)END IF;get(th,dsname,i)END REP END PROCausgang;PROCeingabe:disablestop;ABBILDUNG VARg;TEXT VARstring:=niltext;INT VARx0:=2,y0:=6,xbreite:=77,ylaenge:=13;WINDOW VAReingabefenster:=window(x0,y0,xbreite,ylaenge),ueberschriftfenster;IFeingabeuebereditorTHENueberschriftfenster:=window(2,3,77,1);outframe(ueberschriftfenster);out(ueberschriftfenster,center(ueberschriftfenster,invers("Funktionseingabe")));show(eingabefenster)END IF;REPnimmeingabenentgegen;werteeingabenausEND REP.nimmeingabenentgegen:clearbuffer;IFeingabeuebereditorTHENlasseformeleditorarbeitenELSEstring:=boxanswer(eingabefenster,text(anwendungstext(63),74),string,zentral,x0,y0,xbreite,ylaenge)END IF;IFstring=niltextTHENregeneratemenuscreen;LEAVEeingabeEND IF.lasseformeleditorarbeiten:initialisierevorgabenfuerformeleditor;werteformeleditoreingabeaus.initialisierevorgabenfuerformeleditor:INT VARreplycode,workchannel:=channel;BOUND TEXT VARtextstring:=new("datenbehaelter");textstring:=string;DATASPACE VARds:=old("datenbehaelter");forget("datenbehaelter",quiet);break(quiet);call(formeleditor,formeleditieren,ds,replycode);continue(workchannel).werteformeleditoreingabeaus:textstring:=ds;string:=textstring;forget(ds).werteeingabenaus:g:=neuefunktion(string);IFiserrorTHENgibmeldung(errormessage);clearerrorELSEgibmeldung(anwendungstext(134));IF NOTausgabeaktiviertTHENaktiviere;ausgabeaktiviert:=TRUE ELIFlaenge(eigenefunktionen)>=maximalanzahlfunktionenTHEN
eingabeaktiviert:=FALSE;deactivate(eingabeprocname);deactivate(ladeprocname);regeneratemenuscreen;LEAVEeingabeEND IF;string:=niltextEND IF END PROCeingabe;PROCausgabe:disablestop;THESAURUS VARwunschliste:=menusome(funktionsnamenthesaurus,anwendungstext(64),niltext,ohnereinigung);IFnotempty(wunschliste)THENschreibedieausgewaehltenfunktionenineinedatei;gibdiegewuenschtenfunktionenausEND IF;regeneratemenuscreen.schreibedieausgewaehltenfunktionenineinedatei:ABBILDUNG VARfkt;TEXT CONSTdatname:=scratchdateiname;FILE VARf:=sequentialfile(output,datname);TEXT VARfunktionsname;INT VARi:=0;REPget(wunschliste,funktionsname,i);IFfunktionsname=niltextTHEN LEAVEschreibedieausgewaehltenfunktionenineinedateiEND IF;fkt:=abbildung(funktionsname);IFformeleditoraktivTHENliefereformeleditorformat(f,fkt);line(f)ELSEputline(f,funktionsstring(fkt))END IF END REP.gibdiegewuenschtenfunktionenaus:WINDOW VARu:=window(2,4,77,1),w:=window(2,7,77,16);INT VARersterauszugebendersatz:=1,ersteauszugebendespalte:=1;TEXT CONSTerlaubtezeichen:="?dm";show(u);out(u,center(u,anwendungstext(154)));outframe(w);REPfootnote(anwendungstext(135));scroll(w,datname,1,1,1,ersterauszugebendersatz,ersteauszugebendespalte,erlaubtezeichen,letztesescapezeichen);werteausstiegausEND REP.werteausstiegaus:SELECTpos(erlaubtezeichen,letztesescapezeichen)OF CASE1:show(formular(13));warteCASE2:druckversuch(datname);outframe(w)CASE3:forget(datname,quiet);LEAVEgibdiegewuenschtenfunktionenausEND SELECT END PROCausgabe;PROCzeigen:disablestop;WINDOW VARw:=window(35,10,40,12);zeigeelementarefunktionsnamen;zeigebenutzerdefiniertefunktionsnamen;warte;page(w,TRUE);oldfootnote.zeigeelementarefunktionsnamen:TEXT VARtheselement,zeile;INT VARi:=0;show(w);cursor(w,1,1);out(w,center(w,anwendungstext(68)));get(verzeichnisderstandardfunktionen,theselement,i);WHILEtheselement<>niltextREPzeile:=niltext;WHILEtheselement<>niltextCANDlength(zeile)+length(theselement)<40REPzeileCATtheselement;zeileCATblank;get(verzeichnisderstandardfunktionen,theselement,i)END REP;out(w,center(w,zeile))END REP;line(w).zeigebenutzerdefiniertefunktionsnamen:THESAURUS VARthes:=funktionsnamenthesaurus;i:=0;out(w,center(w,anwendungstext(69)));get(thes,theselement,i);WHILEtheselement<>niltextREPzeile:=niltext;IFlength(theselement)>40THENzeileCATtheselement;get(thes,theselement,i);ELSE WHILEtheselement<>niltextCANDlength(zeile)+length(theselement)<40REPzeileCATtheselement;zeileCATblank;get(thes,theselement,i)END REP END IF;out(w,center(w,zeile));IFremaininglines(w)=0THENwarte;page(w)END IF;END REP;out(w,center(w,anwendungstext(70)+text(laenge(eigenefunktionen))))END PROCzeigen;PROCbeseitigen:disablestop;clearbuffer;SELECTmenualternative(anwendungstext(34),anwendungstext(50),zusatztasten,zentral,ohneabbruch)MOD100OF CASE1:waehlediezuloeschendenfunktionenaus;IFnotempty(auswahl)THENzeigeloeschfensterundinitialisierevariablen;IFebene=1THENloeschedieausgewaehltenfunktionenELSEloeschedieausgewaehltenfunktionenvorsichtigEND IF;warte;IFlaenge(eigenefunktionen)=0THENdeaktiviere;ausgabeaktiviert:=FALSE ELIFlaenge(eigenefunktionen)<maximalanzahlfunktionenTHENeingabeaktiviert:=TRUE;activate(eingabeprocname);activate(ladeprocname)END IF END IF;regeneratemenuscreenCASE2:footnote(anwendungstext(61));initialisieren;deaktiviere;ausgabeaktiviert:=FALSE;oldfootnote;refreshsubmenuEND SELECT.waehlediezuloeschendenfunktionenaus:THESAURUS VARauswahl:=menusome(funktionsnamenthesaurus,anwendungstext(73),niltext,ohnereinigung).zeigeloeschfensterundinitialisierevariablen:TEXT VARname,frage;TERM VAReintrag;INT VARi:=0;WINDOW VARw:=window(2,4,77,19);show(w);out(w,center(w,anwendungstext(142)));line(w).loeschedieausgewaehltenfunktionen:get(auswahl,name,i);WHILEname<>niltextREPeintrag:=listenposition(eigenefunktionen,name);frage:=anwendungstext(75)+funktionsstring(abbildung(name))+anwendungstext(76);footnote(anwendungstext(141));IFyes(w,frage)THENloeschebenannteabbildung(name);putline(w,anwendungstext(137))END IF;get(auswahl,name,i)END REP.
loeschedieausgewaehltenfunktionenvorsichtig:THESAURUS VARfunktionenmitloeschverbot:=emptythesaurus;get(auswahl,name,i);WHILEname<>niltextREPeintrag:=listenposition(eigenefunktionen,name);IFreferenziertefunktion(eintrag)THENfunktionenmitloeschverbot:=funktionenmitloeschverbot+nameELSEfrage:=anwendungstext(75)+funktionsstring(abbildung(name))+anwendungstext(76);footnote(anwendungstext(141));IFyes(w,frage)THENloeschebenannteabbildung(name);putline(w,anwendungstext(137))END IF;auswahl:=auswahl-name;funktionenmitloeschverbot:=funktionenmitloeschverbot-nameEND IF;get(auswahl,name,i)END REP;IFnotempty(funktionenmitloeschverbot)THENgibhinweisaufreferenziertefunktionenEND IF.gibhinweisaufreferenziertefunktionen:line(w);putline(w,anwendungstext(152));i:=0;get(funktionenmitloeschverbot,name,i);WHILEname<>niltextREPput(w,name);get(funktionenmitloeschverbot,name,i)END REP;line(w);putline(w,anwendungstext(153))END PROCbeseitigen;PROCsichern:disablestop;TEXT VARmeldung:=niltext,dateiname;IFarchivangemeldet(meldung)THENclearbuffer;sichereausgewaehltefunktionenELIFmeldung<>niltextTHENgibmeldung(meldung)END IF;release(archive);oldfootnote.sichereausgewaehltefunktionen:waehlefunktionenaus;IFnotempty(wunschliste)THENwaehlefunktionendateikennung;schreibefunktioneninausgewaehltedatei;sicheredateiaufdasarchiv(dateiname)END IF.waehlefunktionenaus:THESAURUS VARwunschliste:=menusome(funktionsnamenthesaurus,anwendungstext(139),niltext,mitreinigung).waehlefunktionendateikennung:TEXT CONSTfktdateipraefix:=fktdatname+text(ebene,2);dateiname:=eingegebenerdateiname(fktdateipraefix);IFdateiname=niltextTHEN LEAVEsichereausgewaehltefunktionenEND IF.schreibefunktioneninausgewaehltedatei:TEXT VARfunktionsname;INT VARi:=0;FILE VARf:=sequentialfile(output,dateiname);get(wunschliste,funktionsname,i);WHILEfunktionsname<>niltextREPwrite(f,funktionsstring(abbildung(funktionsname))+trennzeichen);get(wunschliste,funktionsname,i)END REP END PROCsichern;TEXT PROCeingegebenerdateiname(TEXT CONSTpraefix):TEXT VARkurzname:=niltext,langname:=niltext;REPclearbuffer;kurzname:=compress(menuanswer(anwendungstext(65),kurzname,zentral))UNTILkurzname=niltextCORdateinamefreigegebenEND REP;IFkurzname=niltextTHENniltextELSElangnameEND IF.dateinamefreigegeben:langname:=praefix+doppelpunkt+kurzname;NOT(archivinhaltCONTAINSlangname)CORmenuyes(anwendungstext(66),zentral)END PROCeingegebenerdateiname;PROCsicheredateiaufdasarchiv(TEXT CONSTdateiname):footnote(anwendungstext(67));commanddialogue(FALSE);save(dateiname,archive);IFiserrorTHENgibmeldung(errormessage);clearerrorELSEgibmeldung(anwendungstext(72))END IF;commanddialogue(TRUE);forget(dateiname,quiet)END PROCsicheredateiaufdasarchiv;PROCladen:disablestop;TEXT VARmeldung:=niltext,dateiname:=niltext;TEXT CONSTfktdateipraefix:=fktdatname+text(ebene,2);IFarchivangemeldet(meldung)THEN IFnotempty(archivinhaltLIKE(fktdateipraefix+":*"))THENholeausgewaehltefunktionen;release(archive);ueberpruefeaktivierungELSErelease(archive);gibmeldung(anwendungstext(78))END IF ELIFmeldung<>niltextTHENrelease(archive);gibmeldung(meldung)END IF;oldfootnote.holeausgewaehltefunktionen:bestimmedateinamen;IFdateierfolgreicheingelesen(dateiname)THENlesefunktionenein;forget(dateiname,quiet)END IF.bestimmedateinamen:dateiname:=ausgewaehlterdateiname(fktdateipraefix,anwendungstext(81),anwendungstext(82));IFdateiname=niltextTHEN LEAVEholeausgewaehltefunktionenEND IF.lesefunktionenein:ABBILDUNG VARfkt;FILE VARf:=sequentialfile(input,dateiname);TEXT VARfunktionstext;WHILE NOTeof(f)REPget(f,funktionstext,trennzeichen);footnote(anwendungstext(145)+funktionstext+anwendungstext(146));versuchefunktioneinzutragenEND REP.versuchefunktioneinzutragen:REP IFlaenge(eigenefunktionen)>=maximalanzahlfunktionenTHENgibmeldung(anwendungstext(205));eingabeaktiviert:=FALSE;LEAVElesefunktioneneinEND IF;fkt:=neuefunktion(funktionstext);IFiserrorTHENclearerror;clearbuffer;funktionstext:=menuanswer(anwendungstext(83),funktionstext,zentral);IFlsexitkey=menupunktendeTHEN LEAVElesefunktionenein
ELIFfunktionstext=niltextTHEN LEAVEversuchefunktioneinzutragenEND IF ELSE LEAVEversuchefunktioneinzutragenEND IF END REP END PROCladen;TEXT PROCausgewaehlterdateiname(TEXT CONSTpraefix,botschaft,ueberschrift):THESAURUS VARarchivdateien:=archivinhaltLIKE(praefix+":*");IFnotempty(archivdateien)THENmenuone(archivdateien,ueberschrift,niltext,mitreinigung)ELSEgibmeldung(botschaft);niltextEND IF END PROCausgewaehlterdateiname;BOOL PROCdateierfolgreicheingelesen(TEXT CONSTdateiname):forget(dateiname,quiet);footnote(anwendungstext(163));fetch(dateiname,archive);IFiserrorTHENgibmeldung(errormessage);clearerror;FALSE ELSE TRUE END IF END PROCdateierfolgreicheingelesen;BOOL PROCarchivangemeldet(TEXT VARmeldung):TEXT CONSTvorlaeufigerarchivname:="Mathematik";IFmenuno(anwendungstext(84),zentral)THEN LEAVEarchivangemeldetWITH FALSE END IF;footnote(anwendungstext(138));archive(vorlaeufigerarchivname);IFiserrorTHENmeldung:=errormessage;clearerror;FALSE ELSEarchivinhalt:=ALLarchive;IFiserrorTHENergebnisderzweitenanmeldungELSE TRUE END IF END IF.ergebnisderzweitenanmeldung:meldung:=errormessage;clearerror;IFsubtext(meldung,1,14)="Archiv heisst "CANDsubtext(meldung,16,20)<>"?????"THENarchive(subtext(meldung,16,length(meldung)-1));IFiserrorTHENmeldung:=errormessage;clearerror;FALSE ELSEarchivinhalt:=ALLarchive;IFiserrorTHENmeldung:=errormessage;clearerror;FALSE ELSE TRUE END IF END IF ELSEmeldung:=anwendungstext(85);FALSE END IF END PROCarchivangemeldet;LETmaxnachkommastellen=12;PROCbestimmenachkommastellen:INT VARzahl;REPclearbuffer;TEXT VARanzahlnachkommastellen:=menuanswer(anwendungstext(86),text(nachkomma(ebene)),zentral);IFcompress(anzahlnachkommastellen)=niltextTHEN LEAVEbestimmenachkommastellenEND IF;zahl:=int(anzahlnachkommastellen);IFlastconversionokCANDzahl>-1CANDzahl<=maxnachkommastellenTHENsetzenachkommastellen(zahl);LEAVEbestimmenachkommastellenEND IF;out(bell)END REP END PROCbestimmenachkommastellen;PROCbestimmehalbgraphiczeichen:SELECTmenualternative(anwendungstext(93),anwendungstext(92),"ism",zentral,ohneabbruch)MOD100OF CASE1:ibmgraphiccharCASE2:stdgraphiccharOTHERWISE LEAVEbestimmehalbgraphiczeichenEND SELECT;regeneratemenuscreenEND PROCbestimmehalbgraphiczeichen;PROCbestimmeformeleditoreinsatz:SELECTmenualternative(anwendungstext(94),anwendungstext(95),"1234m",zentral,ohneabbruch)MOD100OF CASE1:formeleditoraktiv(TRUE);eingabeuebereditor(TRUE)CASE2:formeleditoraktiv(FALSE);eingabeuebereditor(TRUE)CASE3:formeleditoraktiv(TRUE);eingabeuebereditor(FALSE)CASE4:formeleditoraktiv(FALSE);eingabeuebereditor(FALSE)END SELECT END PROCbestimmeformeleditoreinsatz;PROCbestimmeformeleditorzeichensatz:forget("formelzeichensatz",quiet);BOUND TEXT VARformelzeichensatz:=new("formelzeichensatz");SELECTmenualternative(anwendungstext(207),anwendungstext(92),"ism",zentral,ohneabbruch)MOD100OF CASE1:formelzeichensatz:="ibmoperatoren"CASE2:formelzeichensatz:="standardoperatoren"OTHERWISEforget("formelzeichensatz",quiet);LEAVEbestimmeformeleditorzeichensatzEND SELECT;DATASPACE VARds:=old("formelzeichensatz");INT VARreplycode;call(formeleditor,zeichensatzumstellen,ds,replycode);forget(ds);forget("formelzeichensatz",quiet)END PROCbestimmeformeleditorzeichensatz;PROCbestimmedruckseitenformat:LETminimum=20,maximum=200;INT VARspaltenanzahl,zeilenanzahl,breite,laenge;TEXT VAReingabe;INT VARx0:=2,y0:=6,xbreite:=77,ylaenge:=13;WINDOW VAReingabefenster:=window(x0,y0,xbreite,ylaenge);druckseitenformat(spaltenanzahl,zeilenanzahl);liesspaltenanzahlein;lieszeilenanzahlein;definieredruckseitenformat(breite,laenge).liesspaltenanzahlein:REPclearbuffer;eingabe:=boxanswer(eingabefenster,text(anwendungstext(215),74),text(spaltenanzahl),zentral,x0,y0,xbreite,ylaenge);IFcompress(eingabe)=niltextTHENraeumebildschirmauf;LEAVEbestimmedruckseitenformatEND IF;breite:=int(eingabe);IFlastconversionokCANDbreite>=minimumCANDbreite<=maximumTHEN LEAVEliesspaltenanzahleinEND IF;out(bell)END REP.lieszeilenanzahlein:REPclearbuffer;eingabe:=boxanswer(eingabefenster,text(anwendungstext(216
),74),text(zeilenanzahl),zentral,x0,y0,xbreite,ylaenge);IFcompress(eingabe)=niltextTHENraeumebildschirmauf;LEAVEbestimmedruckseitenformatEND IF;laenge:=int(eingabe);IFlastconversionokCANDlaenge>=minimumCANDlaenge<=maximumTHENraeumebildschirmauf;LEAVElieszeilenanzahleinEND IF;out(bell)END REP END PROCbestimmedruckseitenformat;PROCraeumebildschirmauf:INT VARi;FORiFROM9UPTO14REPcursor(1,i);out(del)END REP;refreshsubmenuEND PROCraeumebildschirmauf;ROW2BOOL VARformeleditoreingeschaltet:=ROW2BOOL:(FALSE,FALSE),formeleditoreingabe:=ROW2BOOL:(FALSE,FALSE);PROCformeleditoraktiv(BOOL CONSTschalter):formeleditoreingeschaltet(ebene):=schalterEND PROCformeleditoraktiv;BOOL PROCformeleditoraktiv:formeleditoreingeschaltet(ebene)END PROCformeleditoraktiv;PROCeingabeuebereditor(BOOL CONSTschalter):formeleditoreingabe(ebene):=schalterEND PROCeingabeuebereditor;BOOL PROCeingabeuebereditor:formeleditoreingabe(ebene)END PROCeingabeuebereditor;PROCliefereformeleditorformat(FILE VARf,ABBILDUNG CONSTfkt):forget("temporaerer datenraum",quiet);BOUND TEXT VARtextformat:=new("temporaerer datenraum");textformat:=formel(fkt);DATASPACE VARds:=old("temporaerer datenraum");INT VARreplycode;call(formeleditor,formelindateischreiben,ds,replycode);wertereplycodeaus;forget(ds);forget("temporaerer datenraum",quiet).wertereplycodeaus:TEXT VARzeile,tempdat:=scratchdateiname;IFreplycode=allesokTHENcopy(ds,tempdat);FILE VARf2:=sequentialfile(input,tempdat);output(f);WHILE NOTeof(f2)REPgetline(f2,zeile);putline(f,zeile)END REP;forget(tempdat,quiet)ELSEputline(f,funktionsstring(fkt))END IF END PROCliefereformeleditorformat;PROCverfahren(PROC(ABBILDUNG CONST)auszufuehrendeprozedur,TEXT CONSTprozedurname):disablestop;ABBILDUNG VARarbeitsfunktion;REPeditierearbeitsfunktionen;ergaenzeumunterstriche;IFletztesescapezeichen=menupunktendeTHENregeneratemenuscreen;LEAVEverfahrenEND IF;auszufuehrendeprozedur(arbeitsfunktion);IFiserrorTHENclearerror;schreibestatuszeile(prozedurname);show(eingabemaske);gibmeldung(errormessage)END IF;loeschetemporaereabbildung(arbeitsfunktion)UNTILletztesescapezeichen=menupunktendeEND REP;regeneratemenuscreen.editierearbeitsfunktionen:initialisieredievariablen;schreibestatuszeile(prozedurname);editiere.initialisieredievariablen:PARAMETER VARraster;INT VARi;TAG VAReingabemaske:=formular(1);raster(1):=niltext;FORiFROM1UPTOmaxfunktionenREPraster(i+1):=fkttext(i)END REP.editiere:REPbearbeiteeingabeformular;werteausstiegausEND REP.bearbeiteeingabeformular:footnote(anwendungstext(189));show(eingabemaske);putget(eingabemaske,raster,letztearbeitsfkt,letztesescapezeichen);IFiserrorTHENclearerror;schreibestatuszeile(prozedurname);show(eingabemaske);gibmeldung(errormessage);letztesescapezeichen:=menupunktende;LEAVEeditiereEND IF.werteausstiegaus:SELECTpos("?zwm",letztesescapezeichen)OF CASE1:gibinformationzumformularCASE2:zeigenCASE3:IFkorrekteeingabeTHEN LEAVEeditierearbeitsfunktionenEND IF CASE4:LEAVEeditiereEND SELECT.korrekteeingabe:INT VARdoppelpunktlage:=pos(raster(letztearbeitsfkt),doppelpunkt);TEXT VARfstring:=raster(letztearbeitsfkt);footnote(anwendungstext(114));changeall(fstring,unterstrichzeichen,niltext);IFcompress(fstring)=niltextTHENgibmeldung(anwendungstext(190));FALSE ELSE IFselbstdefiniertefunktionTHEN IF NOTeingabeaktiviertTHENgibmeldung(anwendungstext(205));LEAVEkorrekteeingabeWITH FALSE END IF;arbeitsfunktion:=neuefunktion(fstring)ELSEarbeitsfunktion:=funktionsaufruf(fstring)END IF;IFiserrorTHENgibmeldung(errormessage);clearerror;FALSE ELSE IFselbstdefiniertefunktionTHENraster(letztearbeitsfkt):=text(raster(letztearbeitsfkt),doppelpunktlage-1);ausgabeaktiviert:=laenge(eigenefunktionen)>=1;eingabeaktiviert:=laenge(eigenefunktionen)<maximalanzahlfunktionen;END IF;TRUE END IF END IF.selbstdefiniertefunktion:doppelpunktlage<>0.gibinformationzumformular:WINDOW VARw:=window(3,6,75,17);outframe(w);IFebene=1THENshow(formular(4))ELSEshow(formular(23))END IF;warte.ergaenzeumunterstriche:FORiFROM1UPTOmaxfunktionenREPchangeall(raster(i+1),blank,
unterstrichzeichen);raster(i+1)CAT((100-length(raster(i+1)))*unterstrichzeichen);fkttext(i):=raster(i+1)END REP END PROCverfahren;PROCraeumeauf:schreibeselbstdefiniertefunktionenindatei;initialisieren;trageselbstdefiniertefunktionenein;oldfootnote.schreibeselbstdefiniertefunktionenindatei:TEXT VARbeliebig:=scratchdateiname;FILE VARf:=sequentialfile(output,beliebig);TERM VARt:=listenanfang(eigenefunktionen);WHILEt<>nilREPputline(f,funktionsstring(abbildung(NAMEt)));t:=nachfolger(t)END REP.trageselbstdefiniertefunktionenein:TEXT VARzeile;ABBILDUNG VARabb;f:=sequentialfile(input,beliebig);WHILE NOTeof(f)REPgetline(f,zeile);abb:=neuefunktion(zeile)END REP;forget(beliebig,quiet)END PROCraeumeauf;PROCverfahrensende(TEXT CONSTzeichen):letztesescapezeichen:=zeichenEND PROCverfahrensende;PROCueberpruefeaktivierung:IFlaenge(eigenefunktionen)>0CAND NOTausgabeaktiviertTHENaktiviere;ausgabeaktiviert:=TRUE;refreshsubmenuELIFlaenge(eigenefunktionen)=0CANDausgabeaktiviertTHENdeaktiviere;ausgabeaktiviert:=FALSE;refreshsubmenuEND IF END PROCueberpruefeaktivierung;PROCaktiviere:activate(loeschprocname);activate(ausgabeprocname);activate(sicherungsprocname)END PROCaktiviere;PROCdeaktiviere:deactivate(loeschprocname);deactivate(ausgabeprocname);deactivate(sicherungsprocname)END PROCdeaktiviere;END PACKETmenufunktionen;

