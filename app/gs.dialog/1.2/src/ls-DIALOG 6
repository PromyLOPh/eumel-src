(* 
        
          ********************************************************* 
          ********************************************************* 
          **                                                     ** 
          **                     ls-DIALOG 6                     ** 
          **                 Archiv-/Taskhandling                ** 
          **                     Version 1.2                     ** 
          **                                                     ** 
          **                  (Stand: 04.11.88)                  ** 
          **                                                     ** 
          **                                                     ** 
          **         Autor: Wolfgang Weber, Bielefeld            ** 
          **                                                     ** 
          **                                                     ** 
          ** Copyright (C) 1987, 1988 Eva Latta-Weber, Bielefeld ** 
          **                                                     ** 
          ** Copyright (C) 1988 ERGOS GmbH, Siegburg             ** 
          **                                                     ** 
          ********************************************************* 
          ********************************************************* 
 
                                                                           *) 
 
PACKET  ls dialog 6  DEFINES{}       menu archiv notizort setzen,{}       menu archiv grundeinstellung,{}       menu archiv zieltask einstellen,{}       menu archiv zieltask aendern,{}       menu archiv reservieren,{}       menu archiv neue diskette,{}       menu archiv schreiben,{}       menu archiv checken,{}       menu archiv schreibcheck,{}       menu archiv holen,{}       menu archiv loeschen,{}       menu archiv verzeichnis,{}       menu archiv verzeichnis drucken,{}       menu archiv initialisieren,{}
       menu archiv reservierung aufgeben,{}       archiv:{}LET menukartenname  =  "ls-MENUKARTE:Archiv";{}LET ack             =   0,{}    schreiben       =   1,{}    checken         =   2,{}    schreibcheck    =   3,{}    holen           =   4,{}    loeschen        =   5,{}    list code       =  15,{}    reserve code    =  19;{}BOOL VAR zieltask ist archivmanager   :: TRUE,{}         archiv gehoert mir           :: FALSE,{}         fehlerfall                   :: FALSE,{}         kontakt mit zieltask erfolgt :: FALSE;{}
TEXT VAR zieltaskname                 :: "ARCHIVE",{}         aktueller archivname         :: "";{}INT VAR stationsnummer                :: station (myself),{}        letzte funktion               :: 11,{}        notizort                      :: 3;{}PROC archiv:{}  install menu (menukartenname, FALSE);{}  handle  menu ("ARCHIV"){}END PROC archiv;{}PROC melde zieltaskerror (TEXT CONST meldung):{}  IF   meldung = menubasistext (47){}       THEN menuinfo (menubasistext (123)){}  ELIF meldung = menubasistext (46){}
       THEN menuinfo (menubasistext (124)){}  ELIF pos (meldung, "inkonsistent") > 0{}       THEN menuinfo (menubasistext (125)){}  ELIF     pos (meldung, "Lesen unmoeglich") > 0{}       COR pos (meldung, "Schreiben unmoeglich") > 0{}       THEN menuinfo (menubasistext (126)){}  ELIF pos (meldung, "Archiv heisst") > 0 AND pos (meldung, "?????") > 0{}       THEN menuinfo (menubasistext (127)){}  ELIF pos (meldung, "Archiv heisst") > 0{}       THEN menuinfo (menubasistext (128)){}  ELIF pos (meldung, "Schreibfehler") > 0 CAND pos (meldung, "Archiv") > 0{}
       THEN menuinfo (menubasistext (129)){}  ELIF pos (meldung, "Lesefehler") > 0{}       THEN menuinfo (menubasistext (130)){}  ELIF pos (meldung, "Kommando") > 0 AND pos (meldung, "unbekannt") > 0{}       THEN menuinfo (menubasistext (131)){}  ELIF pos (meldung, "falscher Auftrag fuer Task") > 0{}       THEN menuinfo (menubasistext (132)){}  ELIF meldung = menubasistext (41){}       THEN menuinfo (menubasistext (133)){}  ELIF meldung = menubasistext (42){}       THEN menuinfo (menubasistext (134)){}
  ELIF pos (meldung, "Collector") > 0 AND pos(meldung, "fehlt") > 0{}       THEN menuinfo (menubasistext (135)){}  ELIF pos (meldung, "kein Zugriffsrecht auf Task") > 0{}       THEN menuinfo (menubasistext (132)){}  ELIF pos (meldung, "nicht initialisiert") > 0{}       THEN menuinfo (menubasistext (136)){}  ELIF pos (meldung, "ungueltiger Format-Code") > 0{}       THEN menuinfo (menubasistext (137)){}  ELSE menuinfo (invers (meldung)){}  FI{}END PROC melde zieltaskerror;{}PROC menu archiv notizort setzen (INT CONST wert):{}
   SELECT wert OF{}     CASE 1,2,3,4,5 : notizort := wert{}     OTHERWISE        notizort := 3{}   END SELECT{}END PROC menu archiv notizort setzen;{}PROC menu archiv grundeinstellung (INT CONST ort):{}  menu archiv zieltask aendern ("ARCHIVE", station (myself), TRUE);{}  menu archiv notizort setzen (ort);{}  zieltask anzeigen{}END PROC menu archiv grundeinstellung;{}PROC menu archiv zieltask einstellen:{}  TEXT VAR taskname :: "";{}  INT  VAR stationsnr, auswahl;{}  BOOL VAR ist amanager;{}  erfrage daten;{}
  kontrolliere daten;{}  menu archiv zieltask aendern (taskname, stationsnr, ist amanager);{}  refresh submenu;{}  zieltask anzeigen.{}  erfrage daten:{}    auswahl := menualternative (menubasistext (51), menubasistext (52),{}                                menubasistext (53), 5, TRUE);{}    SELECT auswahl OF{}      CASE 1, 101 : menu archiv zieltask aendern{}                    ("ARCHIVE",     station (myself), TRUE );{}                    ausstieg{}      CASE 2, 102 : menu archiv zieltask aendern{}
                    (name (father), station (myself), FALSE);{}                    ausstieg{}      CASE 3, 103 : menu archiv zieltask aendern{}                    ("PUBLIC",      station (myself), FALSE);{}                    ausstieg{}      CASE 4, 104 : handeinstellung{}      OTHERWISE ausstieg{}    END SELECT.{}  ausstieg:{}    refresh submenu;{}    zieltask anzeigen;{}    LEAVE menu archiv zieltask einstellen.{}  handeinstellung:{}    taskname     := menuanswer (menubasistext (81), zieltaskname, 5);{}
    stationsnr   := int (menuanswer (menubasistext (82),{}                         text (station (myself)), 5));{}    ist amanager := menuyes (menubasistext (83), 5).{}  kontrolliere daten:{}    IF   compress (taskname) = ""{}      OR compress (taskname) = "-"{}      OR taskname = name (myself){}       THEN menuinfo (menubasistext (64));{}            LEAVE menu archiv zieltask einstellen{}    FI.{}END PROC menu archiv zieltask einstellen;{}PROC menu archiv zieltask aendern (TEXT CONST taskname,{}
                                   INT  CONST stationsnr,{}                                   BOOL CONST ist archivmanager):{}  menufootnote (menubasistext (21) + menubasistext (23));{}  gib ggf archiv frei;{}  IF ist archivmanager{}     THEN archivmanager einstellen{}     ELSE sonstige task einstellen{}  FI;{}  aktiviere gueltige archivmenupunkte.{}  gib ggf archiv frei:{}    IF archiv gehoert mir{}       THEN archivreservierung aufgeben{}    FI.{}  archivmanager einstellen:{}    zieltask ist archivmanager   := TRUE;{}
    zieltaskname                 := taskname;{}    stationsnummer               := stationsnr;{}    kontakt mit zieltask erfolgt := FALSE;{}    aktueller archivname         := "";{}    archiv gehoert mir           := FALSE;{}    letzte funktion              := 11.{}  sonstige task einstellen:{}    zieltask ist archivmanager := FALSE;{}    zieltaskname               := taskname;{}    stationsnummer             := stationsnr;{}    aktueller archivname       := "";{}    archiv gehoert mir         := FALSE;{}
    letzte funktion            := 6.{}END PROC menu archiv zieltask aendern;{}PROC menu archiv reservieren:{}  TEXT VAR archivname :: "", meldung :: "";{}  kontrolliere einstellung;{}  menufootnote (menubasistext (21) + menubasistext (24));{}  versuche archiv zu reservieren (meldung);{}  werte meldung aus;{}  archiv anmelden (archivname, meldung, TRUE);{}  IF archivname = ""{}     THEN behandle archivfehler{}     ELSE aktueller archivname := archivname{}  FI;{}  aktiviere gueltige archivmenupunkte;{}
  refresh submenu;{}  zieltask anzeigen.{}  kontrolliere einstellung:{}    IF   NOT zieltask ist archivmanager{}         THEN aktiviere gueltige archivmenupunkte;{}              refresh submenu;{}              LEAVE menu archiv reservieren{}    ELIF NOT kontakt mit zieltask erfolgt{}         THEN versuche kontakt herzustellen{}    FI.{}  versuche kontakt herzustellen:{}    TEXT VAR fehler :: "";{}    IF NOT task ist kommunikativ (fehler){}       THEN melde zieltaskerror (fehler);{}            melde rigoros ab;{}
            LEAVE menu archiv reservieren{}       ELSE kontakt mit zieltask erfolgt := TRUE{}    FI.{}  werte meldung aus:{}    IF meldung <> ""{}       THEN melde zieltaskerror (meldung);{}            melde rigoros ab;{}            LEAVE menu archiv reservieren{}    FI.{}  behandle archivfehler:{}    melde zieltaskerror (meldung);{}    archivreservierung aufgeben;{}    melde rigoros ab{}END PROC menu archiv reservieren;{}PROC melde rigoros ab:{}  aktueller archivname         := "";{}  archiv gehoert mir           := FALSE;{}
  kontakt mit zieltask erfolgt := FALSE{}END PROC melde rigoros ab;{}PROC versuche archiv zu reservieren (TEXT VAR fehler):{}  IF NOT kontakt mit zieltask erfolgt{}     THEN fehler := menubasistext (44);{}          archiv gehoert mir := FALSE;{}          LEAVE versuche archiv zu reservieren{}  FI;{}  disable stop;{}  IF eigene station{}     THEN reserve ("beknackter archivename",/zieltaskname ){}     ELSE reserve ("beknackter archivename", stationsnummer/zieltaskname){}  FI;{}  IF is error{}     THEN fehler := errormessage;{}
          melde rigoros ab;{}          clear error{}     ELSE archiv gehoert mir := TRUE;{}          fehler             := "";{}  FI;{}  enable stop{}END PROC versuche archiv zu reservieren;{}PROC archiv anmelden (TEXT VAR archivname, fehler, BOOL CONST mit anfrage):{}  ueberpruefe archivbesitz;{}  fuehre archivanmeldung aus.{}  ueberpruefe archivbesitz:{}    IF NOT archiv gehoert mir OR NOT kontakt mit zieltask erfolgt{}       THEN fehler := menubasistext (45);{}            melde rigoros ab;{}            LEAVE archiv anmelden{}
    FI.{}  fuehre archivanmeldung aus:{}    IF mit anfrage{}       THEN frage nach eingelegter diskette und melde an{}       ELSE melde archiv unter richtigem namen an{}    FI.{}  frage nach eingelegter diskette und melde an:{}    IF menuyes (menubasistext (84), 5){}       THEN menufootnote (menubasistext (21) + menubasistext (25));{}            melde archiv unter richtigem namen an{}       ELSE fehler := menubasistext (46);{}            aktueller archivname := "";{}            LEAVE archiv anmelden{}
    FI.{}  melde archiv unter richtigem namen an:{}    disable stop;{}    IF eigene station{}       THEN reserve ("beknackter archivename",/zieltaskname);{}            list (/zieltaskname);{}       ELSE reserve ("beknackter archivename", stationsnummer/zieltaskname);{}            list (stationsnummer/zieltaskname){}    FI;{}    IF is error{}       THEN fehler := errormessage;{}            behandle die fehlermeldung{}       ELSE archivname := "beknackter archivename";{}            fehler     := "";{}            enable stop{}
   FI.{} behandle die fehlermeldung:{}   IF   subtext (fehler, 1, 14) = menubasistext (61){}          CAND subtext (fehler, 16, 20) <> menubasistext (62){}        THEN clear error; enable stop;{}             archivname := subtext (fehler, 16, length (fehler) - 1);{}             melde archiv nun wirklich richtig an;{}             fehler := "";{}             enable stop{}   ELIF subtext (fehler, 1, 14) = menubasistext (61){}          CAND subtext (fehler, 16, 20) = menubasistext (62){}        THEN clear error; enable stop;{}
             archivname := "";{}             fehler     := menubasistext (62){}   ELSE clear error; enable stop;{}        archivname := ""{}   FI.{}  melde archiv nun wirklich richtig an:{}    IF eigene station{}       THEN reserve (archivname,/zieltaskname);{}       ELSE reserve (archivname, stationsnummer/zieltaskname){}    FI.{}END PROC archiv anmelden;{}PROC menu archiv neue diskette:{}  ueberpruefe reservierung;{}  melde neue diskette an.{}  ueberpruefe reservierung:{}    IF NOT (archiv gehoert mir AND kontakt mit zieltask erfolgt){}
       THEN melde zieltaskerror (menubasistext (47));{}            LEAVE menu archiv neue diskette{}    FI.{}  melde neue diskette an:{}    TEXT VAR archivname :: "", meldung :: "";{}    menufootnote (menubasistext (21) + menubasistext (26));{}    archiv anmelden (archivname, meldung, FALSE);{}    IF archivname = ""{}       THEN behandle archivfehler{}       ELSE aktueller archivname := archivname{}    FI;{}    zieltask anzeigen.{}  behandle archivfehler:{}    melde zieltaskerror (meldung);{}    aktueller archivname := "".{}
END PROC menu archiv neue diskette;{}PROC menu archiv schreiben:{}  dateioperation  mit zieltask (schreiben);{}  regenerate menuscreen{}END PROC menu archiv schreiben;{}PROC menu archiv checken:{}  dateioperation mit zieltask (checken);{}  regenerate menuscreen{}END PROC menu archiv checken;{}PROC menu archiv schreibcheck:{}  dateioperation mit zieltask (schreibcheck);{}  regenerate menuscreen{}END PROC menu archiv schreibcheck;{}PROC menu archiv holen:{}  dateioperation mit zieltask (holen);{}  regenerate menuscreen{}
END PROC menu archiv holen;{}PROC menu archiv loeschen:{}  dateioperation mit zieltask (loeschen);{}  regenerate menuscreen{}END PROC menu archiv loeschen;{}PROC dateioperation mit zieltask (INT CONST wahl):{}  ueberpruefe kommunikationsbasis und sinnhaftigkeit;{}  lasse dateien auswaehlen;{}  operiere mit ausgewaehlten dateien.{}  ueberpruefe kommunikationsbasis und sinnhaftigkeit:{}    IF   unzulaessiger zieltaskname{}         THEN LEAVE dateioperation mit zieltask{}    ELIF zieltaskname = name (myself){}
         THEN melde zieltaskerror (menubasistext (48));{}              LEAVE dateioperation mit zieltask{}    ELIF zieltask ist archivmanager AND NOT archiv gehoert mir{}         THEN melde zieltaskerror (menubasistext (47));{}              LEAVE dateioperation mit zieltask{}    ELIF NOT zieltask ist archivmanager{}         AND (wahl = checken OR wahl = schreibcheck){}         THEN gib hinweis auf unmoeglich;{}              LEAVE dateioperation mit zieltask{}    ELIF NOT zieltask ist archivmanager{}
         THEN stelle kontakt mit zieltask her{}    ELIF wahl < schreiben OR wahl > loeschen{}         THEN LEAVE dateioperation mit zieltask{}    FI.{}  stelle kontakt mit zieltask her:{}    TEXT VAR fehler :: "";{}    IF task ist kommunikativ (fehler){}       THEN kontakt mit zieltask erfolgt := TRUE{}       ELSE melde zieltaskerror (fehler);{}            LEAVE dateioperation mit zieltask{}    FI.{}  gib hinweis auf unmoeglich:{}    menuinfo (menubasistext (121) + taskname + menubasistext (122)).{}
  taskname:{}    IF eigene station{}       THEN zieltaskname{}       ELSE text (stationsnummer) + "/" + zieltaskname{}    FI.{}  lasse dateien auswaehlen:{}    THESAURUS VAR angekreuzte;{}    disable stop;{}    IF wahl = schreiben  OR wahl = schreibcheck{}       THEN angekreuzte := menusome (ALL myself, operationshinweis,{}                                     ankreuzhinweis, FALSE){}       ELSE angekreuzte := menusome (zieltaskthesaurus, operationshinweis,{}                                     ankreuzhinweis, FALSE){}
    FI;{}    fehlerbehandlung.{}  zieltaskthesaurus:{}    IF eigene station{}       THEN ALL /zieltaskname{}       ELSE ALL (stationsnummer/zieltaskname){}    FI.{}  ankreuzhinweis:{}    menubasistext (91) + operationskennzeichnung (wahl) + menubasistext (92).{}  operationshinweis:{}    operationsbezeichnung (wahl) + zieltaskhinweis.{}  operiere mit ausgewaehlten dateien:{}    bereite bildschirm vor;{}    steige ggf bei leerem thesaurus aus;{}    IF wahl = schreiben OR wahl = schreibcheck{}       THEN zuerst loeschen{}
    FI;{}    IF wahl = schreibcheck{}       THEN fehlerfall := FALSE;{}            dateioperation ausfuehren (angekreuzte, schreiben, FALSE);{}            IF NOT fehlerfall{}               THEN dateioperation ausfuehren (angekreuzte, checken, TRUE){}            FI{}       ELSE dateioperation ausfuehren (angekreuzte, wahl, TRUE){}    FI.{}  bereite bildschirm vor:{}    show menuwindow.{}  steige ggf bei leerem thesaurus aus:{}    IF NOT not empty (angekreuzte){}       THEN menuwindowline (2);{}            menuwindowout (menubasistext (94));{}
            menuwindowstop;{}            LEAVE dateioperation mit zieltask{}    FI.{}  zuerst loeschen:{}    menuwindowout (menuwindowcenter (menubasistext (21) + menubasistext (31)));{}    menuwindowline;{}    IF not empty (angekreuzte){}       THEN disable stop;{}            THESAURUS CONST zu loeschende ::{}                            angekreuzte / zieltaskthesaurus;{}            fehlerbehandlung;{}            biete ggf dateien zum loeschen an{}       ELSE menuwindowpage{}    FI.{}  biete ggf dateien zum loeschen an:{}
    IF not empty (zu loeschende){}       THEN menuwindowout (menuwindowcenter (invers (menubasistext (108))));{}            menuwindowline;{}            menuwindowout (menuwindowcenter (menubasistext (109)));{}            menuwindowline (2);{}            dateien rausschmeissen{}       ELSE menuwindowpage{}    FI.{}  dateien rausschmeissen:{}    command dialogue (FALSE);{}    biete dateien einzeln zum loeschen an;{}    menuwindowpage;{}    command dialogue (TRUE).{}  biete dateien einzeln zum loeschen an:{}
    INT VAR z, index;{}    FOR z FROM 1 UPTO highest entry (zu loeschende) REP{}      disable stop;{}      IF name (zu loeschende, z) <> ""{}         THEN stelle frage und fuehre aus{}      FI;{}      fehlerbehandlung{}    PER.{}  stelle frage und fuehre aus:{}    IF menuwindowyes ("'" + name (zu loeschende, z) + "' "{}                          + menubasistext (111)){}       THEN erase (name (zu loeschende, z), task (zieltaskname)){}       ELSE menuwindowout (menubasistext (110));{}            menuwindowline;{}
            delete (angekreuzte, name (zu loeschende, z), index);{}            pause (20){}    FI.{}  fehlerbehandlung:{}    IF is error{}       THEN regenerate menuscreen;{}            melde zieltaskerror (errormessage);{}            clear error; enable stop;{}            LEAVE dateioperation mit zieltask{}    FI.{}END PROC dateioperation mit zieltask;{}PROC dateioperation ausfuehren (THESAURUS CONST angekreuzte,{}                                INT CONST wahl,{}                                BOOL CONST mit schlussbemerkung):{}
  INT VAR spalte :: 1, zeile :: 3, k, anzahl :: 0;{}  menuwindowout (menuwindowcenter (invers (operationsbezeichnung (wahl){}                                        + zieltaskhinweis)));{}  command dialogue (FALSE);{}  fuehre einzelne operationen aus;{}  command dialogue (TRUE);{}  IF mit schlussbemerkung{}     THEN schreibe schlussbemerkung{}     ELSE menuwindowpage{}  FI.{}  fuehre einzelne operationen aus:{}    FOR k FROM 1 UPTO highest entry (angekreuzte) REP{}      IF name (angekreuzte, k) <> ""{}
         THEN disable stop;{}              bildschirmausgabe;{}              operation ausfuehren;{}              anzahl INCR 1;{}              fehlerbehandlung{}      FI{}    PER.{}  bildschirmausgabe:{}    spalte := 1;{}    IF remaining menuwindowlines < 2{}       THEN menuwindowpage; zeile := 1{}       ELSE zeile INCR 1{}    FI;{}    menuwindowcursor (spalte, zeile);{}    ergaenzter dateiname.{}  ergaenzter dateiname:{}    INT VAR windowcolumn, windowrow;{}    SELECT wahl OF{}      CASE schreiben : menuwindowout (menubasistext (105) + dateiname){}
      CASE checken   : get menuwindowcursor (windowcolumn, windowrow);{}                       menuwindowout (dateiname + menubasistext (106));{}                       menuwindowcursor (windowcolumn, windowrow);{}      CASE holen     : menuwindowout (menubasistext (107) + dateiname){}    END SELECT.{}  dateiname:{}    " """ + name (angekreuzte, k) + """ ".{}  operation ausfuehren:{}    IF eigene station{}       THEN fuehre eigenstationoperation aus{}       ELSE fuehre fremdstationoperation aus{}    FI.{}
  fuehre eigenstationoperation aus:{}    SELECT wahl OF{}      CASE schreiben : save  (name (angekreuzte, k), /zieltaskname){}      CASE checken   : check (name (angekreuzte, k), /zieltaskname);{}                       bestaetige{}      CASE holen     : ueberschreiben erfragen eigene station{}      CASE loeschen  : loeschen erfragen eigene station{}    END SELECT.{}  ueberschreiben erfragen eigene station:{}    IF exists (name (angekreuzte, k)){}       THEN menuwindowline;{}            IF menuwindowyes (dateiname + menubasistext (112)){}
               THEN zeile INCR 2;{}                    menuwindowline;{}                    forget (name (angekreuzte, k), quiet);{}                    fetch  (name (angekreuzte, k), /zieltaskname){}            FI{}       ELSE fetch (name (angekreuzte, k), /zieltaskname){}    FI.{}  loeschen erfragen eigene station:{}    IF menuwindowyes (dateiname + menubasistext (111)){}       THEN erase (name (angekreuzte, k), /zieltaskname){}    FI.{}  fuehre fremdstationoperation aus:{}    SELECT wahl OF{}      CASE schreiben : save  (name (angekreuzte, k), ziel){}
      CASE checken   : check (name (angekreuzte, k), ziel); bestaetige{}      CASE holen     : ueberschreiben erfragen fremde station{}      CASE loeschen  : loeschen erfragen fremde station{}    END SELECT.{}  ueberschreiben erfragen fremde station:{}    IF exists (name (angekreuzte, k)){}       THEN menuwindowline;{}            IF menuwindowyes (dateiname + menubasistext (112)){}               THEN zeile INCR 2;{}                    menuwindowline;{}                    forget (name (angekreuzte, k), quiet);{}
                    fetch  (name (angekreuzte, k), ziel){}            FI{}       ELSE fetch (name (angekreuzte, k), ziel){}    FI.{}  loeschen erfragen fremde station:{}    IF menuwindowyes (dateiname + menubasistext (111)){}       THEN erase (name (angekreuzte, k), ziel){}    FI.{}  ziel:{}    stationsnummer/zieltaskname.{}  bestaetige:{}    IF NOT is error{}       THEN menuwindowout (dateiname + menubasistext (114)){}    FI.{}  schreibe schlussbemerkung:{}    IF remaining menuwindowlines < 7{}       THEN menuwindowpage; menuwindowline{}
       ELSE menuwindowline (2){}    FI;{}    IF anzahl > 0{}       THEN menuwindowout (menubasistext (93) +{}                           operationskennzeichnung (wahl)){}       ELSE menuwindowout (menubasistext (94)){}    FI;{}    menuwindowstop.{}  fehlerbehandlung:{}    IF is error{}       THEN fehlerfall := TRUE;{}            regenerate menuscreen;{}            melde zieltaskerror (errormessage);{}            clear error; enable stop;{}            LEAVE dateioperation ausfuehren{}    FI.{}END PROC dateioperation ausfuehren;{}
TEXT PROC operationsbezeichnung (INT CONST nr):{}  SELECT nr OF{}    CASE schreiben    : menubasistext (95){}    CASE checken      : menubasistext (97){}    CASE schreibcheck : menubasistext (99){}    CASE holen        : menubasistext (101){}    CASE loeschen     : menubasistext (103){}    OTHERWISE ""{}  END SELECT{}END PROC operationsbezeichnung;{}TEXT PROC operationskennzeichnung (INT CONST nr):{}  SELECT nr OF{}    CASE schreiben    : menubasistext (96){}    CASE checken      : menubasistext (98){}
    CASE schreibcheck : menubasistext (100){}    CASE holen        : menubasistext (102){}    CASE loeschen     : menubasistext (104){}    OTHERWISE ""{}  END SELECT{}END PROC operationskennzeichnung;{}BOOL PROC not empty (THESAURUS CONST t):{}  INT VAR i;{}  FOR i FROM 1 UPTO highest entry (t) REP{}    IF name (t, i) <> ""{}       THEN LEAVE not empty WITH TRUE{}    FI{}  PER;{}  FALSE{}END PROC not empty;{}TEXT PROC zieltaskhinweis:{}  IF   zieltaskname = "ARCHIVE"{}       THEN "(" + menubasistext (78) + ")"{}
  ELIF zieltaskname = name (father){}       THEN "(" + menubasistext (79) + ")"{}  ELSE menubasistext (80) + zieltaskname + ")"{}  FI{}END PROC zieltaskhinweis;{}PROC menu archiv verzeichnis:{}  forget("Interne Dateiliste bei Archivoperation", quiet);{}  ueberpruefe kommunikationsbasis;{}  liste dateien der zieltask auf;{}  regenerate menuscreen.{}  ueberpruefe kommunikationsbasis:{}    IF   unzulaessiger zieltaskname{}         THEN LEAVE menu archiv verzeichnis{}    ELIF zieltaskname = name (myself){}
         THEN LEAVE ueberpruefe kommunikationsbasis{}    ELIF zieltask ist archivmanager AND NOT archiv gehoert mir{}         THEN melde zieltaskerror (menubasistext (47));{}             LEAVE menu archiv verzeichnis{}    ELIF NOT zieltask ist archivmanager{}         THEN stelle kontakt mit zieltask her{}    FI.{}  stelle kontakt mit zieltask her:{}    TEXT VAR fehler :: "";{}    IF task ist kommunikativ (fehler){}       THEN kontakt mit zieltask erfolgt := TRUE{}       ELSE melde zieltaskerror (fehler);{}
            LEAVE menu archiv verzeichnis{}    FI.{}  liste dateien der zieltask auf:{}    erstelle liste;{}    gib liste aus;{}    forget ("Interne Dateiliste bei Archivoperation", quiet).{}  erstelle liste:{}    menufootnote (menubasistext (21) + menubasistext (28));{}    FILE VAR f :: sequential file (output, "Interne Dateiliste bei Archivoperation");{}    disable stop;{}    IF eigene station{}       THEN list (f, /zieltaskname){}       ELSE list (f, stationsnummer/zieltaskname){}    FI;{}    IF is error{}
       THEN melde zieltaskerror (errormessage);{}            forget ("Interne Dateiliste bei Archivoperation", quiet);{}            clear error; enable stop;{}            LEAVE menu archiv verzeichnis{}    FI;{}    enable stop.{}  gib liste aus:{}    modify (f);{}    IF NOT (zieltaskname = name (myself)){}       THEN to line (f, 1);{}            insert record (f);{}            notiere kopfzeile;{}            headline (f, menubasistext (43));{}       ELSE entferne eigenen namen aus der liste{}    FI;{}
    to line (f, 1);{}    cursor on; menuwindowshow (f); cursor off.{}  notiere kopfzeile:{}    IF zieltask ist archivmanager{}       THEN write record (f, headline (f));{}       ELSE write record (f, zieltaskbezeichnung){}    FI.{}  entferne eigenen namen aus der liste:{}    TEXT VAR zeile :: ""; INT VAR i;{}    FOR i FROM lines (f) DOWNTO 1 REP{}      to line (f, i);{}      read record (f, zeile);{}      IF pos (zeile, "Interne Dateiliste bei Archivoperation") > 0{}         THEN delete record (f);{}
              LEAVE entferne eigenen namen aus der liste{}      FI{}    PER{}END PROC menu archiv verzeichnis;{}PROC menu archiv verzeichnis drucken:{}  forget ("Interne Dateiliste bei Archivoperation", quiet);{}  ueberpruefe kommunikationsbasis;{}  erstelle listing;{}  drucke listing aus.{}  ueberpruefe kommunikationsbasis:{}    IF   unzulaessiger zieltaskname{}         THEN LEAVE menu archiv verzeichnis drucken{}    ELIF zieltaskname = name (myself){}         THEN LEAVE ueberpruefe kommunikationsbasis{}
    ELIF zieltask ist archivmanager AND NOT archiv gehoert mir{}         THEN melde zieltaskerror (menubasistext (47));{}             LEAVE menu archiv verzeichnis drucken{}    ELIF NOT zieltask ist archivmanager{}         THEN stelle kontakt mit zieltask her{}    FI.{}  stelle kontakt mit zieltask her:{}    TEXT VAR fehler :: "";{}    IF task ist kommunikativ (fehler){}       THEN kontakt mit zieltask erfolgt := TRUE{}       ELSE melde zieltaskerror (fehler);{}            LEAVE menu archiv verzeichnis drucken{}
    FI.{}  erstelle listing:{}    LET dummy name pos = 18;{}    FILE VAR listfile; INT VAR i; TEXT VAR record :: "";{}    TEXT CONST head :: 70 * "=", end :: 70 * "-";{}    IF menuno (menubasistext (90), 5){}       THEN LEAVE menu archiv verzeichnis drucken{}    FI;{}    menufootnote (menubasistext (21) + menubasistext (29));{}    disable stop;{}    listfile := sequential file (output, "Interne Dateiliste bei Archivoperation");{}    IF eigene station{}       THEN list (listfile, /zieltaskname){}       ELSE list (listfile, stationsnummer/zieltaskname){}
    FI;{}    IF is error{}       THEN melde zieltaskerror (errormessage);{}            forget ("Interne Dateiliste bei Archivoperation", quiet);{}            clear error; enable stop;{}            LEAVE menu archiv verzeichnis drucken{}    FI;{}    enable stop.{}  drucke listing aus:{}    schreibe dateikopf;{}    loesche dummy names;{}    schreibe fuss;{}    drucke und loesche listing.{}  schreibe dateikopf:{}    modify (listfile);{}    to line (listfile, 1);{}    FOR i FROM 1 UPTO 6 REP insert record (listfile) PER;{}
    to line (listfile, 1);{}    write record (listfile, "#type (""elanlist"")#"); down (listfile);{}    write record (listfile, "#start (2.5,0.0)##limit (20,5)#"{}                            + "#pagelength (26.0)#"); down (listfile);{}    write record (listfile, head); down (listfile);{}    schreibe erkennungszeile; down (listfile);{}    write record (listfile, "        Listing vom " + date + ",  "{}                            + time of day + " Uhr"); down (listfile);{}    write record (listfile, head).{}
  schreibe erkennungszeile:{}    IF zieltask ist archivmanager{}       THEN write record (listfile, "Archiv: " + headline (listfile)){}       ELSE write record (listfile, "Task  : " + taskbezeichnung){}    FI.{}  taskbezeichnung:{}    IF eigene station{}       THEN zieltaskname{}       ELSE text (stationsnummer) + "/" + zieltaskname{}    FI.{}  loesche dummy names:{}    to line (listfile, 8);{}    WHILE NOT eof (listfile) REP{}      read record (listfile, record);{}      IF (record SUB dummy name pos) = "-"{}
         OR pos (record, "Interne Dateiliste bei Archivoperation") > 0{}         THEN delete record (listfile){}         ELSE down (listfile){}      FI{}    PER.{}  schreibe fuss:{}    output (listfile);{}    putline (listfile, end).{}  drucke und loesche listing:{}    menufootnote (menubasistext (21) + menubasistext (30));{}    disable stop;{}    print ("Interne Dateiliste bei Archivoperation");{}    IF is error{}       THEN melde zieltaskerror (errormessage);{}            clear error; enable stop;{}
            forget ("Interne Dateiliste bei Archivoperation", quiet);{}            LEAVE menu archiv verzeichnis drucken{}    FI;{}    enable stop;{}    forget ("Interne Dateiliste bei Archivoperation", quiet){}END PROC menu archiv verzeichnis drucken;{}TEXT PROC zieltaskbezeichnung:{}  IF eigene station{}     THEN menubasistext (77) + taskbezeichnung{}     ELSE menubasistext (76) + text (stationsnummer) + "   " +{}          menubasistext (77) + zieltaskname{}  FI.{}  taskbezeichnung:{}    IF   zieltaskname = "ARCHIVE"{}
         THEN menubasistext (78){}    ELIF zieltaskname = name (father){}         THEN menubasistext (79) + " (" + zieltaskname + ")"{}         ELSE zieltaskname{}    FI{}END PROC zieltaskbezeichnung;{}BOOL PROC unzulaessiger zieltaskname:{}  IF compress (zieltaskname) = "" OR compress (zieltaskname) = "-"{}     THEN TRUE{}     ELSE FALSE{}  FI{}END PROC unzulaessiger zieltaskname;{}PROC menu archiv initialisieren:{}  TEXT VAR archivname :: "", meldung :: "";{}  klaere zieltaskart;{}  formatiere ggf;{}
  initialisiere ggf.{}  klaere zieltaskart:{}    IF NOT zieltask ist archivmanager{}       THEN menuinfo (menubasistext (121) + zieltaskname +{}                      menubasistext (122));{}            LEAVE menu archiv initialisieren{}    FI.{}  formatiere ggf:{}    IF menuyes (menubasistext (85), 5){}       THEN nimm archiv in beschlag;{}            fuehre formatierung aus{}    FI.{}  nimm archiv in beschlag:{}    stelle archivbesitz sicher;{}    IF aktueller archivname <> ""{}       THEN archivname := aktueller archivname{}
       ELSE archivname := menubasistext (75){}    FI;{}    IF eigene station{}       THEN reserve (archivname,/zieltaskname){}       ELSE reserve (archivname, stationsnummer/zieltaskname){}    FI;{}    aktueller archivname := archivname;{}    archiv gehoert mir   := TRUE;{}    zieltask anzeigen.{}  stelle archivbesitz sicher:{}    IF NOT archiv gehoert mir OR NOT kontakt mit zieltask erfolgt{}           THEN versuche kommunikation;{}                versuche archiv zu reservieren (meldung);{}                werte meldung aus{}
    FI.{}  versuche kommunikation:{}    TEXT VAR fehler :: "";{}    IF NOT task ist kommunikativ (fehler){}       THEN melde zieltaskerror (fehler);{}            melde rigoros ab;{}            LEAVE menu archiv initialisieren{}       ELSE kontakt mit zieltask erfolgt := TRUE{}    FI.{}  werte meldung aus:{}    IF meldung <> ""{}       THEN melde zieltaskerror (meldung);{}            aktueller archivname := "";{}            zieltask anzeigen;{}            LEAVE menu archiv initialisieren{}    FI.{}
  fuehre formatierung aus:{}    INT VAR auswahl :: menualternative (menubasistext (54),{}                                        menubasistext (55),{}                                        menubasistext (56), 5, TRUE);{}    IF auswahl = 0{}       THEN LEAVE fuehre formatierung aus{}    FI;{}    IF auswahl > 100{}       THEN auswahl DECR 100{}    FI;{}    command dialogue (FALSE);{}    disable stop;{}    menufootnote (menubasistext (21) + menubasistext (27));{}    IF eigene station{}       THEN formatiere auf eigener station{}
       ELSE formatiere auf fremder station{}    FI;{}    IF is error{}       THEN melde zieltaskerror (errormessage);{}            clear error; enable stop;{}            command dialogue (TRUE);{}            LEAVE formatiere ggf{}       ELSE enable stop;{}            command dialogue (TRUE);{}            aktiviere gueltige archivmenupunkte;{}            refresh submenu;{}            zieltask anzeigen{}    FI.{}  formatiere auf eigener station:{}    IF auswahl < 5{}       THEN format (auswahl, /zieltaskname){}
       ELSE format (/zieltaskname){}    FI.{}  formatiere auf fremder station:{}     IF auswahl < 5{}       THEN format (auswahl, stationsnummer/zieltaskname){}       ELSE format (stationsnummer/zieltaskname){}    FI.{}  initialisiere ggf:{}    stelle archivbesitz sicher;{}    archiv anmelden (archivname, meldung, FALSE);{}    IF   archivname <> ""{}         THEN aktueller archivname := archivname;{}              archiv gehoert mir   := TRUE;{}              aktiviere gueltige archivmenupunkte;{}              refresh submenu;{}
              zieltask anzeigen;{}              frage nach ueberschreiben{}    ELIF meldung = menubasistext (63) OR meldung = menubasistext (62){}         THEN frage nach initialisieren{}    ELSE melde zieltaskerror (meldung);{}         aktueller archivname := "";{}         zieltask anzeigen;{}         LEAVE menu archiv initialisieren{}    FI.{}  frage nach ueberschreiben:{}    IF menuyes (menubasistext (86) + archivname + menubasistext (87), 5){}       THEN erfrage neuen namen und initialisiere{}
       ELSE LEAVE menu archiv initialisieren{}    FI.{}  frage nach initialisieren:{}    IF menuyes (menubasistext (88), 5){}       THEN erfrage neuen namen und initialisiere{}       ELSE LEAVE menu archiv initialisieren{}    FI.{}  erfrage neuen namen und initialisiere:{}    TEXT VAR neuer name := compress(menuanswer (menubasistext (89),{}                                                aktueller archivname, 5));{}    IF   neuer name <> ""{}         THEN archivname := neuer name{}    ELIF neuer name = "" AND archivname = ""{}
         THEN archivname := menubasistext (75){}    FI;{}    command dialogue (FALSE);{}    disable stop;{}    IF eigene station{}       THEN reserve (archivname, /zieltaskname);{}            clear (/zieltaskname){}       ELSE reserve (archivname, stationsnummer/zieltaskname);{}            clear (stationsnummer/zieltaskname){}    FI;{}    IF is error{}       THEN melde zieltaskerror (errormessage);{}            clear error; enable stop;{}            command dialogue (TRUE);{}            melde rigoros ab;{}
            archivreservierung aufgeben;{}            aktiviere gueltige archivmenupunkte;{}            refresh submenu;{}            zieltask anzeigen;{}            LEAVE menu archiv initialisieren{}       ELSE enable stop; command dialogue (TRUE);{}            aktueller archivname := archivname;{}            archiv gehoert mir   := TRUE;{}            aktiviere gueltige archivmenupunkte;{}            refresh submenu;{}            zieltask anzeigen{}    FI{}END PROC menu archiv initialisieren;{}PROC archive (TEXT CONST archive name,task, INT CONST station):{}
  call (reserve code, archive name, station/task){}END PROC archive;{}PROC menu archiv reservierung aufgeben:{}  IF archiv gehoert mir{}     THEN menufootnote (menubasistext (21) + menubasistext (22));{}          archivreservierung aufgeben;{}  FI;{}  erase menunotice;{}  old menufootnote{}END PROC menu archiv reservierung aufgeben;{}PROC archivreservierung aufgeben:{}  command dialogue (FALSE);{}  disable stop;{}  IF eigene station{}     THEN release (/zieltaskname){}     ELSE release (stationsnummer/zieltaskname);{}
  FI;{}  IF is error{}     THEN clear error{}  FI;{}  enable stop;{}  command dialogue (TRUE);{}  archiv gehoert mir   := FALSE;{}  aktueller archivname := ""{}END PROC archivreservierung aufgeben;{}BOOL PROC eigene station:{}  IF stationsnummer = 0 OR stationsnummer = station (myself){}     THEN TRUE{}     ELSE FALSE{}  FI{}END PROC eigene station;{}PROC aktiviere gueltige archivmenupunkte:{}  IF   zieltask ist archivmanager AND NOT archiv gehoert mir{}       THEN aktiviere nur grundfunktionen{}
  ELSE aktiviere alle momentan gueltigen punkte{}  FI.{}  aktiviere alle momentan gueltigen punkte:{}    IF letzte funktion = 11{}       THEN activate (1); activate (2);{}            activate (4); activate (5); activate (6); activate (7); activate (8);{}            activate (10); activate (11);{}            activate (13); activate (14);{}    ELIF letzte funktion = 6{}       THEN deactivate (1); deactivate (2);{}            activate (4); deactivate (5); deactivate (6); activate (7); activate (8);{}
            activate (10); activate (11);{}            deactivate (13); activate (14);{}    FI.{}  aktiviere nur grundfunktionen:{}     activate (1); deactivate (2);{}     deactivate (4); deactivate (5); deactivate (6); deactivate (7); deactivate (8);{}     deactivate (10); deactivate (11);{}     activate (13); activate (14).{}END PROC aktiviere gueltige archivmenupunkte;{}PROC zieltask anzeigen:{}  IF zieltask ist archivmanager{}     THEN schreibe taskname und archivname{}     ELSE schreibe taskname{}
  FI.{}  schreibe taskname:{}    write menunotice (menubasistext (59) + ""13"" + name der task, notizort).{}  schreibe taskname und archivname:{}    write menunotice (menubasistext (59) + ""13"" + name der task +{}                      ""13"" + menubasistext (60) + ""13"" + archivname,{}                      notizort).{}  name der task:{}    IF   zieltaskname = "ARCHIVE" AND eigene station{}         THEN " " + menubasistext (71){}    ELIF zieltaskname = "PUBLIC"  AND eigene station{}         THEN " " + menubasistext (72){}
    ELIF zieltaskname = name (father){}         THEN " " + menubasistext (73){}    ELSE " " + ggf gekuerzter zieltaskname{}    FI.{}  ggf gekuerzter zieltaskname:{}    TEXT VAR interner name;{}    IF eigene station{}       THEN interner name := zieltaskname;{}       ELSE interner name := text (stationsnummer) + "/" + zieltaskname{}    FI;{}    IF length (interner name) < 20{}       THEN ""15"" + interner name + " "14""{}       ELSE ""15"" + subtext (interner name, 1 , 18) + ".." + " "14""{}    FI.{}
  archivname:{}    IF NOT archiv gehoert mir OR aktueller archivname = ""{}       THEN " " + menubasistext (74){}       ELSE " "15"" + ggf gekuerzter archivname + " "14""{}    FI.{}  ggf gekuerzter archivname:{}    IF   eigene station AND length (aktueller archivname) > 20{}         THEN subtext (aktueller archivname, 1, 18) + ".."{}    ELIF NOT eigene station AND length (aktueller archivname) > 17{}         THEN subtext (aktueller archivname, 1, 15) + ".."{}    ELSE aktueller archivname{}    FI.{}
END PROC zieltask anzeigen;{}BOOL PROC task ist kommunikativ (TEXT VAR  fehler):{}  INT VAR antwort;{}  DATASPACE VAR dummy space := nilspace;{}    IF zieltask ist archivmanager{}       THEN schicke reservierungscode{}       ELSE schicke listcode{}    FI.{}  schicke reservierungscode:{}    disable stop;{}    IF eigene station{}       THEN pingpong (/zieltaskname, reserve code, dummy space, antwort);{}       ELSE pingpong (stationsnummer/zieltaskname, reserve code,{}                      dummy space, antwort){}
    FI;{}    werte antwort aus.{}  schicke listcode:{}    disable stop;{}    IF eigene station{}       THEN pingpong (/zieltaskname, list code, dummy space, antwort);{}       ELSE pingpong (stationsnummer/zieltaskname, list code,{}                      dummy space, antwort){}    FI;{}    werte antwort aus.{}  werte antwort aus:{}    IF is error{}       THEN clear error{}    FI;{}    BOUND TEXT VAR inhalt := dummy space;{}    enable stop;{}    IF   antwort  =   0 THEN fehler := ""{}    ELIF antwort  =  -1 THEN fehler := menubasistext (41){}
    ELIF antwort  =  -2 THEN fehler := menubasistext (42){}    ELSE fehler  := inhalt{}    FI;{}    forget (dummy space);{}    IF antwort = ack{}       THEN kontakt mit zieltask erfolgt := TRUE;  TRUE{}       ELSE kontakt mit zieltask erfolgt := FALSE; FALSE{}    FI{}END PROC task ist kommunikativ;{}END PACKET ls dialog 6;{}

