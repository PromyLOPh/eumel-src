PACKET ls mp bap 1  DEFINES                (*******************************) 
                                           (*                             *) 
       stdvoreinstellung der parameter,    (*         ls-MP BAP 1         *) 
       werkstueckdefinition,               (*         Version 1.1         *) 
       tastendefinition,                   (*                             *) 
       phasendefinition,                   (*   (c) 1987, 1988            *) 
       bewertungsschluessel,               (*       by Eva Latta-Weber    *) 
       werkstueckaufhaenger,               (*          Bielefeld          *) 
       tastenbezeichnung,                  (*                             *) 
       piepse,                             (*******************************) 
                                            
       mp bap einstellung anzeigen,         
       mp bap standardwerte,                
       mp bap breite des werkstuecks, 
       mp bap hoehe  des werkstuecks, 
       mp bap invers normal, 
       mp bap zeichensatz, 
       mp bap fehlerzeichen, 
       mp bap tastenbelegung, 
       mp bap anzahl arbeitsphasen, 
       mp bap dauer einer arbeitsphase, 
       mp bap pausendauer, 
       mp bap wertungsschluessel: 
 
LET maxspalten         =            70,{}    maxzeilen          =            14,{}    kleinster wert     =             1,{}    oben unten return  = ""3""10""13"",{}    punkt              =           "+",{}    punkt und zurueck  =        "+"8"",{}    piep               =         ""7"",{}    blank              =           " ";{}INT  VAR aktuelle werkstueckbreite,{}         aktuelle werkstueckhoehe,{}         kleinster aktueller zeichencode,{}         groesster aktueller zeichencode,{}         aktuelle anzahl der arbeitsphasen,{}
         aktuelle arbeitsphasendauer in minuten,{}         aktuelle pausendauer in minuten;{}TEXT VAR aktuelles fehlerzeichen,{}         nach rechts,{}         nach links,{}         nach oben,{}         nach unten,{}         ausbesserung,{}         naechstes;{}BOOL VAR inversdarstellung;{}ROW 11 REAL VAR bewertung;{}WINDOW VAR w1, w2, w3, w4;{}PROC stdvoreinstellung der parameter:{}  aktuelle werkstueckbreite               :=     15;{}  aktuelle werkstueckhoehe                :=     12;{}  kleinster aktueller zeichencode         :=     65;{}
  groesster aktueller zeichencode         :=     90;{}  aktuelle anzahl der arbeitsphasen       :=      3;{}  aktuelle arbeitsphasendauer in minuten  :=     10;{}  aktuelle pausendauer in minuten         :=      2;{}  aktuelles fehlerzeichen                 :=    "F";{}  nach rechts                             :=  ""2"";{}  nach links                              :=  ""8"";{}  nach oben                               :=  ""3"";{}  nach unten                              := ""10"";{}  ausbesserung                            :=  ""1"";{}
  naechstes                               := ""27"";{}  inversdarstellung                       :=  FALSE;{}  bewertung := ROW 11 REAL : (0.0, 0.1, 0.2, 0.3, 0.4, 0.5,{}                                   0.6, 0.7, 0.8, 0.9, 1.0){}END PROC stdvoreinstellung der parameter;{}PROC werkstueckdefinition (INT VAR breite, hoehe, kleinster, groesster,{}                           TEXT VAR fzeichen, BOOL VAR invers):{}  breite        := aktuelle werkstueckbreite;{}  hoehe         := aktuelle werkstueckhoehe;{}
  kleinster     := kleinster aktueller zeichencode;{}  groesster     := groesster aktueller zeichencode;{}  fzeichen      := aktuelles fehlerzeichen;{}  invers        := inversdarstellung{}END PROC werkstueckdefinition;{}PROC tastendefinition (TEXT VAR rechts, links, hoch, runter, aus, nach):{}  rechts        := nach rechts;{}  links         := nach links;{}  hoch          := nach oben;{}  runter        := nach unten;{}  aus           := ausbesserung;{}  nach          := naechstes{}END PROC tastendefinition;{}
PROC phasendefinition (INT VAR aphasenzahl, aphasendauer, pausendauer):{}  aphasenzahl   := aktuelle anzahl der arbeitsphasen;{}  aphasendauer  := aktuelle arbeitsphasendauer in minuten;{}  pausendauer   := aktuelle pausendauer in minuten{}END PROC phasendefinition;{}PROC bewertungsschluessel (ROW 11 REAL VAR schluessel):{}  INT VAR zeiger;{}  FOR zeiger FROM 1 UPTO 11 REP{}    schluessel [zeiger] := bewertung [zeiger]{}  PER{}END PROC bewertungsschluessel;{}PROC mp bap einstellung anzeigen:{}  aktuellen parameterzustand anzeigen;{}
  regenerate menuscreen{}END PROC mp bap einstellung anzeigen;{}PROC mp bap standardwerte:{}  standardwerte einstellen;{}  regenerate menuscreen{}END PROC mp bap standardwerte;{}PROC mp bap breite des werkstuecks:{}  breite des werkstuecks einstellen;{}  regenerate menuscreen{}END PROC mp bap breite des werkstuecks;{}PROC mp bap hoehe des werkstuecks:{}  hoehe des werkstuecks einstellen;{}  regenerate menuscreen{}END PROC mp bap hoehe des werkstuecks;{}PROC mp bap invers normal:{}  werkstueckdarstellung einstellen;{}
  regenerate menuscreen{}END PROC mp bap invers normal;{}PROC mp bap zeichensatz:{}  zeichensatz einstellen;{}  regenerate menuscreen{}END PROC mp bap zeichensatz;{}PROC mp bap fehlerzeichen:{}  fehlerzeichen veraendern;{}  regenerate menuscreen{}END PROC mp bap fehlerzeichen;{}PROC mp bap tastenbelegung:{}  tastaturbelegung einstellen;{}  regenerate menuscreen{}END PROC mp bap tastenbelegung;{}PROC mp bap anzahl arbeitsphasen:{}  anzahl der arbeitsphasen festlegen;{}  regenerate menuscreen{}END PROC mp bap anzahl arbeitsphasen;{}
PROC mp bap dauer einer arbeitsphase:{}  dauer einer arbeitsphase festlegen;{}  regenerate menuscreen{}END PROC mp bap dauer einer arbeitsphase;{}PROC mp bap pausendauer:{}  pausendauer festlegen;{}  regenerate menuscreen{}END PROC mp bap pausendauer;{}PROC mp bap wertungsschluessel:{}  wertungsschluessel veraendern;{}  regenerate menuscreen{}END PROC mp bap wertungsschluessel;{}PROC aktuellen parameterzustand anzeigen:{}  zeige die fenster;{}  fuelle die fenster mit inhalt;{}  gib hinweis aus.{}
  zeige die fenster:{}    w1 := window ( 2,  2, 37, 20);{}    w2 := window (41,  2, 38, 20);{}    w3 := window ( 1,  1, 79, 24);{}    page; show (w1); show (w2).{}  fuelle die fenster mit inhalt:{}    zeige inhalt fenster 1;{}    zeige inhalt fenster 2.{}  zeige inhalt fenster 1:{}    zeige eingestellte parameter an (w1).{}  zeige inhalt fenster 2:{}    gib bewertungsschluessel aus (w2).{}  gib hinweis aus:{}    out footnote (w3, anwendungstext (2)); pause.{}END PROC aktuellen parameterzustand anzeigen;{}
PROC zeige eingestellte parameter an (WINDOW VAR w):{}  zeige ueberschrift;{}  zeige werkstueckdefinition;{}  zeige tastenbelegung;{}  zeige simulationszeiten.{}  zeige ueberschrift:{}    cursor (w, 1,  1); out (w, center (w, invers (anwendungstext ( 1)))).{}  zeige werkstueckdefinition:{}    cursor (w, 2,  3); out (w, anwendungstext ( 6));{}                       out (w, text (aktuelle werkstueckbreite, 3));{}                       out (w, anwendungstext (28));{}    cursor (w, 2,  4); out (w, anwendungstext ( 7));{}
                       out (w, text (aktuelle werkstueckhoehe,  3));{}                       out (w, anwendungstext (28));{}    cursor (w, 2,  5); out (w, anwendungstext ( 8));{}                        IF inversdarstellung{}                           THEN out (w, anwendungstext (29)){}                           ELSE out (w, anwendungstext (30)){}                        FI;{}    cursor (w, 2,  6); out (w, anwendungstext ( 9));{}                       out (w, zeichensatz);{}    cursor (w, 2,  7); out (w, anwendungstext (10));{}
                       out (blank + aktuelles fehlerzeichen).{}  zeige tastenbelegung:{}    cursor (w, 2,  9); out (w, anwendungstext (11));{}                       out (w, tastenbezeichnung (nach rechts));{}    cursor (w, 2, 10); out (w, anwendungstext (12));{}                       out (w, tastenbezeichnung (nach links));{}    cursor (w, 2, 11); out (w, anwendungstext (13));{}                       out (w, tastenbezeichnung (nach oben));{}    cursor (w, 2, 12); out (w, anwendungstext (14));{}                       out (w, tastenbezeichnung (nach unten));{}
    cursor (w, 2, 13); out (w, anwendungstext (15));{}                       out (w, tastenbezeichnung (ausbesserung));{}    cursor (w, 2, 14); out (w, anwendungstext (16));{}                       out (w, tastenbezeichnung (naechstes)).{}  zeige simulationszeiten:{}    cursor (w, 2, 16); out (w, anwendungstext (17));{}                       out (w, text (aktuelle anzahl der arbeitsphasen, 4));{}    cursor (w, 2, 17); out (w, anwendungstext (18));{}                       out (w, text (aktuelle arbeitsphasendauer in minuten, 4));{}
                       out (w, anwendungstext (51));{}    cursor (w, 2, 18); out (w, anwendungstext (19));{}                       out (w, text (aktuelle pausendauer in minuten, 4));{}                       out (w, anwendungstext (51));{}    cursor (w, 2, 20); out (w, anwendungstext ( 5));{}                       out (w, gesamtdauerangabe).{}  zeichensatz:{}    blank + code (kleinster aktueller zeichencode) + "..." +{}            code (groesster aktueller zeichencode) + " ("  +{}            text (groesster aktueller zeichencode{}
                   - kleinster aktueller zeichencode + 1, 2) +{}            anwendungstext (28) + ")".{}  gesamtdauerangabe:{}    text ( arbeitsdauer + pausendauer, 4) + anwendungstext (51).{}  arbeitsdauer:{}      aktuelle anzahl der arbeitsphasen{}    * aktuelle arbeitsphasendauer in minuten.{}  pausendauer:{}      (aktuelle anzahl der arbeitsphasen - 1){}    * aktuelle pausendauer in minuten.{}END PROC zeige eingestellte parameter an;{}PROC gib bewertungsschluessel aus (WINDOW VAR w):{}  zeichne koordinatenkreuz;{}
  trage messwerte ein.{}  zeichne koordinatenkreuz:{}    cursor (w, 1,  1); out (w, center (w, invers (anwendungstext ( 4))));{}    cursor (w, 2,  3); out (w, anwendungstext (20));{}    cursor (w, 2,  4); out (w, anwendungstext (21));{}    cursor (w, 2,  6); out (w, anwendungstext (23));{}    cursor (w, 2,  7); out (w, anwendungstext (22));{}    cursor (w, 2,  8); out (w, anwendungstext (22));{}    cursor (w, 2,  9); out (w, anwendungstext (22));{}    cursor (w, 2, 10); out (w, anwendungstext (22));{}
    cursor (w, 2, 11); out (w, anwendungstext (24));{}    cursor (w, 2, 12); out (w, anwendungstext (22));{}    cursor (w, 2, 13); out (w, anwendungstext (22));{}    cursor (w, 2, 14); out (w, anwendungstext (22));{}    cursor (w, 2, 15); out (w, anwendungstext (22));{}    cursor (w, 2, 16); out (w, anwendungstext (25));{}    cursor (w, 2, 17); out (w, anwendungstext (26));{}    cursor (w, 2, 19); out (w, anwendungstext (27)).{}  trage messwerte ein:{}    INT CONST abszisse :: 16, ordinate :: 2;{}
    INT VAR nr;{}    FOR nr FROM 1 UPTO 11 REP{}      zeichne einen punkt{}    PER.{}  zeichne einen punkt:{}    cursor (w, ordinate + 3 * nr, abszisse - nachkommastelle); out (punkt).{}  nachkommastelle:{}    int(bewertung [nr] * 10.0).{}END PROC gib bewertungsschluessel aus;{}PROC standardwerte einstellen:{}  zeige fenster;{}  zeige eingestellte parameter an (w1);{}  gib information aus;{}  hole bestaetigung ein.{}  zeige fenster:{}    w1 := window ( 2,  2, 37, 20);{}    w2 := window (41, 10, 37, 12);{}
    w3 := window (41,  2, 37,  6);{}    page; show (w1); show (w2); show (w3).{}  gib information aus:{}    cursor (w2, 1, 1); out (w2, center (w2, invers (anwendungstext (52))));{}    cursor (w2, 2, 3); out (w2, anwendungstext (67));{}    cursor (w2, 2, 4); out (w2, anwendungstext (68));{}    cursor (w2, 2, 7); out (w2, anwendungstext (69));{}    cursor (w2, 2, 9); out (w2, anwendungstext (70));{}    cursor (w2, 2,10); out (w2, anwendungstext (71));{}    cursor (w2, 2,11); out (w2, anwendungstext (72));{}
    cursor (w2, 2,12); out (w2, anwendungstext (73)).{}  hole bestaetigung ein:{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (66))));{}    cursor (w3, 2, 3);{}    IF yes (w3, anwendungstext (66)){}       THEN stdvoreinstellung der parameter;{}            gib positive rueckmeldung{}    FI.{}  gib positive rueckmeldung:{}    page (w1);{}    zeige eingestellte parameter an (w1);{}    cleop  (w3, 2, 3); out (anwendungstext (221));{}    cursor (w3, 2, 5); out (anwendungstext (  3));{}
    pause.{}END PROC standardwerte einstellen;{}PROC breite des werkstuecks einstellen:{}  zeige die fenster;{}  hinweise an den benutzer ausgeben;{}  werkstueck zeigen (w3);{}  erfrage veraenderung;{}  REP{}    neuen wert vom bildschirm holen{}  UNTIL benutzer ist einverstanden PER.{}  zeige die fenster:{}    w1 := window ( 2, 2, 26, 6);{}    w2 := window (30, 2, 48, 6);{}    w3 := window (2, 9, 77, 16);{}    page; show (w1); show (w2).{}  hinweise an den benutzer ausgeben:{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (52))));{}
    cursor (w1, 2, 3); out (w1, anwendungstext (53));{}                       out (w1, text (kleinster wert, 3));{}    cursor (w1, 2, 4); out (w1, anwendungstext (54));{}                       out (w1, text (maxspalten,     3));{}    cursor (w1, 2, 6); out (w1, anwendungstext (55));{}                       out (w1, text (aktuelle werkstueckbreite, 3)).{}  erfrage veraenderung:{}    cursor (w2, 1, 1); out (w2, center (w2, invers (anwendungstext (57))));{}    cursor (w2, 2, 3);{}    IF no (anwendungstext (216)){}
       THEN LEAVE breite des werkstuecks einstellen{}    FI.{}  neuen wert vom bildschirm holen:{}    cleop  (w2, 2, 3); out (w2, anwendungstext (58));{}    cursor (w2, 2, 4); out (w2, anwendungstext (59));{}    cursor (w2, 2, 6); out (w2, anwendungstext (60));{}    aktuelle werkstueckbreite := ermittelter wert (1, maxspalten,{}                                                aktuelle werkstueckbreite).{}  benutzer ist einverstanden :{}    gib aktuelle infos aus;{}    hole bestaetigung.{}  gib aktuelle infos aus:{}
    hinweise an den benutzer ausgeben;{}    werkstueck zeigen (w3);{}    cleop (w2, 1, 3).{}  hole bestaetigung:{}    cursor (w2, 2, 3);{}    IF yes (w2, anwendungstext (62)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC breite des werkstuecks einstellen;{}PROC hoehe des werkstuecks einstellen:{}  fenster zeigen;{}  hinweise an den benutzer ausgeben;{}  werkstueck zeigen (w3);{}  erfrage veraenderung;{}  REP{}    neuen wert vom bildschirm holen{}  UNTIL benutzer ist einverstanden PER.{}
  fenster zeigen:{}    w1 := window ( 2, 2, 26, 6);{}    w2 := window (30, 2, 48, 6);{}    w3 := window (2, 9, 77, 16);{}    page; show (w1); show (w2).{}  hinweise an den benutzer ausgeben:{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (52))));{}    cursor (w1, 2, 3); out (w1, anwendungstext (53));{}                       out (w1, text (kleinster wert, 3));{}    cursor (w1, 2, 4); out (w1, anwendungstext (54));{}                       out (w1, text (maxzeilen,      3));{}    cursor (w1, 2, 6); out (w1, anwendungstext (55));{}
                       out (w1, text (aktuelle werkstueckhoehe, 3)).{}  erfrage veraenderung:{}    cursor (w2, 1, 1); out (w2, center (w2, invers (anwendungstext (63))));{}    cursor (w2, 2, 3);{}    IF no (anwendungstext (217)){}       THEN LEAVE hoehe des werkstuecks einstellen{}    FI.{}  neuen wert vom bildschirm holen:{}    cleop  (w2, 2, 3); out (w2, anwendungstext (58));{}    cursor (w2, 2, 4); out (w2, anwendungstext (59));{}    cursor (w2, 2, 6); out (w2, anwendungstext (64));{}    aktuelle werkstueckhoehe := ermittelter wert (1, maxzeilen,{}
                                                  aktuelle werkstueckhoehe).{}  benutzer ist einverstanden :{}    gib aktuelle infos aus;{}    hole bestaetigung.{}  gib aktuelle infos aus:{}    hinweise an den benutzer ausgeben;{}    werkstueck zeigen (w3);{}    cleop (w2, 1, 3).{}  hole bestaetigung:{}    cursor (w2, 2, 3);{}    IF yes (w2, anwendungstext (65)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC hoehe des werkstuecks einstellen;{}PROC werkstueckdarstellung einstellen:{}  fenster zeigen;{}
  hinweise an den benutzer ausgeben;{}  werkstueck zeigen (w3);{}  REP{}    bestaetigung einholen;{}    hinweise an den benutzer ausgeben;{}    werkstueck zeigen (w3){}  UNTIL benutzer ist einverstanden PER.{}  fenster zeigen:{}    w1 := window ( 2,  2, 28,  6);{}    w2 := window (32,  2, 46,  6);{}    w3 := window ( 2,  9, 77, 16);{}    page; show (w1); show (w2).{}  hinweise an den benutzer ausgeben:{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (52))));{}    cursor (w1, 2, 3); out (w1, anwendungstext (74));{}
                       out (w1, anwendungstext (76));{}    cursor (w1, 2, 4); out (w1, anwendungstext (74));{}                       out (w1, anwendungstext (77));{}    cursor (w1, 2, 6); out (w1, anwendungstext (75));{}                       IF inversdarstellung{}                          THEN out (w1, anwendungstext (77)){}                          ELSE out (w1, anwendungstext (76)){}                       FI.{}  bestaetigung einholen:{}    page (w2);{}    cursor (w2, 1, 1); out (w2, center (w2, invers (anwendungstext (89))));{}
    cursor (w2, 2, 3);{}    IF yes (w2, anwendungstext (78)){}       THEN veraendere darstellungsart{}       ELSE LEAVE werkstueckdarstellung einstellen{}    FI.{}  veraendere darstellungsart:{}    IF inversdarstellung{}       THEN inversdarstellung := FALSE{}       ELSE inversdarstellung := TRUE{}    FI.{}  benutzer ist einverstanden:{}    cleop (w2, 1, 3);{}    cursor (w2, 2, 3);{}    IF yes (w2, anwendungstext (99)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC werkstueckdarstellung einstellen;{}
PROC zeichensatz einstellen:{}  zeige fenster;{}  gib eingestellten zeichensatz an;{}  gib bedienhinweise aus;{}  erfrage neueinstellung;{}  REP{}    erfrage das neue fehlerzeichen;{}    ermittle das kleinste zeichen;{}    ermittle das groesste zeichen;{}    page (w1);{}    gib eingestellten zeichensatz an{}  UNTIL benutzer ist einverstanden PER.{}  zeige fenster:{}    w1 := window ( 2,  2, 28, 22);{}    w2 := window (32, 10, 46, 14);{}    w3 := window (32,  2, 46,  6);{}    page; show (w1); show (w2); show (w3).{}
  gib eingestellten zeichensatz an:{}    cursor (w1, 1, 1);{}    out (w1, center (w1, invers (anwendungstext (79))));{}    gib zeichenkette aus (w1, kleinster aktueller zeichencode,{}                              groesster aktueller zeichencode,{}                              code (aktuelles fehlerzeichen)).{}  gib bedienhinweise aus:{}    cursor (w2, 1, 1); out (w2, center (w2, invers (anwendungstext (52))));{}    cursor (w2, 2, 3); out (w2, anwendungstext (80));{}    cursor (w2, 2, 4); out (w2, anwendungstext (81));{}
    cursor (w2, 2, 5); out (w2, anwendungstext (82));{}    cursor (w2, 2, 6); out (w2, anwendungstext (83));{}    cursor (w2, 2, 8); out (w2, anwendungstext (84));{}    cursor (w2, 2, 9); out (w2, anwendungstext (85));{}    cursor (w2, 2,10); out (w2, anwendungstext (86));{}    cursor (w2, 2,12); out (w2, anwendungstext (87));{}    cursor (w2, 2,13); out (w2, anwendungstext (88)).{}  erfrage neueinstellung:{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (90))));{}    cursor (w3, 2, 3);{}
    IF no (w3, anwendungstext (91)){}       THEN LEAVE zeichensatz einstellen{}    FI.{}  erfrage das neue fehlerzeichen:{}    gib vollstaendigen zeichensatz aus;{}    gib fehlerzeicheninformationen aus;{}    REP{}      lasse fehlerzeichen eingeben{}    UNTIL fehlerzeichen ist ok PER.{}  gib vollstaendigen zeichensatz aus:{}    page (w1); page (w2); page (w3);{}    cursor (w1, 1, 1);{}    out (w1, center (w1, invers (anwendungstext (92))));{}    gib zeichenkette aus (w1, 33, 126, 0).{}  gib fehlerzeicheninformationen aus:{}
    cursor (w2, 1, 1);{}    out (w2, center (w2, invers (anwendungstext (52))));{}    cursor (w2, 2, 3);  out (w2, anwendungstext (95));{}    cursor (w2, 2, 4);  out (w2, anwendungstext (96));{}    cursor (w2, 2, 6);  out (w2, anwendungstext (97)).{}  lasse fehlerzeichen eingeben:{}    cursor (w3, 1, 1);{}    out (w3, center (w3, invers (anwendungstext (100))));{}    cursor (w3, 2, 3);{}    out (w3, anwendungstext (101));{}    cursor on; inchar (aktuelles fehlerzeichen); cursor off;{}    IF fehlerzeichen ist ok{}
       THEN out (w3, aktuelles fehlerzeichen);{}            markiere das fehlerzeichen im ersten fenster;{}       ELSE lege beschwerde ein{}    FI.{}  fehlerzeichen ist ok:{}        code (aktuelles fehlerzeichen) >=  33{}    AND code (aktuelles fehlerzeichen) <= 126.{}  markiere das fehlerzeichen im ersten fenster:{}    positioniere cursor in zeichenkette (w1, 33, code (aktuelles fehlerzeichen));{}    out (w1, invers (aktuelles fehlerzeichen)).{}  lege beschwerde ein:{}    piepse;{}    cursor (w2, 2, 8); out (w2, anwendungstext (102));{}
    cursor (w2, 2,10); out (w2, anwendungstext (103));{}    cursor (w2, 2,11); out (w2, anwendungstext (104));{}    cursor (w2, 2,12); out (w2, anwendungstext (105));{}    cursor (w2, 2,13); out (w2, anwendungstext (106));{}    cursor (w2, 2,14); out (w2, anwendungstext (107)).{}  ermittle das kleinste zeichen:{}    page (w2); page (w3);{}    gib kleinste zeichencode informationen aus;{}    lasse den vorbereich festlegen.{}  ermittle das groesste zeichen:{}    lasse den nachbereich festlegen.{}  gib kleinste zeichencode informationen aus:{}
    cursor (w2, 1, 1);{}    out (w2, center (w2, invers (anwendungstext (52))));{}    cursor (w2, 2, 3); out (w2, anwendungstext (111));{}    cursor (w2, 2, 4); out (w2, anwendungstext (112));{}    cursor (w2, 2, 5); out (w2, anwendungstext (113));{}    cursor (w2, 2, 6); out (w2, anwendungstext (114));{}    cursor (w2, 2, 8); out (w2, anwendungstext (115));{}    cursor (w2, 2, 9); out (w2, anwendungstext (116));{}    cursor (w2, 2,10); out (w2, anwendungstext (117));{}    cursor (w2, 2,11); out (w2, anwendungstext (118));{}
    cursor (w2, 2,13); out (w2, anwendungstext (119));{}    cursor (w2, 2,14); out (w2, anwendungstext (120)).{}  lasse den vorbereich festlegen:{}    INT VAR s, z; page (w3); cursor (w3, 1, 1);{}    out (w3, center (w3, invers (anwendungstext (121))));{}    cursor (w3, 2, 3); out (w3, anwendungstext (122));{}    cursor (w3, 2, 4); out (w3, anwendungstext (123));{}    cursor (w3, 2, 5); out (w3, anwendungstext (125));{}    get cursor (s, z); cursor on;{}    kleinster aktueller zeichencode := code (aktuelles fehlerzeichen);{}
    groesster aktueller zeichencode := code (aktuelles fehlerzeichen);{}    kleinster aktueller zeichencode := eingabe mit intervallanzeige ( w1, 33,{}                                       code (aktuelles fehlerzeichen),{}                                       kleinster aktueller zeichencode, s, z);{}    cursor off.{}  lasse den nachbereich festlegen:{}    cursor (w3, 1, 1);{}    out (w3, center (w3, invers (anwendungstext (121))));{}    cursor (w3, 2, 3); out (w3, anwendungstext (122));{}    cursor (w3, 2, 4); out (w3, anwendungstext (124));{}
    cursor (w3, 2, 5); out (w3, anwendungstext (125));{}    get cursor (s, z); cursor on;{}    groesster aktueller zeichencode := eingabe mit intervallanzeige ( w1,{}                                       code (aktuelles fehlerzeichen), 126,{}                                       groesster aktueller zeichencode, s, z);{}    cursor off.{}  benutzer ist einverstanden:{}    page (w3); cursor (w3, 1, 1);{}    out (w3, center (w3, invers (anwendungstext (90))));{}    cursor (w3, 2, 3);{}    IF yes (w3, anwendungstext (126)){}
       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC zeichensatz einstellen;{}PROC fehlerzeichen veraendern:{}  fenster zeigen;{}  gib eingestellten zeichensatz an;{}  gib bedienhinweise aus;{}  erfrage neueinstellung;{}  REP{}    lasse fehlerzeichen einstellen{}  UNTIL benutzer ist einverstanden PER.{}  fenster zeigen:{}    w1 := window ( 2,  2, 28, 22);{}    w2 := window (32, 10, 46, 14);{}    w3 := window (32,  2, 46,  6);{}    page; show (w1); show (w2); show (w3).{}  gib eingestellten zeichensatz an:{}
    cursor (w1, 1, 1);{}    out (w1, center (w1, invers (anwendungstext (79))));{}    gib zeichenkette aus (w1, kleinster aktueller zeichencode,{}                              groesster aktueller zeichencode,{}                              code (aktuelles fehlerzeichen)).{}  gib bedienhinweise aus:{}    cursor (w2, 1, 1);{}    out (w2, center (w2, invers (anwendungstext (52))));{}    cursor (w2, 2, 3); out (w2, anwendungstext (131));{}    cursor (w2, 2, 4); out (w2, anwendungstext (132));{}    cursor (w2, 2, 5); out (w2, anwendungstext (133));{}
    cursor (w2, 2, 7); out (w2, anwendungstext (134));{}    cursor (w2, 2, 8); out (w2, anwendungstext (135));{}    cursor (w2, 2, 9); out (w2, anwendungstext (136)).{}  erfrage neueinstellung:{}    cursor (w3, 1, 1);{}    out (w3, center (w3, invers (anwendungstext (130))));{}    cursor (w3, 2, 3);{}    IF no (w3, anwendungstext (137)){}       THEN LEAVE fehlerzeichen veraendern{}    FI.{}  lasse fehlerzeichen einstellen:{}    INT VAR s, z, fehlercode :: code (aktuelles fehlerzeichen);{}    page (w3); cursor (w3, 1, 1);{}
    out (w3, center (w3, invers (anwendungstext (138))));{}    cursor (w3, 2, 3); out (w3, anwendungstext (139));{}    cursor (w3, 2, 4); out (w3, anwendungstext (140));{}    cursor (w3, 2, 5); out (w3, anwendungstext (141));{}    get cursor (s, z); cursor on;{}    fehlercode := eingabe mit elementanzeige (w1,{}                                              kleinster aktueller zeichencode,{}                                              groesster aktueller zeichencode,{}                                              fehlercode, s, z);{}
    cursor off;{}    aktuelles fehlerzeichen := code (fehlercode).{}  benutzer ist einverstanden:{}    page (w3); cursor (w3, 1, 1);{}    out (w3, center (w3, invers (anwendungstext (130))));{}    cursor (w3, 2, 3);{}    IF yes (w3, anwendungstext (142)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC fehlerzeichen veraendern;{}PROC tastaturbelegung einstellen:{}  ROW 6 TEXT VAR tastenname, taste;{}  fenster zeigen;{}  REP{}    tastaturneubelegung vornehmen{}  UNTIL benutzer ist einverstanden PER.{}
  fenster zeigen:{}    w1 := window ( 2,  2, 28, 10);{}    w2 := window ( 2, 14, 28, 10);{}    w3 := window (32, 10, 46, 14);{}    w4 := window (32,  2, 46,  6);{}    page; show (w1); show (w2); show (w3); show (w4).{}  tastaturneubelegung vornehmen:{}    alte tastenbelegung einlesen;{}    tastenbelegung anzeigen;{}    bedienhinweise ausgeben;{}    veraenderung erfragen;{}    neue tastenbelegung erfragen;{}    hinweis zur bewertung und stand ausgeben.{}  alte tastenbelegung einlesen:{}    INT VAR z1;{}
    FOR z1 FROM 1 UPTO 6 REP{}      tastenname [z1] := anwendungstext (z1 + 10){}    PER;{}    taste [1] := nach rechts;{}    taste [2] := nach links;{}    taste [3] := nach oben;{}    taste [4] := nach unten;{}    taste [5] := ausbesserung;{}    taste [6] := naechstes;{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (151)))).{}  tastenbelegung anzeigen:{}    INT VAR cspa, czei;{}    cursor (w1, 2, 3); out (w1, tastenname [1]);{}                       out (w1, tastenbezeichnung (taste [1]));{}
                       get cursor (w1, cspa, czei); cleol (w1, cspa, czei);{}    cursor (w1, 2, 4); out (w1, tastenname [2]);{}                       out (w1, tastenbezeichnung (taste [2]));{}                       get cursor (w1, cspa, czei); cleol (w1, cspa, czei);{}    cursor (w1, 2, 5); out (w1, tastenname [3]);{}                       out (w1, tastenbezeichnung (taste [3]));{}                       get cursor (w1, cspa, czei); cleol (w1, cspa, czei);{}    cursor (w1, 2, 6); out (w1, tastenname [4]);{}
                       out (w1, tastenbezeichnung (taste [4]));{}                       get cursor (w1, cspa, czei); cleol (w1, cspa, czei);{}    cursor (w1, 2, 8); out (w1, tastenname [5]);{}                       out (w1, tastenbezeichnung (taste [5]));{}                       get cursor (w1, cspa, czei); cleol (w1, cspa, czei);{}    cursor (w1, 2,10); out (w1, tastenname [6]);{}                       out (w1, tastenbezeichnung (taste [6]));{}                       get cursor (w1, cspa, czei); cleol (w1, cspa, czei).{}
  bedienhinweise ausgeben:{}    cursor (w2, 1, 1); out (center (w2, invers (anwendungstext (152))));{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (52))));{}    cursor (w3, 2, 3); out (w3, anwendungstext (153));{}    cursor (w3, 2, 4); out (w3, anwendungstext (154));{}    cursor (w3, 2, 6); out (w3, anwendungstext (155));{}    cursor (w3, 2, 7); out (w3, anwendungstext (156));{}    cursor (w3, 2, 8); out (w3, anwendungstext (157));{}    cursor (w3, 2, 9); out (w3, anwendungstext (158));{}
    cursor (w3, 2,11); out (w3, anwendungstext (159));{}    cursor (w3, 2,12); out (w3, anwendungstext (160));{}    cursor (w3, 2,13); out (w3, anwendungstext (161));{}    cursor (w3, 2,14); out (w3, anwendungstext (162)).{}  veraenderung erfragen:{}    cursor (w4, 1, 1); out (w4, center (w4, invers (anwendungstext (163))));{}    cursor (w4, 2, 3);{}    IF no (w4, anwendungstext (164)){}       THEN LEAVE tastaturbelegung einstellen{}    FI.{}  neue tastenbelegung erfragen:{}    INT VAR z2; page (w4);{}
    cursor (w4, 1, 1); out (w4, center (w4, invers (anwendungstext (163))));{}    cursor (w4, 2, 3); out (w4, anwendungstext (165));{}    FOR z2 FROM 1 UPTO 6 REP{}      gib tastenhinweis;{}      hole tastatureingabe;{}      tastenbelegung anzeigen{}    PER.{}  gib tastenhinweis:{}    cleol (w4, 2, 5); out (w4, tastenname [z2]).{}  hole tastatureingabe:{}    INT VAR s, z; get cursor (w4, s, z);{}    cursor on; inchar (taste [z2]); cursor off;{}    cursor (w4, s, z); out (w4, tastenbezeichnung (taste [z2])).{}
  hinweis zur bewertung und stand ausgeben:{}    IF neue tastenbelegung ist ok{}       THEN akzeptiere{}       ELSE akzeptiere nicht{}    FI.{}  neue tastenbelegung ist ok:{}    INT VAR zeiger; TEXT VAR tastenkette :: "";{}    FOR zeiger FROM 1 UPTO 6 REP{}      IF pos (tastenkette, taste [zeiger]) > 0{}         THEN LEAVE neue tastenbelegung ist ok WITH FALSE{}         ELSE tastenkette CAT taste [zeiger]{}      FI{}    PER;{}    TRUE.{}  akzeptiere:{}    cursor (w2, 3, 4);{}    out (w2, anwendungstext (166));{}
    cursor (w2, 7, 6);{}    out (w2, anwendungstext (167)).{}  akzeptiere nicht:{}    cursor (w2, 3, 3); out (w2, anwendungstext (168));{}    cursor (w2, 3, 4); out (w2, anwendungstext (169));{}    cursor (w2, 3, 6); out (w2, anwendungstext (170));{}    cursor (w2, 3, 7); out (w2, anwendungstext (171));{}    cursor (w2, 3, 9); out (w2, anwendungstext (172));{}    cursor (w2, 5,10); out (w2, anwendungstext (173)).{}  benutzer ist einverstanden:{}    page (w4);{}    cursor (w4, 1, 1); out (w4, center (w4, invers (anwendungstext (163))));{}
    IF neue tastenbelegung ist ok{}       THEN gib hinweis auf abspeicherung{}       ELSE frage nach neueingabe{}    FI.{}  gib hinweis auf abspeicherung:{}    cursor (w4, 3, 3); out (w4, anwendungstext (174));{}    neue tastenbelegung festschreiben;{}    cursor (w4, 3, 5); out (w4, anwendungstext (  2));{}    cursor on; pause; cursor off;{}    TRUE.{}  neue tastenbelegung festschreiben:{}    nach rechts   := taste [1];{}    nach links    := taste [2];{}    nach oben     := taste [3];{}    nach unten    := taste [4];{}
    ausbesserung  := taste [5];{}    naechstes     := taste [6].{}  frage nach neueingabe:{}    cursor (w4, 2, 3);{}    IF yes (w4, anwendungstext (175)){}       THEN cleop (w2, 1, 3); FALSE{}       ELSE alte tastenbelegung einlesen;{}            tastenbelegung anzeigen;{}            cleop  (w4, 2, 3); out (w4, anwendungstext (176));{}            cursor (w4, 3, 5); out (w4, anwendungstext (  2));{}            cursor on; pause; cursor off;{}            TRUE{}    FI.{}END PROC tastaturbelegung einstellen;{}
PROC simulationszeiten anzeigen (WINDOW VAR w):{}  cursor (w, 1, 1); out (w, center (w, invers (anwendungstext (181))));{}  cursor (w, 2, 3); out (w, anwendungstext (17));{}                    out (w, text (aktuelle anzahl der arbeitsphasen, 4));{}  cursor (w, 2, 4); out (w, anwendungstext (18));{}                    out (w, text (aktuelle arbeitsphasendauer in minuten, 4));{}                    out (w, anwendungstext (51));{}  cursor (w, 2, 5); out (w, anwendungstext (19));{}                    out (w, text (aktuelle pausendauer in minuten, 4));{}
                    out (w, anwendungstext (51));{}  cursor (w, 2, 7); out (w, anwendungstext ( 5));{}                       out (w, gesamtdauerangabe).{}  gesamtdauerangabe:{}    text ( arbeitsdauer + pausendauer, 4) + anwendungstext (51).{}  arbeitsdauer:{}      aktuelle anzahl der arbeitsphasen{}    * aktuelle arbeitsphasendauer in minuten.{}  pausendauer:{}      (aktuelle anzahl der arbeitsphasen - 1){}    * aktuelle pausendauer in minuten.{}END PROC simulationszeiten anzeigen;{}PROC anzahl der arbeitsphasen festlegen:{}
  INT CONST minwert :: 2, maxwert :: 20;{}  zeige fenster;{}    hinweise an den benutzer ausgeben;{}    simulationszeiten anzeigen (w2);{}    erfrage veraenderung;{}  REP{}    neuen wert vom bildschirm holen{}  UNTIL benutzer ist einverstanden PER.{}  zeige fenster:{}    w1 := window ( 2,  2, 28,  6);{}    w2 := window (22, 12, 37,  7);{}    w3 := window (32,  2, 47,  6);{}    page; show (w1); show (w2); show (w3).{}  hinweise an den benutzer ausgeben:{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (52))));{}
    cursor (w1, 2, 3); out (w1, anwendungstext (53));{}                       out (w1, text (minwert, 2));{}    cursor (w1, 2, 4); out (w1, anwendungstext (54));{}                       out (w1, text (maxwert, 2));{}    cursor (w1, 2, 6); out (w1, anwendungstext (55));{}                       out (w1, text (aktuelle anzahl der arbeitsphasen, 2)).{}  erfrage veraenderung:{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (182))));{}    cursor (w3, 2, 3);{}    IF no (anwendungstext (218)){}
       THEN LEAVE anzahl der arbeitsphasen festlegen{}    FI.{}  neuen wert vom bildschirm holen:{}    cleop  (w3, 2, 3); out (w3, anwendungstext ( 58));{}    cursor (w3, 2, 4); out (w3, anwendungstext ( 59));{}    cursor (w3, 2, 6); out (w3, anwendungstext (183));{}    aktuelle anzahl der arbeitsphasen := ermittelter wert (minwert, maxwert,{}                                         aktuelle anzahl der arbeitsphasen).{}  benutzer ist einverstanden:{}    hinweise an den benutzer ausgeben;{}    simulationszeiten anzeigen (w2);{}
    cleop (w3, 2, 3);{}    IF yes (w3, anwendungstext (184)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC anzahl der arbeitsphasen festlegen;{}PROC dauer einer arbeitsphase festlegen:{}  INT CONST minwert :: 1, maxwert :: 60;{}  zeige fenster;{}  hinweise an den benutzer ausgeben;{}  simulationszeiten anzeigen (w2);{}  erfrage veraenderung;{}  REP{}    neuen wert vom bildschirm holen{}  UNTIL benutzer ist einverstanden PER.{}  zeige fenster:{}    w1 := window ( 2,  2, 28,  6);{}    w2 := window (22, 12, 37,  7);{}
    w3 := window (32,  2, 47,  6);{}    page; show (w1); show (w2); show (w3).{}  hinweise an den benutzer ausgeben:{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (52))));{}    cursor (w1, 2, 3); out (w1, anwendungstext (53));{}                       out (w1, text (minwert, 2));{}                       out (w1, anwendungstext (51));{}    cursor (w1, 2, 4); out (w1, anwendungstext (54));{}                       out (w1, text (maxwert, 2));{}                       out (w1, anwendungstext (51));{}
    cursor (w1, 2, 6); out (w1, anwendungstext (55));{}                       out (w1, text (aktuelle arbeitsphasendauer in minuten, 2));{}                       out (w1, anwendungstext (51)).{}  erfrage veraenderung:{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (187))));{}    cursor (w3, 2, 3);{}    IF no (anwendungstext (219)){}       THEN LEAVE dauer einer arbeitsphase festlegen{}    FI.{}  neuen wert vom bildschirm holen:{}    INT VAR spa, zei;{}    cleop  (w3, 2, 3); out (w3, anwendungstext ( 58));{}
    cursor (w3, 2, 3); out (w3, anwendungstext ( 58));{}    cursor (w3, 2, 4); out (w3, anwendungstext ( 59));{}    cursor (w3, 2, 6); out (w3, anwendungstext (188));{}    get cursor (w3, spa, zei);{}    cursor (w3, spa + 3, zei); out (w3, anwendungstext (51));{}    cursor (w3, spa, zei);{}    aktuelle arbeitsphasendauer in minuten{}                               := ermittelter wert (minwert, maxwert,{}                                  aktuelle arbeitsphasendauer in minuten).{}  benutzer ist einverstanden:{}
    hinweise an den benutzer ausgeben;{}    simulationszeiten anzeigen (w2);{}    cleop (w3, 2, 3);{}    IF yes (w3, anwendungstext (189)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC dauer einer arbeitsphase festlegen;{}PROC pausendauer festlegen:{}  INT CONST minwert :: 1, maxwert :: 30;{}  zeige fenster;{}  hinweise an den benutzer ausgeben;{}  simulationszeiten anzeigen (w2);{}  erfrage veraenderung;{}  REP{}    neuen wert vom bildschirm holen{}  UNTIL benutzer ist einverstanden PER.{}
  zeige fenster:{}    w1 := window ( 2,  2, 28,  6);{}    w2 := window (22, 12, 37,  7);{}    w3 := window (32,  2, 47,  6);{}    page; show (w1); show (w2); show (w3).{}  hinweise an den benutzer ausgeben:{}    cursor (w1, 1, 1); out (w1, center (w1, invers (anwendungstext (52))));{}    cursor (w1, 2, 3); out (w1, anwendungstext (53));{}                       out (w1, text (minwert, 2));{}                       out (w1, anwendungstext (51));{}    cursor (w1, 2, 4); out (w1, anwendungstext (54));{}
                       out (w1, text (maxwert, 2));{}                       out (w1, anwendungstext (51));{}    cursor (w1, 2, 6); out (w1, anwendungstext (55));{}                       out (w1, text (aktuelle pausendauer in minuten, 2));{}                       out (w1, anwendungstext (51)).{}  erfrage veraenderung:{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (191))));{}    cursor (w3, 2, 3);{}    IF no (anwendungstext (220)){}       THEN LEAVE pausendauer festlegen{}    FI.{}
  neuen wert vom bildschirm holen:{}    INT VAR spa, zei;{}    cleop  (w3, 2, 3); out (w3, anwendungstext ( 58));{}    cursor (w3, 2, 4); out (w3, anwendungstext ( 59));{}    cursor (w3, 2, 6); out (w3, anwendungstext (192));{}    get cursor (w3, spa, zei);{}    cursor (w3, spa + 3, zei); out (w3, anwendungstext (51));{}    cursor (w3, spa, zei);{}    aktuelle pausendauer in minuten{}                               := ermittelter wert (minwert, maxwert,{}                                          aktuelle pausendauer in minuten).{}
  benutzer ist einverstanden:{}    hinweise an den benutzer ausgeben;{}    simulationszeiten anzeigen (w2);{}    cleop (w3, 2, 3);{}    IF yes (w3, anwendungstext (193)){}       THEN TRUE{}       ELSE FALSE{}    FI.{}END PROC pausendauer festlegen;{}PROC wertungsschluessel veraendern:{}  INT CONST abszisse :: 16, ordinate :: 2;{}  zeige fenster;{}  gib bewertungsschluessel aus (w1);{}  gib informationen aus;{}  stelle frage nach veraenderung;{}  REP{}    neueinstellung{}  UNTIL benutzer ist einverstanden PER.{}
  zeige fenster:{}    w1 := window ( 2,  2, 38, 22);{}    w2 := window (42, 10, 37, 14);{}    w3 := window (42,  2, 37,  6);{}    page; show (w1); show (w2); show (w3).{}  gib informationen aus:{}    cursor (w2, 1, 1); out (w2, center (w2, invers (anwendungstext (52))));{}    cursor (w2, 2, 3); out (w2, anwendungstext (195));{}    cursor (w2, 2, 4); out (w2, anwendungstext (196));{}    cursor (w2, 2, 6); out (w2, anwendungstext (197));{}    cursor (w2, 2, 7); out (w2, anwendungstext (198));{}    cursor (w2, 2, 8); out (w2, anwendungstext (199));{}
    cursor (w2, 2,11); out (w2, anwendungstext (200));{}    cursor (w2, 2,12); out (w2, anwendungstext (201));{}    cursor (w2, 2,13); out (w2, anwendungstext (202)).{}  stelle frage nach veraenderung:{}    cursor (w3, 1, 1); out (w3, center (w3, invers (anwendungstext (205))));{}    cursor (w3, 2, 3);{}    IF no (anwendungstext (206)){}       THEN LEAVE wertungsschluessel veraendern{}       ELSE gib hinweis auf linkes fenster{}    FI.{}  gib hinweis auf linkes fenster:{}    cleop  (w3, 2, 3); out (w3, anwendungstext (211));{}
    cursor (w3, 2, 4); out (w3, anwendungstext (212));{}    cursor (w3, 2, 5); out (w3, anwendungstext (213)).{}  neueinstellung:{}    INT VAR zeiger;{}    cursor an;{}    FOR zeiger FROM 1 UPTO 11 REP{}      gehe auf aktuelle punktposition;{}      lasse verschieben{}    PER;{}    cursor aus.{}  gehe auf aktuelle punktposition:{}    cursor (w1, ordinate + 3 * zeiger, abszisse - nachkommastelle).{}  nachkommastelle:{}    int (bewertung [zeiger] * 10.0).{}  lasse verschieben:{}    TEXT VAR eingabezeichen; INT VAR position;{}
    REP{}      inchar (eingabezeichen);{}      position := pos (oben unten return, eingabezeichen);{}      fuehre angemessene reaktion aus{}    UNTIL position = 3 PER.{}  fuehre angemessene reaktion aus:{}    SELECT position OF{}      CASE 1: steige auf{}      CASE 2: steige ab{}      CASE 3: (* tue nichts *){}      OTHERWISE piepse{}    END SELECT.{}  steige auf:{}    IF bewertung [zeiger] < 1.0{}       THEN loesche alten punkt;{}            bewertung [zeiger] INCR 0.1;{}            schreibe neuen punkt{}
       ELSE piepse{}    FI.{}  steige ab:{}    IF bewertung [zeiger] > 0.0{}       THEN loesche alten punkt;{}            bewertung [zeiger] DECR 0.1;{}            schreibe neuen punkt{}       ELSE piepse{}    FI.{}  loesche alten punkt:{}    INT VAR tabspalte, tabzeile;{}    gehe auf aktuelle punktposition;{}    get cursor (w1, tabspalte, tabzeile);{}    IF tabspalte = ordinate + 3 OR tabzeile = abszisse{}       THEN out (w1, "|"){}       ELSE out (w1, blank){}    FI.{}  schreibe neuen punkt:{}    gehe auf aktuelle punktposition;{}
    out (w1, punkt und zurueck).{}  benutzer ist einverstanden:{}    cleop (w3, 2, 3);{}    IF yes (w3, anwendungstext (207)){}       THEN TRUE{}       ELSE gib hinweis auf linkes fenster;{}            FALSE{}    FI.{}END PROC wertungsschluessel veraendern;{}PROC cleol (WINDOW VAR w, INT CONST cursorspalte, cursorzeile):{}  cursor (w, cursorspalte, cursorzeile);{}  IF remaining lines (w) > 1{}     THEN out (w, (areaxsize (w) - cursorspalte + 1) * blank){}     ELSE out (w, (areaxsize (w) - cursorspalte) * blank){}
  FI;{}  cursor (w, cursorspalte, cursorzeile){}END PROC cleol;{}PROC cleop (WINDOW VAR w, INT CONST cursorspalte, cursorzeile):{}  cleol (w, cursorspalte, cursorzeile);{}  INT VAR i;{}  FOR i FROM 1 UPTO remaining lines (w) REP{}    cleol (w, 1, cursorzeile + i){}  PER;{}  cursor  (w, cursorspalte, cursorzeile){}END PROC cleop;{}PROC cursor an:{}  INT VAR spalte, zeile;{}  get cursor (spalte, zeile); cursor on; cursor (spalte, zeile){}END PROC cursor an;{}PROC cursor aus:{}  INT VAR spalte, zeile;{}
  get cursor (spalte, zeile); cursor off; cursor (spalte, zeile){}END PROC cursor aus;{}INT PROC eingabe mit intervallanzeige (WINDOW VAR w, INT CONST minwert,{}                                       maxwert, anfangswert, cursorspalte,{}                                       cursorzeile):{}  BOOL VAR ist aufsteigend :: minwert = anfangswert;{}  INT  VAR aktueller wert  :: anfangswert, alter wert, eingelesener wert;{}  REP{}    hole position aus vorgabe (oben unten return, eingelesener wert);{}    SELECT eingelesener wert OF{}
      CASE 1: erniedrige aktuellen wert wenn moeglich{}      CASE 2: erhoehe aktuellen wert wenn moeglich{}    END SELECT{}  UNTIL eingelesener wert = 3 PER;{}  aktueller wert.{}  erniedrige aktuellen wert wenn moeglich:{}    IF aktueller wert > minwert{}       THEN alter wert := aktueller wert;{}            aktueller wert DECR 1;{}            IF ist aufsteigend{}               THEN loesche alte markierung{}               ELSE markiere neues zeichen{}            FI{}       ELSE piepse{}    FI.{}  erhoehe aktuellen wert wenn moeglich:{}
    IF aktueller wert < maxwert{}       THEN alter wert := aktueller wert;{}            aktueller wert INCR 1;{}            IF ist aufsteigend{}               THEN markiere neues zeichen{}               ELSE loesche alte markierung{}            FI{}       ELSE piepse{}    FI.{}  loesche alte markierung:{}    positioniere cursor in zeichenkette (w, 33, alter wert);{}    out (w, code (alter wert) + "  ");{}    cursor (cursorspalte, cursorzeile).{}  markiere neues zeichen:{}    positioniere cursor in zeichenkette (w, 33, aktueller wert);{}
    out (w, invers (code (aktueller wert)));{}    cursor (cursorspalte, cursorzeile).{}END PROC eingabe mit intervallanzeige;{}INT PROC eingabe mit elementanzeige (WINDOW VAR w, INT CONST minwert,{}                                     maxwert, anfangswert,{}                                     cursorspalte, cursorzeile):{}  INT VAR aktueller wert :: anfangswert, alter wert, eingelesener wert;{}  REP{}    hole position aus vorgabe (oben unten return, eingelesener wert);{}    SELECT eingelesener wert OF{}
      CASE 1: erniedrige aktuellen wert wenn moeglich{}      CASE 2: erhoehe aktuellen wert wenn moeglich{}    END SELECT{}  UNTIL eingelesener wert = 3 PER;{}  aktueller wert.{}  erniedrige aktuellen wert wenn moeglich:{}    IF aktueller wert > minwert{}       THEN alter wert := aktueller wert;{}            aktueller wert DECR 1;{}            loesche alte markierung;{}            markiere neues zeichen{}       ELSE piepse{}    FI.{}  erhoehe aktuellen wert wenn moeglich:{}    IF aktueller wert < maxwert{}
       THEN alter wert := aktueller wert;{}            aktueller wert INCR 1;{}            loesche alte markierung;{}            markiere neues zeichen{}       ELSE piepse{}    FI.{}  loesche alte markierung:{}    positioniere cursor in zeichenkette (w, minwert, alter wert);{}    out (w, code (alter wert) + "  ");{}    cursor (cursorspalte, cursorzeile).{}  markiere neues zeichen:{}    positioniere cursor in zeichenkette (w, minwert, aktueller wert);{}    out (w, invers (code (aktueller wert)));{}
    cursor (cursorspalte, cursorzeile).{}END PROC eingabe mit elementanzeige;{}PROC werkstueck zeigen (WINDOW VAR w):{}  INT VAR zaehler, spalte, zeile;{}  page (w);{}  werkstueckaufhaenger (spalte, zeile);{}  schreibe werkstueck zeilenweise.{}  schreibe werkstueck zeilenweise:{}    FOR zaehler FROM 1 UPTO aktuelle werkstueckhoehe REP{}      positioniere den cursor;{}      bastle eine zeile;{}      gib eine zeile aus{}    PER.{}  positioniere den cursor:{}    cursor (w, spalte,  zeile + zaehler - 1).{}
  bastle eine zeile:{}    TEXT VAR zeileninhalt := "";{}    INT VAR z;{}    FOR z FROM 1 UPTO aktuelle werkstueckbreite REP{}      zeileninhalt CAT code (random (kleinster aktueller zeichencode,{}                                     groesster aktueller zeichencode)){}    PER.{}  gib eine zeile aus:{}    IF inversdarstellung{}       THEN out (w, invers (zeileninhalt)){}       ELSE out (w, zeileninhalt){}    FI.{}END PROC werkstueck zeigen;{}PROC werkstueckaufhaenger (INT VAR spalte, zeile):{}  spalte := ((maxspalten - aktuelle werkstueckbreite) DIV 2) + 3;{}
  zeile  := ((maxzeilen  - aktuelle werkstueckhoehe ) DIV 2) + 2;{}  IF inversdarstellung THEN spalte DECR 1 FI{}END PROC werkstueckaufhaenger;{}PROC gib zeichenkette aus (WINDOW VAR w,{}                           INT CONST kleinster, groesster, markiertes):{}  INT VAR zaehler;{}  FOR zaehler FROM kleinster UPTO groesster REP{}    positioniere cursor in zeichenkette (w, kleinster, zaehler);{}    IF zaehler = markiertes{}       THEN out (w, invers (code (zaehler))){}       ELSE out (w, code (zaehler)){}
    FI{}  PER{}END PROC gib zeichenkette aus;{}PROC positioniere cursor in zeichenkette (WINDOW VAR w,{}                                          INT CONST mincode, position):{}  cursor (w, 4 + ((position - mincode) DIV 19) * 5,{}             3 + ((position - mincode) MOD 19)){}END PROC positioniere cursor in zeichenkette;{}TEXT PROC tastenbezeichnung (TEXT CONST zeichen):{}  IF code (zeichen) >= 33 AND code (zeichen) <= 126{}     THEN "<" + zeichen + ">"{}     ELSE umgesetzter code{}  FI.{}  umgesetzter code:{}
    SELECT code (zeichen) OF{}      CASE   1: anwendungstext (31){}      CASE   2: anwendungstext (32){}      CASE   3: anwendungstext (33){}      CASE   8: anwendungstext (34){}      CASE   9: anwendungstext (35){}      CASE  10: anwendungstext (36){}      CASE  11: anwendungstext (37){}      CASE  12: anwendungstext (38){}      CASE  13: anwendungstext (39){}      CASE  16: anwendungstext (40){}      CASE  27: anwendungstext (41){}      CASE  32: anwendungstext (42){}      CASE 214: anwendungstext (43){}
      CASE 215: anwendungstext (44){}      CASE 216: anwendungstext (45){}      CASE 217: anwendungstext (46){}      CASE 218: anwendungstext (47){}      CASE 219: anwendungstext (48){}      CASE 251: anwendungstext (49){}      OTHERWISE anwendungstext (50){}  END SELECT{}END PROC tastenbezeichnung;{}INT PROC ermittelter wert (INT CONST minimum, maximum, startwert):{}  INT VAR aktueller wert, eingelesener wert;{}  cursor an;{}  aktueller wert := startwert;{}  REP{}    gib dreistellig aus und positioniere zurueck (aktueller wert, FALSE);{}
    hole position aus vorgabe (oben unten return, eingelesener wert);{}    SELECT eingelesener wert OF{}      CASE 1: erhoehe aktuellen wert wenn moeglich{}      CASE 2: erniedrige aktuellen wert wenn moeglich{}    END SELECT{}  UNTIL eingelesener wert = 3 PER;{}  cursor aus;{}  aktueller wert.{}  erhoehe aktuellen wert wenn moeglich:{}    IF aktueller wert < maximum{}       THEN aktueller wert INCR 1{}       ELSE piepse{}    FI.{}  erniedrige aktuellen wert wenn moeglich:{}    IF aktueller wert > minimum{}
       THEN aktueller wert DECR 1{}       ELSE piepse{}    FI.{}END PROC ermittelter wert;{}PROC gib dreistellig aus und positioniere zurueck (INT CONST wert,{}                                                   BOOL CONST mit wertwandel):{}  INT VAR spalte, zeile; get cursor (spalte, zeile);{}  IF mit wertwandel{}     THEN out ("'" + code (wert) + "'"){}     ELSE out (text (wert, 3)){}  FI;{}  cursor (spalte, zeile);{}END PROC gib dreistellig aus und positioniere zurueck;{}PROC hole position aus vorgabe (TEXT CONST vorgabe, INT VAR position):{}
  TEXT VAR eingabezeichen; INT VAR spa, zei;{}  REP{}    get cursor (spa, zei); inchar (eingabezeichen); cursor (spa, zei);{}    position := pos (vorgabe, eingabezeichen);{}    IF position = 0 THEN piepse; cursor (spa, zei) FI{}  UNTIL position > 0 PER{}END PROC hole position aus vorgabe;{}PROC piepse:{}  INT VAR spa, zei; get cursor (spa, zei); out (piep); cursor (spa, zei){}END PROC piepse;{}END PACKET ls mp bap 1;{}stdvoreinstellung der parameter{}

