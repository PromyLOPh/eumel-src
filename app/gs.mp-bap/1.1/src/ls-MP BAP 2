PACKET ls mp bap 2  DEFINES                (*******************************) 
                                           (*                             *) 
  materialpruefung, mp,                    (*         ls-MP BAP 2         *) 
  bildschirmarbeitsplatz, bap,             (*         Version 1.1         *) 
                                           (*                             *) 
  mp bap simulation ausfuehren,            (*   (c) 1987, 1988            *) 
  mp bap auswertung auf bildschirm,        (*       by Eva Latta-Weber    *) 
  mp bap drucken von auswertungen,         (*          Bielefeld          *) 
                                           (*                             *) 
  mp bap protokollumfang festlegen,        (*******************************) 
  mp bap kurzauswertung, 
 
  druckereinstellung fuer protokolldatei, 
  stddruckereinstellung fuer protokolldatei: 
 
 
 
LET maxeintraege             =                    800, 
    protokolldateipraefix    =       "ls-Protokoll: ", 
    menukarte                =  "ls-MENUKARTE:MP-BAP", 
    menubezeichnung          =                  "BAP", 
    auswertdateipostfix      =        " - Auswertung", 
    protokolldateityp        =                   1955, 
    maxspalten               =                     70, 
    maxzeilen                =                     14,{}    blank                    =                    " ",{}    trenn                    =                    "|",{}    werkstueckendekennung    =                      1,{}    pausenendekennung        =                      2,{}    simulationsendekennung   =                      3,{}    markierung ein           =                 ""15"",{}    markierung aus           =                " "14"",{}    stdschrifttyp            =                     "",{}
    stdxstart                =                    0.0,{}    stdystart                =                    0.0,{}    stdfeldbreite            =                   21.0,{}    stdfeldlaenge            =                   29.5;{}LET  KONTROLLTABELLE = STRUCT (INT  letzter eintrag,{}                                    breite, hoehe,{}                                    kleinster code, groesster code,{}                                    anzahl aphasen, aphasendauer,{}                                    pausendauer,{}
                               TEXT datum, uhrzeit, fehlerzeichen,{}                                    nach rechts, nach links,{}                                    nach oben, nach unten,{}                                    ausbesserung, naechstes,{}                               BOOL inversdarstellung,{}                               ROW  11 REAL bewertung,{}                               ROW maxeintraege KONTROLLE tabelle),{}     KONTROLLE       = STRUCT (INT  eintragskennung,{}                                    produktionsfehler,{}
                                    anzahl korrekturen,{}                                    anzahl bedienfehler,{}                               REAL anfang, ende, differenz),{}     WERKSTUECK      = ROW maxspalten ROW maxzeilen INT;{}INT  VAR breite, hoehe, kleinster code, groesster code,{}         anzahl aphasen, aphasendauer, pausendauer,{}         eckspalte, eckzeile, x, y, xsize, ysize;{}TEXT VAR fehlerzeichen, nach rechts, nach links, nach oben, nach unten,{}         ausbesserung, naechstes, datum, uhrzeit;{}
TEXT VAR protokollschrifttyp :: stdschrifttyp;{}REAL VAR xstart              :: stdxstart,{}         ystart              :: stdystart,{}         schreibfeldbreite   :: stdfeldbreite,{}         schreibfeldlaenge   :: stdfeldlaenge;{}ROW 11 REAL VAR bewertung;{}BOOL VAR inversdarstellung,{}         kontrolldatei zur vatertask ::  TRUE,{}         mit kurzprotokoll           ::  TRUE,{}         mit anmerkungen             ::  TRUE,{}         auswertung geht zum drucker :: FALSE;{}WERKSTUECK VAR werkstueck;{}
PROC bildschirmarbeitsplatz:{}  kontrolldatei zur vatertask := FALSE;{}  install menu (menukarte);{}  handle menu  (menubezeichnung);{}END PROC bildschirmarbeitsplatz;{}PROC bap:{}  bildschirmarbeitsplatz{}END PROC bap;{}PROC materialpruefung:{}  TEXT VAR benutzerkennung :: "", protokollname, alter dateiname :: std;{}  install menu (menukarte, FALSE);{}  kontrolldatei zur vatertask := TRUE;{}  ermittle eingestellte parameter;{}  bereite den bildschirm vor;{}  ermittle die benutzerkennung;{}  gib benutzerhinweise aus;{}
  arbeitsplatzsimulation ausfuehren (benutzerkennung, protokollname);{}  forget (protokollname, quiet);{}  last param (alter dateiname).{}  bereite den bildschirm vor:{}    WINDOW VAR w :: window ( 2, 10, 77, 14);{}    page;{}    show (w);{}    out (w, center (w, anwendungstext (400))).{}  ermittle die benutzerkennung:{}    benutzerkennung := compress (boxanswer (w, anwendungstext (401), "", 5));{}    IF benutzerkennung = ""{}       THEN cursor on; page;{}            LEAVE materialpruefung{}    FI.{}
  gib benutzerhinweise aus:{}    boxinfo (w, anwendungstext (402));{}    boxinfo (w, anwendungstext (403));{}    boxinfo (w, anwendungstext (404));{}    gib bedieninformationen aus (2);{}    boxinfo (w, anwendungstext (405));{}    boxinfo (w, anwendungstext (406));{}    boxinfo (w, anwendungstext (407));{}    boxinfo (w, anwendungstext (408)).{}END PROC materialpruefung;{}PROC mp:{}  materialpruefung{}END PROC mp;{}PROC mp bap simulation ausfuehren:{}  TEXT VAR benutzerkennung :: "", dateiname;{}
  kontrolldatei zur vatertask := FALSE;{}  ermittle eingestellte parameter;{}  bereite den bildschirm vor;{}  ermittle die benutzerkennung;{}  arbeitsplatzsimulation ausfuehren (benutzerkennung, dateiname);{}  regenerate menuscreen.{}  bereite den bildschirm vor:{}    WINDOW VAR w :: window (2,2,77,22);{}    page;{}    out (w, center (w, anwendungstext (399))).{}  ermittle die benutzerkennung:{}    benutzerkennung := compress (boxanswer (w, anwendungstext (401), "", 5));{}    IF benutzerkennung = ""{}
       THEN regenerate menuscreen;{}            LEAVE mp bap simulation ausfuehren{}    FI.{}END PROC mp bap simulation ausfuehren;{}PROC mp bap auswertung auf bildschirm:{}  auswertung geht zum drucker := FALSE;{}  lasse protokolldateien auswaehlen;{}  werte protokolldateien aus;{}  regenerate menuscreen.{}  lasse protokolldateien auswaehlen:{}    THESAURUS VAR verfuegbare;{}    verfuegbare := infix namen (ALL myself, protokolldateipraefix,{}                                            protokolldateityp);{}
    IF NOT not empty (verfuegbare){}       THEN noch kein protokoll{}       ELSE biete auswahl an{}    FI.{}  noch kein protokoll:{}    regenerate menuscreen;{}    menuinfo (anwendungstext (424));{}    LEAVE mp bap auswertung auf bildschirm.{}  biete auswahl an:{}    verfuegbare := menusome (verfuegbare, anwendungstext (421),{}                             anwendungstext (422), FALSE).{}  werte protokolldateien aus:{}    INT VAR k;{}    steige ggf bei leerem thesaurus aus;{}    FOR k FROM 1 UPTO highest entry (verfuegbare) REP{}
      IF name (verfuegbare, k) <> ""{}         THEN disable stop;{}              gib hinweis auf auswertung;{}              simulationsauswertung (name (verfuegbare, k), TRUE);{}              forget (name (verfuegbare, k) + auswertdateipostfix, quiet);{}              fehlerbehandlung{}      FI{}    PER.{}  steige ggf bei leerem thesaurus aus:{}    IF NOT not empty (verfuegbare){}       THEN regenerate menuscreen;{}            menuinfo (anwendungstext (423));{}            LEAVE mp bap auswertung auf bildschirm{}
    FI.{}  gib hinweis auf auswertung:{}    page;{}    WINDOW VAR fenster :: window ( 2, 2, 77, 22);{}    show (fenster);{}    cursor (fenster, 1,  9); out (fenster, center (fenster, name (verfuegbare, k)));{}    cursor (fenster, 1, 12); out (fenster, center (anwendungstext (274))).{}  fehlerbehandlung:{}    IF is error{}       THEN regenerate menuscreen;{}            menuinfo (invers (errormessage));{}            clear error; enable stop;{}            LEAVE mp bap auswertung auf bildschirm{}    FI.{}
END PROC mp bap auswertung auf bildschirm;{}PROC mp bap drucken von auswertungen:{}  auswertung geht zum drucker := TRUE;{}  lasse protokolldateien auswaehlen;{}  werte protokolldateien aus;{}  regenerate menuscreen.{}  lasse protokolldateien auswaehlen:{}    THESAURUS VAR verfuegbare;{}    verfuegbare := infix namen (ALL myself, protokolldateipraefix,{}                                            protokolldateityp);{}    IF NOT not empty (verfuegbare){}       THEN noch kein protokoll{}       ELSE biete auswahl an{}
    FI.{}  noch kein protokoll:{}    regenerate menuscreen;{}    menuinfo (anwendungstext (424));{}    LEAVE mp bap drucken von auswertungen.{}  biete auswahl an:{}    verfuegbare := menusome (verfuegbare, anwendungstext (425),{}                             anwendungstext (422), FALSE).{}  werte protokolldateien aus:{}    INT VAR k;{}    steige ggf bei leerem thesaurus aus;{}    FOR k FROM 1 UPTO highest entry (verfuegbare) REP{}      IF name (verfuegbare, k) <> ""{}         THEN disable stop;{}              gib hinweis auf auswertung;{}
              simulationsauswertung (name (verfuegbare, k), FALSE);{}              print (name (verfuegbare, k) + auswertdateipostfix);{}              forget (name (verfuegbare, k) + auswertdateipostfix, quiet);{}              fehlerbehandlung{}      FI{}    PER.{}  steige ggf bei leerem thesaurus aus:{}    IF NOT not empty (verfuegbare){}       THEN regenerate menuscreen;{}            menuinfo (anwendungstext (423));{}            LEAVE mp bap drucken von auswertungen{}    FI.{}  gib hinweis auf auswertung:{}
    page;{}    WINDOW VAR fenster :: window ( 2, 2, 77, 22);{}    show (fenster);{}    cursor (fenster, 1,  9); out (fenster, center (fenster, name (verfuegbare, k)));{}    cursor (fenster, 1, 12); out (fenster, center (anwendungstext (270))).{}  fehlerbehandlung:{}    IF is error{}       THEN regenerate menuscreen;{}            menuinfo (invers (errormessage));{}            clear error; enable stop;{}            LEAVE mp bap drucken von auswertungen{}    FI.{}END PROC mp bap drucken von auswertungen;{}
PROC mp bap protokollumfang festlegen:{}  page;{}  zeige aktuellen protokollumfang an;{}  gib erlaeuterungen zum protokollumfang;{}  frage nach umfangsaenderung;{}  regenerate menuscreen{}END PROC mp bap protokollumfang festlegen;{}PROC mp bap kurzauswertung:{}  page;{}  zeige aktuelle kurzauswertungseinstellung an;{}  gib erlaeuterungen zur kurzauswertung;{}  frage nach kurzauswertungsaenderung;{}  regenerate menuscreen{}END PROC mp bap kurzauswertung;{}PROC druckereinstellung fuer protokolldatei (TEXT CONST schrifttyp,{}
                                             REAL CONST linker rand,{}                                                        oberer rand,{}                                                        feldbreite,{}                                                        feldlaenge):{}  protokollschrifttyp := schrifttyp;{}  xstart              := linker rand;{}  ystart              := oberer rand;{}  schreibfeldbreite   := feldbreite;{}  schreibfeldlaenge   := feldlaenge;{}END PROC druckereinstellung fuer protokolldatei;{}
PROC stddruckereinstellung fuer protokolldatei:{}  protokollschrifttyp := stdschrifttyp;{}  xstart              := stdxstart;{}  ystart              := stdystart;{}  schreibfeldbreite   := stdfeldbreite;{}  schreibfeldlaenge   := stdfeldlaenge{}END PROC stddruckereinstellung fuer protokolldatei;{}                 (********************************){}PROC arbeitsplatzsimulation ausfuehren (TEXT CONST kennung,{}                                        TEXT VAR   dateiname):{}  ermittle eingestellte parameter;{}
  lege datei mit kennung an (kennung, dateiname);{}  cursor on;{}  fuehre simulation durch (dateiname);{}  schicke ggf protokolldatei zur vatertask;{}  gib ggf kurzprotokoll aus.{}  schicke ggf protokolldatei zur vatertask:{}    IF kontrolldatei zur vatertask{}       THEN command dialogue (FALSE);{}            save (dateiname);{}            command dialogue (TRUE){}    FI.{}  gib ggf kurzprotokoll aus:{}    IF mit kurzprotokoll{}       THEN kurzauswertung auf bildschirm (dateiname){}       ELSE page; put (anwendungstext (271)){}
    FI.{}END PROC arbeitsplatzsimulation ausfuehren;{}PROC ermittle eingestellte parameter:{}  werkstueckdefinition (breite, hoehe, kleinster code, groesster code,{}                        fehlerzeichen, inversdarstellung);{}  tastendefinition     (nach rechts, nach links, nach oben, nach unten,{}                        ausbesserung, naechstes);{}  phasendefinition     (anzahl aphasen, aphasendauer, pausendauer);{}  bewertungsschluessel (bewertung);{}END PROC ermittle eingestellte parameter;{}PROC lege datei mit kennung an (TEXT CONST kennung, TEXT VAR datname):{}
  BOUND KONTROLLTABELLE VAR tab;{}  TEXT VAR interner name :: protokolldateipraefix;{}  interner name CAT kennung;{}  lege neue datei an;{}  type (old (datname), protokolldateityp).{}  lege neue datei an:{}    INT VAR i :: 0; TEXT VAR bezeichnung;{}    REP{}      i INCR 1;{}      bezeichnung := interner name + " /" + text (i){}    UNTIL NOT exists (bezeichnung) PER;{}    tab := new (bezeichnung);{}    initialisiere tabelle;{}    datname := bezeichnung.{}  initialisiere tabelle:{}    tab.letzter eintrag := 0.{}
END PROC lege datei mit kennung an;{}PROC fuehre simulation durch (TEXT CONST dateiname):{}  BOUND KONTROLLTABELLE VAR tab :: old (dateiname);{}  TEXT CONST moegliche eingabezeichen :: nach rechts  + nach links +{}                                         nach oben    + nach unten +{}                                         ausbesserung + naechstes;{}  treffe vorbereitungen;{}  trage grunddaten in tabelle;{}  simuliere.{}  treffe vorbereitungen:{}     initialisierungen;{}     WINDOW VAR fenster :: window (  1,  9, 79, 16);{}
     page;{}     gib bedieninformationen aus (2);{}     werkstueckaufhaenger (eckspalte, eckzeile);{}     weise auf arbeitsbeginn hin;{}     beginn der arbeitsphase      :=               clock (1);{}     beginn der bearbeitung       := beginn der arbeitsphase;{}     arbeitsphasenlaenge          := real (aphasendauer * 60).{}  initialisierungen:{}    INT  VAR eintragzaehler        :: 0,{}             arbeitsphasenzaehler  :: 1,{}             werkstueckzaehler     :: 0,{}             bedienfehlerzaehler   :: 0,{}
             korrekturzaehler      :: 0,{}             produktionsfehler,{}             cursorspalte relativ,{}             cursorzeile  relativ;{}    REAL VAR beginn der arbeitsphase,{}             beginn der bearbeitung,{}             arbeitsphasenlaenge,{}             arbeitsphasenueberziehung,{}             pausenueberziehung.{}  weise auf arbeitsbeginn hin:{}    page (fenster);{}    boxinfo (fenster, anwendungstext (252), 5, maxint);{}    clear buffer.{}  trage grunddaten in tabelle:{}    tab.datum               := date;{}
    tab.uhrzeit             := time of day;{}    tab.breite              := breite;{}    tab.hoehe               := hoehe;{}    tab.kleinster code      := kleinster code;{}    tab.groesster code      := groesster code;{}    tab.anzahl aphasen      := anzahl aphasen;{}    tab.aphasendauer        := aphasendauer;{}    tab.pausendauer         := pausendauer;{}    tab.fehlerzeichen       := fehlerzeichen;{}    tab.nach rechts         := nach rechts;{}    tab.nach links          := nach links;{}    tab.nach oben           := nach oben;{}
    tab.nach unten          := nach unten;{}    tab.ausbesserung        := ausbesserung;{}    tab.naechstes           := naechstes;{}    tab.inversdarstellung   := inversdarstellung;{}    tab.bewertung           := bewertung;{}    eintragzaehler          := 1.{}  simuliere:{}    REP{}      gib holehinweis;{}      hole werkstueck  (werkstueck, produktionsfehler);{}      zeige werkstueck (werkstueck, fenster);{}      lasse werkstueck bearbeiten{}    UNTIL simulationsende erreicht PER.{}  gib holehinweis:{}
    page (fenster);{}    cursor (fenster, 2, 3); out (fenster, anwendungstext (253)).{}  lasse werkstueck bearbeiten:{}    initialisiere den relativcursor;{}    setze cursor;{}    clear buffer;{}    bearbeite das werkstueck.{}  initialisiere den relativcursor:{}    cursorspalte relativ := 1;{}    cursorzeile relativ  := 1.{}  setze cursor:{}    IF inversdarstellung{}       THEN cursor (fenster, eckspalte + cursorspalte relativ,{}                             eckzeile  + cursorzeile  relativ - 1);{}
       ELSE cursor (fenster, eckspalte + cursorspalte relativ - 1,{}                             eckzeile  + cursorzeile  relativ - 1);{}    FI.{}  bearbeite das werkstueck:{}    BOOL VAR werkstueck voll bearbeitet :: FALSE;{}    REP{}      hole eingabe und werte aus{}    UNTIL werkstueck voll bearbeitet PER.{}  hole eingabe und werte aus:{}    TEXT VAR eingabezeichen := incharety (100);{}    SELECT eingabezeichenposition OF{}      CASE 1: wenn moeglich nach rechts{}      CASE 2: wenn moeglich nach links{}
      CASE 3: wenn moeglich nach oben{}      CASE 4: wenn moeglich nach unten{}      CASE 5: wenn moeglich ausbessern{}      CASE 6: beende werkstueckbearbeitung{}      OTHERWISE entscheide ob gepiepst wird{}    END SELECT.{}  eingabezeichenposition:{}    pos (moegliche eingabezeichen, eingabezeichen).{}  wenn moeglich nach rechts:{}    IF cursorspalte relativ < breite{}       THEN cursorspalte relativ INCR 1;{}            setze cursor{}       ELSE registriere bedienfehler{}    FI.{}  wenn moeglich nach links:{}
    IF cursorspalte relativ > 1{}       THEN cursorspalte relativ DECR 1;{}            setze cursor{}       ELSE registriere bedienfehler{}    FI.{}  wenn moeglich nach oben:{}    IF cursorzeile relativ > 1{}       THEN cursorzeile relativ DECR 1;{}            setze cursor{}       ELSE registriere bedienfehler{}    FI.{}  wenn moeglich nach unten:{}    IF cursorzeile relativ < hoehe{}       THEN cursorzeile relativ INCR 1;{}            setze cursor{}       ELSE registriere bedienfehler{}    FI.{}
  wenn moeglich ausbessern:{}    IF werkstueck [cursorspalte relativ][cursorzeile relativ] = code (fehlerzeichen){}       THEN werkstueck [cursorspalte relativ][cursorzeile relativ] := code (blank);{}            korrekturzaehler INCR 1;{}            get cursor (fenster, x, y);{}            out (fenster, blank);{}            cursor (fenster, x, y);{}       ELSE registriere bedienfehler{}    FI.{}  registriere bedienfehler:{}    piepse; bedienfehlerzaehler INCR 1.{}  entscheide ob gepiepst wird:{}    IF eingabezeichen <> "" THEN piepse FI.{}
  beende werkstueckbearbeitung:{}    IF   simulationsende erreicht{}         THEN trage simulationsende in tabelle ein{}    ELIF arbeitsphasenende erreicht{}         THEN trage werkstueckdaten in tabelle ein;{}              ermittle ueberziehung der arbeitsphase;{}              lege eine pause ein{}    ELSE trage werkstueckdaten in tabelle ein{}    FI;{}    werkstueck voll bearbeitet := TRUE.{}  lege eine pause ein:{}    nimm pausendaten;{}    weise auf pausenanfang hin;{}    pausiere;{}    weise auf pausenende hin;{}
    registriere pausenueberziehung.{}  nimm pausendaten:{}    REAL VAR pausenanfang :: clock (1),{}             pausenende   :: pausenanfang + real (pausendauer * 60);.{}  weise auf pausenanfang hin:{}    page (fenster);{}    boxnotice (fenster, anwendungstext (255), 5, x, y, xsize, ysize).{}  pausiere:{}    REP{}      pause (int ((pausenende - clock (1)) * 10.0)){}    UNTIL clock (1) >= pausenende PER.{}  weise auf pausenende hin:{}    page (fenster);{}    pausenanfang := clock (1);{}    piepse;{}
    clear buffer;{}    boxinfo (fenster, anwendungstext (256), 5, maxint);{}    pausenende   := clock (1).{}  registriere pausenueberziehung:{}    pausenueberziehung := pausenende - pausenanfang;{}    trage pausenueberziehung in tabelle ein.{}  trage werkstueckdaten in tabelle ein:{}    REAL VAR bearbeitungsende :: clock (1);{}    tab.tabelle [eintragzaehler].eintragskennung    := werkstueckendekennung;{}    tab.tabelle [eintragzaehler].produktionsfehler  := produktionsfehler;{}    tab.tabelle [eintragzaehler].anzahl korrekturen := korrekturzaehler;{}
    tab.tabelle [eintragzaehler].anzahl bedienfehler:= bedienfehlerzaehler;{}    tab.tabelle [eintragzaehler].anfang             := beginn der bearbeitung;{}    tab.tabelle [eintragzaehler].ende               := bearbeitungsende;{}    tab.tabelle [eintragzaehler].differenz          := bearbeitungszeit;{}    erhoehe eintragzaehler;{}    beginn der bearbeitung := clock (1);{}    werkstueckzaehler INCR 1;{}    bedienfehlerzaehler := 0;{}    korrekturzaehler    := 0.{}  trage pausenueberziehung in tabelle ein:{}
    tab.tabelle [eintragzaehler].eintragskennung    := pausenendekennung;{}    tab.tabelle [eintragzaehler].produktionsfehler  := 0;{}    tab.tabelle [eintragzaehler].anzahl korrekturen := 0;{}    tab.tabelle [eintragzaehler].anzahl bedienfehler:= 0;{}    tab.tabelle [eintragzaehler].anfang             := pausenanfang;{}    tab.tabelle [eintragzaehler].ende               := pausenende;{}    tab.tabelle [eintragzaehler].differenz          := pausenueberziehung;{}    erhoehe eintragzaehler;{}    arbeitsphasenzaehler    INCR 1;{}
    beginn der bearbeitung  := clock (1);{}    beginn der arbeitsphase := clock (1);{}    bearbeitungslaenge bestimmen.{}  trage simulationsende in tabelle ein:{}    bearbeitungsende := clock (1);{}    tab.tabelle [eintragzaehler].eintragskennung    := simulationsendekennung;{}    tab.tabelle [eintragzaehler].produktionsfehler  := produktionsfehler;{}    tab.tabelle [eintragzaehler].anzahl korrekturen := korrekturzaehler;{}    tab.tabelle [eintragzaehler].anzahl bedienfehler:= bedienfehlerzaehler;{}
    tab.tabelle [eintragzaehler].anfang             := beginn der bearbeitung;{}    tab.tabelle [eintragzaehler].ende               := bearbeitungsende;{}    tab.tabelle [eintragzaehler].differenz          := bearbeitungszeit;{}    tab.letzter eintrag                             := eintragzaehler.{}  bearbeitungszeit:{}    bearbeitungsende - beginn der bearbeitung.{}  erhoehe eintragzaehler:{}    IF eintragzaehler < maxeintraege{}       THEN eintragzaehler INCR 1{}       ELSE trage simulationsende in tabelle ein;{}
            errorstop (anwendungstext (254)){}    FI.{}  ermittle ueberziehung der arbeitsphase:{}    arbeitsphasenueberziehung := clock (1) - beginn der arbeitsphase{}                                           - arbeitsphasenlaenge.{}  bearbeitungslaenge bestimmen:{}    arbeitsphasenlaenge := real (aphasendauer * 60){}                                - arbeitsphasenueberziehung{}                                - pausenueberziehung.{}  arbeitsphasenende erreicht:{}    clock (1) - beginn der arbeitsphase >= arbeitsphasenlaenge.{}
  simulationsende erreicht:{}    arbeitsphasenzaehler = anzahl aphasen AND arbeitsphasenende erreicht.{}END PROC fuehre simulation durch;{}PROC gib bedieninformationen aus (INT CONST zeile):{}  WINDOW VAR f1 :: window ( 2, zeile, 35, 6),{}             f2 :: window (40, zeile, 39, 6);{}  show (f1); show (f2);{}  cursor (f1, 2, 1); out (f1, anwendungstext (11));{}                     out (f1, tastenbezeichnung ( nach rechts));{}  cursor (f1, 2, 2); out (f1, anwendungstext (12));{}                     out (f1, tastenbezeichnung ( nach links));{}
  cursor (f1, 2, 3); out (f1, anwendungstext (13));{}                     out (f1, tastenbezeichnung ( nach oben));{}  cursor (f1, 2, 4); out (f1, anwendungstext (14));{}                     out (f1, tastenbezeichnung ( nach unten));{}  cursor (f1, 2, 5); out (f1, anwendungstext (15));{}                     out (f1, tastenbezeichnung ( ausbesserung));{}  cursor (f1, 2, 6); out (f1, anwendungstext (16));{}                     out (f1, tastenbezeichnung ( naechstes));{}  cursor (f2, 2, 1); out (f2, anwendungstext (17));{}
                     out (f2, text (anzahl aphasen, 4));{}  cursor (f2, 2, 2); out (f2, anwendungstext (18));{}                     out (f2, text (aphasendauer,   4));{}                     out (f2, anwendungstext (51));{}  cursor (f2, 2, 3); out (f2, anwendungstext (19));{}                     out (f2, text (pausendauer,    4));{}                     out (f2, anwendungstext (51));{}  cursor (f2, 2, 4); out (f2, anwendungstext ( 5));{}                     out (f2, text (gesamtzeit,      4));{}                     out (f2, anwendungstext (51));{}
  cursor (f2, 2, 6); out (f2, anwendungstext (251));{}                     out (f2, 3 * blank);{}                     out (f2, fehlerzeichen).{}END PROC gib bedieninformationen aus;{}INT PROC gesamtzeit:{}  anzahl aphasen * aphasendauer + (anzahl aphasen - 1) * pausendauer{}END PROC gesamtzeit;{}PROC hole werkstueck (WERKSTUECK VAR w, INT VAR anzahl fehler):{}  INT VAR spaltenzaehler, zeilenzaehler;{}  anzahl fehler := 0;{}  FOR zeilenzaehler FROM 1 UPTO hoehe REP{}    ermittle eine zeile{}  PER.{}
  ermittle eine zeile:{}    FOR spaltenzaehler FROM 1 UPTO breite REP{}      ermittle eine position;{}      ggf fehler registrieren{}    PER.{}  ermittle eine position:{}    w [spaltenzaehler][zeilenzaehler] := zufallscode.{}  zufallscode:{}    random (kleinster code, groesster code).{}  ggf fehler registrieren:{}    IF w [spaltenzaehler][zeilenzaehler] = code (fehlerzeichen){}       THEN anzahl fehler INCR 1{}    FI.{}END PROC hole werkstueck;{}PROC zeige werkstueck (WERKSTUECK CONST w, WINDOW VAR f):{}
  INT VAR spaltenzaehler, zeilenzaehler;{}  page (f);{}  FOR zeilenzaehler FROM 1 UPTO hoehe REP{}    zeige eine zeile{}  PER.{}  zeige eine zeile:{}    cursor (f, eckspalte, eckzeile + zeilenzaehler - 1);{}    ggf invers einschalten;{}    FOR spaltenzaehler FROM 1 UPTO breite REP{}      out (f, code (w [spaltenzaehler][zeilenzaehler])){}    PER;{}    ggf invers ausschalten.{}  ggf invers einschalten:{}    IF inversdarstellung THEN out (f, markierung ein) FI.{}  ggf invers ausschalten:{}    IF inversdarstellung THEN out (f, markierung aus) FI.{}
END PROC zeige werkstueck;{}PROC kurzauswertung auf bildschirm (TEXT CONST dateiname):{}  WINDOW VAR fenster :: window (  2, 10, 77, 13);{}  show (fenster);{}  clear buffer;{}  notiere ueberschrift;{}  notiere ergebnis.{}  notiere ueberschrift:{}    cursor (fenster, 1, 1);{}    out (fenster, center (fenster, anwendungstext (275)));{}    cursor (fenster, 1, 2);{}    out (fenster, center (fenster, anwendungstext (276))).{}  notiere ergebnis:{}    BOUND KONTROLLTABELLE CONST k := old (dateiname);{}    ermittle die simulationsdaten;{}
    notiere gesamtzahl werkstuecke;{}    notiere zeichengesamtzahl;{}    notiere bedienfehler;{}    notiere benoetigte zeit;{}    notiere gesamtausbesserungsrate;{}    notiere gesamtbewertungsfaktor;{}    notiere gesamtbewertungszahl mit pausenueberziehung;{}    cursor (1, 24); out (anwendungstext (2));{}    pause.{}  ermittle die simulationsdaten:{}    INT  VAR z, anzahl zeichen pro werkstueck,{}             anzahl werkstuecke        ::   0,{}             anzahl bedienfehler       ::   0,{}             anzahl produktionsfehler  ::   0,{}
             anzahl korrekturen        ::   0;{}    REAL VAR gesamtzahl zeichen, anteil korrekturen,{}             gesamtzeit                :: 0.0,{}             pausenueberzug            :: 0.0;{}    FOR z FROM 1 UPTO k.letzter eintrag REP{}      IF   k.tabelle [z].eintragskennung = werkstueckendekennung{}           THEN anzahl werkstuecke       INCR 1;{}                anzahl bedienfehler      INCR k.tabelle [z].anzahl bedienfehler;{}                anzahl produktionsfehler INCR k.tabelle [z].produktionsfehler;{}
                anzahl korrekturen       INCR k.tabelle [z].anzahl korrekturen;{}                gesamtzeit               INCR k.tabelle [z].differenz;{}      ELIF k.tabelle [z].eintragskennung = pausenendekennung{}           THEN pausenueberzug           INCR k.tabelle [z].differenz;{}      FI{}    PER;{}    anzahl zeichen pro werkstueck := k.breite * k.hoehe;{}    gesamtzahl zeichen            :=   real (anzahl werkstuecke){}                                     * real (anzahl zeichen pro werkstueck);{}
    IF anzahl produktionsfehler = 0{}       THEN anteil korrekturen    := 1.0{}       ELSE anteil korrekturen    :=   real (anzahl korrekturen){}                                     / real (anzahl produktionsfehler){}    FI.{}  notiere gesamtzahl werkstuecke:{}    cursor (fenster, 12, 4); out (fenster, anwendungstext (277));{}                             out (fenster, text (anzahl werkstuecke, 8)).{}  notiere zeichengesamtzahl:{}    cursor (fenster, 12, 5); out (fenster, anwendungstext (278));{}                             out (fenster, zahl aus zeichenkette).{}
  zahl aus zeichenkette:{}    subtext (text (gesamtzahl zeichen, 9, 0), 1, 8).{}  notiere bedienfehler:{}    cursor (fenster, 12, 6); out (fenster, anwendungstext (279));{}                             out (fenster, text (anzahl bedienfehler, 8)).{}  notiere benoetigte zeit:{}    cursor (fenster, 12, 7); out (fenster, anwendungstext (280));{}                             out (fenster, text (gesamtzeit,         8, 2)).{}  notiere gesamtausbesserungsrate:{}    cursor (fenster, 12, 9); out (fenster, anwendungstext (281));{}
                             out (fenster, text (anteil korrekturen, 8, 2)).{}  notiere gesamtbewertungsfaktor:{}    cursor (fenster, 12,10); out (fenster, anwendungstext (282));{}                             out (fenster, text (bewertungsfaktor, 8, 2)).{}  bewertungsfaktor:{}    bewertungsmasszahl (anteil korrekturen).{}  notiere gesamtbewertungszahl mit pausenueberziehung:{}    cursor (fenster, 12, 12); out (fenster, (anwendungstext (283)));{}                              out (fenster, text (gesamtwertung,   8, 2));{}
    cursor (fenster, 12, 13); out (fenster, (anwendungstext (284)));{}                              out (fenster, 8 * "=").{}  gesamtwertung:{}    IF gesamtzeit = 0.0{}       THEN 0.0{}       ELSE gesamtzahl zeichen / (gesamtzeit + pausenueberzug){}                               * bewertungsfaktor{}    FI.{}END PROC kurzauswertung auf bildschirm;{}PROC simulationsauswertung (TEXT CONST dateiname, BOOL CONST mit zeigen):{}  TEXT CONST auswertdatei :: dateiname + auswertdateipostfix;{}  ermittle die kenndaten aus der protokolldatei (dateiname);{}
  notiere ueberschrift 1               (auswertdatei);{}  notiere die kenndaten der simulation (auswertdatei);{}  notiere die werkstueckkenndaten      (auswertdatei);{}  notiere ein beispielwerkstueck       (auswertdatei);{}  notiere ueberschrift 2               (auswertdatei);{}  notiere gesamtergebnisse             (auswertdatei, dateiname);{}  notiere ueberschrift 3               (auswertdatei);{}  notiere tabellenkopf                 (auswertdatei);{}  notiere einzelne werkstueckdaten     (auswertdatei, dateiname);{}
  notiere ggf die anmerkungen;{}  zeige ggf auswertung auf bildschirm.{}  notiere ggf die anmerkungen:{}    IF mit anmerkungen{}       THEN notiere anmerkungen        (auswertdatei);{}    FI.{}  zeige ggf auswertung auf bildschirm:{}    IF mit zeigen{}       THEN cursor on; show (auswertdatei); cursor off{}    FI.{}END PROC simulationsauswertung;{}PROC ermittle die kenndaten aus der protokolldatei (TEXT CONST dateiname):{}  BOUND KONTROLLTABELLE CONST k := old (dateiname);{}  breite                    := k.breite;{}
  hoehe                     := k.hoehe;{}  kleinster code            := k.kleinster code;{}  groesster code            := k.groesster code;{}  fehlerzeichen             := k.fehlerzeichen;{}  inversdarstellung         := k.inversdarstellung;{}  nach rechts               := k.nach rechts;{}  nach links                := k.nach links;{}  nach oben                 := k.nach oben;{}  nach unten                := k.nach unten;{}  ausbesserung              := k.ausbesserung;{}  naechstes                 := k.naechstes;{}
  anzahl aphasen            := k.anzahl aphasen;{}  aphasendauer              := k.aphasendauer;{}  pausendauer               := k.pausendauer;{}  datum                     := k.datum;{}  uhrzeit                   := k.uhrzeit;{}  bewertung                 := k.bewertung;{}END PROC ermittle die kenndaten aus der protokolldatei;{}PROC notiere ueberschrift 1 (TEXT CONST auswertdatei):{}  IF exists (auswertdatei){}     THEN forget (auswertdatei, quiet){}  FI;{}  FILE VAR f :: sequential file (output, auswertdatei);{}
  IF auswertung geht zum drucker{}     THEN schreibe druckeranweisungen{}  FI;{}  putline (f, center (auswertdatei));{}  putline (f, center (length (auswertdatei) * "="));{}  put (f, anwendungstext (272)); put (f, datum); put (f, 26 * blank);{}  put (f, anwendungstext (273)); putline (f, uhrzeit);{}  line (f);{}  putline (f, center (anwendungstext (291)));{}  putline (f, center (length (anwendungstext (291)) * "=")).{}  schreibe druckeranweisungen:{}    write (f, "#type (""");{}    write (f, protokollschrifttyp);{}
    write (f, """)##limit (");{}    write (f, text (schreibfeldbreite));{}    write (f, ")##pagelength (");{}    write (f, text (schreibfeldlaenge));{}    write (f, ")##start (");{}    write (f, text (xstart));{}    write (f, ",");{}    write (f, text (ystart));{}    write (f, ")#"); line (f).{}END PROC notiere ueberschrift 1;{}PROC notiere ueberschrift 2 (TEXT CONST auswertdatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}  putline (f, center (anwendungstext (285)));{}  putline (f, center (length (anwendungstext (285)) * "=")){}
END PROC notiere ueberschrift 2;{}PROC notiere ueberschrift 3 (TEXT CONST auswertdatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}  line (f, 2);{}  putline (f, center (anwendungstext (311)));{}  putline (f, center (length (anwendungstext (311)) * "="));{}  line (f){}END PROC notiere ueberschrift 3;{}PROC notiere die kenndaten der simulation (TEXT CONST auswertdatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}  ROW 6 TEXT VAR ausgabe;{}  bestuecke ausgabezeilen;{}  schreibe ausgabezeilen.{}
  bestuecke ausgabezeilen:{}    ausgabe [1] :=   anwendungstext (11){}                   + gleichlang (tastenbezeichnung (nach rechts ), 23){}                   + anwendungstext (17){}                   + text (anzahl aphasen,   4);{}    ausgabe [2] :=   anwendungstext (12){}                   + gleichlang (tastenbezeichnung (nach links  ), 23){}                   + anwendungstext (18){}                   + text (aphasendauer,     4) + anwendungstext (51);{}    ausgabe [3] :=   anwendungstext (13){}
                   + gleichlang (tastenbezeichnung (nach oben   ), 23){}                   + anwendungstext (19){}                   + text (pausendauer,      4) + anwendungstext (51);{}    ausgabe [4] :=   anwendungstext (14){}                   + gleichlang (tastenbezeichnung (nach unten  ), 23){}                   + anwendungstext ( 5){}                   + text (simulationsdauer, 4) + anwendungstext (51);{}    ausgabe [5] :=   anwendungstext (15){}                   + gleichlang (tastenbezeichnung (ausbesserung), 23);{}
    ausgabe [6] :=   anwendungstext (16){}                   + gleichlang (tastenbezeichnung (naechstes   ), 23){}                   + anwendungstext (251){}                   + (3 * blank) + fehlerzeichen.{}  simulationsdauer:{}    anzahl aphasen * aphasendauer + (anzahl aphasen - 1) * pausendauer.{}  schreibe ausgabezeilen:{}    INT VAR i;{}    FOR i FROM 1 UPTO 6 REP{}      putline (f, ausgabe [i]){}    PER;{}    line (f).{}END PROC notiere die kenndaten der simulation;{}PROC notiere die werkstueckkenndaten (TEXT CONST auswertdatei):{}
  FILE VAR f :: sequential file (output, auswertdatei);{}  ROW 4 TEXT VAR ausgabe;{}  bestuecke ausgabezeilen;{}  schreibe ausgabezeilen.{}  bestuecke ausgabezeilen:{}    ausgabe [1] :=  anwendungstext (292) + text (breite,        4) +{}                    anwendungstext (296);{}    ausgabe [2] :=  anwendungstext (293) + text (hoehe,          4) +{}                    anwendungstext (296);{}    ausgabe [3] :=  anwendungstext (294) + text (breite * hoehe, 4) +{}                    anwendungstext (296);{}
    ausgabe [4] :=  anwendungstext (295) + zeichenumfang.{}  zeichenumfang:{}    " " + code (kleinster code) + " ... " + code (groesster code) +{}    " (" + text (groesster code - kleinster code + 1, 3) +{}    anwendungstext (296) + ")".{}  schreibe ausgabezeilen:{}    INT VAR i;{}    FOR i FROM 1 UPTO 4 REP putline (f, ausgabe [i]) PER;{}    line (f).{}END PROC notiere die werkstueckkenndaten;{}PROC notiere ein beispielwerkstueck (TEXT CONST auswertdatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}
  WERKSTUECK VAR beispiel;{}  INT VAR beispielfehler;{}  hole werkstueck (beispiel, beispielfehler);{}  notiere ueberschrift;{}  notiere werkstueckzeilen;{}  notiere werkstueckleerzeilen.{}  notiere ueberschrift:{}    putline (f, center (anwendungstext (297)));{}    putline (f, center (length (anwendungstext (297)) * "-")).{}  notiere werkstueckzeilen:{}    INT VAR bs, bz;{}    FOR bz FROM 1 UPTO hoehe REP{}      notiere eine zeile{}    PER.{}  notiere eine zeile:{}    TEXT VAR beispielzeile :: "";{}
    konstruiere beispielzeile;{}    gib beispielzeile aus.{}  konstruiere beispielzeile:{}    beispielzeile CAT (((80 - breite) DIV 2) * blank);{}    FOR bs FROM 1 UPTO breite REP{}      beispielzeile CAT code (beispiel [bs][bz]){}    PER.{}  gib beispielzeile aus:{}    putline (f, beispielzeile).{}  notiere werkstueckleerzeilen:{}    line (f, maxzeilen - hoehe + 1).{}END PROC notiere ein beispielwerkstueck;{}PROC notiere gesamtergebnisse (TEXT CONST auswertdatei, protokolldatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}
  BOUND KONTROLLTABELLE CONST k :: old (protokolldatei);{}  ermittle die simulationsdaten;{}    notiere gesamtzahl werkstuecke;{}    notiere anzahl zeichen pro werkstueck;{}    notiere zeichengesamtzahl;{}    notiere bedienfehler;{}    notiere produktionsfehlerzahl;{}    notiere fehlerkorrekturen;{}    notiere gesamtzeit mit pausenueberziehung;{}    notiere zeichenzahl pro sekunde mit;{}    notiere gesamtausbesserungsrate;{}    notiere gesamtbewertungsfaktor  mit;{}    notiere gesamtbewertungszahl    mit;{}
    notiere gesamtzeit ohne pausenueberziehung;{}    notiere zeichenzahl pro sekunde ohne;{}    notiere gesamtbewertungszahl    ohne.{}  ermittle die simulationsdaten:{}    INT  VAR z, anzahl zeichen pro werkstueck,{}             anzahl werkstuecke        ::   0,{}             anzahl bedienfehler       ::   0,{}             anzahl produktionsfehler  ::   0,{}             anzahl korrekturen        ::   0;{}    REAL VAR gesamtzahl zeichen, anteil korrekturen,{}             gesamtzeit                :: 0.0,{}
             pausenueberzug            :: 0.0;{}    FOR z FROM 1 UPTO k.letzter eintrag REP{}      IF   k.tabelle [z].eintragskennung = werkstueckendekennung{}           THEN anzahl werkstuecke       INCR 1;{}                anzahl bedienfehler      INCR k.tabelle [z].anzahl bedienfehler;{}                anzahl produktionsfehler INCR k.tabelle [z].produktionsfehler;{}                anzahl korrekturen       INCR k.tabelle [z].anzahl korrekturen;{}                gesamtzeit               INCR k.tabelle [z].differenz;{}
      ELIF k.tabelle [z].eintragskennung = pausenendekennung{}           THEN pausenueberzug           INCR k.tabelle [z].differenz;{}      FI{}    PER;{}    anzahl zeichen pro werkstueck := k.breite * k.hoehe;{}    gesamtzahl zeichen            :=   real (anzahl werkstuecke){}                                     * real (anzahl zeichen pro werkstueck);{}    IF anzahl produktionsfehler = 0{}       THEN anteil korrekturen    := 1.0{}       ELSE anteil korrekturen    :=   real (anzahl korrekturen){}
                                     / real (anzahl produktionsfehler){}    FI.{}  notiere gesamtzahl werkstuecke:{}    put (f, anwendungstext (277)); putline (f, text (anzahl werkstuecke, 8)).{}  notiere anzahl zeichen pro werkstueck:{}    put (f, anwendungstext (286)); putline (f, text (breite * hoehe,     8)).{}  notiere zeichengesamtzahl:{}    put (f, anwendungstext (278)); putline (f, zahl aus zeichenkette);{}    line (f).{}  zahl aus zeichenkette:{}    subtext (text (gesamtzahl zeichen, 9, 0), 1, 8).{}
  notiere produktionsfehlerzahl:{}    put (f, anwendungstext (287)); putline (f, text (anzahl produktionsfehler, 8)).{}  notiere fehlerkorrekturen:{}    put (f, anwendungstext (288)); putline (f, text (anzahl korrekturen, 8)).{}  notiere bedienfehler:{}    put (f, anwendungstext (279)); putline (f, text (anzahl bedienfehler,8));{}    line (f).{}  notiere gesamtzeit mit pausenueberziehung:{}    put (f, anwendungstext (301)); put (f, text (gesamtzeit mit, 8, 1));{}    putline (f, anwendungstext (300)).{}
  gesamtzeit mit:{}    gesamtzeit + pausenueberzug.{}  notiere zeichenzahl pro sekunde mit:{}    put (f, anwendungstext (302));{}    putline (f, text (zeichenpro sec mit, 8, 1));{}    line (f).{}  zeichen pro sec mit:{}    IF gesamtzeit + pausenueberzug > 0.0{}       THEN gesamtzahl zeichen / (gesamtzeit + pausenueberzug){}       ELSE 0.0{}    FI.{}  notiere gesamtausbesserungsrate:{}    put (f, anwendungstext (281)); putline (f, text (anteil korrekturen, 8, 1)).{}  notiere gesamtbewertungsfaktor mit:{}
    put (f, anwendungstext (282)); putline (f, text (bewertungsfaktor, 8, 1));{}    line (f).{}  bewertungsfaktor:{}    bewertungsmasszahl (anteil korrekturen).{}  notiere gesamtbewertungszahl mit:{}    put (f, (anwendungstext (283))); putline (f, text (gesamtwertung mit,   8, 1));{}    put (f, (anwendungstext (284))); putline (f, 8 * "=").{}  gesamtwertung mit:{}    IF gesamtzeit = 0.0{}       THEN 0.0{}       ELSE gesamtzahl zeichen / (gesamtzeit + pausenueberzug){}                               * bewertungsfaktor{}
    FI.{}  notiere gesamtzeit ohne pausenueberziehung:{}    put (f, anwendungstext (303)); put (f, text (gesamtzeit, 8, 1));{}    putline (f, anwendungstext (300)).{}  notiere zeichenzahl pro sekunde ohne:{}    put (f, anwendungstext (302));{}    putline (f, text (zeichenpro sec ohne, 8, 1)).{}  zeichen pro sec ohne:{}    IF gesamtzeit > 0.0{}       THEN gesamtzahl zeichen / gesamtzeit{}       ELSE 0.0{}    FI.{}  notiere gesamtbewertungszahl ohne:{}    put (f, (anwendungstext (304))); putline (f, text (gesamtwertung ohne,   8, 1));{}
    put (f, (anwendungstext (284))); putline (f, 8 * "=").{}  gesamtwertung ohne:{}    IF gesamtzeit = 0.0{}       THEN 0.0{}       ELSE gesamtzahl zeichen / gesamtzeit * bewertungsfaktor{}    FI.{}END PROC notiere gesamtergebnisse;{}PROC notiere tabellenkopf (TEXT CONST auswertdatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}  putline (f, anwendungstext (312));{}  putline (f, anwendungstext (313));{}  putline (f, anwendungstext (314));{}  putline (f, anwendungstext (315));{}  putline (f, anwendungstext (316));{}
  putline (f, anwendungstext (317));{}  putline (f, anwendungstext (318));{}END PROC notiere tabellenkopf;{}PROC notiere einzelne werkstueckdaten (TEXT CONST auswertdatei, dateiname):{}  BOUND KONTROLLTABELLE CONST k :: old (dateiname);{}  FILE VAR f :: sequential file (output, auswertdatei);{}  INT  VAR zeiger, werkstuecknummer :: 0;{}  TEXT VAR ausgabezeile :: "";{}  FOR zeiger FROM 1 UPTO k.letzter eintrag REP{}   notiere bearbeitungszeile{}  PER.{}  notiere bearbeitungszeile:{}    IF   k.tabelle [zeiger].eintragskennung = werkstueckendekennung{}
         THEN werkstuecknummer INCR 1;{}              schreibe werkstueckzeile{}    ELIF k.tabelle [zeiger].eintragskennung = pausenendekennung{}         THEN schreibe pausenzeile{}    ELIF k.tabelle [zeiger].eintragskennung = simulationsendekennung{}         THEN werkstuecknummer INCR 1;{}              schreibe abschluss{}    ELSE putline (f, 75 * "?"){}    FI.{}  schreibe werkstueckzeile:{}    konstruiere ausgabezeile;{}    putline (f, ausgabezeile).{}  konstruiere ausgabezeile:{}    ausgabezeile := "";{}
    ausgabezeile CAT text (werkstuecknummer, 5);{}    ausgabezeile CAT 2 * blank;{}    ausgabezeile CAT trenn;{}    ausgabezeile CAT text (k.tabelle [zeiger].anzahl bedienfehler, 5);{}    ausgabezeile CAT 3 * blank;{}    ausgabezeile CAT trenn;{}    ausgabezeile CAT text (k.tabelle [zeiger].produktionsfehler,   6);{}    ausgabezeile CAT 2 * blank;{}    ausgabezeile CAT trenn;{}    ausgabezeile CAT text (k.tabelle [zeiger].anzahl korrekturen,  6);{}    ausgabezeile CAT 2 * blank;{}    ausgabezeile CAT trenn;{}
    ausgabezeile CAT text (k.tabelle [zeiger].differenz,  6, 1);{}    ausgabezeile CAT blank;{}    ausgabezeile CAT trenn;{}    ausgabezeile CAT text (zeichen pro zeiteinheit,  6, 1);{}    ausgabezeile CAT blank;{}    ausgabezeile CAT trenn;{}    ausgabezeile CAT text (einzelausbesserungsrate,  6, 1);{}    ausgabezeile CAT blank;{}    ausgabezeile CAT trenn;{}    ausgabezeile CAT text (bewertungsmasszahl (einzelausbesserungsrate), 6, 1);{}    ausgabezeile CAT blank;{}    ausgabezeile CAT trenn;{}
    ausgabezeile CAT text (endbewertungszahl, 6, 1);{}    ausgabezeile CAT blank.{}  zeichen pro zeiteinheit:{}    real (breite * hoehe) / k.tabelle [zeiger].differenz.{}  einzelausbesserungsrate:{}    IF k.tabelle [zeiger].produktionsfehler = 0{}       THEN 0.0{}       ELSE   real (k.tabelle [zeiger].anzahl korrekturen){}            / real (k.tabelle [zeiger].produktionsfehler ){}    FI.{}  endbewertungszahl:{}    real (breite * hoehe) / k.tabelle [zeiger].differenz{}                          * bewertungsmasszahl (einzelausbesserungsrate).{}
  schreibe pausenzeile:{}    line (f);{}    put     (f, anwendungstext (320));{}    put     (f, text (k.tabelle [zeiger].differenz, 6, 1));{}    putline (f, anwendungstext (300));{}    line (f).{}  schreibe abschluss:{}    putline (f, anwendungstext (318));{}    putline (f, anwendungstext (319));{}    line (f);{}    konstruiere ausgabezeile;{}    ausgabezeile := "(" +{}                    subtext (ausgabezeile, 2, length (ausgabezeile) - 1) +{}                    ")";{}    putline (f, ausgabezeile).{}
END PROC notiere einzelne werkstueckdaten;{}PROC notiere anmerkungen (TEXT CONST auswertdatei):{}  FILE VAR f :: sequential file (output, auswertdatei);{}  line (f);{}  schreibe kopf;{}  schreibe hinweis auf letztes werkstueck;{}  schreibe hinweis auf bedienfehler;{}  erlaeutere bewertungsschluessel;{}  stelle bewertungsschluessel graphisch dar;{}  schreibe rest.{}  schreibe kopf:{}    putline (f, center (anwendungstext (325)));{}    putline (f, center (length (anwendungstext (325)) * "="));{}    line (f).{}
  schreibe hinweis auf letztes werkstueck:{}    INT VAR i;{}    FOR i FROM 326 UPTO 337 REP{}      putline (f, anwendungstext (i)){}    PER;{}    line (f).{}  schreibe hinweis auf bedienfehler:{}    FOR i FROM 339 UPTO 341 REP{}      putline (f, anwendungstext (i)){}    PER;{}    line (f).{}  erlaeutere bewertungsschluessel:{}    FOR i FROM 343 UPTO 372 REP{}      putline (f, anwendungstext (i)){}    PER.{}  stelle bewertungsschluessel graphisch dar:{}    putline (f, anwendungstext (374));{}    putline (f, anwendungstext (375));{}
    ermittle die startposition;{}    zeichne diagramm;{}    trage werte ein.{}  ermittle die startposition:{}    modify (f);{}    INT VAR zeilenpos :: lines (f) + 2, spaltenpos :: 18.{}  zeichne diagramm:{}    cursor (f, spaltenpos, zeilenpos     , anwendungstext (20));{}    cursor (f, spaltenpos, zeilenpos +  1, anwendungstext (21));{}    cursor (f, spaltenpos, zeilenpos +  3, anwendungstext (23));{}    cursor (f, spaltenpos, zeilenpos +  4, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos +  5, anwendungstext (22));{}
    cursor (f, spaltenpos, zeilenpos +  6, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos +  7, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos +  8, anwendungstext (24));{}    cursor (f, spaltenpos, zeilenpos +  9, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos + 10, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos + 11, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos + 12, anwendungstext (22));{}    cursor (f, spaltenpos, zeilenpos + 13, anwendungstext (25));{}
    cursor (f, spaltenpos, zeilenpos + 14, anwendungstext (26));{}    cursor (f, spaltenpos, zeilenpos + 15, anwendungstext (27)).{}  trage werte ein:{}    zeilenpos INCR 13;{}    INT VAR bwzeiger;{}    FOR bwzeiger FROM 1 UPTO 11 REP{}      cursor (f, spaltenpos + 3 * bwzeiger, zeilenpos - konkreter wert, "+"){}    PER.{}  konkreter wert:{}    int (bewertung [bwzeiger] * 10.0).{}  schreibe rest:{}    output (f);{}    line (f, 2);{}    FOR i FROM 377 UPTO 387 REP{}      putline (f, anwendungstext (i)){}
    PER;{}    haenge an jede zeile ein blank an.{}  haenge an jede zeile ein blank an:{}    TEXT VAR inhalt;{}    INT  VAR zeilenzeiger;{}    modify (f);{}    FOR zeilenzeiger FROM 1 UPTO lines (f) REP{}      to line (f, zeilenzeiger);{}      read record (f, inhalt);{}      inhalt CAT blank;{}      write record (f, inhalt){}    PER;{}    to line (f,1).{}END PROC notiere anmerkungen;{}PROC cursor (FILE VAR f, INT CONST spa, zei, TEXT CONST text):{}  positioniere an zeile;{}  positioniere an spalte;{}
  gib text an position aus.{}  positioniere an zeile:{}    IF zeile noch nicht vorhanden{}       THEN schaffe zeile und gehe dorthin{}       ELSE to line (f,zei){}    FI.{}  zeile noch nicht vorhanden:{}    zei > lines (f).{}  schaffe zeile und gehe dorthin:{}    INT VAR zaehler 1;{}    IF lines (f) = 0{}       THEN to line (f,lines (f));{}            insert record (f);{}    FI;{}    FOR zaehler 1 FROM lines (f)  UPTO zei REP{}      to line (f,lines (f));{}      down (f);insert record (f){}    PER;{}
    to line(f,zei).{}  positioniere an spalte:{}    TEXT VAR alter satz :: "", neuer satz :: "", restsatz ::"";{}    INT VAR satzlaenge;{}    read record (f,alter satz);{}    satzlaenge := length (alter satz);{}    IF satzlaenge = 0{}       THEN neuer satz CAT (spa -1) * " "{}    ELIF satzlaenge >= spa{}       THEN neuer satz := subtext(alter satz,1,spa-1);{}            restsatz   := subtext(alter satz, spa + length (text));{}       ELSE neuer satz := alter satz;{}            neuer satz CAT (spa - satzlaenge - 1) * " "{}
    FI.{}  gib text an position aus:{}   neuer satz CAT text;{}   IF restsatz <> ""{}      THEN neuer satz CAT restsatz{}   FI;{}   write record(f,neuer satz).{} END PROC cursor;{}TEXT PROC gleichlang (TEXT CONST text, INT CONST laenge):{}  TEXT VAR intern :: compress (text);{}  INT  VAR anzahl :: laenge - length (intern);{}  IF anzahl < 0{}     THEN subtext (intern, 1, laenge){}     ELSE intern + (anzahl * blank){}  FI{}END PROC gleichlang;{}REAL PROC bewertungsmasszahl (REAL CONST wert):{}  REAL VAR interner wert := round (wert, 1);{}
  IF interner wert > wert{}     THEN interner wert DECR 0.1{}  FI;{}  interpoliere.{}  interpoliere:{}    REAL VAR unterer wert, oberer wert;{}    unterer wert := interner wert;{}    IF unterer wert = 1.0{}       THEN oberer wert := 1.0{}       ELSE oberer  wert := unterer wert + 0.1{}    FI;{}    unterer wert := bewertung (int (unterer wert * 10.0) + 1);{}    oberer  wert := bewertung (int (oberer  wert * 10.0) + 1);{}    unterer wert + (oberer wert - unterer wert) * faktor.{}  faktor:{}    frac (wert * 10.0).{}
END PROC bewertungsmasszahl;{}PROC zeige aktuellen protokollumfang an:{}  WINDOW VAR w :: window (2, 2, 34,  5);{}  show (w);{}  cursor (w, 1, 1); out (w, center (w, invers (anwendungstext (431))));{}  IF mit anmerkungen{}     THEN cursor (w, 2, 4); out (w, anwendungstext (432)){}     ELSE cursor (w, 2, 4); out (w, anwendungstext (433));{}  FI.{}END PROC zeige aktuellen protokollumfang an;{}PROC gib erlaeuterungen zum protokollumfang:{}  WINDOW VAR f :: window ( 2, 9, 77, 15);{}  show (f);{}  cursor (f, 1, 1); out (f, center (f, invers (anwendungstext (434))));{}
  cursor (f, 5, 3); out (f, anwendungstext (435));{}  cursor (f, 5, 4); out (f, anwendungstext (436));{}  cursor (f, 5, 5); out (f, anwendungstext (437));{}  cursor (f, 5, 6); out (f, anwendungstext (438));{}  cursor (f, 5, 8); out (f, anwendungstext (439));{}  cursor (f, 5, 9); out (f, anwendungstext (440));{}  cursor (f, 5,10); out (f, anwendungstext (441));{}  cursor (f, 5,11); out (f, anwendungstext (442));{}  cursor (f, 5,13); out (f, anwendungstext (443));{}  cursor (f, 5,14); out (f, anwendungstext (444));{}
END PROC gib erlaeuterungen zum protokollumfang;{}PROC frage nach umfangsaenderung:{}  WINDOW VAR fenster :: window (38, 2, 41, 5);{}  show (fenster);{}  cursor (fenster, 1, 1); out (fenster, center (fenster, invers (anwendungstext (451))));{}  cursor (fenster, 4, 3); out (fenster, anwendungstext (452));{}  cursor (fenster, 4, 4);{}  IF yes (fenster, anwendungstext (453)){}     THEN  mit anmerkungen := NOT mit anmerkungen{}  FI.{}END PROC frage nach umfangsaenderung;{}PROC zeige aktuelle kurzauswertungseinstellung an:{}
  WINDOW VAR w :: window ( 2, 2, 34,  5);{}  show (w);{}  cursor (w, 1, 1); out (w, center (w, invers (anwendungstext (431))));{}  IF mit kurzprotokoll{}     THEN cursor (w, 7, 4); out (w, anwendungstext (461));{}     ELSE cursor (w, 7, 4); out (w, anwendungstext (462));{}  FI.{}END PROC zeige aktuelle kurzauswertungseinstellung an;{}PROC gib erlaeuterungen zur kurzauswertung:{}  WINDOW VAR f :: window ( 2, 9, 77, 15);{}  show (f);{}  cursor (f, 1, 1); out (f, center (f, invers (anwendungstext (463))));{}
  cursor (f, 5, 3); out (f, anwendungstext (464));{}  cursor (f, 5, 4); out (f, anwendungstext (465));{}  cursor (f, 5, 5); out (f, anwendungstext (466));{}  cursor (f, 5, 6); out (f, anwendungstext (467));{}  cursor (f, 5, 8); out (f, anwendungstext (468));{}  cursor (f, 5, 9); out (f, anwendungstext (469));{}  cursor (f, 5,10); out (f, anwendungstext (470));{}  cursor (f, 5,11); out (f, anwendungstext (471));{}  cursor (f, 5,13); out (f, anwendungstext (472));{}  cursor (f, 5,14); out (f, anwendungstext (473));{}
END PROC gib erlaeuterungen zur kurzauswertung;{}PROC frage nach kurzauswertungsaenderung:{}  WINDOW VAR fenster :: window (38, 2, 41, 5);{}  show (fenster);{}  cursor (fenster, 1, 1); out (fenster, center (fenster, invers (anwendungstext (481))));{}  cursor (fenster, 5, 3); out (fenster, anwendungstext (482));{}  cursor (fenster, 5, 4);{}  IF yes (fenster, anwendungstext (483)){}     THEN  mit kurzprotokoll := NOT mit kurzprotokoll{}  FI.{}END PROC frage nach kurzauswertungsaenderung;{}END PACKET ls mp bap 2;{}

