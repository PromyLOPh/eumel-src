#start(2.5,1.5)# 
#pageblock# 
#block# 
#page (91)# 
#headeven# 
%#center#EUMEL-Systemhandbuch 
 
 
#end# 
#headodd# 
#center#7. Der Fontspeicher#right#% 
 
 
#end# 
 
#ib(9)#7. Der #ib#Fontspeicher#ie##ie(9)# 
 
 
 
#ib(9)#7.1. #ib#Fonttabellen#ie##ie(9)# 
 
 
Damit die Textverarbeitung Dokumente formatieren kann, muß sie über Breiten und
Höhen der einzelnen Schrifttypen (auch "#ib#Fonts#ie#" genannt) des Druckers, auf dem das
Dokument gedruckt wird, Bescheid wissen. Auch bei dem Ausdruck des Dokuments
wird diese Information benötigt. Im EUMEL-System stellt der #ib#Fontspeicher#ie# diese Infor­
mation den #ib#Formatierprogramm#ie#en (#on("i")#lineform#off("i")# und #on("i")#pageform#off("i")#) und dem #ib#EUMEL-Drucker#ie#
zur Verfügung. 
 
Da nun der Drucker Angaben zur Positionierung in seinen #ib#Mikroschritten#ie# (kleinste
Schrittweite in horizontaler oder vertikalter Richtung) benötigt, liefert die Fonttabelle
die Breiten- und Höhenangaben in Mikroschritten und eine Umrechnungseinheit von
Schritten in Zentimeter oder umgekehrt. So braucht der EUMEL-Drucker bei Positionie­
rungen keine Umrechnung vorzunehmen. Allerdings müssen die Formatierprogramme
auch in Mikroschritten des jeweiligen Druckers rechnen. Dadurch werden jedoch
Unterschiede durch Rundungsfehler zwischen dem EUMEL-Drucker und den Forma­
tierprogrammen vermieden. 
 
Bei diesem Konzept können Fonts von verschiedenen Druckern nicht in einer Fontta­
belle verwaltet werden, denn unterschiedliche Drucker haben meist verschiedene
Mikroschritte. Somit muß es für jeden Drucker mindestens eine Fonttabelle geben. 
 
Es gibt aber auch Fälle, in denen Fonts auf einem Drucker nicht mit anderen Fonts des
Druckers zusammengedruckt werden können. Solche Fälle liegen z.B. bei Typenrad­
druckern vor, die immer nur mit einem Typenrad drucken können und dessen Zei­
chenbreite hardwaremäßig eingestellt werden muß (z.B. beim Olivetti PR320), bei
Druckern, die verschiedene Fonts für Längs- und Querformat haben (z.B. beim Agfa
P400), oder bei Druckern, deren Fonts geladen werden (z.B. beim HP 2686). Eine
#on("b")##ib#Fonttabelle#ie##off("b")# enthält also alle die Fonts eines Druckers, #on("b")#die auf dem Drucker kompati­
bel sind#off("b")#. Es kann mehrere Fonttabellen zu einem Drucker geben. 
 
Die verschiedenen Fonttabellen werden von im Multi-User Betrieb von der Task "#ib#confi­
gurator#ie#" verwaltet. Sie enthält alle Fonttabellen, die auf dem Rechner zur Verfügung
stehen. Mit dem Kommando 
 
 
  #ib#fonttable#ie# ("Name der Fonttabelle") 
 
 
wird in einer Task die gewünschte Fonttabelle eingestellt. Danach stehen die Fonts
dieser Tabelle in der Task zur Verfügung. Die Einstellung der Fonttabelle vererbt sich
auf die Sohntasks, d.h. wird eine Sohntask begonnen, so ist dort die Fonttabelle des
Vaters eingestellt. 
 
Dazu das folgenden Beispiel: 
 
    Für den Agfa-Drucker P400 gibt es die Fonttabellen "agfa" und "agfaquer", in
    denen die Fonts für Längsdruck bzw. Querdruck enthalten sind. In der Task
    #on("i")#PUBLIC#off("i")# wird mit dem Kommando #on("i")#fonttable ("agfa")#off("i")# die Fonttabelle "agfa" ein­
    gestellt. Alle neuen Sohntasks können sofort ohne weitere Einstellung mit der
    Textformatierung im Längsformat beginnen. Will nun jemand im Querformat
    drucken, so muß er in seiner Task mit dem Kommando #on("i")#fonttable ("agfaquer")#off("i")# den
    Fontspeicher auf die Fonts zum Querdruck umstellen. 
 
Das Kommando 
 
 
  #ib#list fonts#ie# 
 
 
listet die Fonts der eingestellten Fontabelle ins #on("i")#notebook#off("i")# und das Kommando 
 
 
  #ib#list fonttables#ie# 
 
 
informiert über die verfügbaren Fonttabellen. 
 
 
 
 
#ib(9)#7.2. Erstellen einer #ib#Fonttabelle#ie##ie(9)# 
 
 
Die Fonttabelle ist ein Datenraum mit einer eigenen Struktur. Somit kann sie nicht
mehr mit dem Editor, sondern nur mit einem entsprechenden Programm bearbeitet
werden. Solch ein Programm befindet sich in der Datei "#ib#font convertor#ie#" auf dem Stan­
dardarchiv 'std.zusatz'. Diese Datei sollte in einer Systemtask (Sohntask von "SYSUR")
insertiert werden. Danach stehen entsprechende Kommandos zur Bearbeitung einer
Fonttabelle zur Verfügung. 
 
Um eine Fonttabelle zu bekommen, muß zuerst eine #on("b")##ib#Fontdatei#ie##off("b")# (d.h. eine editierbare
Datei mit dem unten beschriebenen Aufbau) angelegt werden. Mit dem Kommando 
 
 
  #ib#create fonttable#ie# ("Name der Fontdatei") 
 
 
werden alle in der Fontdatei spezifizierten Fonttabellen erstellt. Sie liegen als benannte
Datenräume in der Task vor und können mit dem Kommando #on("i")#save#off("i")# von einer System­
task an die Task "configurator" gesendet werden. Danach sind diese Fonttabellen in
allen Task auf dem Rechner verfügbar und können mit dem #on("i")#fonttable#off("i")# - Kommando
eingestellt werden. 
 
Soll dagegen eine bestehende Fonttabelle geändert werden, so erstellt das Komman­
do 
 
 
  #ib#create fontfile#ie# ("Name der Fonttabelle", "Name der Fontdatei") 
 
 
aus der angegebenen Fonttabelle eine Fontdatei. Die Fonttabelle muß dazu in der Task
als benannter Datenraum vorliegen (d.h. sie muß eventuell mit #on("i")#fetch#off("i")# von der Task
"configurator" geholt werden). In der so erstellten Fontdatei können die Änderungen
mit dem Editor vorgenommen, mit #on("i")#create fonttable#off("i")# die geänderte Fonttabelle erstellt
und diese wiederum mit #on("i")#save#off("i")# an die Task "configurator" gesendet werden. Mit dem
#on("i")#fonttable#off("i")#-Kommando kann dann in den bestehenden Tasks die geänderte Fonttabelle
eingestellt werden. Alle neuen Tasks erhalten automatisch die geänderte Fonttabelle. 
 
 
 
#ib(9)#Prozedurbeschreibung der Umwand­ 
lungs­Kommandos#ie(9)# 
 
 
Nach der Insertierung der Datei "font convertor" stehen die folgenden Kommandos zur
Umwandlung einer Fontdatei in eine Fonttabelle oder umgekehrt zur Verfügung. 
 
#ib#create fontfile#ie# 
     PROC create fontfile (TEXT CONST fonttable name, fontfile name) 
     Zweck:  Aus Fonttabelle 'fonttable name' wird eine Fontdatei mit dem ange­
             gebenen Name erstellt. Die Fonttabelle muß dabei in der eigenen Task
             als benannter Datenraum vorliegen. 
 
#ib#create fonttable#ie# 
     PROC create fonttable (TEXT CONST fontfile name) 
     Zweck:  Es werden alle Fonttabellen erzeugt, die in der Fontdatei 'fontfile name'
             angegeben sind. Die Fonttabellen liegen dann als benannte Datenräu­
             me in der Task vor. 
 
     PROC create fonttable 
     Zweck:  Es werden alle Fonttabellen erzeugt, die in der zuletzt bearbeiteten
             Datei angegeben sind. 
 
 
 
 
#ib(9)#7.3. Aufbau der #ib#Fontdatei#ie##ie(9)# 
 
 
In der Fontdatei können drei Strukturen stehen und zwar Kennungen, Identifkationen
und Zeichenspezifikationen.#u##count#)#e# 
#foot# 
 
#value#) Beim formalen Aufbau bedeuten eckige Klammern, daß diese Angaben optional sind. 
 
#end# 
 
 
 
#ib(9)##ib#Kennungen#ie##ie(9)# 
 
 
    Formaler Aufbau:  <#on("i")#Kennung#off("i")#>  :  Name 1  [,  Name 2]  [ ... ] ; 
 
    Eine Kennung leitet eine Definition ein. Für die Namen der Namensliste gelten die
    folgenden Konventionen: 
 
     -  der Name muß als TEXT-Denoter angegeben werden, 
     -  der Name muß ungleich #on("i")#niltext#off("i")# sein, 
     -  Leerzeichen sind im Namen nicht signifikant (d.h. "agfa quer" wird zu "agfa­
        quer"). 
 
    Eine Kennung kann die folgenden Werte annehmen: 
 
    <#on("i")#Kennung#off("i")#>       { FONTTABLE, FONT } 
 
    - #on("b")##ib#FONTTABLE#ie##off("b")# 
        Hiermit wird eine Definition einer Fonttabelle eingeleitet. Es wird nur der erste
        Name der Namensliste ausgewertet, da die Fonttabelle eindeutig identifiziert
        sein muß. Alle folgenden Angaben werden dieser Fonttabelle zugeordnet, bis
        eine neue Kennung FONTTABLE folgt. 
 
    - #on("b")##ib#FONT#ie##off("b")# 
        Hiermit wird eine Definition eines Schrifttyps eingeleitet. Ein Schrifttyp kann
        mehrere Namen haben. Jedoch darf in einer Fonttabelle jeder Fontname nur
        einem Font zugeordnet werden. 
 
 
 
#ib(9)##ib#Identifikation#ie#en#ie(9)# 
 
 
    Formaler Aufbau: [ <#on("i")#Identifikation#off("i")#>  =  <Wert der Identifikation> ; ] 
 
    Mit den Identifikationen werden bestimmte Angaben zu den Kennungen gemacht.
    Sie müssen unmittelbar nach der entsprechenden Kennung folgen, brauchen aber
    nur angegeben werden, wenn sie von den Standardwerten abweichen. 
 
 
 
#ib(9)#Identifikationen nach der Kennung #ib#FONTTABLE#ie##ie(9)# 
 
 
    <#on("i")#Identifikation#off("i")#>       { x unit, y unit, on string, off string } 
 
    - #on("b")##ib#x unit#ie##off("b")# 
        Hiermit wird die Anzahl der Mikroschritte des Druckers pro Zentimeter in
        horizontaler (x-) Richtung spezifiziert. Die Einheit muß als REAL-Denoter
        angegeben werden. Alle weiteren Breitenangaben zu den Fonts dieses Druk­
        kers beziehen sich auf diese Einheit. 
 
        STD-Wert:    10.0 / 2.54  =  3.937008 
 
    - #on("b")##ib#y unit#ie##off("b")# 
        Hiermit wird die Anzahl der Mikroschritte des Druckers pro Zentimeter in
        vertikaler (y-) Richtung spezifiziert. Die Einheit muß als REAL-Denoter ange­
        geben werden. Alle weiteren Höhenangaben zu den Fonts dieses Druckers
        beziehen sich auf diese Einheit. 
 
        STD-Wert:     6.0 / 2.54  =  2.362205 
 
    - #on("b")##ib#on string#ie##off("b")# 
        Hier müssen vier Textdenoter, durch Komma getrennt, angegeben werden.
        Die Textdenoter enthalten die Befehlssequenzen, um beim Drucker die Mo­
        difikationen anzuschalten. Dabei ist die Reihenfolge der Modifikationen 
            underline,   bold,   italics,   reverse. 
        Liegt für eine der Modifikationen keine Befehlssequenz vor, so muß #on("i")#niltext#off("i")#
        angegeben werden. Die Befehlssequenzen können vom Druckertreiber ab­
        gefragt werden. 
 
        STD-Wert:    #on("i")#niltext#off("i")# für alle Modifikationen 
 
    - #on("b")##ib#off string#ie##off("b")# 
        Hier müssen vier Textdenoter, durch Komma getrennt, angegeben werden.
        Die Textdenoter enthalten die Befehlssequenzen, um beim Drucker die Mo­
        difikationen auszuschalten. Dabei ist die Reihenfolge der Modifikationen 
            underline,   bold,   italics,   reverse. 
        Liegt für eine der Modifikationen keine Befehlssequenz vor, so muß #on("i")#niltext#off("i")#
        angegeben werden. Die Befehlssequenzen können vom Druckertreiber ab­
        gefragt werden. 
 
        STD-Wert:    #on("i")#niltext#off("i")# für alle Modifikationen 
 
 
 
#ib(9)#Identifikationen nach der Kennung #ib#FONT#ie##ie(9)# 
 
 
    <#on("i")#Identifikation#off("i")#>       {  font lead, font height, font depth, indentation pitch, 
                               next larger font, next smaller font, 
                               font string, y offsets, bold offset   } 
 
    - #on("b")##ib#font lead#ie##off("b")##u##count#)#e# 
        Der Durchschuß eines Fonts gibt den Zwischenraum in vertikaler Richtung
        zwischen den Zeilen bei einfachem Zeilenvorschub an. Er muß in Mikroschrit­
        ten der y-Richtung als INT-Denoter angegeben werden. 
 
        STD-Wert:    0 
#foot# 
 
#value#) Für spätere Erweiterungen des EUMEL-Druckers wurde die bisherige Fonthöhe in Durchschuß, Fonthöhe
   und Fonttiefe aufgespalten. Für alle bis jetzt definierten Leistungen braucht nur wie bisher die Fonthöhe
   angegeben zu werden. Der Durchschuß und die Fonttiefe werden dann auf Null gesetzt. 
#end# 
 
    - #on("b")##ib#font height#ie##off("b")##u##value#)#e# 
        Die Fonthöhe ist die Distanz von der Basislinie bis zur Oberkante des höch­
        sten Zeichens. Sie muß in Mikroschritten der y-Richtung als INT-Denoter
        angegeben werden. 
 
        STD-Wert:    6 Zeilen pro Inch entsprechend der definierten #on("i")#y unit#off("i")# 
 
    - #on("b")##ib#font depth#ie##off("b")##u##value#)#e# 
        Die Fonttiefe ist die Distanz von der Basislinie bis zur Unterkante des tief­
        sten Zeichens. Sie muß in Mikroschritten der y-Richtung als INT-Denoter
        angegeben werden. 
 
        STD-Wert:    0 
 
    - #on("b")##ib#indentation pitch#ie##off("b")# 
        Einrückungen oder Aufzählungen werden äquidistant berechnet, d.h. Anzahl
        der Zeichen mal einer festen Breite. Diese Einrückbreite sollte ein Mittel al­
        ler Zeichenbreiten sein und braucht nicht der Breite des Leerzeichens zu
        entsprechen. Sie muß in Mikroschritten der x-Richtung als INT-Denoter an­
        gegeben werden. 
 
        STD-Wert:    10 Zeichen pro Inch entsprechend der definierten #on("i")#x unit#off("i")# 
 
    - #on("b")##ib#next larger font#ie##off("b")# 
        Hier muß der Name des nächst größeren Fonts als TEXT-Denoter aufgeführt
        werden. Gibt es keinen nächst größeren Font, so ist #on("i")#niltext#off("i")# anzugeben. 
 
        STD-Wert:    #on("i")#niltext#off("i")# 
 
    - #on("b")##ib#next smaller font#ie##off("b")# 
        Hier muß der Name des nächst kleineren Fonts als TEXT-Denoter aufge­
        führt werden. Gibt es keinen nächst kleineren Font, so ist #on("i")#niltext#off("i")# anzugeben.
        Bei Indizes oder Exponenten wird automatisch auf diesen nächst kleineren
        Font umgeschaltet. 
 
        STD-Wert:    #on("i")#niltext#off("i")# 
 
 
    - #on("b")##ib#font string#ie##off("b")# 
        Hier kann als TEXT-Denoter eine Befehlssequenz angegeben werden, die
        den Drucker auf diesen Font umschaltet. Diese Befehlssequenz kann vom
        Druckertreiber abgefragt werden. Dadurch ist es nicht nötig, daß er die Na­
        men der Fonts kennt. 
 
        STD-Wert:    #on("i")#niltext#off("i")# 
 
    - #on("b")##ib#y offsets#ie##off("b")# 
        Um bei Matrixdruckern Schriften zu erzeugen, die höher als eine Nadelreihe
        sind, müssen entsprechende Bitmuster des Textes an verschiedenen y-Po­
        sitionen ausgegeben werden. Um diese Anforderung durch den EUMEL-
        Drucker zu unterstützen, kann hier eine Liste von Verschiebungen von der
        Basislinie angegeben werden, an denen der Text ein weiteres Mal ausgege­
        ben wird. Dabei bedeuten negative Werte eine Verschiebung oberhalb und
        positive Werte eine Verschiebung unterhalb der Basislinie. Ist der Wert Null,
        so wird der Text auf der Basislinie ausgegeben. Die Modifikation #on("i")#underline#off("i")#
        wird bei der Ausgabe des Textes nur an der ersten Verschiebung angestellt.
        Die Werte für die Verschiebungen müssen in Mikroschritten der y-Richtung
        als INT-Denoter angegeben und durch Komma getrennt werden. 
 
        STD-Wert:    0 
 
    - #on("b")##ib#bold offset#ie##off("b")# 
        Falls der Drucker die Modifikation #on("i")#bold#off("i")# nicht beherrscht, versucht der
        EUMEL-Drucker sie durch Doppeldruck zu simulieren. Der 'bold offset' gibt
        an, ob und wieviel der zweite Durchgang in x-Richtung verschoben werden
        soll. Dies ergibt insbesondere bei Laserdruckern, die nicht für alle Schriftty­
        pen einen Bold-Typ haben, einen recht guten Fettdruck. Der Wert muß in
        Mikroschritten der x-Richtung als INT-Denoter angegeben werden. 
 
        STD-Wert:    0 
 
 
 
#ib(9)##ib#Zeichenspezifikationen#ie##ie(9)# 
 
 
 
   Formaler Aufbau:   [ <Zeichen>  [,  <Breite des Zeichens>] 
                                   [,  <Ersatzdarstellung des Zeichens>] ; ] 
 
 
   Nachdem die Identifikationen zu einer Kennung angegeben wurden, können Zei­
   chenspezifikationen folgen, d.h. zu einem Zeichen kann die Breite und/oder eine
   Ersatzdarstellung spezifiziert werden. Dazu muß zuerst das Zeichen selber als
   TEXT-Denoter angegeben werden. 
 
   - #on("b")##ib#Breite des Zeichens#ie##off("b")# 
       Die Zeichenbreite muß als INT-Denoter in Mikroschritten angegeben werden.
       Alle Zeichenbreiten werden mit der Einrückbreite vorbesetzt, so daß nur sol­
       che Zeichen angegeben werden müssen, deren Breite von der Einrückbreite
       abweichen. Negative Zeichenbreiten sind nicht erlaubt. Die Angabe von Zei­
       chenbreiten nach der Kennung FONTTABLE wird ignoriert. 
 
   - #on("b")##ib#Ersatzdarstellung des Zeichens#ie##off("b")# 
       Die Ersatzdarstellung wird statt des Zeichens ausgedruckt. Sie muß als
       TEXT-Denoter angegeben werden. Werden Ersatzdarstellungen nach der
       Kennung FONTTABLE angegeben, so gelten sie global für alle Fonts dieser
       Fonttabelle. Sie können jedoch bei der Fontangabe lokal wieder überschrie­
       ben werden. Eine Ersatzdarstellung darf höchsten 255 Zeichen lang sein. Alle
       Ersatzdarstellungen eines Fonts dürfen 32767 Zeichen nicht überschreiten. 
 
 
 
#ib(9)##ib#Kommentare in der Fontdatei#ie##ie(9)# 
 
 
   In der Fontdatei dürfen Kommentare eingefügt werden. Sie müssen den Kommen­
   taren der ELAN-Syntax entsprechen, d.h. mit '(*' beginnen und mit '*)' enden. 
 
 
 
#ib(9)##ib#Deutsche Namen#ie##ie(9)# 
 
 
   Kennungen und Identifikationen dürfen in der Fontdatei auch mit folgenden deut­
   schen Namen angegeben werden. 
 
       FONTABLE            :   FONTABELLE 
       FONT                :   FONT 
 
#free (0.15)# 
       x unit              :   x einheit 
       y unit              :   y einheit 
       on string           :   on sequenz 
       off string          :   off sequenz 
       indentation pitch   :   einrueckbreite 
       font lead           :   durchschuss 
       font height         :   fonthoehe 
       font depth          :   fonttiefe 
       next larger font    :   groesserer font 
       next smaller font   :   kleinerer font 
       font string         :   font sequenz 
       y offsets           :   y verschiebungen 
       bold offset         :   bold verschiebung 
 
 
 
 
#ib(9)#7.4. Beispiel für eine Fontdatei#ie(9)# 
 
 
In diesem Beispiel einer Fonttdatei sind drei Fonttabellen enthalten, nämlich "agfa" und
"agfaquer" für den Agfa-Drucker und "epson" für einen Epson-Drucker. 
 
 
FONTTABLE  :  "agfa" ; 
  x unit      =  160.0 ;                 #right#(* Anzahl der Mikroschritte pro cm *) 
  y unit      =  160.0 ; 
  on string   =  "\UL1;",  "\BO1;",  "\IT1;",  "\CFW;\CBB;" ; 
  off string  =  "\UL0;",  "\BO0;",  "\IT0;",  "\CFT;\CBT;" ; 
 
#right#(* globale Ersatzdarstellungen für alle Agfa-Fonts *) 
 
  ""214"" ,   "\!298;" ;                       #right#(* AE *) 
  ""215"" ,   "\!299;" ;                       #right#(* OE *) 
  ""216"" ,   "\!300;" ;                       #right#(* UE *) 
  ""217"" ,   "\!451;" ;                       #right#(* ae *) 
  ""218"" ,   "\!452;" ;                       #right#(* oe *) 
  ""219"" ,   "\!453;" ;                       #right#(* ue *) 
  . 
  . 
  . 
 
  FONT  :  "trium10" ; 
    indentation pitch   =  30 ; 
    font lead           =  7 ; 
    font heigth         =  54 ; 
    font depth          =  15 ; 
    next larger font    =  "trium12" ; 
    next smaller font   =  "helvetica8" ; 
    font string         =  "\FO5;" ; 
 
    " "     ,    20 ;           "!"  ,      16 ; 
    """"    ,    22 ;           "\#"  ,      31 ; 
    "$"     ,    31 ;           "%"  ,      55 ; 
    . 
    . 
    . 
    ""217"" ,    31 ;                          #right#(* ae          *) 
 
#right#(* lokale Ersatzdarstellungen für Font "trium10" *) 
 
    ""244"" ,    43 ,   "\FO23;\!725;\FO5;" ;  #right#(* ungleich    *) 
    ""245"" ,    31 ,   "\FO23;\!405;\FO5;" ;  #right#(* mal-Zeichen *) 
 
  FONT  :  "modern12",  "elanlist" ;    #right#(* Mehrere Namen für einen Font *) 
    indentation pitch  =  33 ; 
    font lead          =  14; 
    font heigth        =  53; 
    font depth         =  13; 
    next larger font   =  "" ; 
    next smaller font  =  "micro" ; 
    font string        =  "\FO11;" 
                                        #right#(* Alle Zeichen haben die gleiche Breite *) 
 
  FONT . . . 
 
 
FONTTABLE  :  "agfaquer" ; 
  x unit      =  160.0 ; 
  y unit      =  160.0 ; 
  on string   =  "\UL1;",  "\BO1;",  "\IT1;",  "\CFW;\CBB;" ; 
  off string  =  "\UL0;",  "\BO0;",  "\IT0;",  "\CFT;\CBT;" ; 
  . 
  . 
  . 
 
 
FONTTABLE  :  "epson" ; 
  x unit      =  47.24409 ;                    #right#(* 120.0 / 2.54 *) 
  y unit      =  85.03937 ;                    #right#(* 216.0 / 2.54 *) 
  on string   =  ""27"-"1"",  "",  ""27"4",  ""; 
  off string  =  ""27"-"0"",  "",  ""27"5",  ""; 
 
  ""214"" ,   ""27"R"2""091""27"R"0"" ;        #right#(* AE                           *) 
  ""215"" ,   ""27"R"2""092""27"R"0"" ;        #right#(* OE                           *) 
  ""216"" ,   ""27"R"2""093""27"R"0"" ;        #right#(* UE                           *) 
  ""217"" ,   ""27"R"2""123""27"R"0"" ;        #right#(* ae                           *) 
  ""218"" ,   ""27"R"2""124""27"R"0"" ;        #right#(* oe                           *) 
  ""219"" ,   ""27"R"2""125""27"R"0"" ;        #right#(* ue                           *) 
  ""220"" ,   "k" ;                            #right#(* Trenn-k                      *) 
  ""221"" ,   "-" ;                            #right#(* Trennstrich                  *) 
  ""222"" ,   "\#" ;                            #right#(* geschütztes Nummernkreuz     *) 
  ""223"" ,   " " ;                            #right#(* geschütztes Leerzeichen      *) 
  ""251"" ,   ""27"R"2""126""27"R"0"" ;        #right#(* ss                           *) 
  ""252"" ,   ""27"R"2""064""27"R"0"" ;        #right#(* Paragraph                    *) 
 
  FONT  :  "12",  "elite",  "elite12" ;        #right#(* Mehrere Namen für einen Font *) 
    font height        =  36 ; 
    indentation pitch  =  10 ; 
    next smaller font  =  "12.klein" ; 
    font string        =  ""27"!"1""27"p"0""27"T" ; 
    bold offset        =  2 ; 
 
  FONT  :  "12.klein",  "elite.klein",  "elanlist" ; 
    font height         =  20 ; 
    indentation pitch   =  10 ; 
    next smaller font   =  "12.klein" ; 
    font string         =  ""27"!"1""27"p"0""27"S"1"" ; 
    bold offset         =  1 ; 
 
  FONT  :  "12.hoch" ; 
    font height         =  96 ; 
    indentation pitch   =  10 ; 
    next smaller font   =  "12.klein" ; 
    font string         =  "" ; 
    bold offset         =  2 ; 
    y offsets           =  12, -12 ;#right#(* der Text wird jeweils 12 Mikroschritte unter-    
                                    #right#   und überhalb der Basislinie ausgegeben *) 
 
  FONT  :  "prop10",  "prop" ; 
    font height         =  12 ; 
    indentation pitch   =  24 ; 
    next smaller font   =  "" ; 
    font string         =  ""27"!"0""27"p"1""27"T" ; 
    bold offset         =  2 ; 
 
    "!"   ,   10 ; 
    """"  ,   16 ; 
    "("   ,   12 ; 
    . . . 
 
 
 
 
 
#ib(9)#7.5. Schnittstelle des #ib#Fontspeicher#ie#s#ie(9)# 
 
 
 
Das Paket #on("i")#font store#off("i")# liefert die folgenden Prozeduren: 
 
#ib#fonttable#ie# 
     PROC fonttable (TEXT CONST fonttable name) 
     Zweck:  Stellt die angegebene Fonttabelle in der Task ein. Dabei wird zuerst in
             der eigenen Task nach der angegebenen Fonttabelle gesucht. Existiert
             die Fonttabelle in der eigenen Task nicht, so wird die Fonttabelle von
             der Task "configurator" geholt. 
             Wenn die Fonttabelle eingestellt ist, sind in der Task nur noch die Fonts
             dieser Fonttabelle bekannt. Die Einstellung vererbt sich auf die Sohn­
             tasks. 
 
     TEXT PROC fonttable 
     Zweck:  Liefert den Name der eingestellten Fonttabelle. 
 
#ib#list fonttables#ie# 
     PROC list fonttables 
     Zweck:  Zeigt die Liste der verfügbaren Fonttabellen im #on("i")#notebook#off("i")#. 
 
#ib#list fonts#ie# 
     PROC list fonts 
     Zweck:  Listet die Fonts der eingestellten Tabelle ins #on("i")#notebook#off("i")#. 
 
     PROC list fonts (TEXT CONST fonttable name) 
     Zweck:  Listet die Fonts der angegebenen Fonttabelle ins #on("i")#notebook#off("i")#. Die vorher
             eingestellte Fonttabelle bleibt jedoch weiter eingestellt. 
 
#ib#x step conversion#ie# 
     INT PROC x step conversion (REAL CONST cm) 
     Zweck:  Rechnet die in Zentimeter angegebene Länge in Mikroschritte der
             x-Richtung um. 
 
     REAL PROC x step conversion (INT CONST steps) 
     Zweck:  Rechnet die in Mikroschritten der x-Richtung angegebene Länge in
             Zentimeter um. 
 
#ib#y step conversion#ie# 
     INT PROC y step conversion (REAL CONST cm) 
     Zweck:  Rechnet die in Zentimeter angegebene Länge in Mikroschritte der
             y-Richtung um. 
 
     REAL PROC y step conversion (INT CONST steps) 
     Zweck:  Rechnet die in Mikroschritten der y-Richtung angegebene Länge in
             Zentimeter um. 
 
#ib#on string#ie# 
     TEXT PROC on string (INT CONST modification) 
     Zweck:  Liefert die in der Fonttabelle spezifizierte Befehlssequenz, um eine
             Modifikation anzuschalten. Es gibt die folgenden Modifikationen 
                   1     underline 
                   2     bold 
                   4     italics 
                   8     reverse 
 
#ib#off string#ie# 
     TEXT PROC off string (INT CONST modification) 
     Zweck:  Liefert die in der Fonttabelle spezifizierte Befehlssequenz, um eine
             Modifikation auszuschalten. Es gibt die folgenden Modifikationen 
                   1     underline 
                   2     bold 
                   4     italics 
                   8     reverse 
 
#ib#font#ie# 
     INT PROC font (TEXT CONST font name) 
     Zweck:  Liefert die interne Fontnummer des Fonts. Mit dieser Fontnummer
             können die weiteren Informationen über den Font angefordert werden.
             Existiert kein Font mit diesem Namen, so wird Null geliefert. 
 
     TEXT PROC font (TEXT CONST font nr) 
     Zweck:  Liefert den Fontnamen des Fonts mit der angegeben Fontnummer. Hat
             der Font mehrere Namen, so wird der erste Name der Namensliste aus
             der Fontdatei geliefert. Existiert kein Font unter dieser Nummer, so wird
             #on("i")#niltext#off("i")# geliefert. 
 
#ib#font exists#ie# 
     BOOL PROC font exists (TEXT CONST font name) 
     Zweck:  Informationsprozedur zur Abfrage der Existenz eines Fonts. 
 
#ib#next smaller font exists#ie# 
     BOOL PROC next smaller font exists  (INT CONST font nr, 
                                          INT VAR next smaller font) 
     Zweck:  Informationsprozedur zur Abfrage der Existenz des nächst kleineren
             Fonts. Wenn er existiert, wird die Fontnummer dieses Fonts zurück­
             geliefert. 
 
#ib#next larger font exists#ie# 
     BOOL PROC next larger font exists  (INT CONST font nr, 
                                         INT VAR next larger font) 
     Zweck:  Informationsprozedur zur Abfrage der Existenz des nächst größeren
             Fonts. Wenn er existiert, wird die Fontnummer dieses Fonts zurück­
             geliefert. 
 
#ib#indentation pitch#ie# 
     INT PROC indentation pitch (INT CONST font nr) 
     Zweck:  Liefert die Einrückbreite in Mikroschritten der x-Richtung. Sie sollte eine
             mittlere Breite der Zeichen sein, denn mit ihr werden die Einrückungen
             und Aufzählungen berechnet. 
 
#ib#font lead#ie# 
     INT PROC font lead (INT CONST font nr) 
     Zweck:  Liefert den Durchschuss des Fonts in Mikroschritten der y-Richtung.
             Der Druchschuß ist der Zwischenraum zwischen den einzelnen Zeilen
             bei einfachem Zeilenvorschub. 
 
#ib#font height#ie# 
     INT PROC font height (INT CONST font nr) 
     Zweck:  Liefert die Höhe des Fonts in Mikroschritten der y-Richtung. Die Fon­
             thöhe ist die Distanz von der Basislinie bis zur Oberkante des höchsten
             Zeichens. 
 
#ib#font depth#ie# 
     INT PROC font depth (INT CONST font nr) 
     Zweck:  Liefert die Tiefe des Fonts in Mikroschritten der y-Richtung. Die Fonttie­
             fe ist die Distanz von der Basislinie bis zur Unterkante des tiefsten
             Zeichens. 
 
#ib#font string#ie# 
     TEXT PROC font string (INT CONST font nr) 
     Zweck:  Liefert den Fontstring des Fonts. Der Fontstring enthält die Befehls­
             sequenz, um den Drucker auf diesen Font umzuschalten. 
 
#ib#y offsets#ie# 
     TEXT PROC y offsets (INT CONST font nr) 
     Zweck:  Liefert einen Text mit den y-Verschiebungen von der Basislinie. Die
             einzelnen Verschiebungen können mit dem Operator 'ISUB' abgefragt
             werden. 
 
#ib#bold offsets#ie# 
     INT PROC bold offsets (INT CONST font nr) 
     Zweck:  Liefert die 'bold'-Verschiebung. 
 
#ib#char pitch#ie# 
     INT PROC char pitch (INT CONST font nr, TEXT CONST char) 
     Zweck:  Liefert die Breite des Zeichens in Mikroschritten der x-Richtung. 
 
#ib#replacement#ie# 
     TEXT PROC replacement (INT CONST font nr, TEXT CONST char) 
     Zweck:  Falls das Zeichen eine Ersatzdarstellung hat, so wird diese geliefert,
             anderfalls das Zeichen selbst. 
 
#ib#get font#ie# 
     PROC get font  (INT CONST font nr, 
                     INT VAR indentation pitch, font lead, font height, font depth, 
                     ROW 256 INT VAR pitch table) 
     Zweck:  Die Variablen liefern die entsprechenden Informantionen über den
             Font. Der Eintrag des Codewerts eines Zeichens plus eins in der Brei­
             tentabelle liefert die Breite dieses Zeichens. 
 
#ib#get replacements#ie# 
     PROC get replacements  (INT CONST font nr, 
                             TEXT VAR replacements, 
                             ROW 256 INT VAR replacement table) 
     Zweck:  In der Fonttabelle kann für jedes Zeichen eine Ersatzdarstellung an­
             gegeben werden. Diese Ersatzdarstellungen werden mit dieser Proze­
             dur geliefert. Dabei stehen in der Textvariablen 'replacement' die ge­
             samten Ersatzdarstellungen des Fonts. Die Ersatzdarstellungstabelle
             enthält Zeiger auf den Text der Ersatzdarstellungen. Die Ersatzdarstel­
             lung eines Zeichnes bestimmt sich wie folgt: 
 
 
     ersatzdarstellung : 
       INT CONST wert := replacement table (code( zeichen ) + 1); 
       IF wert > 0 
          THEN INT CONST ende := wert + code (replacements SUB wert); 
               subtext (replacements, wert + 1, ende) 
          ELSE zeichen 
        FI. 
 
 
Bei den Prozeduren des Packets #on("i")#font store#off("i")# können die folgenden Fehlerfälle auftreten: 
 
     -  Fonttabelle noch nicht eingestellt 
          Es wurde noch keine Fonttabelle in der Task eingestellt. 
 
     -  Fonttabelle "fonttable name" gibt es nicht 
          Die angegebene Fonttabelle wurde weder in der eigenen Task, noch in der
          Task 'configurator' gefunden. 
 
     -  Font 'font nr' gibt es nicht 
          Unter der angegebenen Fontnummer gibt es in der eingestellten Font­
          tabelle keinen Font. Speziell ist das für 'font nr' = 0 der Fall, falls ein Font­
          name nicht gefunden wurde. 
 
     -  unzulaessige Modifikation 
          Die angegebene Modifikation ist ungleich 1, 2, 4 oder 8. 
#page# 
 
#headeven# 
 
%#center#EUMEL-Systemhandbuch 
 
 
#end# 
#headodd# 
 
#center#8. Verschiedenes#right#% 
 
 
#end# 
 
#ib(9)#8. Verschiedenes#ie(9)# 
 
 
 
 
#ib(9)#8.1. Der Spoolmanager#ie(9)# 
 
 
Der "#ib#Spoolmanager#ie#" verwaltet eine #ib#Warteschlange von Datenräumen#ie# (Dateien), die von
einem "#ib#Server#ie#" abgearbeitet werden sollen. Dabei puffert der Spoolmanager Dateien,
die von beliebigen Tasks geschickt werden können, in einer Warteschlange und gibt
sie der Reihe nach dem Server zur eigentlichen Verarbeitung. Ein typischer Einsatzfall
(aber nicht der einzige) für ein solches System ist der Druck von Dateien in Multi-
User-Systemen. Unabhängig davon, ob der Drucker gerade aktiv ist und wieviele
Dateien noch auf den Ausdruck warten, kann jeder seine Datei dem Druckerspool (in
der Regel die Task "PRINTER") senden und sofort danach weiterarbeiten. 
 
 
 
#ib(9)#Prozeduren des Spoolmanagers#ie(9)# 
 
 
Im privilegierten Ast des Taskbaumes (Söhne von "SYSUR"), stehen die folgenden
Prozeduren zur Einrichtung eines Spoolmanagers zur Verfügung. 
 
#ib#spool manager#ie# 
     PROC spool manager (PROC server, BOOL CONST with start) 
     Zweck: Die Task, in der die Prozedur aufgerufen wird, wird zum Spoolmanager.
            Wenn 'with start' auf TRUE  gesetzt ist, wird eine Server-Task als unbe­
            nannter Sohn ("-") eingerichtet und mit der übergebenen 'PROC server'
            gestartet. Anderfalls muß der Spool durch den Benutzer mit Hilfe der
            Spoolkommandos (siehe dort) gestartet werden. 
 
     PROC spool manager (PROC server) 
     Zweck: Diese Prozedur ruft die Prozedur 'spool manager' mit 'with start' gleich
            TRUE auf. 
 
 
Mit Hilfe der folgenden Prozeduren kann der Spool eingestellt werden. 
 
#ib#station only#ie# 
     PROC station only (BOOL CONST flag) 
     Zweck: Wenn flag auf TRUE gesetzt ist, nimmt der Spooler nur Aufträge von
            Tasks der eigenen Station entgegen. 
            Voreinstellung: 'station only (FALSE)'. 
 
     BOOL PROC station only 
     Zweck: liefert TRUE, wenn der Spooler nur von der eigenen Station benutzt
            werden darf. 
 
#ib#spool duty#ie# 
     PROC spool duty (TEXT CONST duty) 
     Zweck: Mit dieser Prozedur kann ein Text im Spooler eingestellt werden, der die
            Aufgabe des Spoolers beschreibt. Dieser wird beim 'list' gemeldet. 
 
     TEXT PROC spool duty 
     Zweck: Liefert die eingestellte Text-Beschreibung der Aufgabe des Spools. 
 
#ib#spool control task#ie# 
     PROC spool control task (TASK CONST task) 
     Zweck: Diese Prozedur gibt der Task 'task' und ihrer Söhne die Berechtigung
            Spoolkommandos (z.B. 'stop' oder 'start') an den Spoolmanager zusen­
            den. Dabei muß die Task auf derselben Station wie der Spool sein und
            in der Task muß die Datei "spool cmd", die sich auf dem Standardar­
            chiv befindet, insertiert werden. 
            Wird "SUPERVISOR" als Spoolkontrolltask eingestellt, so können alle
            Tasks der Station, in denen die Datei "spool cmd" insertiert ist, die
            Spoolkommandos geben. 
 
     TASK PROC spool control task 
     Zweck: Liefert die Taskidentifikation der Spoolkontrolltask. 
 
#ib#server channel#ie# 
     PROC server channel (INT CONST channel) 
     Zweck: Mit Hilfe dieser Prozedur wird im Spoolmanager eine Kanalnummer
            eingestellt, die der Server mit der Prozedur 'server channel' abfragen
            kann. 
     Fehlerfall: 
            *  falsche Kanalangabe 
                 Der angegebene Kanal ist kleiner als 1 oder größerer als 32. 
 
     INT PROC serverchannel 
     Zweck: Liefert die Nummer des Kanals, der im Spool eingestellt ist. 
 
#on("b")#Anmerkung:#off("b")#  Soll im nicht-privilegierten Ast des Taskbaums (Söhne von "PUBLIC") ein
            Spool eingerichtet werden, so muß dort die Datei "spool manager", die
            sich auf dem Standardarchiv "std.zusatz" befindet, insertiert werden. 
 
 
 
 
#ib(9)##ib#Spoolkommandos#ie##ie(9)# 
 
 
Ein Spool kann zur Verwaltung der Warteschlange wie jede andere Task ans Termi­
nal gekoppelt werden. Danach stehen die folgenden Spoolkommandos zur Verfügung.
Diese Kommandos sind keine Prozeduren, sondern werden nur interpretiert. Sie dürfen
also nur alleine eingegeben werden. Nach Beendigung der Verwaltungsaufgaben muß
der Spool mit dem Kommando 'break' verlassen werden, da sonst keine weiteren
Aufträge an den Spool gesendet werden können und auch die Warteschlange nicht
weiter abgearbeitet wird. 
 
#ib#stop#ie# 
     Zweck: Die Server-Task wird gelöscht und dadurch der Spool deaktiviert. Der
            Spool empfängt zwar noch weitere Aufträge und sortiert diese in die
            Warteschlange ein. Die Warteschlange wird aber nicht weiterabgearbei­
            tet. Ein eventuell von der Server-Task belegter Kanal wird freigegeben. 
            Ist bei einem 'stop' noch ein Auftrag in Bearbeitung, so wird dieser
            Auftrag abrupt abgebrochen. Es wird jedoch angefragt, ob der Auftrag
            nochmal neu an die erste Stelle in der Warteschlange eingetragen wer­
            den soll. 
            Ist ein Spool deaktiviert, so wird dies bei einem 'list' angezeigt, 
 
#ib#halt#ie# 
     Zweck: Der Spool deaktiviert sich nach Abarbeitung des Auftrags, der gerade
            bearbeitet wird. Bei einem 'list' wird dies vermerkt. 
 
#ib#start#ie# 
     Zweck: Der Spool wird aktiviert, indem eine neue Server-Task begonnen wird. Ist
            der Spool zuvor nicht gestoppt worden, so wird zuerst ein 'stop' durch­
            geführt. 
            Wurde mit der Prozedur 'server channel' kein Kanal eingestellt, so wird
            die Warnung 
                  WARNUNG : Serverkanal nicht eingestellt 
            ausgeben. Der Spool wird trotzdem gestartet. 
 
start (kanal nummer) 
     Zweck: Vor dem Start des Spools wird zuerst mit der Prozedur 'server channel'
            der angegebene Kanal eingestellt. 
 
#ib#first#ie# 
     Zweck: Im Dialog kann ein Auftrag in der Warteschlange auf den ersten Platz
            vorgezogen werden. 
 
#ib#killer#ie# 
     Zweck: Im Dialog werden alle Aufträge der Warteschlange zum Löschen ange­
            boten. 
 
#ib#list spool#ie# 
     Zweck: Der aktuelle Zustand des Spools und die Warteschlange werden geli­
            stet. 
 
Ist nun eine Spoolkontrolltask eingestellt worden (siehe 'spool control task'), so muß in
ihr die Datei "spool cmd" insertiert werden. Danach stehen die folgenden Prozeduren
zur Verfügung. 
 
#ib#stop#ie# 
     PROC stop (TASK CONST spool) 
     Zweck: Dem Spool 'spool' wird ein 'stop' zugestellt, was den Spool deaktiviert.
            Wird noch ein Auftrag bearbeitet, so wird angefragt, ob dieser neu
            eingetragen werden soll. 
 
#ib#halt#ie# 
     PROC halt (TASK CONST spool) 
     Zweck: Dem Spool 'spool' wird ein 'halt' zugestellt, d.h der Spool deaktiviert
            sich nach Beendigung des aktuellen Auftrags. 
 
#ib#wait for halt#ie# 
     PROC wait for halt (TASK CONST spool) 
     Zweck: Dem Spool 'spool' wird ein 'halt' zugestellt. Die Task wartet jedoch auf
            eine Rückantwort, die ihr der Spool sendet, wenn er sich nach Been­
            digung des aktuellen Auftrags deaktiviert hat. 
     Fehlerfall: 
            *  Task "task name" wartet schon auf halt 
               Die angegebene Task wartet schon auf eine Rückantwort des Spools
               'spool'. 
 
#ib#start#ie# 
     PROC start (TASK CONST spool) 
     Zweck: Dem Spool 'spool' wird ein 'start' zugestellt, wodurch der Spool sich
            aktiviert. War der Spool zuvor nicht deaktiviert, so wird er zuerst ge­
            stoppt. 
 
#ib#first#ie# 
     PROC first (TASK CONST spool) 
     Zweck: Im Dialog kann einer der Aufträge in der Warteschlange des Spools
            'spool' auf den ersten Platz vorgezogen werden. 
 
#ib#killer#ie# 
     PROC killer (TASK CONST spool) 
     Zweck: Im Dialog werden die Aufträge der Warteschlange des Spools 'spool'
            zum Löschen angeboten. 
 
 
 
#ib(9)#Arbeitsweise des #ib#Servers#ie##ie(9)# 
 
 
Der Server wird vom Spoolmanager mit einer Prozedur gestartet, die die Abarbeitung
der Warteschlange vornimmt. Dabei muß diese Prozedur zuerst den Datenraum mit
dem 'fetch code' (= 11) holen. Danach kann der Server sich noch mit dem 'fetch
param code' (= 21) die Dateiparameter (Dateiname, Schreib- und Lesepaßwort, Sen­
dername und Senderstation) abholen und mit der Bearbeitung des Auftrags beginnen. 
 
Beispiel: 
 
 
LET fetch code       = 11, 
    param fetch code = 21; 
BOUND STRUCT (TEXT name, write pass, read pass, sendername, 
              INT  senderstation ) VAR msg; 
DATASPACE VAR ds, param ds; 
INT VAR reply; 
 
spool manager (PROC server); 
 
PROC server : 
     disable stop; 
     continue (server channel); 
     REP forget (ds); ds := nilspace; 
         call (father, fetch code, ds, reply); 
         forget (param ds); param ds := nilspace; 
         call (father, param fetch code, param ds, reply); 
         msg := param ds; 
         execute spool; 
         IF is error THEN error treatment FI; 
    PER; 
END PROC server; 
 
PROC execute spool : 
     enable stop; 
     ... 
 
 
 
 
 
#ib(9)#Senden eines Auftrags an den Spool#ie(9)# 
 
 
Jede Task kann jedem Spool durch Aufruf von '#ib#save#ie#' eine Datei senden. 
 
Beispiel: 
 
 
   save ("datei name", task ("spool name")) 
 
 
Dieses 'save'-Kommando funktioniert zweiphasig. Dabei wird in der ersten Phase dem
Spool die Dateiparameter zugesendet. In der zweiten Phase folgt dann der Datenraum
selber. Bei Netzübertragung zu einem Spool ist dieses zweiphasige 'save' jedoch
nachteilig. Deshalb können Dateien vom Typ 'FILE' auch mit einem einphasigen 'save'
unter dem 'file save code' (= 22) an den Spool gesendet werden. Die #on("i")#'headline'#off("i")# dieser
Dateien muß jedoch dann auf eine bestimmte Art und Weise aufbereitet werden, so
daß sie die Dateiparameter enthält. Beim Aufbau der #on("i")#'headline'#off("i")# muß eine Information
muß mit dem Code 0 beginnen und dem Code 1 enden. Die Dateiparamter müssen
dann mit der folgenden Reihenfolge in die #on("i")#'headline'#off("i")# eingetragen werden. 
 
   -  Dateiname 
   -  Schreibepaßwort 
   -  Lesepaßwort 
   -  Name des Senders 
   -  Station des Senders 
 
Beispiel: 
 
 
... 
LET file save code = 22; 
DATASPACE VAR ds := old (file name); 
FILE VAR file := sequential file (input, ds); 
INT VAR reply; 
headline (file,    ""0"" + file name + 
                ""1""0"" + write password + 
                ""1""0"" + read password + 
                ""1""0"" + name (myself) + 
                ""1""0"" + text (station (myself)) + ""1""); 
call (spool task, file save code, ds, reply); 
... 
 
 
Der Spoolmanager setzt bei Dateien, die mit dem 'file save code' angeliefert werden
die #on("i")#'headline'#off("i")# wieder auf den Dateinamen. 
 
Den Benutzer stehen neben dem '#ib#save#ie#'-Kommando zur Übertragung einer Datei zum
Spool noch die folgenden Kommandos zur Verfügung. 
 
 
   save (ALL myself, task ("spool name")) 
   save (SOME myself, task ("spool name")) 
 
       übertragung aller bzw. einiger Dateien der eigenen Task zum Spool. 
 
 
   #ib#erase#ie# ("datei name", task ("spool name")) 
   erase (ALL task ("spool name"), task ("spool name")) 
 
       Löschen eines bzw. aller eigenen Aufträge in der Warteschlange des Spools 
 
 
   #ib#list#ie# (task ("spool name")) 
 
       Liste des Spools über den aktuellen Zustand und die Warteschlange. 
 
Existiert ein Spool "PRINTER", so gibt es noch die folgenden Befehle. 
 
 
   #ib#print#ie# 
   print ("datei name") 
   print (ALL myself) 
   print (SOME myself) 
 
       Sie entsprechen einem 'save' an die Task "PRINTER" 
 
 
   #ib#printer#ie# 
 
       Liefert den internen Taskbezeichner der Task "PRINTER", d.h. diese Proze­
       dur entspricht dem Aufruf von 'task ("PRINTER")'. 
 
 
 
 
 
#ib(9)#8.2. #ib#Freie Kanäle#ie(9)##ie# 
 
 
Das Paket '#ib#free channel#ie#' ermöglicht in Multi-User-Systemen die Einrichtung freier
Kanäle. Freie Kanäle kann man zusätzlich zu dem Terminalkanal, der einem vom
Supervisor zugeordnet wurde, benutzen. Jeder freie Kanal wird durch eine (benannte)
Task - dem #ib#Kanalmanager#ie# - implementiert. Er wird danach mit dem Tasknamen ange­
sprochen und kann von jeder Task belegt und wieder freigegeben werden. Während
einer Belegung können andere Tasks den Kanal nicht benutzen. Der Kanalmanager
koppelt sich für jede Belegung an den physikalischen Kanal an und gibt ihn danach
auch wieder frei. Ein physischer Kanal kann also im Wechsel von mehreren Kanalma­
nagern oder einem Kanalmanager und "normalen" Tasks belegt werden. 
 
Das Paket 'free channel' muß beim Kanalmanager und allen Benutzern des Kanals
bzw. bei einem gemeinsamen Vater insertiert sein. 
 
 
#ib#FCHANNEL#ie# 
     Zweck: Der Datentyp FCHANNEL spezifiziert einen freien Kanal. Die Assoziie­
            rung mit einem realen freien Kanal erfolgt mit der Prozedur 'free chan­
            nel' und der Zuweisung ':=' (ähnlich wie beim Datentyp FILE). 
 
:= 
     OP := (FCHANNEL VAR dest, FCHANNEL CONST source) 
     Zweck: Zuweisung. Wird insbesondere bei der Assoziation (Assoziation: Verbin­
            dung zwischen FCHANNEL VAR und Kanal) benötigt. 
 
#ib#close#ie# 
     PROC close (FCHANNEL VAR f) 
     Zweck: Der belegte FCHANNEL wird freigeben. 
 
     PROC close (TEXT CONST channel name) 
     Zweck: Der namentlich spezifizierte Kanal wird freigegeben. 
 
#ib#dialogue#ie# 
     PROC dialogue (FCHANNEL CONST f, TEXT CONST end of dialogue char) 
     Zweck: Der Terminalkanal wird direkt mit dem angegebenen freien Kanal ge­
            koppelt. (Das Benutzerterminal wird "durchgeschaltet".) Eingaben am
            Terminal werden auf 'f' ausgegeben, auf 'f' ankommende Daten werden
            auf dem Benutzerterminal ausgegeben. Der Datenverkehr erfolgt im
            #ib#Vollduplexmodus#ie#, d.h. der Datenverkehr beider Richtungen läuft unab­
            hängig voneinander parallel. Hiermit können Terminals dynamisch an
            andere Rechner gekoppelt werden. Der Dialogzustand wird durch Ein­
            gabe des 'end of dialogue char' am Benutzerterminal beendet. 
 
#ib#fetch#ie# 
     PROC fetch (FCHANNEL VAR channel, TEXT CONST filename, controlchars) 
     Zweck: Die angegebene datei wird über den Kanal 'channel' eingelesen. Dabei
            besteht 'control chars' aus zwei bis vier Zeichen 
               (eof + eol + handshake + handshake prompt) 
            eof: 
                Dieses Zeichen wird als Dateiabschluß erwartet. 
            eol: 
                Dieses Zeichen wird als Zeilenende erwartet. 
            handshake, handshake prompt: 
                Falls 'handshake prompt <> "" ' ist, wird bei dem Empfang eines
                Prompt­Zeichen eine Quittung (Handshake­Zeichen) ausgegeben. 
 
#ib#free channel#ie# 
     FCHANNEL PROC free channel (TEXT CONST channel name) 
     Zweck: Der namentlich spezifizierte Kanal wird belegt und als FCHANNEL
            geliefert. 
     Fehlerfälle: 
          * task not existing 
          * channel not free 
 
     PROC free channel (INT CONST physical channel number) 
     Zweck: Installiert die eigene Task als Kanalmanager für den angegebenen
            physikalischen Kanal. 
 
#ib#in#ie# 
     PROC in (FCHANNEL CONST f, TEXT VAR response) 
     Zweck: Es werden die Daten geliefert, die seit dem letzten 'in'­Aufruf bzw. seit
            der Assoziierung eingetroffenen Daten geliefert. Bei 'niltext' liegen keine
            Eingabedaten vor. 
 
#ib#open#ie# 
     PROC open (FCHANNEL VAR f) 
     Zweck: Der Kanal wird neu belegt. Die Assoziation erfolgt mit dem gleichen
            Kanal wie bei der letzten Assoziation. 
     Fehlerfälle: 
          * "task" gibt es nicht 
          * Kanal ist nicht frei 
 
#ib#out#ie# 
     PROC out (FCHANNEL VAR f, TEXT CONST message) 
     Zweck: Der übergebene Text wird auf dem Kanal 'f' ausgegeben. 
 
#ib#save#ie# 
     PROC save (FCHANNEL VAR f, TEXT CONST name, control chars) 
     Zweck: Die übergebene Datei muß eine Textdatei sein (Struktur eines FILEs
            haben). Sie wird komplett auf dem Kanal 'f' ausgegeben. 
            Dabei bestehen 'control chars' aus bis zu drei Zeichen: 
               (eof char + eol char + handshake option) 
            eof char: 
                Dieses Zeichen wird als Dateiabschluß geschickt. 
            eol char: 
                Dieses zeichen wird als Zeilenabschluß geschickt. 
            handshake option: 
                Falls die 'control chars' drei Zeichen umfassen, wird nach jeder
                Zeile auf das als drittes definierte Handshake­Zeichen gewartet. 
 
Beispiele: 
 
 
  a) FCHANNEL VAR f := free channel ("otto") ; 
     TEXT VAR antwort ; 
     out (f, "hallo") ; 
     in (f, antwort) ; 
     put (antwort) ; 
     close (f) ; 
 
  b) open (f) ; 
     REP 
       out (f, "hallo ") ; 
       in (f, antwort) 
     UNTIL antwort <> "" PER ; 
     put (antwort) ; 
     close (f) ; 
 
  c) open (f) ; 
     dialogue (f, "§") ; 
     close (f) 

