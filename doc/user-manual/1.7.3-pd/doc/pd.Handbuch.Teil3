                          EUMEL-Benutzerhandbuch 
 
                          TEIL 3: Editor                            
 
Vorwort 
 
Der EUMEL-Editor ist ein Programm zur Bearbeitung von Texten. Er bietet 
vielfältige Möglichkeiten, um Autoren oder Programmierer bei dem Erstellen, 
Korrigieren und Gestalten von Manuskripten oder Programmen zu unterstützen. 
Die größte Hilfe beim Schreiben besteht (durch die Speicherfähigkeit von 
Computern) aus dem Zugriff auf einmal geschriebene Informationen. Im Gegen- 
satz zu einer Schreibmaschine können durch den EUMEL-Editor (beliebig oft) 
Einfügungen vorgenommen, Texte korrigiert, gelöscht und umgeordnet werden. 
Somit ist das Schreiben von Texten mittels des EUMEL-Systems besonders dann 
vorteilhaft und zeitsparend, wenn Texte häufig geändert werden oder wenn 
sie in einer besonders schönen Form gedruckt werden sollen (sofern ein ent- 
sprechender Drucker zur Verfügung steht). Weiterhin bietet der Editor Hilfen 
zum Schreiben an, wie z.B. automatischen Wortumbruch am Zeilenende, eine 
Einrückungsautomatik, "Lernen" von Texten u.a.m.. Zusätzlich kann der Editor 
in seinen Fähigkeiten erweitert und somit für spezielle Schreibarbeiten an- 
gepaßt werden. Bei der Entwicklung des Editors wurde besonderer Wert auf 
einfache Bedienung gelegt: innerhalb von wenigen Minuten kann schon ge- 
schrieben werden und auf dem Bildschirm sieht man direkt, was mit dem Text 
passiert. Das Schreiben und die Korrektur werden durch einige wenige, aber 
leistungsstarke Funktionstasten unterstützt. 
 
Anfänger sollten zumindest das erste Kapitel lesen, bevor mit dem Schreiben 
begonnen wird. Dort wird geschildert, wie auf einfache Weise Texte ge- 
schrieben und geändert werden können. Die beschriebenen Tätigkeiten sollte 
man an einem kleinen Probetext erst einmal ausprobieren. Lesen und an- 
schließendes Ausprobieren eines der hier beschriebenen Vorgänge beschleunigt 
stark das Erlernen der Funktionen des Editors. 
 
Weitere Fähigkeiten des Editors werden in den folgenden Kapiteln erläutert. 
Diese Kapitel sollte man lesen, wenn die ersten Texte geschrieben worden 
sind. Die dort erklärten Möglichkeiten des Editors kann man dann bei Bedarf 
nachlesen, erlernen und einsetzen. Im letzten Kapitel werden Programmierern 
Hinweise gegeben, wie sie die Benutzerschnittstelle des Editors an indivi- 
duelle Bedürfnisse anpassen können. 
 
Einige Gestaltungsmöglichkeiten für Texte kann man nicht auf dem Terminal 
"sehen", wie z.B. Proportionalschriften, Fettdruck usw.. Solche Leistungen 
können durch Anweisungen an die Textkosmetik-Programme und den EUMEL-Drucker 
angefordert werden. Diese Anweisungen müssen in den Text eingefügt werden. 
Dazu sollte das Kapitel über die Textkosmetik gelesen werden. 
 
is nämlich alles ohne Radiergummi-Abbildung !!! 
 
 
 
1. Einführung in die Benutzung des Editors 
 
In diesem Kapitel beschreiben wir das Tastenfeld eines EUMEL-Terminals, weil 
es hier einige Tasten gibt, die auf einer Schreibmaschine nicht vorhanden 
sind. Anschließend erklären wir, wie der Editor ein- und ausgeschaltet wird, 
wie Texte geschrieben und auf einfache Weise korrigiert werden können. Eine 
kurze Erklärung des Tabulators beendet die Einführung. 
 
 
 
Das Tastenfeld 
 
In diesem Abschnitt wird das Tastenfeld eines EUMEL-Terminals erklärt. Es 
wird erläutert, wo sich die Tasten befinden und wie man Umlaute schreibt. 
 
Das Tastenfeld eines EUMEL-Terminals entspricht weitgehend dem einer 
Schreibmaschine. Wir finden also die Buchstaben a-z und die Ziffern 0-9 auf 
Tasten. Mit der SHIFT-Taste und gleichzeitigem Drücken einer anderen Taste 
können die großen Buchstaben und eine Reihe von speziellen anderen Zeichen, 
die Sonderzeichen genannt werden, geschrieben werden. Die "Zwischenraum- 
taste" oder Leertaste erzeugt immer ein Leerzeichen. 
 
Nun gibt es in der Praxis zwei unterschiedliche Tastaturen. Zum einen 
existiert die EDV-Tastatur, die zum Schreiben von Programmen benutzt wird. 
Sie erkennt man daran, daß keine Umlaute (ä, ü, ö) und kein ß auf den Tasten 
eingraviert sind. Dafür gibt es Tasten für eckige und geschweifte Klammern. 
Sollen auf einer solchen Tastatur die Umlaute geschrieben werden, muß man 
sich eines Tricks bedienen: mit der Taste ESC und nachfolgendem Betätigen 
einer anderen Taste erhalten wir den entsprechenden Umlaut. 
Diese Tasten sind standardmäßig vorbelegt, können aber von Benutzern und in 
Anwenderprogrammen geändert werden. 
 
     ESC a bringt ä, ESC A bringt Ä 
     ESC u bringt ü, ESC U bringt Ü 
     ESC o bringt ö, ESC O bringt Ö und 
     ESC s bringt ß. 
 
In der Regel kann man die Umlaute auf dem Bildschirm eines solchen EDV- 
Terminals nicht sehen, sondern sie erscheinen als a, u, usw.. Beim Druck 
eines Textes werden sie aber richtig dargestellt. 
 
Die andere Tastatur entspricht in der Tastenbelegung weitgehend einer deut- 
schen Schreibmaschine und besitzt Tasten für die Umlaute und ß. Sollen vor- 
wiegend deutsche Texte geschrieben werden, empfiehlt es sich, solch ein 
Terminal zu verwenden. 
 
Neben diesen "einfachen" Tasten gibt es noch einige wenige Tasten, die zur 
Bedienung des Editors (aber auch anderer Programme) notwendig sind. Wo die 
Tasten auf Ihrem Gerät liegen, hängt von dem jeweiligen Gerätetyp ab. Die 
Wirkung der Tasten erklären wir in den anschließenden Abschnitten. 
Es kann sein, daß die Tasten nicht richtig beschriftet sind. Dann sollten Sie 
den Betreuer ihrer Installation bitten, diese zu beschriften. Zusätzlich zu 
den hier beschriebenen können sich noch weitere Tasten auf ihrem Terminal 
befinden, die aber keine besondere Bedeutung für den Editor haben. 
 
Taste          Bedeutung 
----------------------------------------------------------------------------- 
SHIFT          Umschalttaste. 
               Für Großbuchstaben statt Kleinbuchstaben und Sonderzeichen 
               statt Ziffern. 
 
RETURN         Beginn einer neuen Zeile (Absatz). 
               Die RETURN-Taste ist oft mit einem geknicktem Pfeil nach 
               links gekennzeichnet. Im Kommandomodus (also bei "gib 
               kommando :") wird ein gegebenes Kommando ausgeführt. 
 
LINKS          Tasten für die Positionierung. 
RECHTS 
OBEN 
UNTEN 
               Positionierung der Schreibmarke (Cursor) in die jeweilige 
               Richtung (auf den Tasten oft auch durch Pfeile dargestellt). 
 
HOP            "Verstärkertaste": Wirkt als Vorschalttaste. 
 
RUBOUT         Löschtaste. 
 
RUBIN          Ein- bzw. Ausschalten des Einfügezustandes. 
 
TAB            Tabulatortaste. 
 
MARK           Ein- bzw. Ausschalten der Markierung. 
 
ESC            Kommandotaste. 
 
Merke: Das Tastenfeld eines EUMEL-Terminals ist in der Regel wie das einer 
Schreibmaschine und kann ebenso bedient werden. Umlaute müssen bei EDV- 
Tastaturen mit Hilfe der Taste ESC geschrieben werden. Einige Spezialtasten 
werden benutzt, um die Textbearbeitung des Editors zu steuern. 
 
Weitere Kommandotasten: 
   SV          Supervisor-Taste im Mehrbenutzer-Betrieb ("multi-user"). 
               Diese Taste bewirkt den Aufruf des Supervisors und ist keine 
               spezielle Editor-Taste. 
   STOP        Anhalten eines Programms. 
               Wird die Taste aus Versehen betätigt (erkennbar daran, daß 
               der Editor nicht "reagiert"), muß WEITER betätigt werden. 
   WEITER      Programm soll weiterlaufen. 
 
 
 
Speicherung von Texten 
 
In diesem Abschnitt wird der Begriff "Datei" erklärt und erläutert, wie 
unterschiedliche Texte auseinandergehalten werden können. 
 
Das EUMEL-System speichert einmal geschriebene Texte, bis sie vom Benutzer 
gelöscht werden. In der Regel wird nicht nur ein (langer) Text oder ein Pro- 
grammtext geschrieben, sondern mehrere und unterschiedliche. Um diese aus- 
einanderhalten zu können, versehen wir sie jeweils mit einem Namen, der frei 
gewählt werden kann. Beispiele für Namen: 
 
   "Brief vom 1.8.83" 
   "1. Kapitel meines Buches" 
 
Eine Sammlung von Zeichen (also im Normalfall unsere geschriebenen Texte), 
die mit einem Namen versehen worden ist, nennt man eine 'Datei' ('file'). Der 
Editor erstellt also eine Datei, wenn wir einen Text schreiben. Eine Datei 
kann bis zu 4 000 Zeilen fassen, wobei eine Zeile bis zu 32 000 Zeichen lang 
sein darf. 
 
Mit Hilfe des (Datei-) Namens kann man den Text (immer) wieder ansprechen, 
solange, bis die Datei gelöscht wird. Bei der Bearbeitung einer Datei durch 
den Editor wirkt sich jede Änderung des Textes auf dem Bildschirm sofort bis 
in die gespeicherte Datei aus. Eine Datei kann durch Kommandos verarbeitet 
werden. Eine Auswahl (Vergl. dazu die Beschreibung des Monitors): 
 
edit (Datei bearbeiten), rename (Datei umbenennen), copy (Duplizieren der 
Datei), to archive (Archivieren), lineform bzw. autoform (Zeilen 
formatieren), pageform (Seiten formatieren), print (Drucken) usw. 
 
Merke: Ein Text wird im EUMEL-System in einer Datei gehalten. Eine Datei 
faßt bis zu 4000 Zeilen Text. Eine Datei kann über den Dateinamen ange- 
sprochen werden, der frei gewählt werden kann. 
 
 
 
Ein- und Ausschalten des Editors 
 
Hier beschreiben wir, wie der Editor ein- und ausgeschaltet wird und wie 
der Editor eine Datei einrichtet. Zusätzlich wird das Ausschalten des auto- 
matischen Wortumbruchs erklärt. 
 
Wenn auf dem Bildschirm die Aufforderung 
 
    gib kommando : 
 
erscheint, befindet man sich in der Monitor-Ebene. Durch 
 
    edit ("dateiname") 
 
kann der EUMEL-Editor eingeschaltet (programmtechnisch: "aufgerufen") 
werden. Ist die Datei noch nicht vorhanden, d.h. kein Text unter dem ange- 
gebenen Namen im System gespeichert, folgt eine Anfrage, ob eine neue Datei 
eingerichtet werden soll. Dies dient zur Kontrolle von Schreibfehlern, die 
besonders bei ähnlichen Dateinamen auftreten. Man kann dann das Einrichten 
der Datei ablehnen, den Dateinamen verbessern und das Kommando erneut geben. 
 
Der Editor zeigt jetzt in der obersten Zeile des Bildschirms die Titelzeile, 
die den Dateinamen und die Zeilennummer enthält, die gerade bearbeitet wird. 
Im Fall einer bereits beschriebenen Datei zeigt der Editor das zuletzt bear- 
beitete Textstück. Bei einer neuen Datei ist der Bildschirm unterhalb der 
Titelzeile leer. Dieser Teil dient als "Schreibfläche". Der Cursor, so nennt 
man die blinkende Schreibmarke, steht dann direkt unter der Titelzeile. Er 
zeigt immer die aktuelle Schreibposition an. Jetzt kann sofort mit dem 
Schreiben begonnen werden, ganz wie mit einer normalen Schreibmaschine. 
 
Beenden der Schreibarbeit und Ausschalten des Editors erfolgt durch Drücken 
der beiden Tasten 
 
     ESC q 
 
nacheinander. Man befindet sich wieder in der alten Kommando-Ebene. 
 
Es ist aber auch möglich, während der Schreibarbeit (also bei eingeschalte- 
tem Editor) durch zweimaliges Drücken von ESC in die (Editor) Kommando- 
Ebene zu gelangen. Nach Abarbeitung des Kommandos gelangt man wieder in den 
normalen Schreibzustand. 
 
Der Editor ist auf das Schreiben von "normalen" Texten eingestellt. Bei 
"normalen" Texten soll ein Wort, welches über das Ende einer Zeile gehen 
würde, automatisch in die nächste Zeile gebracht werden. Dies wird 
"Wortumbruch" genannt. 
 
Ist kein Wortumbruch erwünscht, so gibt man das Kommando 
 
    word wrap (false) 
 
In diesem Fall schreibt der Editor bis zum Zeilenende und springt dann auto- 
matisch (u.U. mitten im Wort) auf die nächste Zeile. Der Wortumbruch kann 
durch 
 
    word wrap (true) 
 
wieder eingeschaltet werden. 
 
Merke: Der Editor wird durch das Kommando 'edit ("name")' aufgerufen und 
und wird durch ESC q wieder verlassen. Der Cursor zeigt die aktuelle 
Schreibposition an. Der Editor ist auf automatischen Wortumbruch eingestellt. 
 
 
 
Schreiben eines Textes 
 
In diesem Abschnitt wird erklärt, wie ein Text geschrieben wird und was es 
mit Absätzen auf sich hat. 
 
Nach dieser etwas langen Vorrede können wir endlich losschreiben. Wird ein 
Zeichen geschrieben, rückt der Cursor automatisch nach rechts auf die 
nächste Schreibstelle. Durch den automatischen Wortumbruch werden ange- 
fangene Worte, die über ein Zeilenende hinausgehen würden, ohne Silbentren- 
nung in die nächste Zeile gebracht. 
Nehmen Sie bitte keine Silbentrennung "per Hand" vor (wie in dieser An- 
leitung).Eingebrachte Trennstriche gelten als Bindestrich und bleiben somit 
auch bei Umformatierungen erhalten, was unerwünscht ist. Für diese mühevolle 
Aufgabe gibt es in der Textkosmetik ein Programm! 
 
Die RETURN-Taste (bei einer Schreibmaschine bedeutet sie "Wagenrücklauf") 
braucht also nur noch betätigt zu werden, wenn eine Zeile vorzeitig beendet 
werden soll: also bei einem Absatz oder einer Leerzeile. Der Cursor wird da- 
bei an den Anfang der nächsten Zeile positioniert. Gleichzeitig erscheint in 
der vorherigen Zeile am rechten Rand des Bildschirms eine Markierung, die 
anzeigt, daß hier ein Absatz gemacht wurde. 
 
Diese Absatzkennzeichnung ist wichtig: Sie bedeutet u.a. eine "Grenze" für 
die Textkosmetik-Programme beim (optimalen) Auffüllen von Zeilen. Für den 
Drucker bedeutet ein Absatz, keinen rechten Randausgleich (druckertechnisch: 
"Blocksatz") in dieser Zeile vorzunehmen. 
Die Absatzkennzeichnung besteht aus einem Leerzeichen in der Datei ("blank"; 
im Unterschied zur Schreibmaschine ist das Leerzeichen in der EDV auch ein 
Zeichen und wird gespeichert). Absatzkennzeichen können gelöscht oder auch 
hinzugefügt werden (wie das gemacht wird, erfahren Sie in den nächsten Ab- 
schnitten). Ist der Wortumbruch ausgeschaltet, erscheint keine Absatzkenn- 
zeichnung beim Betätigen der RETURN-Taste. 
 
Darum ist das Betätigen der RETURN-Taste bei Tabellenzeilen und Programm- 
texten besonders wichtig, denn hier soll ja jede Zeile separat bleiben. 
 
Ein Bildschirm faßt (neben der Titelzeile) üblicherweise 23 Zeilen, die mit 
Text beschrieben werden können. Ist die letzte Zeile voll und muß eine neue 
Zeile begonnen werden, "rutscht" der Bildschirminhalt automatisch um eine 
Zeile nach oben. Damit ist Platz für eine Leerzeile, die nun ebenfalls be- 
schrieben werden kann usw.. Keine Angst: die so verschwundenen Zeilen sind 
natürlich nicht "weg". Da ein Bildschirm immer nur eine beschränkte Anzahl 
von Zeilen hat, kann der Editor nur einen Ausschnitt aus der Datei zeigen. 
In unserem Fall, wo wir zunächst nur am Ende der Datei schreiben, werden 
also immer die letzten Zeilen der Datei angezeigt. 
 
Merke: Ist der Wortumbruch eingeschaltet, wird ein angefangenes Wort, das 
über das Zeilenende gehen würden, an den Anfang der neuen Zeile gebracht. 
Die RETURN-Taste wird nur bei Absätzen, Tabellenzeilen oder Leerzeilen be- 
tätigt. In diesem Fall erscheint eine Absatzkennzeichnung am rechten Rand 
des Bildschirms. Ist der Bildschirm vollgeschrieben, werden beim fort- 
laufenden Schreiben alle Zeilen um eine Zeile nach oben gerückt. 
 
 
 
Einrückungen 
 
Hier wird die Einrückungsautomatik erklärt. 
 
Soll ein Text eingerückt werden (wie in den obigen "Merke"-Zeilen) oder bei 
Aufzählungen, so wird die in der ersten Zeile geschriebene Einrückung auto- 
matisch in den folgenden Zeilen beibehalten, bis sie durch die Posi- 
tionierungstasten wieder aufgehoben wird. Es gibt also kein Einrückkommando. 
Wie der rechte Rand (also die Zeilenbreite) eingestellt wird, erklären wir 
später. 
Dies kann für die gesamte Datei (und somit für den gesamten Text) durch ein 
ein Kommando erfolgen, mit welchem man den Editor auf diese Zeilenbreite 
einstellt. Um den rechten Rand nur für einige Zeilen zu verändern (wie z.B. 
bei unseren "Merke"-Zeilen) kann ein 'limit'-Kommando der Textkosmetik 
verwandt werden. 
 
Merke: Einrückungen werden automatisch beibehalten. 
 
 
 
Einfaches Positionieren und das Editor-Fenster  
 
Um Korrekturen (Überschreiben, Löschen oder Einfügen) vorzunehmen, muß der 
Cursor, der die aktuelle Schreibposition anzeigt, bewegt werden können. Bei 
längeren Texten ist es möglich, den Cursor auch auf Zeilen zu positionieren, 
die sich (noch nicht) auf dem Bildschirm befinden. Somit zeigt der Editor 
nicht nur immer das Ende einer Datei, sondern einen beliebigen Ausschnitt, 
der auf dem Bildschirm im sogenannten Fenster sichtbar ist. 
 
Ist eine Korrektur notwendig, muß der Cursor (blinkende Schreibmarke) auf die 
Stelle positioniert werden, an der die Korrektur vorgenommen werden soll. 
Dazu verwenden wir die Positionierungstasten LINKS, RECHTS, OBEN und UNTEN. 
LINKS und RECHTS bewegen den Cursor innerhalb einer Zeile. Stößt man mit 
RECHTS an das Ende einer Zeile, wird der Cursor an den Anfang der nachfol- 
genden Zeile bewegt. (Positionierungen jenseits des linken Randes sind nicht 
möglich). 
 
Ein Zeilenwechsel kann einfacher mit den Tasten OBEN und UNTEN vorgenommen 
werden. Die Taste OBEN bewegt den Cursor eine Zeile nach oben, die Taste 
UNTEN entsprechend eine Zeile tiefer. 
 
Was passiert nun, wenn der untere oder der obere Rand des Bildschirms er- 
reicht wird und es wird darüber hinaus positioniert? In diesem Fall wird der 
Text zeilenweise nach oben oder nach unten verschoben und es erscheint die 
gewünschte Zeile, wobei andere am anderen Rand "verschwinden". Wir sehen 
also, daß wir mit den Positionierungstasten den Bildschirm als Fenster über 
die Datei hinweggleiten lassen können (Fachausdrücke: "roll up" oder "roll 
down"). Den Text selbst können wir uns auf einem langen Band geschrieben 
vorstellen. Die Zeilennummer, in der der Cursor steht, wird stets in der 
Titelzeile angezeigt. 
 
Innerhalb einer Zeile ist es etwas anders: Positionieren wir bei einer Zeile, 
die breiter als der Bildschirm ist, nach rechts, wird das Fenster nur für 
diese Zeile verschoben (Fachausdruck: "scrolling"). 
 
Merke: Mit Hilfe der vier Positionierungstasten kann man den Cursor auf dem 
Bildschirm bewegen. Außerdem ist es möglich, das Fenster mittels der 
Positionierungstasten über den Text zu bewegen. 
 
 
 
Einfache Korrekturen: Zeichen überschreiben, löschen und einfügen 
 
In diesem Abschnitt wird erklärt, wie einfache Korrekturen durch Über- 
schreiben von Zeichen, Löschen von Zeichen und Einfügen von Zeichen vorge- 
nommen werden können. 
 
Es können Korrekturen gleich beim Schreiben vorgenommen werden, indem die 
zuletzt geschriebenen Zeichen mit der RUBOUT-Taste gelöscht werden. Häufig 
merkt man aber Schreibfehler erst etwas später, so daß man diese Fehler nicht 
so leicht korrigieren kann. Für solche Zwecke muß man den Cursor an die Text- 
stelle bewegen, an dem korrigiert werden soll. Wie man das macht, haben wir 
im letzten Abschnitt geschildert. 
 
Die einfachste Möglichkeit der Korrektur ist das Überschreiben. Soll z.B. ein 
Zeichen durch ein anderes ersetzt werden, so positioniert man den Cursor 
genau über dieses und tippt das richtige Zeichen ein.Das kann natürlich auch 
mit mehreren Zeichen nacheinander erfolgen. 
 
Will man ein Zeichen löschen, so positioniert man auch hier den Cursor auf 
dieses Zeichen und betätigt die Taste RUBOUT. Das Zeichen verschwindet und 
die Restzeile rückt heran. Sollen mehrere Zeichen gelöscht werden, muß die 
RUBOUT-Taste entsprechend oft gedrückt werden. 
 
Steht der Cursor hinter dem letzten Zeichen der Zeile, wird immer das letzte 
Zeichen der Zeile gelöscht. Man kann also mit dieser Eigenschaft eine Zeile 
"von hinten wegradieren". 
 
Fehlende Zeichen kann man genauso einfach einfügen. Man bringt den Cursor 
auf das Zeichen, vor das eingefügt werden soll. Dann drückt man die Taste 
RUBIN. Der Editor gelangt in den Einfüge-Zustand, was in der Titelzeile durch 
RUBIN angezeigt wird. Er fügt alle Zeichen ein, die jetzt getippt werden (an- 
statt zu überschreiben). Der Teil der Zeile rechts vom Cursor rückt jeweils 
um entsprechend viele Stellen nach rechts. 
 
Wichtig ist, daß im RUBIN-Zustand der Editor genauso funktioniert wie im 
Normal-Zustand (natürlich mit der Ausnahme, daß eingefügt statt überschrieben 
wird). 
 
Ein neuerliches Betätigen der RUBIN-Taste beendet den Einfüge-Zustand. Die 
RUBIN-Taste wirkt also wie ein Schalter, der den Einfüge-Zustand ein- und 
ausschaltet. Allerdings kann man nur so viele Zeichen in eine Zeile einfügen, 
bis das letzte Wort der Zeile an das Zeilenende stößt. Das angefangene Wort 
wird am Anfang der folgenden Zeile eingefügt, sofern dort noch Platz ist und 
es nicht offensichtlich ein Absatzende kennzeichnet. Andernfalls wird auto- 
matisch eine neue Zeile für das angefangene Wort eingefügt. 
 
Im eingeschalteten RUBIN-Zustand können keine Zeichen verloren gehen. Viele 
Benutzer lassen darum den RUBIN-Zustand immer eingeschaltet, um sich vor dem 
unbeabsichtigten Überschreiben von Texten zu schützen. Es wird korrigiert, 
indem man die Verbesserung einfügt und den alten Text löscht. 
 
Merke: Mit Hilfe der Positionierungstasten LINKS, RECHTS, OBEN und UNTEN 
kann eine Stelle in der Datei ausgewählt werden, an der eine Korrektur vor- 
genommen werden soll. Die einfachste Korrektur ist das Überschreiben von 
fehlerhaften Zeichen. Zeichen löschen erfolgt mit der Taste RUBOUT. Mit 
RUBIN kann der Einfüge-Zustand ein- und ausgeschaltet werden. Im Einfüge-Zu- 
stand wird nicht überschrieben, sondern es wird vor der Cursor-Position das 
getippte Zeichen eingefügt. 
 
 
 
Springen, Zeilen einfügen/löschen mittels HOP-Taste 
 
Bewegungen des Cursors sind mit den Positionierungstasten bei größeren "Ab- 
ständen" etwas mühsam, ebenso bei umfangreichen Löschungen und Einfügungen. 
Die "Verstärkertaste" HOP ermöglicht es, diese Operationen auf einfache 
Weise zu beschleunigen. Mit der HOP-Taste kann man das Fenster über der 
Datei nicht nur zeilenweise, sondern auch um jeweils eine Fensterlänge ver- 
schieben. Das nennt man Blättern. 
 
Wird die HOP-Taste vor einer anderen der schon erklärten Funktionstasten 
gedrückt, verstärkt sie deren Wirkung. Die HOP-Taste ist eine "Präfix"-Taste: 
sie wird vor (und nicht gleichzeitig, wie z.B. die Umschalttaste SHIFT) einer 
anderen Taste gedrückt. Zuerst das springende Positionieren: 
Weitere wichtige Anwendungen der HOP-Taste beschreiben wir in den nächsten 
Abschnitten. 
 
HOP RECHTS   Sprung an das rechte Zeilenende. 
             Falls die Zeile länger als das Fenster breit ist, wird seitlich 
             geblättert. 
 
HOP LINKS    Sprung an den Zeilenanfang (ggf. seitlich blätternd). 
 
HOP OBEN     Sprung auf die erste Zeile des Bildschirms. 
             Nochmaliges Betätigen dieser Tastenkombination positioniert den 
             Cursor (und damit das Fenster in der Datei) um ein Fenster 
             zurück. 
 
HOP UNTEN    Sprung auf die letzte Zeile des Bildschirms. 
             Das Blättern erfolgt analog HOP OBEN. 
 
HOP RETURN   Macht die aktuelle Zeile zur ersten des Fensters. 
             Die Zeile, in der sich der Cursor befindet, wird die erste 
             Zeile des Fensters. 
 
Die HOP-Taste in Verbindung mit RUBIN und RUBOUT wird zum "verstärkten" 
Löschen und Einfügen verwandt: 
 
HOP RUBIN    Einfügen von Textpassagen: 
             Ab der aktuellen Position des Cursors verschwindet der rest- 
             liche Text. Es kann wie bei der anfänglichen Texteingabe fort- 
             gefahren werden. Die Anzeige REST in der Titelzeile erinnert 
             daran, daß noch ein Resttext existiert. Dieser erscheint nach 
             einem neuerlichen Betätigen der beiden Tasten HOP RUBIN wieder 
             auf dem Bildschirm (die Anzeige REST verschwindet dann wieder). 
 
HOP RUBOUT   Löscht Zeile ab Cursor-Position bis Zeilenende: 
             Löscht die Zeile rechts vom Cursor. Steht der Cursor am Zeilen- 
             anfang, wird dementsprechend die ganze Zeile gelöscht und die 
             Lücke durch Nachrücken der Folgezeilen geschlossen. 
 
Merke: Die HOP-Taste dient in Verbindung mit den Positionierungstasten zum 
"Springen" oder zum "Blättern" innerhalb der Datei. Vor der Taste RUBOUT ge- 
drückt, bewirkt sie die Löschung von Zeilen. Mit HOP RUBIN kann man längere 
Texte in einen Text einfügen. 
 
 
 
Der Tabulator 
 
Eine weitere wichtige Positionierungshilfe ist die TAB-Taste. Sie wird zum 
Schreiben von Tabellen benötigt. Wie bei einer Schreibmaschine können Ta- 
bulatormarken gesetzt bzw. gelöscht werden. 
 
Der Tabulator hat eine wichtige Funktion für das schnelle Positionieren, auch 
wenn keine Marken eingestellt wurden. Voreingestellte Tabulatormarken sind 
nämlich der Textanfang einer Zeile (Einrückung; falls vorhanden) und die 
Stelle direkt hinter dem letzten Zeichen der Zeile. Betätigt man also die 
Taste TAB, dann springt der Cursor an die nächste dieser voreingestellten 
Positionen. So kann man schnell an den Anfang oder das Ende einer Zeile mit 
dem Cursor gelangen (und z.B. am Zeilenende Zeichen "von hinten" löschen 
oder dort weiterschreiben). 
 
Nun zum Setzen des Tabulators: Er wird gesetzt, indem man den Cursor auf die 
Zeilenposition bringt, in der die Marke plaziert werden soll. Hier betätigt 
man nun HOP TAB. Die Tabulatorsetzung kann man in der Titelzeile an einer 
Markierung ("Dach"-Zeichen) sehen (falls sie im Fensterbereich ist und die 
aktuelle Zeile nicht seitlich verschoben ist). Betätigt man nun an irgend- 
einer Position innerhalb einer Zeile die TAB-Taste, wird der Cursor auf die 
Position der nächsten Tabulatormarkierung (die sich rechts vom Cursor be- 
findet) oder eine der voreingestellten Positionen bewegt. 
 
Gesetzte Tabulatormarken können gelöscht werden, indem man mit der TAB- 
Taste die Position der Tabulatormarke einstellt und dann HOP TAB betätigt. 
Die Marke ist dann gelöscht (das Dach verschwindet in der Titelzeile). 
 
Tabulatormarkierungen hinterlassen keine Spuren in der Datei, sondern dienen 
nur als Positionierungshilfen. 
 
Werden Tabulatormarken gesetzt (HOP TAB), gelten die voreingestellten Tabu- 
latormarken (Anfang und Ende einer Zeile) nicht mehr. Dies ist z.B. bei dem 
Schreiben von Tabellen notwendig. Andererseits möchte man beim Schreiben von 
"normalen" Text wieder die voreingestellten Tabulatormarken bedienen können. 
Mit den Tasten 
 
     ESC TAB 
 
kann man die gesetzten Tabulatormarken (erkenntlich an dem "Dach"-Zeichen in 
der Kopfzeile) verschwinden lassen. Dann gelten wieder die voreingestellten 
Marken. Erneutes ESC TAB stellt die gesetzten Tabulatormarken wieder her 
usw. 
 
Merke: Das Einstellen und Löschen von Tabulatormarken erfolgt mit HOP TAB; 
das Positionieren auf diese mit TAB. Voreingestellte Tabulatormarken sind 
Zeilenanfang und -ende. ESC TAB wirkt wie ein Umschalter zwischen voreinge- 
stellten und gesetzten Tabulatormarken. 
 
 
 
2. Beschreibung weiterer Funktionen 
 
In diesem Kapitel werden weitere Funktionen des Editors beschrieben, die bei 
dem Erstellen von Texten und Korrekturen sinnvoll einsetzbar sind. Die 
Kenntnis der hier beschriebenen Funktionen sind für erste Arbeiten nicht 
notwendig (dafür reicht das erste Kapitel). Man sollte aber dieses Kapitel 
zumindest überfliegen, damit bei Bedarf die zusätzlichen Möglichkeiten des 
Editors erlernt und angewandt werden können. 
 
 
 
Zeilen aufbrechen und Rückumbruch 
 
Um grössere Textpassagen einzufügen, betätigt man HOP RUBIN nacheinander. 
Diese Tastenfolge kann benutzt werden, um eine Zeile zu spalten (Zeile auf- 
zubrechen). HOP RUBOUT am Ende einer Zeile macht einen Rückumbruch. 
 
Wie bereits beschrieben, bewirkt HOP RUBIN in einer Zeile, daß der Zeilenrest 
rechts vom Cursor und alle Zeilen unterhalb der aktuellen Zeile scheinbar 
verschwinden. REST in der Titelzeile erinnert daran, daß ein Teil der Datei 
nicht sichtbar ist. 
 
Wird unmittelbar nach HOP RUBIN wiederum HOP RUBIN betätigt, wird der vor- 
herige Zeilenrest als eigenständige Zeile dargestellt. Es ist damit eine Auf- 
spaltung einer Zeile in zwei Zeilen vollzogen. 
 
Der umgekehrte Fall, nämlich zwei Zeilen zu einer zusammenzufassen (sog. 
Rückumbruch), ist durch HOP RUBOUT hinter dem letzten Zeichen einer Zeile 
möglich. (Hinter das letzte Zeichen einer Zeile kann einfach mit dem 
Tabulator positioniert werden). 
 
Das Aufbrechen einer Zeile und der Rückumbruch zusammen angewandt stellen 
also den ursprünglichen Zustand wieder her. Beispiel: Mit HOP RUBIN bricht 
man eine Zeile auf (der Rest der Zeile und nachfolgende Zeilen verschwinden 
vom Bildschirm). Erneutes HOP RUBIN stellt den rechten Zeilenteil auf der 
nächsten Zeile und die nachfolgenden Zeilen auf dem Bildschirm wieder dar. Da 
der Cursor sich noch immer am rechten Rand der aufgebrochenen Zeile befindet, 
kann man mit HOP RUBOUT den ursprünglichen rechten Zeilenteil wieder re- 
kombinieren. 
 
Merke: Zweimaliges HOP RUBIN spaltet eine Zeile auf; HOP RUBOUT hinter dem 
Ende einer Zeile fügt die nachfolgende Zeile an die aktuelle an (Rück- 
umbruch). 
 
 
 
Zahlentabellen schreiben: Dezimaltabulator 
 
Beim Schreiben von Zahlentabellen sollen die Zahlen oft rechtsbündig im Text 
erscheinen. Dazu bietet der Editor den Dezimaltabulator an. 
 
Für jede Zahlenkolonne wird die gewünschte Position der Einerstelle (also der 
letzten Stelle) mit Hilfe eines Tabulators eingestellt. Mit TAB wird der 
Cursor zur jeweils nächsten Tabulatormarke vorgerückt. Werden nun Ziffern 
geschrieben, so schreibt man nicht - wie gewohnt - nach rechts, sondern die 
Ziffern werden nach links eingerückt. Etwas genauer: Beim Drücken einer 
Zifferntaste wird, solange links vor der Zahl noch ein Blank, eine Zahl, "+", 
"-" oder ein Punkt sichtbar ist, diese gelöscht und die hierdurch neu ent- 
standene Ziffernfolge rechtsbündig an der Tabulatorposition geschrieben. 
Zahlenkolonnen können so leicht und rechtsbündig geschrieben werden. 
Wird eine Proportionalschrift (Schrift, bei der die Zeichen unterschiedliche 
Breiten haben) verwandt, sollte man zwischen den einzelnen Zahlenkolonnen 
mindestens zwei Leerzeichen schreiben. Andernfalls bekommt man - auf Grund 
der unterschiedlicher Zeichenbreiten - keine rechtsbündigen Kolonnen ge- 
druckt. 
 
         12           12345,78 
          1               0,23 
      12345            1234,00 
 
Merke: Ziffern werden bei Einsatz des Tabulators automatisch rechtsbündig ab 
der Tabulatormarke geschrieben. 
 
Es gibt somit vier nützliche Automatiken: neben dem automatischen Dezimal- 
tabulator der Wortumbruch, die Einrückautomatik und die Zeileneinfügeauto- 
matik beim einfügenden Schreiben. 
 
 
 
Den Editor lernen lassen 
 
Beliebige Folgen von Tastenbetätigungen können gelernt und Tasten zugeordnet 
werden. Das ist sinnvoll, wenn wiederholt immer die gleichen Tastenbe- 
tätigungen ausgeführt werden müssen, wie z.B. in Tabellenzeilen etwas ein- 
fügen oder wenn des öfteren gleiche Texte geschrieben werden müssen, wie 
z.B. ein Absender, Grußformeln usw. 
 
Der Lernmodus wird durch Betätigen der Tasten ESC HOP eingeschaltet (es 
erscheint LEARN als Kontrolle in der Titelzeile). Alle Tastenanschläge (auch 
Tastenanschläge wie RETURN: man kann also auch mehrere Zeilen lernen lassen) 
werden jetzt gelernt bis zum expliziten Ausschalten des Lernmodus. 
 
Das Beenden oder Ausschalten des Lernmodus erfolgt durch Drücken der drei 
Tasten ESC HOP 'taste'. Dabei wird die gelernte Tastenanschlagsfolge, auch 
Lernsequenz genannt, der Taste 'taste' zugeordnet. 
 
Durch späteres Betätigen der Tastenfolge ESC 'taste' kann der gelernte Text 
an jeder Stelle der Datei geschrieben werden. Beispiel: Ein "Schreiberling" 
hat jeden Tag 27 mal die Worte 'Hochschulrechenzentrum der Universität 
Bielefeld' zu tippen. Er läßt diese Worte den Editor lernen mit 
 
   ESC HOP Hochschulrechenzentrum der Universität Bielefeld 
   ESC HOP b 
 
Die Worte liegen jetzt auf der Taste 'b'. Wird 'b' gedrückt, erscheint ein 
'b' auf dem Bildschirm. Mit ESC 'b' erscheinen die obigen Worte. ESC ist 
also notwendig, um das normale 'b' von der Lernsequenz zu unterscheiden. 
 
Bei einigen Terminaltypen gibt es Tasten, die vom EUMEL-System nicht benutzt 
werden. Bei diesen kann man ESC beim Aufruf der Lernsequenz weglassen. 
 
Welche Tasten dürfen zum Lernen belegt werden? Alle Tasten, außer 
 
- vom System benutzte Tasten, wie SV, CTRL; 
- vom Editor (je nach Anwendung) vorbelegte Tasten, wie die Tasten q oder 
  ESC und HOP; 
- durch Programmierung (siehe dieses Kapitel) fest belegte Tasten. 
 
Praktische Tips: Man sollte die Tastatur nicht mit Lernsequenzen überlasten, 
weil man sich viele Tasten nicht merken kann. Besser ist es, einige wenige 
Tasten fest zu belegen und andere für momentane Aufgaben einzusetzen. 
 
Der Einsatz von Lernsequenzen ist besonders sinnvoll zum Schreiben von An- 
weisungen für die Textkosmetik. Anweisungen wie z.B. 'unterstreichen ein- 
schalten', Schrifttyp-Anweisung usw. werden zweckmäßigerweise auf Tasten 
gelegt. 
 
Hat man sich einmal beim Lernen verschrieben, so ist das nicht weiter 
schlimm: es kann ohne Bedenken korrigiert werden (z.B. mit der Taste RUBOUT). 
Solche Tastenanschläge werden dann allerdings auch gelernt, was man aber 
beim Einsetzen der Lernsequenz kaum sieht. 
 
Merke: Tastenanschläge werden mit ESC HOP gelernt und mit ESC HOP 'taste' 
auf eine Taste gelegt. Mit ESC 'taste' kann die Lernsequenz jederzeit abge- 
rufen werden. 
 
 
 
Mehrere Zeilen auf einmal verarbeiten: Markieren 
 
Oft ergibt sich die Notwendigkeit, mehrere Zeilen oder ganze Textpassagen zu 
löschen oder zu verschieben. Hierbei hilft die Taste MARK, mit der man Texte 
markieren (also kennzeichnen) kann. Die so markierten Texte können dann auf 
verschiedene Weisen als Ganzes verarbeitet werden. 
 
Durch Drücken der Taste MARK wird die Markierung eingeschaltet und - bei 
erneuter Betätigung - wieder ausgeschaltet. Der Anfang der Markierung wird 
"festgehalten" und man kann nun das Markierende durch die Positionierungs- 
tasten und die HOP-Taste in Richtung auf das Dateiende verschieben, wobei 
die dazwischen liegenden Zeichen markiert (in der Regel "video-invertiert" 
dargestellt) werden. Ein so markierter Text kann mit ESC RUBOUT gelöscht 
werden. Markieren und löschen mit ESC RUBOUT ist eine bequeme und sichere 
Löschmethode, da man genau sieht, was gelöscht wird. 
 
Der gelöschte Abschnitt ist aber nicht vollständig gelöscht, sondern er kann 
an anderer (oder an der gleichen) Stelle im Text durch ESC RUBIN wieder ein- 
efügt werden. Dies gilt aber nur für den zuletzt gelöschten Text. Auf diese 
Art kann ein Textabschnitt beliebiger Länge an eine andere Stelle des Textes 
sicher, schnell und bequem verschoben werden. Zusätzlich ist das nachträg- 
liche Korrigieren von fehlerhaften Löschungen leicht möglich, weil der Text 
wieder mit ESC RUBIN leicht reproduziert werden kann. 
 
Mit eingeschalteter Markierung kann auch geschrieben werden. Das markierende 
Schreiben ist eine besonders vorsichtige Art der Texterstellung, denn der 
Texteinschub bleibt erst durch Ausschalten der Markierung (MARK) wirklich 
bestehen. Er kann wieder gelöscht werden (ESC RUBOUT) und an eine andere 
Stelle gebracht werden (ESC RUBIN). Beim markierenden Schreiben wirkt 
RUBOUT immer auf das zuletzt geschriebene Zeichen. 
 
Die Markierung kann auch dazu verwendet werden, auf markierte Textabschnitte 
eigene Benutzerprogramme anzuwenden. 
 
Merke: Die Markierung schaltet man durch die Taste MARK ein und aus. Ein 
markierter Abschnitt kann gelöscht werden (ESC RUBOUT) und an einer anderen 
Stelle wieder eingefügt werden (ESC RUBIN). Mit eingeschalteter Markierung 
kann auch geschrieben werden. Die Markierung dient ebenfalls als Parameter 
für Textverarbeitungsprogramme. 
 
 
 
Zwei einfache Kommandos 
 
Einige Operationen kann man nur mühselig mit den bis jetzt beschriebenen 
Tasten durchführen. Z.B. ist es sehr zeitaufwendig, eine bestimmte Text- 
stelle zu finden. Andere Operationen sind mit den im vorigen Kapitel be- 
schriebenen Tasten überhaupt nicht möglich, wie etwa die Zeilenbreite ein- 
zustellen oder Programme aufzurufen, die die zu editierende Datei ver- 
arbeiten. Solche Operationen werden durch Kommandos ermöglicht, die man vom 
Editor aus geben kann. 
 
Durch zweimaliges Betätigen von ESC erfolgt die Aufforderung 
 
     gib kommando : 
 
Es erscheint auf dem Bildschirm eine Kommandozeile, in der der Benutzer 
Kommandos (d.h. ELAN-Programme) schreiben kann. Durch Betätigen der Taste 
RETURN wird das Kommando ausgeführt. Beispiel: 
 
     ESC ESC                 (* es erscheint 'gib kommando :' *) 
     "diese Zeichen" 
     RETURN 
 
Durch die Angabe eines TEXTes in Anführungstrichen wird nach dem einge- 
schlossenen TEXT 'diese Zeichen' ab der aktuellen Cursor-Position gesucht. 
Wird 'diese Zeichen' gefunden, bleibt der Cursor auf dem gesuchten Text 
stehen. Andernfalls steht der Cursor hinter dem Ende der letzten Zeile der 
Datei. Weiteres Beispiel: 
 
     ESC ESC 
     127 
     RETURN 
 
Durch dieses Kommando wird auf die 127. Zeile positioniert. 
 
Diese beiden häufig benötigten Kommandos haben eine Sonderstellung und 
werden speziell behandelt, weil sie nicht der allgemeinen ELAN-Syntax ent- 
sprechen. Darum dürfen sie auch nicht in Verbindung mit anderen Kommandos 
verwendet werden (siehe nächsten Abschnitt). Alle anderen Kommandos, die wir 
in den nächsten Abschnitten beschreiben, entsprechen der ELAN-Syntax und 
sind somit allgemeine Kommandos. 
 
Merke: Kommandos nach man nach zweimaligen Betätigen der ESC-Taste schreiben. 
Mit RETURN wird die Ausführung des Kommandos ausgelöst. Durch Angabe eines 
TEXTes wird ab der aktuellen Cursor-Position nach diesem TEXT gesucht. Durch 
die Angabe einer ganzen Zahl (INT) wird auf die entsprechende Zeilennummer 
in der Datei positioniert. 
 
 
 
Beliebige Kommandos 
 
Beliebige Kommandos (siehe Monitor-Beschreibung) und ELAN-Programme sind 
zulässig. 
 
Die Kommandozeile kann wie eine "normale" Textzeile editiert werden (Posi- 
tionieren, Überschreiben, Einfügen, Löschen und Markieren). Erzeugt ein 
Programm eine Ausgabe oder rufen fehlerhafte Kommandos Fehlermeldungen 
hervor, werden diese in der ersten Zeile des Bildschirms angezeigt. Danach 
ist man wieder im Editor und kann wie gewohnt arbeiten. 
 
Die oben beschriebenen zwei Spezial-Kommandos kann man nicht mit anderen 
Kommandos zusammen verbinden (mit ';'). Deshalb gibt es für sie auch eine 
ELAN-Form, die es erlaubt, sie mit anderen Kommandos zusammen zu verwenden: 
 
a) TEXT suchen ab der aktuellen Cursor-Position (D ist eine Abkürzung für 
   'DOWN'): 
 
   "diese Zeichen"          (* Spezial-Version    *) 
   D "diese Zeichen"        (* Allgemeine Version *) 
 
b) Auf eine Zeile Positionieren (T ist eine Abkürzung für TO LINE): 
 
   127                      (* Spezial-Version    *) 
   T 127                    (* Allgemeine Version *) 
 
Es können mehrere Kommandos in der Kommandozeile angegeben werden. Die ein- 
zelnen Kommandos müssen in diesem Fall mit ';' voneinander getrennt werden. 
Beispiel: 
 
     ESC ESC 
     T 1; D "noch Zeichen" RETURN 
 
Diese zwei Kommandos werden nacheinander ausgeführt. Zuerst wird auf die 
erste Zeile positioniert und dann (von der ersten Zeile) nach 'noch Zeichen' 
gesucht. Damit ist es möglich, die Datei nicht nur von der aktuellen Zeile zu 
durchsuchen, sondern die gesamte Datei. Soll nicht in Richtung auf das Datei- 
ende, sondern in Richtung auf den Dateianfang (also nach "oben") gesucht 
werden, kann man das U-Kommando (Abkürzung für UP) verwenden: 
 
     ESC ESC 
     U "noch'n Text" RETURN 
 
Ein weiteres Kommando ist das C-Kommando (Abkürzung für 'CHANGE'), mit 
welchem man einen TEXT sucht und diesen dann ersetzen kann. Beispiel: 
 
     ESC ESC 
     "alte Zeichen" C "neue Zeichen" RETURN 
 
Es wird ab der aktuellen Cursor-Position nach 'alte Zeichen' gesucht. Wird 
der TEXT gefunden, wird er durch 'neue Zeichen' ersetzt. Der Cursor befindet 
sich in diesem Fall nach dem ersetzten TEXT. Wird 'alte Zeichen' dagegen 
nicht in der Datei gefunden, befindet sich der Cursor (wie beim erfolglosen 
Suchen mit D) am Ende der letzten Zeile der Datei. 
 
Wie alle andern Kommandos kann auch das C-Kommando mit anderen Kommandos 
verbunden werden. Beispiel: 
 
     ESC ESC 
     T 500; "Schreibfelher" C "Schreibfehler" RETURN 
 
Hier wird ab der 500. Zeile der Datei nach 'Schreibfelher' gesucht und ggf. 
ersetzt. Soll ein TEXT nicht nur einmal, sondern bei jedem Auftreten ersetzt 
werden, benutzt man das CA-Kommando (Abkürzung für CHANGEALL): 
 
     ESC ESC 
     "dieser alte Text" CA "dieser neue Text" RETURN 
 
Dadurch wird 'dieser alte Text' bei jedem Auftreten ab der aktuellen Cursor- 
Position durch 'dieser neue Text' ersetzt. 
 
Merke: Mehrere Kommandos werden mit ';' verbunden. 
 
 
 
Kommandos auf Tasten legen 
 
Oft benutzte Kommandos können auf Tasten gelegt werden. Damit ist es möglich, 
den Editor auf spezielle Bedürfnisse eines Benutzers zu modifizieren. 
 
Anstatt der Taste RETURN beim Abschluß können oft benutzte Kommandos mit der 
Drei-Tastenfolge ESC ! 'taste' auf eine Taste gelegt werden. Beispiel: 
 
     ESC ESC       (* es erscheint die Kommandozeile *) 
     D "Schreibfehler" 
     ESC ! s       (* das Kommando 'DOWN "Schreibfehler"' ist 
                      nun auf die Taste 's' gelegt *) 
 
Wird nun die Taste 's' gedrückt, erscheint das Zeichen 's' auf dem Bildschirm.
Mit ESC s wird das D-Kommando ausgeführt. Natürlich können auch komplizier- 
tere ziertere Kommandos auf Tasten gelegt werden. 
 
Einige Tasten sind bereits mit Kommandos belegt (man kann sie aber ver- 
ändern). Will man ein Kommando, welches auf eine Taste gelegt wurde, ver- 
ändern oder löschen, drückt man im Kommandodialog (!) die Drei-Tastenfolge 
ESC ? 'taste'. Beispiel: 
 
     ESC ESC             (* in den Kommandodialog gehen *) 
     ESC ? s             (* es erscheint nun: 'D "Schreibfehler"' *) 
 
Dieses Kommando kann nun z.B. verändert und ausgeführt (durch RETURN) oder 
wiederum auf die gleiche oder eine andere Taste gelegt werden (durch 
ESC ! 'taste'). 
 
Die Ausführung eines Kommandos kann meist mit ESC abgebrochen werden, 
z.B. wenn ein Suchkommando unerwünscht weit reicht. 
 
Merke: Kommandos können auf Tasten gelegt werden (wie beim Lernen). Das 
letzte Kommando kann durch ESC f wiederholt werden. 
 
 
 
Die wichtigsten Kommandos zur Textverarbeitung 
 
Einige Kommandos sind speziell für die Textverarbeitung im Editor program- 
miert. Die wichtigsten werden hier vorgestellt. 
 
Kommando            Bedeutung 
----------------------------------------------------------------------------- 
"text"              Text suchen: 
D "text"            Der zu suchende Text muß in Anführungszeichen geschrieben 
                    werden (damit werden auch Leerzeichen innerhalb des ge- 
                    suchten Textes wichtig). Es wird ab der Stelle in der 
                    Datei in Richtung auf das Dateiende hin gesucht (also 
                    "nach unten"), an der sich der Cursor befindet. Wird der 
                    Text gefunden, positioniert der Editor den Cursor direkt 
                    dahinter. Beispiel: 
 
                       D "Autor" 
 
                    sucht nach dem ersten Auftreten von 'Autor'. Beachte, daß 
                    bei der Suche nach Zeichen, die man nicht direkt mit der 
                    Tastatur schreiben kann, der Codewert angegeben werden 
                    muß (vergl. dazu die EUMEL-Codetabelle). Beispiel: 
 
                       DOWN ""217""    (* sucht ein ä *) 
                       DOWN "Diesen Text mu"251" man finden" 
 
                    (Ein Codewert innerhalb eines Textes muß in " einge- 
                    schlossen werden). 
                    Wird nur ein Text gesucht, kann man auch nur diesen 
                    angeben. Beispiel: 
 
                       "diesen fehler" 
 
D nummer            (Relatives) Positionieren in Richtung auf das Dateiende. 
                    Beispiel: 
 
                       D 75 
 
                    positioniert um 75 Zeilen in Richtung auf das Dateiende. 
 
U "text"            Analog D, aber in Richtung auf den Dateianfang ("nach 
                    oben"). 
 
U nummer            Analog D, aber in Richtung auf den Dateianfang. 
 
nummer              Absolutes Positionieren: 
T nummer            Durch Angabe einer Zahl, wird auf die entsprechende 
                    Zeile der Datei positioniert. Beispiel: 
 
                       T 317 
                       317 
 
                    Ist die Datei bereits vor der Zeile '317' zu Ende, wird 
                    auf die letzte Zeile der Datei positioniert. 
 
"alt" C "neu"       Suchen und Ersetzen eines Textes: Sucht nach dem Text 
                    'alt'. Falls vorhanden, wird 'alt' durch 'neu' ersetzt. 
                    Beispiel: 
 
                       "einfach" C "leicht" 
 
                    ersetzt 'einfach' durch 'leicht'. 
 
"alt" CA "neu"      Suchen aller 'alt' ab der aktuellen Position bis zum 
                    Dateiende und ersetzen durch 'neu'. 
 
type ("text")       Schreiben eines 'text' durch ein Kommando. Das type-Kom- 
                    mando wird häufig benutzt, um Zeichen zu schreiben, die 
                    nicht auf der Tastatur zu finden sind. In diesem Fall muß 
                    der Codewert des Zeichens angegeben werden (jeweils in 
                    doppelten "). Beispiel (vergl. auch EUMEL-Codetabelle): 
 
                       type (""251"") 
 
                    schreibt ein ß an die aktuelle Position der Zeile. 
 
Merke: Durch das D- bzw. U-Kommando kann ein Text in der Datei gesucht 
werden. Mit C kann ein Text gesucht und ersetzt werden. "alt" CA "neu" er- 
setzt alle 'alt' durch 'neu'. 'type' schreibt ein Zeichen (oder einen Text). 
Durch T kann auf eine bestimmte Zeile der Datei positioniert werden. 
 
 
 
Texte aus anderen Dateien einfügen oder in andere Dateien schreiben 
 
Manchmal ist es notwendig, einen Text in eine andere Datei zu schreiben 
(z.B. wenn man diesen Text noch einmal verwenden will) oder einen Text einer 
anderen Datei in den zu bearbeitenden Text einzufügen. Die GET- und PUT- 
Kommandos bieten die Möglichkeit, Texte zwischen Dateien auszutauschen 
(vergl. auch Paralleleditor). 
 
Das Kommando GET 'dateiname' holt den Text der Datei "dateiname" an die 
aktuelle Schreibposition. Beispiel: 
 
     GET "absender" 
 
holt den Text 'absender'. Wenn also des öfteren Briefe geschrieben werden, 
braucht man sich den Absender nur einmalig in die Datei 'absender' zu schrei- 
ben und kann diesen mit dem Kommando GET (was man auf eine Taste legen kann) 
u.U. mehrmals an verschiedenen Stellen in die Datei einfügen. 
 
Das Kommando PUT (abgekürzt: P) schreibt einen vorher markierten Text in 
eine Datei. Beispiel: 
 
     PUT "Tabelle" 
 
schreibt einen markierten Text in die Datei 'Tabelle'. 'Tabelle' wird ggf. 
eingerichtet. Ist die Datei 'Tabelle' bereits vorhanden, so wird erfragt, ob 
die Datei gelöscht werden kann, um den markierten Text aufzunehmen (über- 
schreiben). Andernfalls wird der markierte Text an den bereits vorhandenen 
Text in 'Tabelle' angefügt. Es ist somit durch mehrmaliges markieren und dem 
PUT-Kommando möglich, Texte aus einer Datei aufzusammeln und in eine neue 
Datei zu geben. 
 
Merke: Die GET- und PUT-Kommandos schreiben bzw. holen Texte aus Dateien. 
 
 
 
Breitere Zeilen bearbeiten 
 
Der Editor ist auf eine Zeilenbreite von 77 Zeichen eingestellt. Oft ist es 
notwendig, mit einer anderen Zeilenbreite zu schreiben, welches man mit dem 
LIMIT-Kommando einstellen kann. Aber auch die Positionierung innerhalb einer 
Zeile wird dadurch etwas anders, weil bei breiteren Zeilen als die Bild- 
schirmbreite die Zeile nicht auf einmal auf den Bildschirm paßt. In diesem 
Fall wird gerollt. 
 
Eine andere Zeilenbreite stellt man durch 'limit' ein. Beachte, daß die somit 
eingestellte Zeilenbreite für die gesamte Datei gilt. Beispiel: 
(Soll eine veränderte Zeilenbreite nur für einen Abschnitt gelten, muß man 
eine Textkosmetik-Anweisung einfügen, welches erst nach Anwendung von 
'lineform' wirkt.) 
 
     limit (180) 
 
Nun kann man wie gewohnt schreiben. Allerdings wird die aktuelle Zeile, in 
der man sich befindet, nicht wie gewohnt am Bildschirmende umgebrochen, 
sondern erst an der Spalte 180 (sofern sie nicht vorher durch die RETURN- 
Taste beendigt wird). Wird über das rechte Bildschirmende hinaus geschrieben, 
bleibt die Cursor-Position am Ende des Bildschirms erhalten, aber die Zeile 
wird beim weiteren Schreiben nach links verschoben, "rollt" also nach links 
(der Anfang der Zeile verschwindet scheinbar nach links). 
 
Mit der Positionierung verhält es sich ähnlich. Wird über den rechten Bild- 
schirmrand mit RECHTS positioniert, wird die Zeile ebenfalls gerollt. HOP 
RECHTS dagegen bewirkt ein Blättern nur innerhalb dieser Zeile nach rechts. 
Analog verläuft es bei verschobener Zeile, wenn nach links (LINKS bzw. HOP 
LINKS) positioniert wird. 
 
Beim Schreiben von Tabellen kann es sinnvoll sein, das Fenster vorübergehend 
auf eine andere Anfangsposition (als 1) einzustellen. Das kann mit dem 
'margin'-Kommando erfolgen. Beispiel: 
 
     margin (50) 
 
Das Fenster des Editors zeigt nun einen Ausschnitt aus der Datei, beginnend 
ab Spalte 50. In der Titelzeile wird "M50" angezeigt. 
 
Merke: Eine veränderte Zeilenbreite wird mit dem limit-Kommando eingestellt. 
Wird über den Bildschirmrand positioniert, wird die Zeile gerollt. Mit dem 
'margin'-Kommando kann spaltenmäßig ein Anfangspunkt des Fensters einge- 
stellt werden. 
 
 
 
Paralleles Editieren (Fenstereditor) 
 
Oft ist notwendig, mit mehreren Dateien gleichzeitig zu arbeiten, z.B. wenn 
aus einer Datei etwas in eine andere kopiert werden muß, wenn Fehler durch 
die Textkosmetik-Programme oder einen Compiler gefunden werden oder wenn man 
kurz etwas in einer andern Datei nachschauen will. Zu diesem Zweck bietet der
Editor die Möglichkeit, zwei (oder mehr) Dateien zur gleichen Zeit zu be- 
arbeiten. 
 
Um ein neues Editor-Fenster einzuschachteln, betätigt man im Editor 
 
     ESC e 
 
Dies eröffnet ein Fenster auf eine andere Datei, deren Name interaktiv er- 
fragt wird. Die obere linke Ecke des Fensters befindet sich an der aktuellen 
Cursor-Position. Dabei darf sich der Cursor nicht zu sehr am rechten oder 
unteren Rand befinden (weil das Fenster sonst zu klein würde). In diesem 
"Fenster" auf eine andere Datei kann man genauso arbeiten, wie im "normalen" 
Editor. ESC q verläßt den aktuellen Fenstereditor (und alle darin einge- 
schachtelten Fenster). 
 
Mit der Tastenfolge 
 
     ESC w 
 
kann man von einem Fenster in das benachbarte wechseln (zyklisch). Insbeson- 
dere kann ein markierter Teil einer Datei mit dem Kommando 
 
     ESC p         (* oder: PUT "" *) 
 
in eine temporäre Datei geschrieben und nach ESC w mit 
 
     ESC g         (* oder: GET "" *) 
 
in die andere Datei eingefügt werden. 
 
Betätigt man ESC e ungefähr in der Mitte des Bildschirms, hat man das Fenster 
auf die neue Datei in der unteren Hälfte des Bildschirms und die "alte" Datei 
in der oberen Bildschirmhälfte. Dies nennt man "Paralleleditor", weil zwei 
Dateien zur gleichen Zeit editiert werden können. Der Paralleleditor wird 
auch von anderen Programmen benutzt, wie z.B. dem ELAN-Compiler, um Fehler- 
meldungen bequem anzuzeigen. 
 
Das Notizbuch schlägt man mit 
 
     ESC n 
 
auf. In diesem Notizbuch werden Informationen durch die Prozedur 
 
     note 
 
geschrieben. 
 
Merke: Der Fenstereditor wird durch ESC e aufgerufen und mit ESC q verlassen. 
Mit ESC w kann zwischen Dateien umgeschaltet werden. In jeder Datei stehen 
die gleichen Funktionen wie im "einfachen" Editor zur Verfügung. Man kann 
markierte Texte mit PUT bzw. GET von einer Datei in die andere bringen 
(Kopieren). 
 
 
 
Arbeiten mit dem Zeileneditor 
 
Der Zeileneditor erlaubt ein Editieren einer Eingabe mit allen Editor- 
Funktionen. 
 
Der Zeileneditor (auch "Feldeditor" genannt) wird über die Prozedur 
 
     editget 
 
aufgerufen. Durch diese Prozedur kann eine Zeile vom Terminal wie im Editor 
eingegeben werden, d.h. es können u.a. Einfügungen bzw. Löschungen in der 
Zeile vorgenommen werden. 'editget' dient darum als Grundlage für alle 'get'- 
Prozeduren. Beispiel: 
 
     TEXT VAR eingabe :: ""; 
     put ("Bitte geben Sie einen Wert ein:"); 
     editget (eingabe); 
     line 
 
'editget' kann aber auch einen Wert ausgeben, den ein Benutzer ggf. 
verändern kann. Beispiel: 
 
     TEXT VAR eingabe :: "trium10"); 
     put ("Bitte Schrifttyp angeben:"); 
     editget (eingabe); 
     line 
 
Hier kann ein Benutzer den TEXT 'trium10' verändern oder nur RETURN betäti- 
gen. 
 
Es gibt noch weitere Versionen von 'editget', bei denen man die Zeilenbreite, 
reservierte Tasten u.a.m. angeben kann. 
 
Merke: 'editget' ist der Zeileneditor. 
 
 
 
3. Vorbelegung von Tasten 
 
Wie schon beschrieben, können Lernsequenzen und Kommandos (d.h. ELAN- 
Programme) Tasten zugeordnet werden. Da einige Funktionen häufig benötigt 
werden, sind diese standardmäßig bestimmten Tasten zugeordnet. 
 
 
 
Kommandodialog 
 
ESC ESC        Kommandodialog einschalten. 
 
ESC ! taste    Im Kommandodialog: geschriebenes Kommando auf Taste legen. 
 
ESC ? taste    Im Kommandodialog: Auf 'taste' gelegtes Kommando anzeigen zum 
               Editieren. 
 
ESC k          Im Kommandodialog: Das zuletzt editierte ELAN-Programm an- 
               zeigen. 
 
 
 
Lernen 
 
ESC HOP        Lernen einschalten. 
 
ESC HOP taste  Lernsequenz auf 'taste' legen. 
 
 
 
Operationen auf Markierungen 
 
ESC RUBOUT     Markiertes "vorsichtig" löschen. 
 
ESC RUBIN      Vorsichtig Gelöschtes einfügen. 
 
ESC p          Markiertes in die Scratch-Datei kopieren (PUT ""), an 
               schließend löschen (kann mit ESC g an anderer Stelle re- 
               produziert werden). 
 
ESC d          Duplizieren: Markiertes in die Scratch-Datei kopieren 
               (PUT ""), anschließend die Markierung abschalten. (Kann mit 
               ESC g beliebig oft reproduziert werden). 
 
ESC g          MIT ESC p gelöschtes oder mit ESC d dupliziertes an aktuelle 
               Cursor-Stelle schreiben, d.h. Scratch-Datei an aktueller 
               Stelle einfügen (GET ""). 
 
 
 
Weitere Operationen 
 
ESC q          Verlassen des Editors. 
 
ESC e          Fenstereditor einschalten. 
 
ESC n          Notizbuch "aufschlagen". 
 
ESC w          Dateiwechsel beim Fenstereditor. 
 
ESC f          Nochmalige Ausführung des letzten Kommandos 
 
ESC b          Das Fenster wird auf den linken Rand der aktuellen (ggf. 
               verschobenen) Zeile gesetzt. 
 
ESC RECHTS     Zum nächsten Wortanfang. 
 
ESC LINKS      Zum vorigen Wortanfang. 
 
ESC 1          Zum Anfang der Datei. 
 
ESC 9          Zum Ende der Datei. 
 
 
 
Zeichen schreiben 
 
ESC a          Schreibt ein ä. 
ESC A          Schreibt ein Ä. 
ESC o          Schreibt ein ö. 
ESC O          Schreibt ein Ö. 
ESC u          Schreibt ein ü. 
ESC U          Schreibt ein Ü. 
ESC s          Schreibt ein ß. 
ESC (          Schreibt eine [. 
ESC )          Schreibt eine ]. 
ESC <          Schreibt eine {. 
ESC >          Schreibt eine }. 
ESC \#          Schreibt ein \#, was auch gedruckt werden kann. 
ESC blank      Schreibt ein (geschütztes) Leerzeichen. 
 
 
 
4. Komplexere Kommandos (ELAN-Programme) 
 
In diesem Kapitel finden Sie (neben den bereits in den vorherigen Kapiteln 
beschriebenen) eine Übersicht über die vorgefertigten Kommandos. Weitere 
können leicht vom Benutzer und Programmierer selbst erstellt werden. 
 
 
 
Wiederholungen schreiben 
 
In der Programmiersprache ELAN gibt es ein Sprachmittel, um Anweisungen 
wiederholen zu lassen. Dieses Sprachmittel nennt man Wiederholungsanweisung 
oder Schleife. Durch dieses Sprachmittel ist es leicht möglich, eine oder 
mehrere Kommandos mehrmals ausführen zu lassen. 
 
Eine Wiederholung, meist Schleife genannt, wird durch die Worte REP (steht 
für 'REPEAT', was soviel wie 'wiederhole' heißt) und PER (die Umkehrung von 
REP) oder END REP gebildet. Alle Anweisungen, die zwischen diesen Worten 
stehen, werden wiederholt ausgeführt (bis das Ende der Datei erreicht ist). 
Damit kann man einen Text in der gesamten Datei ändern. (In den folgenden 
Beispielen schreiben wir die Kommandozeile der besseren Übersichtlichkeit 
halber in mehreren Zeilen). Beispiel: 
 
     T 1; 
     WHILE NOT eof REP 
       "alter text" C "neuer text" 
     PER 
 
Durch die erste Anweisung wird zur ersten Zeile der Datei positioniert. Dann 
steht im Programm eine sogenannte "abweisende Schleife", die durch 'WHILE 
bedingung' eingeleitet wird (die Schleife wird solange ausgeführt, bis die 
Bedingung nicht mehr erfüllt ist). Die Bedingung besteht hier aus einer Ab- 
frage auf das Dateiende der bearbeiteten Datei ('eof'). Nach Eintritt in die 
Schleife wird nach 'alter text' gesucht. Falls gefunden, wird er durch 
'neuer text' ersetzt. Das Suchen und ersetzen wird solange durchgeführt, bis 
das Dateiende erreicht wird. Falls 'alter text' nicht gefunden wird, steht 
man auf dem letzten Zeichen der letzten Zeile der Datei (wie bei einer er- 
folglosen wiederholten letzten Suche), so daß die nächste WHILE-Überprüfung 
die Schleife abbricht. 
 
Die meisten der oben beschriebenen Kommandos gibt es nicht nur als Operato- 
ren, sondern auch als Prozeduren. Beispiele: 
 
     T 1            ==> toline (1) 
     D "text"       ==> down ("text") 
     U "text"       ==> up   ("text") 
     D 17           ==> down (17) 
     U 18           ==> up   (18) 
     "alt" C "neu"  ==> change to ("alt", "neu") 
     "alt" CA "neu" ==> change all ("alt", "neu") 
 
Man kann also das obige Beispiel auch folgendermaßen programmieren: 
 
     toline (1); 
     WHILE NOT eof REP 
       change to ("alter text", "neuer text") 
     PER 
 
Durch dieses zusammengesetzte Editor-Kommando können also ein oder mehrere 
Worte in der gesamten Datei auf einfache Weise geändert werden. 
Natürlich kann man das obige Beispiel einfacher schreiben: 
 
     toline (1); change all ("alter text", "neuer text") 
 
Was muß man nun programmieren, um eine Ersetzung nur einmal pro Zeile vor- 
zunehmen? Erinnern wir uns: nach einer Ersetzung steht der Cursor hinter dem 
ersetzten Text. Somit finden wir bei der erneuten Suche unter Umständen den 
Text nochmals in der aktuellen Zeile. Wenn wir nach einer Ersetzung aber um 
eine Zeile vorwärts positionieren (mit 'down (1)'), kann dies nicht ge- 
schehen. Leider wird durch die Vorwärts-Positionierung die Position des 
Cursors nicht verändert. Somit kann die erneute Suche einen Text in der 
nächsten Zeile verpassen. Man muß also neben der Vorwärts-Positionierung um 
eine Zeile zusätzlich auch noch an den Anfang der Zeile gehen. Für die 
Positionierung innerhalb einer Zeile gibt es die Prozedur 
 
     col (17)                 (* Positioniert auf die 17. Spalte 
                                 der aktuellen Zeile *) 
 
Damit können wir nun eine einmalige Ersetzung in einer Zeile programmieren: 
 
     toline (1); 
     WHILE NOT eof REP 
       col (1); 
       change to ("alter text", "neuer text"); 
       down (1); 
     PER 
 
Es wird erst auf die erste Zeile, erste Spalte positioniert. Dann wird 'alter 
text' gesucht und ggf. durch 'neuer text' ersetzt. Danach wird eine Zeile 
vorwärts positioniert, wiederum auf Spalte 1. Dadurch ist gewährleistet, daß 
eine Ersetzung nur einmal pro Zeile vorgenommen wird und immer von der 
ersten Spalte einer Zeile aus gesucht wird. Dies geschieht solange, bis das 
Ende der Datei erreicht ist. 
 
Manchmal ergibt sich die Notwendigkeit, in Tabellen in jeder Zeile noch Leer- 
spalten einzufügen oder zu entfernen. Auch dies kann mit der Schleife leicht 
erledigt werden: 
 
     toline (1); 
     WHILE NOT eof REP 
       col (48); 
       "" C "   "; 
       down (1) 
     PER 
 
Hier werden in jeder Zeile an der Spalte 48 drei Leerzeichen eingefügt. In 
diesem Fall suchen wir ab der Spaltenposition 48 einen sogenannten "Niltext" 
("leerer Text"). Dieser Text wird natürlich immer gefunden. Aber man muß 
hier aufpassen, denn der gesuchte Text sollte in dieser Zeile vorhanden sein, 
sonst wird in einer der nächsten Zeilen ein TEXT ersetzt, der nicht unbe- 
dingt an der Spaltenposition 48 steht! 
 
Wie bereits angemerkt, sollten in den zu verändernden Zeilen an der Position 
48 ein Leerzeichen stehen, sonst wird das C-Kommando fehlerhaft bei dem 
nächsten TEXT ausgeführt. Das kann man verhindern, indem man folgendes 
programmiert: 
 
     toline (1); 
     WHILE NOT eof REP 
       down (" ");  (* sucht das naechste Blank ab Spalte 48 *) 
       IF col = 48 
         THEN change to (" ", "   "); 
       FI 
     END REP 
 
Die Prozedur 'col' (ohne Parameter) liefert die aktuelle Spaltenposition 
innerhalb einer Zeile. 
 
Manchmal soll eine Änderung nur in einem bestimmten Bereich vorgenommen 
werden. Dazu gibt es die Prozedur 'line no', mit der man die aktuelle Zeilen- 
nummer erfragen kann. Beispiel: 
 
     toline (50); 
     WHILE NOT eof REP 
        aenderungen 
     UNTIL line no = 100 END REP 
 
In diesem Beispiel werden 'aenderungen' im Zeilenbereich 50 - 100 vorgenom- 
men. 'line no' liefert die aktuelle Zeilennummer des FILEs, welches gerade 
vom Editor bearbeitet wird. 
 
Weitere Beispiele: 
 
     (* suchen in Spalte 17: *) 
     REP 
       down ("muster") 
     UNTIL eof OR col = 17 END REP 
 
     (* in Spalte 1 ersetzen: *) 
     REP 
       down ("alt"); 
       IF col = 1 
         THEN "alt" C "neu" 
       FI 
     UNTIL eof END REP 
 
Merke: Eine Wiederholung REP ... PER führt die in ihr enthaltenen An- 
weisungen wiederholt aus. Eine Abfrage auf das Dateiende der bearbeiteten 
Datei ist durch 'eof' möglich. 
 
 
 
Das Notizbuch 
 
Im Notizbuch kann man sich Notizen über den Ablauf von Kommandos machen. 
 
Die Prozedur 
 
     note 
 
schreibt einen INT- oder TEXT-Parameter in eine Zwischendatei. Diese Datei 
kann man sich mit 
 
     ESC n 
 
anschauen. Beispiel: 
 
     (* ersetzen und notieren: *) 
     REP 
       "alt" C "neu"; 
       note (line no) (* Zeilennummer der Ersetzung notieren *) 
     UNTIL eof END REP 
 
Merke: Die Prozedur 'note' schreibt in das Notizbuch. Mit ESC n kann man 
sich das Notizbuch anschauen. 
 
 
 
Neue Editor-Kommandos bereitstellen 
 
Sollen neue Editor-Kommandos bereitgestellt werden, muß man dem Editor ggf. 
mitteilen, ob und wie das Fenster auf die Datei auf dem Bildschirm neu ge- 
schrieben werden muß. 
 
Neue Editor-Kommandos kann man allen Benutzern bereitstellen, in dem ein 
Programm geschrieben wird. Beispiel: 
 
     PROC datum schreiben: 
       type (datum). 
 
     datum: 
       date (clock (1)). (* Siehe auch TEIL 8: Standardpakete *) 
     END PROC datum schreiben 
 
Diese Prozedur (oder mehrere) muß noch in ein PACKET "gekleidet" und dann 
insertiert werden. Dann steht 'datum schreiben' allen Benutzern dieser Task 
oder dessen Sohn-Task zur Verfügung (siehe dazu auch TEIL 5: ELAN-Compiler). 
 
Bei etwas komplizierteren Prozeduren sollte man dem Editor mitteilen, ob und 
wie er das Fenster auf die Datei auf dem Bildschirm neu schreiben muß. 
Normalerweise schreibt der Editor nach einem Kommando den gesamten Bild- 
schirm neu. Dies kann man verhindern, indem man die Prozedur 
 
     nichts neu 
 
aufruft. Sie teilt dem Editor mit, daß das Fenster nicht neu geschrieben 
werden muß. Weitere Prozeduren teilen dem Editor mit, daß Teile des Fensters 
neu geschrieben werden müssen: 
 
     satznr neu       (* Zeilennummer links oben *) 
     ueberschrift neu 
     zeile neu 
     abschnitt neu 
     bild neu 
 
Dabei kann man die Prozeduren in beliebiger Reihenfolge aufrufen, wobei 
jeweils immer die größte Änderung dominiert. Beispiel: 
 
     nichts neu; 
     ... 
     zeile neu; 
     ... 
     bild neu; 
     ... 
     ueberschrift neu 
     ... 
 
'bild neu' dominiert über 'zeile neu', 
'zeile neu' dominiert über 'ueberschrift neu'; 
'ueberschrift neu' dominiert über 'nichts neu'. 
 
Im obigen Beispiel 'datum schreiben' würde es also ausreichen, am Anfang der 
Prozedur 'nichts neu' und am Ende 'zeile neu' aufzurufen, damit nur die 
aktuelle Zeile neu geschrieben wird. 
 
Manchmal ist es notwendig, dem Benutzer bei einer Kommandoverarbeitung neue 
Zustände direkt anzuzeigen. Dafür gibt es die Prozeduren 
 
     satznr zeigen 
     ueberschrift zeigen 
     bild zeigen 
 
Beispiel: 
 
     satznr zeigen (line no) 
 
zeigt bei einer Kommandoverarbeitung die aktuelle Zeilenummer. 
 
Merke: Normalerweise baut der Editor nach einer Kommandoausführung das 
Fenster auf dem Bildschirm neu auf. Mit 'nichts neu' kann das verhindert 
werden. Weitere Prozeduren teilen dem Editor mit, welche Fensterteile neu 
geschrieben werden müssen. Das Schreiben von Fensterteilen kann auch direkt 
ausgelöst werden. 
 
 
 
Die ELAN-Notation 
 
Kommandos werden in ELAN-Notation beschrieben. Dabei bedeuten: 
 
OP              Operator. 
                Der Name des Operators muß mit grossen Buchstaben vor oder 
                zwischen die Operanden geschrieben werden. Beispiele: 
                    OP C (TEXT CONST muster, pattern) 
                    --> "alt" C "neu" 
 
PROC            Prozedur. 
                Der Name der Prozedur muß klein geschrieben werden. Die 
                Parameter werden in Klammern angefügt. Beispiele: 
                    PROC getchar (TEXT VAR zeichen) 
                    --> getchar (character) 
                    PROC edit  (TEXT CONST datei, 
                                INT CONST x, y, xsize, ysize) 
                    --> edit   ("meine datei", 1, 1, 79, 24) 
 
INT             Ganze Zahl ('Integer'). 
                Der Wert ist eine ganze Zahl (ohne Dezimalpunkt!). 
 
BOOL            Wahrheitswert ('Boolean'). 
                Hat zwei Werte: TRUE ('Wahr') und FALSE ('Falsch'). 
 
TEXT            Text. 
                Muß in Anführungszeichen geschrieben werden. Soll das 
                '"'-Zeichen in einem Text vorkommen, muß es doppelt 
                geschrieben werden. 
 
VAR             Veränderbarer Wert. 
                Wert kann von der Prozedur oder dem Operator verändert 
                werden. 
 
CONST           Unveränderbarer Wert. 
                Wert kann von der Prozedur oder dem Operator nicht ver- 
                ändert werden. 
 
 
 
Kommando-Übersicht 
 
In dieser Übersicht werden Editor-Kommandos, die in der Regel nur in Pro- 
grammen verwendet werden, mit (P) gekennzeichnet. "Nicht-Programmierer" 
brauchen also nur die nicht gekennzeichneten Kommandos zu lesen. Alle hier 
aufgeführten Kommandos arbeiten auf die vom Editor bearbeitete Datei 
('editfile'). Einige der Prozeduren stehen auch zur allgemeinen Dateiver- 
arbeitung zur Verfügung (siehe TEIL 7), allerdings dann mit einem zusätz- 
lichen FILE-Parameter. 
 
abschnitt neu (P) 
    PROC abschnitt neu (INT CONST von zeile, bis zeile) 
    Zweck: Mitteilung an den Editor, daß der entsprechende Abschnitt 
           auf dem Bildschirm neu geschrieben werden muß. 
 
at (P) 
    BOOL PROC at (TEXT CONST muster) 
    Zweck: Feststellen, ob der Editor auf 'muster' steht. Die Cursor- 
           Position wird dabei nicht verändert. 
 
bild neu (P) 
    PROC bild neu 
    Zweck: Mitteilung an den Editor, daß das Bild nach Kommandover- 
           arbeitung neu geschrieben werden muß. 
 
bild zeigen 
    PROC bild zeigen 
    Zweck: Mitteilung an den Editor, daß das Bild sofort neu geschrieben 
           werden muß. 
 
C 
    OP C (TEXT CONST muster, pattern) 
    Zweck: Wie D "muster" mit anschließender Ersetzung desselben durch 
           'pattern'. 
 
change to (P) 
    PROC change to (TEXT CONST muster, pattern) 
    Zweck: Analog C. 
 
    PROC change to (TEXT CONST muster, pattern, INT CONST number) 
    Zweck: Analog C, aber nur 'number' Zeilen weit. 
 
CA 
    OP CA (TEXT CONST source, destination) 
    Zweck: Arbeitet ab der aktuellen Position wie 
 
               WHILE NOT eof REP 
                 "source" C "destination" 
               END REP 
 
change all (P) 
    PROC change all (TEXT CONST source, destination) 
    Zweck: Analog CA. 
 
col (P) 
    PROC col (INT CONST pos) 
    Zweck: Positioniert auf die Spalte 'pos' der aktuellen Zeile. 
    Beispiel: 
 
                col (37) 
 
           positioniert auf die 37. Spalte der aktuellen Zeile. 
 
    INT PROC col 
    Zweck: Liefert die aktuelle Position des Cursors innerhalb einer Zeile. 
 
D 
    OP D (INT CONST n) 
    Zweck: Positioniert das Fenster n Zeilen vorwärts in Richtung auf das 
           Dateiende. 
 
    OP D (TEXT CONST muster) 
    Zweck: Sucht 'muster' vorwärts in Richtung auf das Dateiende. Die Suche 
           beginnt direkt hinter der aktuellen Cursor-Position. Wird 'muster' 
           nicht gefunden, steht der Cursor hinter dem letzten Zeichen der 
           Datei. Wird 'muster' gefunden, steht der Cursor direkt auf dem 
           ersten Zeichen von 'muster'. 
 
down (P) 
    PROC down (INT CONST n) 
    Zweck: Analog D. 
 
    PROC down (TEXT CONST muster) 
    Zweck: Analog D. 
 
    PROC down (TEXT CONST muster, INT CONST n) 
    Zweck: Analog D, jedoch geht die Suche nur 'n' Zeilen. 
 
downety (P) 
    PROC downety (TEXT CONST muster) 
    Zweck: Im Gegensatz zu 'down' beginnt die Suche mit dem aktuellen Zeiche 
    n, d.h. der Aufruf führt zu einer leeren Leistung, wenn der Cursor schon 
    auf 'muster' steht. Deshalb bei der Programmierung vorsichtig verwenden. 
 
    PROC downety (TEXT CONST muster, INT CONST n) 
    Zweck: Analog 'downety', jedoch geht die Suche nur 'n' Zeilen und 
           beginnt bei der aktuellen Cursor-Position (siehe oben). 
 
editfile (P) 
    FILE PROC editfile 
    Zweck: Liefert die aktuell editierte Datei. 
 
eof 
    BOOL PROC eof 
    Zweck: Abfrage auf das Dateiende der zu bearbeitenden Datei. 
 
GET 
    OP GET (TEXT CONST dateiname) 
    Zweck: Kopiert den Inhalt der Datei mit dem angegebenen Namen vor die 
           aktuelle Cursor-Position. Ist die Quelldatei kopiert, wird nur 
           der markierte Teil kopiert. 
 
    OP G (TEXT CONST dateiname) 
    Zweck: Wie GET. 
 
len (P) 
    INT PROC len 
    Zweck: Liefert die Länge der aktuellen Zeile. 
 
limit 
    OP limit (INT CONST limit) 
    Zweck: Setzt die rechte Schreibgrenze auf 'limit'. Beispiel: 
 
                limit (120) 
 
           stellt den Editor auf eine Zeilenlänge von 120 Zeichen. 
 
    INT PROC limit 
    Zweck: Liefert die eingestellte Zeilenbreite. 
 
line no (P) 
    INT PROC line no 
    Zweck: Liefert die aktuelle Zeilennummer der editierten Datei. 
 
margin 
    PROC margin (INT CONST anfang) 
    Zweck: Alle Zeilen erscheinen erst ab Spalte 'anfang' im Sichtfenster. 
           Beispiel: 
 
               margin (50) 
 
           legt das Fenster ab Spalte 50 fest. 
 
    INT PROC margin 
    Zweck: Liefert den eingestellten linken Rand. 
 
mark (P) 
    PROC mark (BOOL CONST an) 
    (Zweck: Schaltet die Markierung an der aktuellen Stelle ein bzw. aus. 
           Beispiel: 
 
               mark (true)  (* schaltet Markierung an  *) 
               mark (false) (* schaltet Markierung aus *) 
 
    BOOL PROC mark 
    Zweck: Liefert TRUE, sofern die Markierung eingeschaltet ist. 
 
nichts neu (P) 
    PROC nichts neu 
    Zweck: Mitteilung an den Editor, daß nach Kommandoverarbeitung das Bild 
           nicht neu geschrieben werden muß. 
 
note (P) 
    PROC note (INT CONST wert) 
    Zweck: Schreibt 'wert' in das Notizbuch. 
 
    PROC note (TEXT CONST message) 
    Zweck: Schreibt 'message' in das Notizbuch. 
 
pattern found (P) 
    BOOL PROC pattern found 
    Zweck: Gibt an, ob der letzte Suchprozeß erfolgreich war. 
 
PUT 
    OP PUT (TEXT CONST dateiname) 
    Zweck: Richtet eine Datei mit dem angegebenen Namen ein, kopiert den 
           markierten Textabschnitt in diese. 
 
    OP P (TEXT CONST dateiname) 
    Zweck: Wie PUT. 
 
satznr neu (P) 
    PROC satznr zeigen 
    Zweck: Mitteilung an den Editor, daß nach Kommandoverarbeitung die 
           Zeilennummer rechts oben neu geschrieben werden muß. 
 
satznr zeigen (P) 
    PROC satznr zeigen (INT CONST nr) 
    Zweck: Mitteilung an den Editor, die Zeilennummer 'nr' sofort neu zu 
           schreiben. 
 
T 
    OP T (INT CONST n) 
    Zweck: Positioniert auf die Zeile 'n'. 
 
toline (P) 
    PROC toline (INT CONST n) 
    Zweck: Analog T. 
 
type (P) 
    PROC type (TEXT CONST t) 
    Zweck: Trägt 't' in den Eingabestrom ('f kommando') des Editors ein. 
           Beispiel: 
 
               type (text (sqrt (2.0))) 
 
           fügt an die aktuelle Cursor-Position den Wert 1.41... ein.
           Beispiel: 
 
               INT VAR i; 
               FOR i FROM 1 UPTO 10 REP 
                 type (text (i) + " ") 
               END REP 
              (* Ausgabe: 1 2 3 4 5 6 7 8 9 10 *) 
 
U 
    OP U (INT CONST n) 
    Zweck: Positioniert das Fenster n Zeilen rückwärts in Richtung auf den 
           Dateianfang. 
 
    OP U (TEXT CONST muster) 
    Zweck: Sucht 'muster' rückwärts in Richtung auf den Dateianfang. Die 
           Suche beginnt links neben der aktuellen Cursor-Position. Vergl. D 
 
ueberschrift neu (P) 
    PROC ueberschrift neu 
    Zweck: Mitteilung an den Editor, daß nach Kommandoverarbeitung die 
           Überschriftszeile neu zu schreiben ist. 
 
ueberschrift zeigen (P) 
    PROC ueberschrift zeigen 
    Zweck: Mitteilung an den Editor, daß sofort die Überschriftszeile neu 
           zu schreiben ist. 
 
up (P) 
    PROC up (INT CONST n) 
    Zweck: Analog U. 
 
    PROC up (TEXT CONST muster) 
    Zweck: Analog U. 
 
    PROC up (TEXT CONST muster, INT CONST n) 
    Zweck: Analog U, aber nur 'n' Zeilen weit. 
 
uppety (P) 
    PROC uppety (TEXT CONST muster) 
    Zweck: Im Gegensatz zu 'up' beginnt die Suche direkt auf der aktuellen 
           Cursor-Position. Vergl. 'down'. 
 
    PROC uppety (TEXT CONST muster, INT CONST n) 
    Zweck: Analog 'uppety', aber nur 'n' Zeilen weit. 
 
word (P) 
    TEXT PROC word 
    Zweck: Liefert das Wort von der aktuellen Position bis zum nächsten 
           Blank bzw. Zeilenende. Die Cursor-Position wird nicht verändert. 
 
    TEXT PROC word (TEXT CONST muster) 
    Zweck: Liefert das Wort von der aktuellen Position bis zum nächsten Auf- 
           treten von 'muster' (ausschließlich) bzw. Zeilenende. Die Cursor- 
           Position wird nicht verändert. 
 
    TEXT PROC word (INT CONST laenge) 
    Zweck: Liefert das Wort von der aktuellen Position in der angegebenen 
           'laenge' bzw. bis zum Zeilenende. Die Cursor-Position wird nicht 
           verändert. 
 
word wrap 
    PROC word wrap (BOOL CONST an) 
    Zweck: Schaltet den automatischen Wortumbruch an (voreingestellt) bzw. 
    aus. Beispiel: 
 
             word wrap (true)         (* angeschaltet  *) 
             word wrap (false)        (* ausgeschaltet *) 
 
zeile neu (P) 
    PROC zeile neu 
    Zweck: Mitteilung an den Editor, daß nach Kommandoverarbeitung die 
           aktuelle Zeile neu zu schreiben ist. 
 
 
 
5. EUMEL-Zeichensatz 
 
Das EUMEL-System definiert einen Zeichensatz, der gewährleistet, daß Zeichen 
auf allen Maschinen überall gleich codiert werden. Dadurch ist es z.B. mög- 
lich, Dateien und Programme ohne Konvertierungen zwischen EUMEL-Systemen 
unterschiedlicher Hersteller zu übertragen. Der EUMEL-Zeichensatz beruht auf 
dem ASCII-Zeichensatz (DIN 66 003) mit Erweiterungen. 
 
 
 
Darstellbare Zeichen 
 
Die genaue Darstellung der einzelnen Zeichen hängt vom Endgerät ab. Die hier 
aufgeführten Zeichen sind i.A. auf allen Geräten vorhanden. Ein erweiterter 
Zeichensatz (mit mathematischen, diakritischen und griechischen Zeichen) ist 
nur auf Spezialgeräten verfügbar und wird deshalb hier nicht angegeben. 
 
Beispiele zum Lesen der Tabelle: 
 
    code (" ") ->  32 
    code ("m") -> 109 
 
 |3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 
-+------------------------------------------------------------------- 
0|   (  2  <  F  P  Z  d  n  x                             k 
 | 
1|   )  3  =  G  Q  [  e  o  y                             -        ß 
 | 
2|SP *  4  >  H  R  \\  f p  z                              \# 
 | 
3|!  +  5  ?  I  S  ]  g  q  {                             SP 
 | 
4|"  ,  6  §  J  T  ^  h  r  |                          Ä 
 | 
5|\#  -  7  A  K  U  _  i  s  }                          Ö 
 | 
6|$  .  8  B  L  V  `  j  t  ~                          Ü 
 | 
7|%  /  9  C  M  W  a  k  u                             ä 
 | 
8|&  0  :  D  N  X  b  l  v                             ö 
 | 
9|'  1  ;  E  O  Y  c  m  w                             ü 
 
Anmerkungen: 
1) SP bedeutet Leerzeichen ("blank"). 
2) Die Zeichen 'k', '-' und 'SP' mit den Codes 220, 221, 223 werden für die 
   Zwecke der Textkosmetik benötigt (Trenn 'k' bei der Umwandlung von 'ck' in 
   'kk'; Trennzeichen; geschütztes Leerzeichen). 
3) Das Zeichen '\#' (Code 222) ist druckbar, während das Zeichen '\#' (Code 35) 
   nicht druckbar ist (Einleitungszeichen für Anweisungen der Textkosmetik 
   und Drucker). 
4) Das Zeichen SP (Code 223) wird zur besseren Identifizierung als Unter- 
streichungsstrich auf dem Terminal dargestellt. Im einem Ausdruck erscheint 
es als ein Leerzeichen. 
 
 
 
Steuerzeichen und -tasten 
 
Das EUMEL-System definiert neben den darstellbaren Zeichen auch Steuer- 
zeichen, die entsprechend der angeschlossenen Geräte ggf. jeweils umcodiert 
werden. 
 
Das EUMEL-System definiert (Ausgabe-) Steuerzeichen mit ihren (ausgabesei- 
tigen) Wirkungen. Diese Steuerzeichen sind geräteunabhängig und werden vom 
EUMEL-System automatisch für die jeweiligen Geräte passend umcodiert. Bei 
Standard-Geräteschnittstellen ist die Wirkung anderer Steuerzeichen nicht 
definiert. Für den Anschluß von Druckern, für Datenfernübertragung u.ä. 
können sogenannte "Transparent"-Schnittstellen verwandt werden. Bei diesen 
Schnittstellen ist die Wirkung aller Steuerzeichen undefiniert (vom ange- 
schlossenen Gerät abhängig); es wird aber garantiert, daß alle Zeichen ohne 
Code-Umsetzung direkt ausgegeben werden. 
 
 
 
Ausgabesteuerzeichen 
 
Wert  | Bezeichnung  |  Wirkung 
------+--------------+----------------------------------------- 
 0    |   NUL        |  keine Wirkung, Füllzeichen 
 1    |   HOME       |  Cursor auf linke obere Ecke des Bildschirms 
 2    |   RECHTS     |  Cursor eine Stelle nach rechts 
 3    |   OBEN       |  Cursor eine Zeile nach oben 
 4    |   CL EOP     |  Löschen von Cursor-Position bis Bildschirmende 
 5    |   CL EOL     |  Löschen von Cursor-Position bis Zeilenende 
 6    |   CPOS       |  Cursor positionieren, nächstes Ausgabezeichen be- 
      |              |  stimmt die y-Position (0 <= code (y) <= 23), darauf- 
      |              |  folgendes Ausgabezeichen die x-Position 
      |              |  (0 <= code (x) <= 78). 
 7    |   BELL       |  akustisches Signal 
 8    |   LINKS      |  Cursor eine Stelle nach links 
10    |   UNTEN      |  Cursor eine Zeile nach unten bzw. 'roll up', falls 
      |              |  der Cursor schon in der letzten Zeile stand 
13    |   RETURN     |  Cursor an den Anfang der aktuellen Zeile 
14    |   ENDMARK    |  Ende des zu markierenden Bereichs 
15    |   BEGINMARK  |  Anfang des zu markierenden Bereichs 
 
 
 
Eingabe-Steuertasten 
 
Für die Eingabeseite sind im EUMEL ebenfalls Steuertasten definiert. Diese 
Tasten sollten am angeschlossenen Gerät vorhanden sein oder bereitgestellt 
werden (z.B. durch Überkleben von Tasten) oder müssen mit Hilfe der 
CONTROL-Taste simuliert werden. Das EUMEL-System führt entsprechend der 
folgenden Tabelle evtl. notwendige Umcodierungen der Eingabe durch. Weitere 
vorhandene Spezialtasten erzeugen gerätespezifische Codes. Bei der "Transpa- 
rent"-Schnittstelle werden - symmetrisch zur Ausgabeseite - alle hereinkom- 
menden Zeichen ohne Code-Umsetzung weitergereicht. 
 
Wert  | Bezeichnung 
------+------------ 
 1    |   HOP 
 2    |   RECHTS 
 3    |   OBEN 
 8    |   LINKS 
 9    |   TAB 
10    |   UNTEN 
11    |   RUBIN 
12    |   RUBOUT 
13    |   RETURN 
16    |   MARK 
27    |   ESC 
 
 
 
6. Der Editor als Unterprogramm 
 
Um eine Anpassung der Benutzerschnittstelle an spezielle Bedürfnisse vor- 
nehmen zu können, werden einige noch nicht erläuterte ELAN-Prozeduren zur 
Verfügung gestellt. Mit diesen kann für jede Anwendung ein Spezialprogramm 
zur Verfügung gestellt werden, das den Editor als Unterprogramm aufruft. Für 
den "normalen" Editor-Benutzer ist dieses Kapitel somit nicht weiter von 
Interesse. 
 
 
 
Tastenverwaltung 
 
kommando auf taste legen 
    PROC kommando auf taste legen (TEXT CONST taste, elan programm) 
    Zweck: Belegt die Taste 'taste' mit dem ELAN-Programm 'elan programm'. 
           Beispiel: 
 
               kommando auf taste legen 
                   ("v", "edit (""meine datei"")") 
 
           belegt die Taste 'v' mit der 'edit'-Prozedur. 
 
kommando auf taste 
    TEXT PROC kommando auf taste (TEXT CONST taste) 
    Zweck: Liefert den Quelltext des auf die Taste 'taste' gelegten ELAN-Pro- 
           gramms oder niltext, wenn diese nicht entsprechend belegt ist. 
 
lernsequenz auf taste legen 
    PROC lernsequenz auf taste legen (TEXT CONST taste, lernsequenz) 
    Zweck: Belegt die Taste 'taste' mit den Zeichen 'lernsequenz'. Beispiel: 
 
               lernsequenz auf taste legen ("a", ""217"") 
 
           belegt die Taste 'a' mit dem 'ä'. 
 
lernsequenz auf taste 
    TEXT PROC lernsequenz auf taste (TEXT CONST taste) 
    Zweck: Liefert die auf 'taste' gelegte Tastenanschlagsfolge 
           oder niltext, wenn diese nicht entsprechend belegt ist. 
 
taste enthaelt kommando 
    BOOL PROC taste enthaelt kommando (TEXT CONST taste) 
    Zweck: Liefert TRUE, wenn 'taste' mit einem ELAN-Programm belegt ist. 
 
std tastenbelegung 
    PROC std tastenbelegung 
    Zweck: Belegt die Tasten mit der Standardbelegung. 
 
 
 
Aufruf des Editors, Zeilen- und Fenstereditors 
 
edit 
     PROC edit 
     Zweck: a) Im Monitor: 
               Ruft den Editor mit den zuletzt verwandten Dateinamen auf. 
            b) Im Editor: 
               Der Dateiname wird erfragt. 
            Für jedes 'edit' gilt: 
            Wurde der 'edit' zum ersten mal aufgerufen, nimmt das Fenster 
            den  gesamten Bildschirm ein. Bei erneuten 'edit'-Aufruf wird 
            ein Fenster nach rechts unten ab aktuellen Cursor-Punkt eröffnet. 
 
    PROC edit (TEXT CONST datei) 
    Zweck: Ruft den Editor mit 'datei' auf. 
 
    PROC edit (TEXT CONST datei, x, y, xsize, ysize) 
    Zweck: Wie obiger 'edit'-Aufruf, jedoch kann das Fenster, in der 'datei' 
           editierbar ist, gesetzt werden. Die Parameter definieren ein 
           Editor-Fenster mit der linken oberen Ecke auf den Bildschirmkoor- 
           dinaten 'x' und 'y' und einer Zeilenbreite 'xsize' und 'ysize' 
           Zeilen. Wird der Editor mit 'edit ("datei")' aufgerufen, wird 
           implizit 'edit ("datei", 1, 1, 79, 24)' aufgerufen. 
 
    PROC edit (FILE VAR f) 
    Zweck: Vergl. obige 'edit'-Prozedur. 
 
    PROC edit (THESAURUS CONST t) 
    Zweck: Editieren aller in dem Thesaurus 't' enthaltenen Dateien nachein- 
           ander. Beispiel: 
 
              edit (ALL myself) 
 
    PROC edit (FILE VAR f, INT CONST x, y, xsize, ysize) 
    Zweck: Vergl. obige 'edit'-Prozedur. 
 
editget 
    PROC editget (TEXT VAR editsatz) 
    Zweck: Eingabe mit Editiermöglichkeit von 'editsatz' vom Terminal an der 
           aktuellen Bildschirmposition. 'editsatz' wird ausgegeben. Die 
           Eingabe wird mit RETURN beendet. Im Gegensatz zu 'get' ist hier 
           auch eine leere Eingabe (RETURN) erlaubt. 
 
    PROC editget (TEXT VAR editsatz, INT CONST editlimit, editlaenge, 
                  TEXT CONST sep, res, TEXT VAR exit char) 
    Zweck: Wie oben. Dabei bedeuten: 
 
    editsatz:   TEXT, der zum Editieren ausgegeben wird. 
    editlimit:  Einstellung des 'limit's der Zeile (max. Anzahl von Zeichen). 
                Bei obiger 'editget'-Prozedur wird 'editlimit' mit 
                'maxtextlength' aufgerufen. 
    editlaenge: Breite des Zeilenfensters, bevor gerollt wird (bei leerer 
                Zeile ist dies 77). 
    sep:        Zeichen, bei denen die Eingabe (zusätzlich zu RETURN) 
                beendet werden soll. 
    res:        Angabe von reservierten Tasten. Wird einer dieser Tasten mit 
                ESC betätigt, wird die Eingabe beendet. In 
    exit char:  steht dann ESC und das Zeichen, mit dem der Editor verlassen 
                wurde. 
 
    PROC editget (TEXT VAR editsatz, INT CONST editlimit, 
                  TEXT VAR exit char) 
    Zweck: Siehe oben. 
 
    PROC editget (TEXT VAR editsatz, TEXT CONST sep, res, 
                  TEXT VAR exit char) 
    Zweck: Siehe oben. 
 
show 
   PROC show (FILE VAR f) 
   Zweck: Zeigt eine Datei 'f' auf dem Bildschirm. Wie beim Editor kann mit 
          Hilfe der Positionierungstasten UNTEN bzw. OBEN oder HOP UNTEN bzw. 
          HOP OBEN oder HOP RETURN "geblättert" werden. Die Datei 'f' muß 
          deshalb mit der Verarbeitungsart 'modify' assoziiert worden sein. 
          Soll die Prozedur 'show' verlassen werden, müssen - wie beim Editor 
          - die zwei Tasten ESC und q betätigt werden. Die Datei kann nicht 
          schreibend verändert werden. 
 
   PROC show (TEXT CONST filename) 
   Zweck: Wie obige Prozedur. 
 
 
 
Zeichen verarbeiten 
 
getchar 
    PROC getchar (TEXT VAR zeichen) 
    Zweck: Holt das nächste Eingabezeichen von der Tastatur. 
 
is incharety 
    BOOL PROC is incharety (TEXT CONST zeichen) 
    Zweck: Ist das nächste Eingabezeichen der Tastatur 'zeichen', liefert 
           'is incharety' TRUE. In diesem Fall wird 'zeichen' von der Eingabe 
           verschluckt. Ist das nächste Zeichen von der Tastatur nicht 'zei- 
           chen', liefert 'is incharety' FALSE. Die Eingabe bleibt unver- 
           ändert. 

