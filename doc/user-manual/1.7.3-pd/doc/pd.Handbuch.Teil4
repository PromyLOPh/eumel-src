                       EUMEL-Benutzerhandbuch 
 
                   TEIL 4: Textkosmetik und Druck                  
 
TEIL 4: Textkosmetik und Druck 
 
 
Vorwort 
 
Die Textkosmetik-Programme des EUMEL-Systems bieten eine einfach zu er- 
lernende und zu bedienende Möglichkeit, Texte für den endgültigen Druck zu 
gestalten (Programmtechnisch: #ib#formatieren#ie#). Die Textkosmetik ermög- 
licht zusätzlich, Texte in einer Art und Weise zu manipulieren, die auf 
preiswerten Terminals zur Zeit nicht darstellbar ist, wie z.B. verschieden- 
artige Schriften. "Nebenbei" erledigt die Textkosmetik aufwendige Routine- 
arbeiten, wie z.B. Seitennumerierung und die Plazierung von Fußnoten. 
 
Die Textkosmetik-Programme bearbeiten Dateien, die durch den EUMEL-Editor 
erstellt wurden. Darum sollte man sich zuerst mit dem EUMEL-Editor vertraut 
machen. 
 
Für die meisten Aufgaben ist kein Benutzereingriff erforderlich, darum sind 
die Programme so konstruiert, daß sie durch in den Text eingefügte Anweisun- 
gen gesteuert werden. Einige Arbeiten erfordern den Benutzereingriff, wie 
z.B. die Kontrolle von Silbentrennungen bei fremdsprachigen Texten und die 
Plazierungen von Seitenenden. Diese Arbeiten werden auf einfache Weise 
interaktiv vorgenommen. Die Form der Anweisung ist für die Textkosmetik und 
den EUMEL-Drucker gleich und entspricht der ELAN-Syntax. Man beachte den 
Unterschied zwischen einem Kommando und einer Text-Anweisung: während ein 
Kommando direkt ausgeführt wird, wird eine im Text eingebettete Text-Anwei- 
sung (im weiteren kurz "#ib#Anweisung#ie#" genannt) erst nach dem Aufruf von 
Textkosmetik-und Drucker-Programmen wirksam. 
 
Die Wirkungsweise der Textkosmetik-Anweisungen ist leicht zu erlernen und 
kann vor allen Dingen stufenweise erfolgen. Deshalb ein guter Rat für An- 
fänger: Lesen Sie diesen Teil des Benutzer-Handbuchs erst oberflächlich, so 
daß Sie ungefähr Bescheid wissen, welche Möglichkeiten die Textkosmetik-Pro- 
gramme bieten. Dann können Sie diejenigen Teile der Textkosmetik auswählen 
und bei Bedarf anwenden, die sie für Ihre spezielle Anwendung benötigen. 
 
Zum Schluß noch eine Warnung: Die Regeln, Konventionen und Wirkungsweisen 
des EUMEL-Systems und der Textkosmetik-Programme muß ein Nutzer beherrschen, 
will er das System gut nutzen. Der Lernaufwand erfordert etwas Zeit und Mühe, 
der aber bei der Benutzung einer jeden Maschine erforderlich ist. Soll nur 
ein kurzer Brief geschrieben werden, ist man mit einer Schreibmaschine 
besser bedient. Beherrscht man dagegen die Benutzung des EUMEL-Systems 
einigermaßen, so kann auch die Erstellung eines kurzen Briefes schneller 
erfolgen als auf einer Schreibmaschine. 
 
 
 
1. Einführung in die Benutzung der Textkosmetik 
 
In diesem Kapitel wird eine Übersicht über die verfügbaren Programme der 
Textkosmetik gegeben. 
 
 
 
Schreiben, Gestalten und Drucken von Texten 
 
Im EUMEL-System unterscheiden wir zwischen drei Stufen einer Textbehandlung: 
Erstellung, Gestaltung und Druck. Die Trennung in verschiedene Arbeitsstufen 
hat den Vorteil, daß man sich zu einem Zeitpunkt nur auf einen Arbeits- 
schritt konzentrieren muß. 
 
 
a) Texterstellung bzw. Textbearbeitung 
 
Das Schreiben von Texten wird mit Hilfe des Editors erledigt. In dieser Stufe 
der Texterstellung kann ein Benutzer sich ausschließlich auf das Schreiben 
und die inhaltliche Korrektheit seines Textes konzentrieren. Wird ein Text 
ohne Anweisungen gedruckt, dann erscheint er so, wie er mit dem Editor ge- 
schrieben wurde. Bei der Erstellung des Textes können bereits Textkosmetik- 
Anweisungen in den Text eingefügt werden. 
 
Texte sollten im 'Fließtext'-Modus erstellt werden, d.h. Worte, die über 
Zeilengrenzen gehen würden, werden ohne Silbentrennung vom Editor in die 
nächste Zeile gebracht. 
 
 
b) Textkosmetik bzw. Textgestaltung 
 
Nachdem ein Text geschrieben wurde, kann man ihn mit Textkosmetik-Programmen 
gestalten, ohne ihn inhaltlich zu verändern. Dies kann auch vor oder nach 
eventuellen Korrekturen erfolgen. Die Textkosmetik bietet zur Zeit drei 
Programme an, die je nach Bedarf eingesetzt werden können: 
 
I)   'autoform/lineform' formatiert einen Text zeilenweise und vollzieht 
     eine Silbentrennung. Weiterhin erlaubt 'autoform/lineform' die Verwen- 
     dung unterschiedlicher Schrifttypen und Schrifthöhen. 
 
II)  'pageform' gestattet die Formatierung eines Textes in Seiten (drucktech- 
     nisch: "Paginieren"). Es ist mit 'pageform' u.a. möglich, die Seiten- 
     einteilung zu bestimmen, eine Seite in Spalten zu formatiern ("Zeitungs- 
     format"), Zeilen am Anfang bzw. Ende jeder Seite einfügen zu lassen, 
     eine Seitennummerierung zu erhalten und Fußnoten zu gestalten. 
 
III) 'index' erlaubt die Erstellung von Stichwort- und Inhaltsverzeichnissen. 
 
 
c) Drucken 
 
Zu jedem Zeitpunkt der Textbehandlung kann gedruckt werden. Um Drucker mit 
unterschiedlichen Eigenschaften betreiben zu können, wurde der (Fachausdruck: 
"virtuelle") EUMEL-Drucker als Schnittstelle zwischen dem EUMEL-System und 
(echten) Druckern geschaffen. Der EUMEL-Drucker beachtet die gleichen An- 
weisungen wie die Textkosmetik-Programme und noch einige zusätzliche, die 
nur für die Druckaufbereitung notwendig sind. Spezielle Druckleistungen, wie 
z.B. verschiedenartige Schrifttypen, können nur auf besonderen Druckern er- 
zeugt werden. Verfügt ein Drucker nicht über eine bestimmte Hardware-Eigen- 
schaft, wird die vom Benutzer geforderte Leistung ignoriert. Somit ist es 
möglich, Probedrucke für Korrekturen auch auf preiswerten Druckern herzu- 
stellen. 
 
Merke: Der EUMEL-Editor übernimmt die Texterstellung; 'lineform' formatiert 
zeilenweise; 'pageform' formatiert seitenweise; 'index' erstellt Stich- und 
Inhaltsverzeichnisse; der EUMEL-Drucker ist eine Software-Anpassung an 
unterschiedliche Ausgabe-Geräte. 
 
 
 
Anweisungen für die Textkosmetik und den Drucker 
 
In diesem Abschnitt wird beschrieben, wie Anweisungen für die Textkosmetik- 
Programme in einen Text eingefügt werden. 
 
Die Ausführung von 'lineform', 'pageform', 'index' und EUMEL-Drucker wird 
mit Hilfe von Anweisungen gesteuert, die man in den Text an geeigneter 
Stelle einfügt. Anweisungen haben die Form 
 
    #kommando# 
 
Beachte, daß jede Anweisung von #-Zeichen eingeschlossen sein muß, damit 
die Anweisung vom eigentlichen Text unterschieden werden kann. Beispiele: 
 
    #page#   (* aber auch z.B.: # page   # *) 
    #free (3.0)# 
    #type ("elitedeutsch")# 
 
Das "#"-Zeichen darf nur für Anweisungen verwandt werden, also sonst nicht 
im Text vorkommen. (Wird das "#"-Zeichen benötigt, muß das Zeichen mit ESC # 
geschrieben werden. Vergl. auch die Tastenbelegung in der Editor-Beschrei- 
bung). 
 
Die von '#'-Zeichen eingeschlossenen Anweisungen sind so konstruiert, daß 
sie - wie alle anderen Kommandos im EUMEL-System auch - der ELAN-Syntax 
entsprechen (u.a. müssen sie klein geschrieben werden; Parameter in runden 
Klammern; mehrere Parameter werden durch Kommata getrennt; TEXT-Parameter 
in Anführungsstrichen; REAL-Parameter mit Dezimalpunkt usw.). Leerzeichen 
spielen (außer in TEXT-Parametern) keine Rolle und können zur besseren Les- 
barkeit beliebig verwandt werden. 
 
Man beachte den Unterschied zwischen einer Anweisung und einem Kommando: 
während es nur eine beschränkte Anzahl von Anweisungen gibt, die nur von den 
Textkosmetik-Programmen ausgeführt werden (also sonst nicht in Programmen 
oder Monitor benutzt werden können), kann ein Benutzer ein Kommando in der 
Regel in einem Programm, im Editor oder im Monitor verwenden. Hinzu kommt, 
daß neben dem vom EUMEL-System zur Verfügung gestellten Kommandos in der 
Regel noch installationsspezifische und/oder benutzereigene Kommandos gibt. 
 
Anweisungen dürfen im allgemeinen überall auf einer Zeile stehen (wie z.B. 
in der nächsten Zeile). #on("underline")#Ausnahmen#off("underline")# werden 
bei der Beschreibung der Anweisungen speziell erwähnt. Alle Anweisungen 
werden zum frühest möglichen Zeitpunkt ausgeführt, haben also u.U. bereits 
Auswirkungen auf die Zeile, in der sie stehen. 
 
Die Zeichen, aus denen eine Anweisung besteht, werden bei der Formatierung 
einer Zeile oder Seite nicht mitgezählt und vom EUMEL-Drucker nicht gedruckt. 
Eine Zeile, die nur aus Anweisungen besteht, wird ebenso behandelt. 
 
Merke: Anweisungen steuern die Verarbeitung der Textkosmetik-Programme. Sie 
müssen in '#'-Zeichen eingeschlossen sein und dürfen in der Regel überall 
auf einer Zeile stehen. Sie werden an der Stelle ausgeführt, an der sie 
stehen. 
 
 
 
Aufruf der Textkosmetik-Programme 
 
In diesem Abschnitt wird beschrieben, wie die Textkosmetik-Programme 
aktiviert werden. 
 
Die Textkosmetik-Programme werden durch Kommandos aktiviert (d.h. in der 
'gib kommando:'-Ebene). Die Aktivierung (Fachausdruck: "Aufruf") erfolgt - 
ebenso wie beim Editor - durch den Namen des Programms und die Angabe 
der Datei. Beispiele: 
 
   autoform ("meine datei") 
   lineform ("text1"); 
   pageform ("1. Kapitel") 
   index    ("Buch.p") 
 
Das Programm 'pageform' erzeugt aus der Eingabedatei eine Druckdatei, die 
entsprechend umgeformt wird (Fußnoten werden an die richtige Stelle plaziert, 
Seitenummern eingesetzt u.a.m.). Diese Druckdatei bekommt den Namen der 
angegebenen Eingabedatei mit dem Zusatz '.p'. Beispiel: 'pageform ("text")' 
erzeugt eine Datei 'text.p'. Es ist auch erlaubt, 'pageform' durch die Angabe 
eines zweiten Parameters mitzuteilen, wie die Druckdatei heißen soll: 
 
   pageform ("mein text", "erste Druckdatei") 
 
Ähnlich verhält es sich mit dem Programm 'index', welches bis zu 9 Stichwort- 
bzw. Inhaltsverzeichnisse erstellen kann. Da in den Verzeichnissen die 
Seitennummern aufgeführt werden, kann 'index' nur Druckdateien bearbeiten. 
Beispiel: 
 
   index ("handbuch.p") 
 
Das Programm 'index' erstellt die angeforderten Verzeichnisse in Dateien, 
die mit dem Zusatz '.i<nummer>' gekennzeichnet werden. Beispiele (für den 
obigen Aufruf): 
 
   'Handbuch.i1', 'Handbuch.i2' 
 
usw.. 
 
Merke: Die Textkosmetik-Programme werden durch Kommandos aufgerufen mit der 
Angabe der Dateinamen als Parameter. 
 
 
 
Vorzeitiger Abbruch und Fehlermeldungen 
 
Alle Textkosmetik-Programme können vorzeitig vom Benutzer abgebrochen werden. 
Eventuelle Fehlermeldungen werden durch den Paralleleditor angezeigt. 
 
Durch die Taste SV und das Supervisor-Kommando 'halt' können die Textkosme- 
tik-Programme jederzeit vorzeitig abgebrochen werden. Die Eingabedatei steht 
dann unverändert zur Verfügung. Ein vorzeitiger Abbruch kann notwendig sein, 
wenn ein Programm mit einer falschen Datei aufgerufen wurde oder zu viele 
Fehler gemeldet wurden. 
 
Alle Textkosmetik-Programme melden Fehler, wenn eine oder mehrere Anweisun- 
gen falsch benutzt werden. Die Fehlermeldungen werden auf dem Bildschirm 
angezeigt. Bei Beendigung eines Programms wird - falls Fehler entdeckt 
wurden - die Fehlermeldungen im oberen Fenster des Paralleleditors angezeigt, 
während im unteren Fenster die Eingabedatei zur Korrektur angeboten wird. 
 
Merke: Vorzeitiger Abbruch eines Programms durch SV und 'halt'. (Die Eingabe- 
datei steht unverändert zur Verfügung.) Fehlermeldungen werden im Parallel- 
editor angezeigt. 
 
 
 
2. Zeilenweises formatieren: 'autoform/lineform' 
 
Die Programme 'autoform' oder 'lineform' formatieren einen Text zeilenweise 
(ggf. mit Silbentrennung), unter Berücksichtigung von Schrifttyp und Zeilen- 
breite. 
 
 
 
Eine Datei formatieren: 'autoform/lineform'-Kommando 
 
Die Programme 'lineform/autoform' werden unter Angabe der Datei aufgerufen. 
Beispiel: 
 
     lineform ("meine datei") 
     autoform ("Brief vom 24.12.") 
 
 
 
Unterschied von 'autoform' und 'lineform' 
 
Zur Zeilenformatierung werden zwei Programme angeboten, die sich nur in der 
Art der Behandlung von Silbentrennungen unterscheiden: 
 
a) autoform: 
   Zeilenformatierung mit automatischer Silbentrennung. 'autoform' sollte 
   nur bei deutschen Texten eingesetzt werden, weil die Silbentrennung bei 
   fremdsprachigen Texten nach anderen Regeln erfolgen muß. 
 
b) lineform: 
   Zeilenformatierung mit Silbentrennung "per Hand", wobei (nach deutschen 
   Trennregeln) ein sinnvoller Trennvorschlag gemacht wird. Die Trennstelle 
   kann interaktiv soweit verschoben werden, wie das zu trennende Wort noch 
   auf die Zeile paßt. 
 
Merke: 'autoform' nimmt eine automatische Silbentrennung vor, während 
'lineform' die #ib#Silbentrennung "per Hand"#ie# erlaubt.  
 
 
 
Übersicht über 'autoform'/'lineform' 
 
'autoform'/'lineform' formatieren eine Datei zeilenweise. Dabei werden 
Zeilen möglichst vollständig aufgefüllt. 
 
'autoform'/'lineform' haben im wesentlichen vier Aufgaben: 
 
a) Auffüllen von Zeilen: 
   'autoform'/'lineform' können besonders gut nach Korrekturen eingesetzt 
   werden, bei denen - nach Einfügungen oder Löschungen - nicht vollstän- 
   dige oder zu lange Zeilen in der Datei stehen bleiben können. 
 
b) Erstellen von Zeilen mit unterschiedlichen Schrifttypen: 
   Werden in einer Datei mehrere Schriftarten ('type'-Anweisung) verwandt, 
   berechnen 'autoform'/'lineform' nach der eingestellten Zeilenbreite die 
   Anzahl Zeichen, die auf eine Zeile passen. 
 
c) Erstellen von unterschiedlichen Zeilenlängen: 
   Manchmal ist es notwendig, die Breite von Zeilen zu verändern ('limit'- 
   Anweisung). Dies wird von 'autoform'/'lineform' berücksichtigt. 
 
d) Silbentrennung: 
   Automatische ('autoform') und interaktive Silbentrennung ('lineform'). 
   Sofern notwendig, werden Silbentrennungen rückgängig gemacht. 
 
'autoform'/'lineform' beachten nur wenige Anweisungen: 
 
Anweisung        Zweck 
 
     limit       Zeilenbreite einstellen 
     off         Schrifttyp-Modifikation ausstellen 
     on          Schrifttyp-Modifikation einstellen 
     type        Schrifttyp einstellen 
 
 
'autoform'/'lineform' akzeptieren als Eingabe eine Datei und verändern diese. 
Dafür wird eine (interne) Zwischendatei benötigt. Deshalb ist darauf zu 
achten, daß noch ausreichend Platz auf dem System ist, der jedoch nur 
zwischenzeitig für den Formatierungsschritt benötigt wird. 
 
'autoform'/'lineform' fragen nach ihrem Aufruf an, auf welche Zeilenbreiten 
und mit welchem Schrifttyp die Datei formatiert werden soll. Diese Informa- 
ionen werden von 'autoform'/'lineform' in Form von 'limit'- und 'type'-An- 
weisungen in der Datei vermerkt, so daß die Anfragen bei weiteren Datei- 
Bearbeitungen entfallen. 
 
Bei Zeilen, die länger als die angegebene Zeilenbreite sind, werden die- 
jenigen Worte, die über die Zeilenbreite hinausgehen, in die nächste Zeile 
umgebrochen. Kürzere Zeilen werden aus der nachfolgenden Zeile bis zur 
Zeilenbreite aufgefüllt. Worte werden jedoch nicht über Absatzgrenzen hinweg 
verschoben. Deshalb ist vor Anwendung von 'lineform' darauf zu achten, daß 
Absätze richtig markiert wurden. Fehlende Markierungen sollte man nachträg- 
lich einfügen (RETURN am Ende einer Zeile), andernfalls werden Zeilen über 
Absatzgrenzen zusammen gezogen. Dies gilt insbesondere für Tabellenzeilen. 
 
Einrückungen (Leerzeichen am Anfang einer Zeile) werden von 'autoform'/'line- 
form' ebenfalls bei der Formatierung von Zeilen eingehalten. 
Dabei behandelt die Prozedur 'autoform'/'lineform' Einrückungen in einem 
speziellen Fall nicht so, wie ein Benutzer es erwarten würde. Bei ein- 
zeiligen Absätzen wird - falls die Zeile länger als das eingestellte Limit 
ist und der "überschüssige" Teil in eine neue Zeile umgebrochen werden muß 
- die Einrückung der aktuellen Zeile beibehalten. Das ist meist das 
"richtige" Verhalten, während es bei Aufzählungen falsch ist, weil die 
zweite Zeile einer Aufzählung oft eingerückt wird. Beispiel: 
 
          - Diese Zeile war zu lang und wurde unter 
          das "-"-Zeichen umgebrochen. 
 
Man sollte daher - nach Verarbeitungsende - die Datei nach solchen Fällen 
durchsuchen. 
 
Merke: 'autoform'/'lineform' vervollständigen zu kurze Zeilen oder brechen 
zu lange Zeilen um. Dabei werden Absätze beachtet. 
 
 
 
Interaktive Silbentrennung mit 'lineform' 
 
'lineform' trennt Silben interaktiv. 'lineform' sollte deshalb für fremd- 
sprachige Texte angewandt werden. 
 
Paßt ein Wort nicht mehr ganz auf eine Zeile, dann wird dieses Wort inter- 
aktiv zur Trennung angeboten. Die Umgebung dieses Wortes wird zur Er- 
leichterung des Trennvorgangs mit angezeigt. Das Trennzeichen erscheint an 
einer sinnvollen Stelle im zu trennenden Wort. Beispiel: 
 
       Text vor dem Trennwort; das 
       Trenn-wort steht mit nachfolgendem Text in dieser Zeile 
 
Der Benutzer hat die Möglichkeit, das Trennzeichen mit Hilfe der Positionie- 
rungstasten innerhalb des "Trennbereichs" (das ist der markierte Bereich, der 
noch auf die Zeile passen würde), zu verschieben. An der gewünschten Trenn- 
position (der Wortteil, der noch auf die Zeile kommen soll, steht links vom 
Trennstrich) kann die RETURN-Taste betätigt werden. RETURN zeigt dem Pro- 
gramm 'lineform' an, daß an dieser Stelle die Trennung erfolgen soll. 'line- 
form' fügt an den ersten Teil des Wortes das "-"-Zeichen an und schreibt den 
abgetrennten Wortteil in die nächste Zeile. 
Hinweis: Das Trennzeichen "-" hat einen anderen Code als der "normale" 
Bindestrich (vergl. dazu die Codetabelle), da Trennungen ggf. bei erneuten 
Änderungen wieder rückgängig gemacht werden müssen. 
 
Es stehen folgende Operationen bei der interaktiven Trennung zur Verfügung: 
 
     Taste      Bedeutung 
 
     RETURN        Trennen. 
     LINKS         Trennstelle um ein Zeichen nach links verschieben. 
     RECHTS        Trennstelle um ein Zeichen nach rechts verschieben. 
     HOP LINKS     Trennstelle vor das Wort setzen (das Wort wird an dieser 
                   Position nicht getrennt). 
     HOP RECHTS    Trennstelle in die ursprüngliche Position setzen. 
     BLANK         Trennzeichen wird von "-" auf " " umgeschaltet. 
                   Dies kann verwandt werden, um Worte, die nicht zusammen 
                   geschrieben werden sollen, beim Trennvorgang in zwei 
                   Worte aufzuspalten. 
     -             Schaltet das Trennzeichen von Leerzeichen (" ") wieder auf 
                   den Trennstrich ("-") um. 
 
Zwei Sonderbedingungen sind bei der interaktiven Trennung noch zu beachten: 
 
 - Bei Worten mit Bindestrich wird die Trennstelle hinter dem Bindestrich als 
   Leerzeichen angezeigt. Die Trennstelle vor dem Bindestrich wird bei 
   weiterem Positionieren nach links übersprungen. Das verhindert, daß Worte 
   mit führendem Bindestrich im Text erscheinen. 
 
 - Bei einer Trennposition zwischen den Zeichen "ck" wird das Zeichen "c" in 
   ein "k" umgewandelt. Beispiel: 
 
     Druk-ker                 
Hinweis: Das umgewandelte "k" hat einen anderen Code als das "normale" 
"k" (vergl. dazu die Codetabelle). Das ist notwendig, um bei späteren 
Änderungen solche Trennungen wieder rückgängig machen zu können. 
 
Sofern für die Zeilenformatierung notwendig, macht die Prozedur 'lineform' 
bereits erfolgte Trennungen rückgängig (das Trennzeichen wird entfernt und 
die Wortteile wieder zusammengefügt), wenn sich das getrennte Wort nicht mehr 
am Zeilenende (etwa durch Korrekturen oder Veränderungen der Zeilenbreite) 
befinden sollte. 
 
Merke: 'lineform' bietet Worte zur Silbentrennung an. Die "Trennstelle" kann 
durch den Nutzer verschoben werden. 
 
 
 
Automatische Silbentrennung mit 'autoform' 
 
'autoform' arbeitet wie 'lineform', nur werden die Silbentrennungen auto- 
matisch vorgenommen. 
 
Ist eine Silbentrennung bei der Formatierung notwendig, übernimmt 'autoform' 
diese automatisch und gibt diese zur Kontrolle auf dem Bildschirm aus. Die 
automatische Silbentrennung arbeitet mit einer hohen Trenngüte; allerdings 
nur für deutsche Texte. Trotzdem kann es vorkommen, daß einige Trennungen 
(insbesondere bei Fremdworten) falsch vorgenommen werden. In diesem Fall 
muß man diese nachträglich mit dem Editor korrigieren. Dabei sollte man das 
oben erwähnte Trennzeichen verwenden (ESC -). 
 
 
Wenige oder viele Silbentrennungen: Trennpunkt einstellen 
 
Viele Silbentrennungen in einem Text erschweren das Lesen. Würde man nun 
keine Silbentrennungen vornehmen, wird der rechte Rand stark "ausgefranst" 
oder beim Blocksatz ("rechter Randausgleich") müssen viele Zwischenräume 
zwischen den Worten eingefügt werden. Durch das Kommando 
 
     hyphenation width (prozentuale angabe) 
 
kann der Trennpunkt, ab dem die Silbentrennung einsetzen soll, eingestellt 
werden. Die Angabe erfolgt in Prozenten der Zeilenbreite. Beispielsweise 
stellt 'hyphenation width (5)' den Trennpunkt auf 5% der Zeilenbreite ein 
(Voreingestellt ist 7). Bei einer Angabe von 20 werden sehr wenige Worte zur 
Silbentrennung angeboten, während bei einer Angabe von '3' ungefähr jede 
dritte Zeile eine Silbentrennung versucht wird. Die Einstellung des Trenn- 
punktes bestimmt also, ab wann ein Wort zur Silbentrennung untersucht wird. 
Andererseits bestimmt die Einstellung auch, wieviel Zwischenraum zwischen 
Worten eingefügt werden muß, um einen rechten Randausgleich zu erzielen. 
 
Merke: 'hyphenation width' bestimmt, an welchem Punkt Worte zur Silbentren- 
nung angeboten werden. 
 
 
Mit unterschiedlichen Schriften schreiben: 'type' 
 
Unterschiedliche Schrifttypen#ie# werden mit der 'type'-Anweisung ange- 
fordert. 
 
Es ist möglich, mit 'lineform' verschiedenartige Schrifttypen (kurz Typen 
genannt) verarbeiten zu lassen. Jeder Typ hat - neben dem speziellen Aus- 
sehen der Zeichen - die Eigenschaft, daß jedes Zeichen eine bestimmte Breite 
und Höhe hat. 
 
Es gibt zwei Arten von Schriften: bei äquidistanten Schriften sind alle 
Zeichen gleich breit (wie bei einer "normalen" Schreibmaschine). Proportio- 
nalschrift findet man in gedruckten Büchern. Hier haben unterschiedliche 
Zeichen auch unterschiedliche Breiten. Die Zeichen ".", "i", "!" sind z.B. 
schmaler als die Zeichen "w", "o", "m" usw. 
 
Mit der Anweisung 
 
    type ("schriftname") 
 
kann auf einen anderen Schrifttyp umgeschaltet werden (auch mehrmals inner- 
halb einer Zeile). Dieser Typ gilt solange, bis wieder ein neue 'type'-An- 
weisung gegeben wird. Beispiel: 
 
   \#type("basker12")\#Jetzt schreiben wir in einer Schrift. Und jetzt 
   schalten wir um auf\#type ("modern12")\# noch eine andere Schrift. 
 
Welche Schriftarten zur Verfügung stehen, hängt natürlich von dem verfügbaren 
Drucker ab. Sie können die Schrifttypen bei Ihrer EUMEL-Installation er- 
fragen.   
Schrifttypen können modifiziert gedruckt werden (vergl. dazu den nächsten Ab- 
schnitt). Durch die Angabe einer 'type'-Anweisung werden alle Modifikationen 
ausgeschaltet. 
 
Merke: Eine 'type'-Anweisung gibt einen gewünschten Schrifttyp an. 
 
 
 
Kursiv, fett, unterstrichen, revers drucken: 'on/off' 
 
Mit der 'on'- und 'off'-Anweisung ist es möglich, einen Schrifttyp zu modi-f 
izieren. Die Schrift wird zwar nicht gewechselt, aber verändert gedruckt. 
Zur Zeit ist unterstrichen, fett, kursiv und der Druck von weiß auf schwarz 
möglich (abhängig vom eingesetzten Drucker). 
 
Die 'on'/'off'-Anweisung wirkt wie ein Schalter, der die gewünschte Schrift- 
typ-Modifikation ein- bzw. ausschaltet. Beispiel: 
 
... Das EUMEL-System ermöglicht es, 
\#on("italic")\#kursiv\#off("italic")\# 
und 
\#on("underline")\#unterstrichen\#off("underline")\# 
und 
\#on("bold")\#fett\#off("bold")\# 
und 
\#on("revers")\#revers\#off("revers")\# 
zu schreiben. 
 
Die Anweisung 'on' schaltet die Modifikation ein, 'off' schaltet sie aus. 
Folgende Modifikationen sind z.Zt. implementiert: 
 
     bold         (Fettdruck) 
     italic       (Kursivdruck) 
     underline    (Unterstreichung) 
     revers       (Weiß auf Schwarz) 
 
Dabei ist folgendes zu beachten: 
 
a) Ein 'type'-Anweisung schaltet eine Modifikation immer aus. 
 
b) Eine Modifikation sollte nicht über einen Absatz gehen ('lineform' er- 
   zeugt eine Warnung). Somit ist es gewährleistet, daß das Ausschalten 
   einer Modifikation nicht vergessen wird. 
 
c) Nicht alle Drucker können die hier angegebenen Modifikationen auch 
   drucken. Bitte erkundigen Sie sich bei Ihrer Installation. 
 
d) Welche Modifikationen gleichzeitig eingeschaltet werden können, ist 
   ebenfalls druckerabhängig. 
 
Merke: Die Anweisungen 'on' und 'off' schalten eine Modifikation an- und aus. 
 
 
 
Gesperrt schreiben 
 
Wird ein Wort g e s p e r r t geschrieben, muß natürlich verhindert werden, 
daß dieses Wort beim Formatieren getrennt wird. Andere Worte, wie z.B. in 
Formeln, sollten ebenfalls zusammen auf eine Zeile geschrieben werden (z.B. 
'sin (x)'). 
 
Dies kann man erreichen, indem man nicht das Leerzeichen zwischen die Zeichen 
schreibt, denn das Leerzeichen bedeutet für 'autoform'/'lineform' immer das 
Ende eines Wortes. Man nimmt stattdessen ESC blank. ESC blank erscheint auf 
dem Bildschirm zur besseren Identifizierung als Unterstreichungsstrich (oder 
invers:  ) Beim Drucken wird jedoch wieder ein Leerzeichen produziert. 
Beispiel: 
 
     g_e_s_p_e_r_r_t     (auf dem Terminal) 
     g e s p e r r t     (auf Papier) 
 
Wir nennen dieses Leerzeichen auch "geschütztes Leerzeichen". 
 
Merke: G e s p e r r t wird mit dem geschützten Leerzeichen geschrieben. 
 
 
 
Tabellen und Aufzählungen schreiben 
 
Aufzählungen und Tabellen werden automatisch richtig formatiert und gedruckt, 
wenn man sich an einige einfache Regeln hält. 
 
Verwendet man eine Proportionalschrift beim Tabellenschreiben, so sind die 
Spalten in der Regel unterschiedlich breit, selbst wenn eine gleiche Anzahl 
Zeichen in jeder Spalte geschrieben wird. Dies kann man durch das Schreiben 
von einem "Doppelblank" vermeiden. Beispiel: 
 
    nnnnn | zweite Spalte 
    mmmmm | steht nicht untereinander 
 
aber mit Doppelblank: 
 
     nnnn   |  zweite Spalte 
     mmmm   |  stehen jetzt untereinander 
 
Das Doppelblank dient 'lineform/autoform' und dem Drucker als Zeichen, daß 
die Positionen speziell berechnet ('lineform') und beim Druck berücksichtigt 
werden müssen. In seltenen Fällen (insbesondere beim Einsatz von Schriftypen, 
die in der Größe stark voneinander abweichen) kann es vorkommen, daß diese 
Tabellenautomatik nicht funktioniert und Spalten übereinander gedruckt 
werden. In solchen Fällen muß man die Anzahl der trennenden Doppelblanks 
erhöhen.  
 
Praktischer Tip: 
Beachte, daß für das Funktionieren der "Tabellenautomatik" bei proportionalen 
Schriften es erforderlich ist, das jede Tabellenzeile eine Absatzzeile ist. 
Man sollte diese Zeilen vor dem Druck daraufhin überprüfen oder durch 'line- 
form/autoform' die Datei bearbeiten lassen. Sollte durch die zeilenweise 
Formatierung einmal zwei Zeilen zusammengezogen sein (wegen fehlender Absatz- 
kennzeichnung), kann man diese leicht mit dem Editor wieder "auseinander- 
brechen" (zweimaliges HOP RUBIN). 
 
Ähnliches gilt bei Aufzählungen. Beispiel: 
 
   1) Das ist die erste Aufzählung. 
      Dieser Satz wird bündig gedruckt. 
   2) Hier auch. 
 
Auch in solchen Fällen wird der gedruckte Text in der Regel richtig einge- 
rückt. Die Aufzählungsautomatik wirkt nur nach einem Absatz und bei Propor- 
tionalschriften. Die Regeln sind etwas kompliziert, so daß sie hier nicht 
einzeln aufgeführt werden (siehe S. #topage("block")# unter dem Kommando 
'block'). Trifft man auf einen der seltenen Fälle, wo die Einrückungsautoma- 
tik nicht funktioniert, kann man immer das Doppelblank der Tabellenautomatik 
verwenden. 
 
Merke: Die Tabellen- und die Aufzählungsautomatik sorgen dafür, daß Tabellen- 
spalten und Aufzählungen bündig gedruckt werden. 
 
 
 
Zeilenbreite einstellen: 'limit' 
 
Mit der 'limit'-Anweisung kann die Zeilenbreite eingestellt werden. 
 
Die 'limit'-Anweisung gibt (in cm) an, wie breit die Zeile sein soll. Be- 
achte, daß die Angabe der Zeilenbreite nichts mit dem LIMIT-Kommando des 
Editors zu tun hat. Dieses gibt an, wieviel Zeichen einer äquidistanten 
Schrift beim Schreiben auf eine Bildschirmzeile passen sollen. 
 
Die Zeilenbreite wird zusammen mit dem Schrifttyp beim erstmaligen Aufruf von 
'autoform'/'lineform' interaktiv erfragt und als 'limit'-Anweisung (zusammen 
mit der 'type'-Anweisung) in die erste Zeile der Datei eingetragen. Es kann 
in einer Datei mehrmals verändert werden. Die Zeilenbreite gilt immer ab der 
Zeile, in der die 'limit'-Anweisung steht. Beispiel: 
 
            \#limit(10.0)\#Mit der 'limit'-Anwei­
            sung kann man Paragraphen in einem
            anderen Format leicht gestalten.
            Die rechte Schreibgrenze wird durch
            die 'limit'-Anweisung eingestellt,
            während der linke Rand durch eine
            entsprechende Einrückung gestaltet
            wird. \#limit(13.5)\# 
 
Man beachte, daß als Parameter in der 'limit'-Anweisung eine Zahl mit Dezi- 
malpunkt angegeben werden muß. 
 
Die folgende Tabelle gibt sinnvolle 'limit'-Einstellungen für die am 
häufigsten verwandten Papiergrößen an: 
 
 
       Format       'limit'           Verbleibender 
                  (Zeilenbreite)         Rand 
 
      DIN A4          16.0 cm          je 2.65 cm 
 
      DIN A5          12.0 cm          je 1.42 cm 
 
      DIN A4 quer     25.0 cm          je 2.35 cm 
 
Merke: Die 'limit'-Anweisung stellt die Zeilenbreite in cm ein, während das 
'LIMIT'-Kommando des Editors die Zeilenbreite in Anzahl Zeichen angibt. 
 
 
 
3. Seitenweises formatieren: 'pageform' 
 
'pageform' formatiert eine Datei seitenweise, wobei Routinearbeiten, wie 
etwa die Plazierung von Fußnoten, Seitennummerierung usw. ebenfalls von 
'pageform' erledigt werden. 
 
 
 
Eine Datei in Seiten teilen: 'pageform'-Kommando 
 
Das Programm 'pageform' wird mit dem Kommando 
 
     pageform ("Buch") 
 
aufgerufen. 'pageform' erzeugt aus der Eingabedatei (hier: 'Buch') eine 
Druckdatei, deren Name durch ein angehängtes '.p' gebildet wird (in unserem 
Beispiel: 'Buch.p'). 
 
 
Übersicht über die Arbeitsweise von 'pageform' 
 
'pageform' erzeugt aus einer Eingabedatei eine Druckdatei, wobei z.B. Fuß- 
noten und Seitennummern an den richtigen Stellen eingefügt werden. 
 
'pageform' akzeptiert als Eingabe eine Datei und produziert eine neue Datei, 
die "Druckdatei". Die Druckdatei besteht aus der Eingabedatei mit ggf. neu 
eingefügten Zeilen. Die eingesetzten Zeilen stammen aus 'head'-, 'bottom' 
oder 'footnote'-Anweisungen. Dadurch erhöht sich die Zeilenanzahl der Datei 
(bis zu 15%). 
 
Durch 'pageform' ist es möglich, am Anfang und am Ende jeder Seite Zeilen 
einfügen zu lassen. Solche Textzeilen aus Kopf- bzw. Fußbereichen sowie 
Zeilen aus Fußnoten werden in der Druckdatei in jede Seite an entsprechender 
Stelle eingefügt. 
 
Es ist möglich, in Kopf- oder Fußzeilen Seitennummern aufzunehmen. Diese Sei- 
tennummern werden von 'pageform' bei Seitenwechseln automatisch erhöht und
an eine vom Benutzer gekennzeichnete Stelle eingesetzt. Fußnoten können auch 
durch Nummern gekennzeichnet werden. Querverweise sind ebenfalls möglich. 
 
'pageform' berechnet die Anzahl von Zeilen, die auf eine Seite passen sollen, 
aus den Angaben für die Seitenlänge, eingestellten Zeilenvorschub und even- 
tuelle Kopf-, Fuß- und Fußnotenzeilen. Bei der Berechnung wird von der je- 
weiligen Schrifthöhe des eingestellten Schriftyps ('type'-Anweisung) ausge- 
gangen. Dann zeigt 'pageform' das errechnete Seitenende auf dem Bildschirm 
an. Das Seitenende kann interaktiv verschoben werden, um es an eine ge- 
wünschte Stellen zu plazieren oder es können Leerzeilen eingefügt/gelöscht 
werden, um Seiten gleich lang zu machen. Zusätzlich ist es auch möglich, 
Seiten in Spalten ("Zeitungsdruck") aufzuteilen und diese interaktiv zu 
formatieren. 
 
     Anweisungs-Übersicht 
 
     bottom           Fußzeilen                     *) 
     bottomeven          "                          *) 
     bottomodd           "                          *) 
     columns          Spaltenformatieren 
     columnsend       Spalten ausschalten 
     count            Zähler erhöhen und einsetzen 
     end              Beendet 'head', 'bottom' und  *) 
                      'foot'-Bereiche 
     foot             Fußnote                       *) 
     free             Zeilen freilassen             *) 
     goalpage         Seitenverweis (Ziel) 
     head             Kopfzeilen                    *) 
     headeven            "                          *) 
     headodd             "                          *) 
     linefeed         Zeilenabstand                 *) 
     page             Neue Seite anfangen           *) 
     pagelength       Seitenlänge setzen 
     pagenr           Seitennummer bzw. -zeichen 
     setcount         Zähler setzen 
     topage           Seitenverweis (Ursprung) 
     value            Wert des Zählers einsetzen 
 
*) Diese Anweisungen dürfen nur allein oder als letztes auf einer Zeile stehen. 
 
 
Merke: 'pageform' erlaubt nicht nur eine Seitenformatierung, sondern auch 
Spaltenformatierung, Fußnoten-Plazierung, Kopf- und/oder Fußzeilen, Seiten- 
numerierung und Querverweise. 'pageform' erzeugt eine neue Datei, die 
"Druckdatei" mit dem Namen der Eingabedatei, an den ".p" angefügt wird. 
 
 
 
Seitenende interaktiv verschieben#ie# mit 'pageform' 
 
In diesem Abschnitt wird beschrieben, welche interaktiven Möglichkeiten 
'pageform' bietet, um Seiten zu gestalten. 
 
Auf dem Bildschirm wird das von 'pageform' errechnete jeweilige Seitenende 
unter Angabe der aktuellen Seitennummer angezeigt. Das Seitenende erscheint 
ungefähr in der Mitte des Bildschirmes und wird durch eine von 'pageform' ge- 
kennzeichnete Zeile markiert, die auch - nach erfolgter Seitenformatierung - 
in der Druckdatei zu sehen ist. (Der EUMEL-Drucker druckt diese Zeile nicht.) 
Beispiel: 
 
\#page\#\#--------------------- Ende Seite 1 ---\# 
 
Über der Markierung erscheinen die letzten Zeilen der bereits verarbeiteten 
Seite, darunter Zeilen der nächsten Seite. Es ist nun mit Hilfe der Positio- 
nierungstasten möglich, die Markierung und damit das Seitenende nach "oben 
zu verschieben". Somit kann vermieden werden, daß logisch zusammengehörender 
Text auseinandergerissen wird und z.B. "Waisenkinder"  entstehen (letzte 
Zeile eines Abschnittes kommt noch auf die neue Seite). 
 
Bei der interaktiven Seitenformatierung kann die Markierung nicht über das 
errechnete Ende einer Seite nach "unten" oder über das vorherige, bereits 
verarbeitete Seitenende nach "oben" verschoben werden. Die Markierung kann 
auch nicht in einen Fußnotenbereich plaziert werden, weil Fußnoten sinn- 
vollerweise nicht geteilt werden sollten. 
 
Entstehen Leerzeilen bei der Seitenformatierung am Anfang einer Seite (z.B. 
durch Plazierung des Seitenendes zwischen zwei Absätzen), so werden diese 
von 'pageform' automatisch aus der Druckdatei entfernt. Will man Leerzeilen 
am Anfang einer Seite#ie#, dann sollte das 'free' in Verbindung mit der 
'page'-Anweisung verwandt werden. 
 
Zusätzlich ist es möglich, Leerzeilen in eine Seite der Druckdatei einzu- 
fügen und/oder beliebige Zeilen zu löschen (vergl. b)). 
 
Folgende Operationen stehen bei der interaktiven Seitenformatierung zur 
Verfügung: 
 
a) Seitenende verschieben: 
 
'pageform' berechnet das "rechnerische" Seitenende und zeigt dieses auf dem 
Bildschirm durch die Markierung an. Die Markierung kann interaktiv verschoben 
werden: 
 
       Taste                  Bedeutung 
 
      RETURN          Seitenende an diese Stelle plazieren. 
      OBEN            Seitenende eine Zeile nach oben verschieben. 
      UNTEN           Seitenende eine Zeile nach unten verschieben 
                      (wenn vorher nach "oben" verschoben). 
      HOP OBEN        Seitenende um einen Bildschirm nach oben verschieben. 
      HOP UNTEN       Seitenende um einen Bildschirm nach unten verschieben. 
 
b) Leerzeilen einfügen und/oder Zeilen löschen 
 
Ergeben die Berechnungen von 'pageform', daß der bearbeitete Text nicht 
richtig auf der Seite plaziert ist, können in die Seite (der Druckdatei!) 
Leerzeilen eingefügt und/ oder Zeilen gelöscht werden. Dies kann beispiels- 
weise sinnvoll sein, wenn durch die Löschung einer Zeile ein Absatz noch auf 
die Seite passen würde oder durch die Einfügung von Leerzeilen ein Absatz 
auf der letzten Zeile der Seite endet. Oft ist es auch sinnvoll, daß alle 
Seiten gleich lang sind. In diesem Fall sollten vor Kapiteln und Absätzen 
Leerzeilen eingefügt oder gelöscht werden. 
 
Um Leerzeilen einzufügen und/oder Zeilen zu löschen, muß die Markierung (wie 
unter a) beschrieben) an die Stelle plaziert werden, an der die Änderung 
vorgenommen werden soll. Abschließend berechnet 'pageform' die Seite erneut. 
 
       Taste                  Bedeutung 
 
      HOP RUBIN       Leerzeilen einfügen. 
                      Anstatt der Markierung können durch (u.U. mehrmaliges) 
                      RETURN Leerzeilen eingefügt werden. HOP RUBIN beendet 
                      den Vorgang (wie Zeileneinfügen im Editor). 
 
      HOP RUBOUT      Zeile löschen. 
                      Die Zeile unmittelbar oberhalb der Markierung wird 
                      gelöscht. 
 
'page'-Anweisung bestätigen/löschen 
 
Wird von der Prozedur 'pageform' eine 'page'-Anweisung angetroffen, so wird 
das so gewünschte Seitenende auf dem Bildschirm des Benutzers angezeigt. Die 
'page'-Anweisung kann entweder bestätigt oder gelöscht werden. 
 
       Taste                  Bedeutung 
 
      RETURN          Seitenende bestätigen. 
 
      RUBOUT          'page'-Anweisung ignorieren. Die Prozedur 'pageform' 
                      bearbeitet in diesem Fall die Datei weiter, als ob 
                      keine 'page'-Anweisung angetroffen wurde. 
 
Merke: Ein Seitenende wird von 'pageform' auf dem Bildschirm angezeigt. Dies 
kann man mit den Positionierungstasten verschieben. Es können in die Seite 
Leerzeilen eingefügt oder Zeilen gelöscht werden. Eine 'page'-Anweisung kann 
man bestätigen oder löschen. 
 
 
 
Seitenlänge einstellen: 'pagelength' 
 
'pageform' ist auf eine Seitenlänge von 25.0 cm eingestellt (entspricht 
einem DINA4-Schreibfeld). Ist eine andere Seitenlänge erwünscht, muß die 
'pagelength'-Anweisung in den Text eingefügt werden. 
 
Beispiel: 
 
   \#pagelength (20.0)\# 
 
stellt die Seitenlänge auf 20 cm ein. Man beachte, daß der Dezimalpunkt bei 
der Seitenlänge mit angegeben werden muß. 
 
Die folgende Tabelle gibt die Seitenlänge für die am häufigsten gewählten 
Papiergrößen an: 
 
       Format     Seitenlänge       oberer und 
                   (in cm)          unterer Rand 
 
      DIN A4        25.0              je 2.35 cm 
 
      DIN A5        18.0              je 2.15 cm 
 
      DIN A4 quer   18.0              je 2.15 cm 
 
Merke: Mit der 'pagelength'-Anweisung kann die Seitenlänge (in cm) einge- 
tellt werden. 
 
 
 
Zeilenabstand einstellen: 'linefeed' 
 
Die 'linefeed'-Anweisung stellt einen Zeilenvorschub relativ zu der Schrift- 
höhe des eingestellten Schrifttyps ein. 
 
'pageform' berechnet die Anzahl Zeilen/Seite immer in Abhängigkeit vom einge- 
stellten Schrifttyp. Hat man z.B. eine Schrift gewählt, die doppelt so hoch 
wie z.B. eine Schreibmaschinenschrift ist, bekommt man auch entsprechend 
weniger Zeilen auf eine Seite. Um diesen Berechnungsvorgang braucht sich ein 
Nutzer in der Regel nicht zu kümmern. 
 
Anders verhält es sich, wenn ein anderer Zeilenvorschub als der "normale" 
Abstand zwischen Zeilen vorgenommen werden soll. In diesem Fall muß man wis- 
sen, daß die "Höhe" einer Zeile sich aus der Schrifttypgröße errechnet plus 
(ca.) 10%, welches den Abstand zwischen den Zeilen darstellt. 
 
Soll nun ein anderer Abstand eingestellt werden, wird die 'linefeed'-An- 
weisung eingesetzt. Der Parameter gibt an, um wieviel eine Zeilenhöhe erhöht 
oder verringert werden soll. Beispiel: 
 
   \#linefeed (2.0)\# 
 
Nach Antreffen dieser Anweisung wird die Zeilenhöhe durch 2 * eingestellte 
Schrifttypgröße errechnet. Es wird also der Zeilenabstand zwischen den Zeilen 
entsprechend vergrößert, da die Schriftgröße gleich bleibt. Dies entspricht 
dem zweizeiligen Schreiben bei einer Schreibmaschine (wenn man davon absieht, 
daß hier auch unterschiedliche Schrifthöhen berücksichtigt werden). Ein 
1 1/2 zeiliges Schreiben wäre mit 
 
   \#linefeed (1.5)\# 
 
einzustellen. 
 
   \#linefeed (0.5)\# 
 
stellt die Zeilenhöhe = 1/2 * eingestellte Schrifthöhe ein, so daß die Zeilen 
teilweise ineinander gedruckt werden. Bei 'linefeed (0.0)' werden Zeilen 
übereinander gedruckt (druckerabhängig). 
 
Man beachte, daß die Angabe in der 'linefeed'-Anweisung relativ erfolgt. Bei 
allen anderen Anweisungen der Textkosmetik werden Angabe in Zentimeter ver- 
langt. Die 'linefeed'-Anweisung bildet somit eine Ausnahme (von der Regel). 
 
Merke: Wieviel Zeilen auf eine Seite passen, ist von den Höhen der einge- 
stellten Schrifttypen abhängig. Diese Berechnung erfolgt automatisch durch 
'pageform'. Die 'linefeed'-Anweisung stellt einen Zeilenvorschub relativ zum 
eingestellten Schrifttyp ein. 
 
 
 
Platz freihalten: 'free' 
 
Mit der 'free'-Anweisung kann man einen zusammenhängenden Teil auf einer 
Seite freihalten. 
 
Die 'free'-Anweisung wird an solchen Stellen im Text eingesetzt, an denen - 
nach dem Druck - Zeichnungen, Tabellen und ähnliches eingeklebt werden sol- 
len. Es wird der in der 'free'-Anweisung angebene Platz freigehalten. Bei- 
spiel: 
 
\#free (2.0)\# 
hält zwei Zentimeter frei. Paßt der angeforderte Platz nicht mehr auf die 
Seite, so wird der angeforderte Platz auf der nächsten Seite reserviert 
('pageform' plaziert das Seitenende vor die 'free'-Anweisung). 
 
Merke: Die 'free'-Anweisung hält einen Platz auf dem Papier frei (Angabe in 
cm). 
 
 
 
Neue Seite beginnen: 'page' 
 
An einigen Stellen im Text, z.B. zu Beginn eines neuen Kapitels, soll unbe- 
ingt eine neue Seite angefangen werden. 
 
Dies erreicht - wie bereits erwähnt - man mit der 'page'-Anweisung. 'page- 
form' meldet im diesem Fall, nach wieviel cm auf der Seite die Anweisung an- 
getroffen wurde. Man kann nun mit RETURN das Seitenende bestätigen, oder die 
Anweisung (in der Druckdatei) löschen. Im letzteren Fall berechnet 'page- 
form' die Seite neu (als ob die 'page'-Anweisung nicht dagewesen wäre). 
 
Gleichzeitig ist es möglich, mit Hilfe der 'page'-Anweisungs eine neue Sei- 
tennummer#ie# für die neue Seite einzustellen (vergl. die nächsten Ab- 
chnitte). 
 
Merke: Die 'page'-Anweisung bewirkt eine neue Seite und muß beim Formatieren 
bestätigt werden. 
 
 
 
Kopf- und Fußzeilen: 'head/bottom' 
 
Mit den 'head'- und #ib#'bottom'-Anweisung#ie#en ist es möglich, Zeilen am 
Anfang und Ende jeder Seite einfügen zu lassen. 
 
Zeilen am Anfang ("Kopfzeilen") und Ende ("Fußzeilen") jeder Seite werden 
nur einmal geschrieben und mit Anweisungen gekennzeichnet. Diese Zeilen fügt 
'pageform' dann an den entsprechenden Stellen ein. Beispiel: 
 
\#head\# 
                Unser EUMEL-Benutzerhandbuch 
 
\#end\# 
 
Diese zwei Zeilen (also die zwischen den 'head'- und 'end'-Anweisungen ein- 
geschlossenen Zeilen) werden unverändert von 'pageform' an den Anfang jeder 
Seite in die Druckdatei plaziert. Man beachte, daß zweckmäßigerweise (minde- 
stens) eine Leerzeile nach einer solchen Kopfzeile in den 'head'-Bereich ein- 
gefügt werden sollte, um die Kopfzeile von dem eigentlichen Text der Seite zu 
trennen. 
 
Entsprechendes gilt für Fußzeilen, die zwischen 'bottom' und 'end' einge- 
chlossen werden müssen: 
 
\#bottom\# 
                   Autor: I. Listig 
\#end\# 
 
Praktischer Tip: Man füge nach einer Schriftzeile mindestens eine Leerzeile 
ein (in einem 'head') bzw. vor der Schriftzeile (in einem 'bottom'), um den 
eigentlichen Text von den Kopf- bzw. Fußzeilen abzuheben. 
 
'pageform' zählt die Seiten, beginnend mit der Seitennummer '1'. (Wie man 
Seitennummern in die Kopf- und Fußzeilen bekommt, verraten wir im nächsten 
Abschnitt). Es ist nun möglich, getrennte Kopf- und Fußzeilen für gerade und 
ungerade Seiten zu gestalten (wie in diesem Benutzerhandbuch). Dies erfolgt 
mit den Anweisungen 'headeven' und 'headodd' für Seiten mit geraden und un- 
geraden Seitennummern; ('bottomeven' und 'bottomodd' dito). 
 
Diese Anweisungen müssen ebenfalls jeweils mit einer 'end'-Anweisung be- 
endet werden. 
 
Es ist möglich, Kopf- und Fußzeilen mehrmals innerhalb einer Datei zu 
wechseln, um unterschiedliche Beschriftungen zu erhalten (z.B. kapitelweise). 
Dies ist jedoch nur sinnvoll, wenn dies auf einer neuen Seite erfolgt, also 
unmittelbar nach einer 'page'-Anweisung in den Text eingefügt wird. Beispiel: 
 
    \#page\# 
    \#head\# 
              Neuer Seiten Kopf 
 
    \#end\# 
 
"Fußzeilen" sollen überall gleiches Aussehen haben, unabhängig davon, welche 
Anweisungen im restlichen Text gegeben werden. Darum werden die bei der De- 
finition einer Fußzeile aktuellen Werte für 
 
  limit 
  type 
  linefeed 
 
bei dem Einsetzen der Zeilen berücksichtigt. Es ist somit erlaubt, einen 
anderen Schrifttyp (z.B. als der restliche Text) für Fußzeilen zu verwenden, 
indem die 'type'-Anweisung innerhalb des 'bottom'-Bereiches gegeben wird. 
Beachte, daß nach 'head'-, 'bottom' und auch 'foot'-Bereiche die o.a. Kom- 
mandos nicht automatisch zurückgestellt werden. Darum sollte vor der 'end'- 
Anweisung wieder auf den im übrigen Text verwandten Schrifttyp zurückge- 
stellt werden. Gleiches gilt für die 'limit'- und 'linefeed'-Anweisung. 
Beispiel: 
 
     \#bottom\# 
     \#type ("besonders schoen")\# 
                        Autor: I. Listig 
 
     (Schriftyp zurückstellen): \#type ("normal")\# \#end\# 
 
Merke: Kopf- und Fußzeilen können durch die Anweisungen 'head' bzw. 'bottom' 
oder 'headeven', 'headodd' bzw. 'bottomeven', 'bottomodd' definiert werden. 
Die Zeilen müssen jeweils durch die 'end'-Anweisung beendet werden. 
 
 
 
Seiten numerieren 
 
In den Kopf- und Fußzeilen steht das '%'-Zeichen für die aktuelle Seiten- 
nummer. 
 
Erscheint das '%'-Zeichen innerhalb eines Kopf- oder Fußbereiches, wird von 
'pageform' beim Einsetzen dieser Zeilen auf jeder Seite die aktuelle Seiten- 
nummer#ie# eingesetzt (sind mehrere '%'-Zeichen vorhanden, wird die Seiten- 
nummer mehrmals eingesetzt). Beispiel: 
 
\#head\# 
                 Seite: - % - 
 
\#end\# 
 
Durch einen Fußbereich kann man die Seitennummern auch am Ende einer Seite 
haben. Man beachte, daß sich bei mehrstelligen Seitennummern durch das Ein- 
setzen die Zeilenlänge vergrößert. 
 
Manchmal ist es notwendig und sinnvoll, einen Text in mehreren Dateien zu 
halten. Bei einer Folgedatei muß die Seitennummer dann neu gesetzt werden. 
Das erfolgt mit der 'page'-Anweisung. Beispiel: 
 
\#page (4)\# 
 
vollzieht eine neue Seite. Die Seitennummer der neuen Seite ist '4'. 
 
Bei einigen Spezialanwendungen benötigt man mehr als eine Seitennummer. 
Beispielsweise soll ein Text nicht nur absolut, sondern auch jede Seite in 
jedem Kapitel separat durchgezählt werden. Eine andere Anwendung ist die 
Benennung einer Folgeseite, wie in diesem Beispiel: 
 
\#page (4711)\# 
\#head\# 
               Mein Buch         Seite: % 
 
\#end\# 
\#pagenr ("$", 4712)\# 
\#bottom\# 
 
               Nächste Seite: $ 
\#end\# 
 
Durch die 'pagenr'-Anweisung gibt man ein neues "Seitenzeichen" (hier: '$') 
und den Anfangwert für diese Seitennummer (hier: '4712'), der ebenfalls wie 
das '%'-Seitenzeichen von 'pageform' bei jeder neuen Seite um '1' erhöht und 
ggf. in die Kopf- und Fußzeilen eingesetzt wird. Es sind zwei zusätzliche 
Seitenzeichen (neben dem '%') möglich. 
 
Merke: In den Kopf- und Fußzeilen wird ein '%'-Zeichen von 'pageform' durch 
die aktuelle Seitennummer ersetzt. Die Seitennummer kann durch das 'page'- 
Anweisung neu gesetzt werden. 
 
 
 
Fußnoten schreiben: 'foot' 
 
Fußnoten werden direkt im Text durch die Anweisungen 'foot' und 'end' ge- 
kennzeichnet. Die Fußnoten plaziert 'pageform' an das Ende einer Seite. 
 
Fußnoten werden vom Benutzer direkt in den Text geschrieben, am besten nach 
einem Absatz. Die Fußnote wird von 'pageform' an das Ende einer Seite, ggf. 
vor Fußzeilen plaziert. Für die Kennzeichnung von Fußnoten und die ent- 
sprechende Markierung im Text ist der Benutzer selbst zuständig. Allerdings 
wird von 'pageform' bei dem Einsetzen einer Fußnote am Ende einer Seite 
Unterstreichungsstriche vor die Fußnoten eingefügt, damit Fußnoten vom 
"normalen" Text abgehoben werden. 
 
\#foot\# 
*) Das ist die erste Anmerkung auf dieser Seite. 
\#end\# 
 
Mehrere Fußnoten innerhalb einer Seite werden von 'pageform' in der Reihen- 
folge ihres Auftretens gesammelt und am Ende der Seite plaziert. Für eine 
entsprechende Trennung der Fußnoten voneinander (z.B. durch Leerzeilen) hat 
der Benutzer selbst zu sorgen. 
 
Man sollte eine Fußnote unmittelbar hinter den Absatz schreiben, in der die 
Markierung für die Fußnote erscheint, denn u.U. paßt die Fußnote nicht mehr 
auf die aktuelle Seite und muß somit von 'pageform' auf die nächste Seite 
gebracht werden. 'pageform' geht davon aus, daß die Kennzeichnung der Fuß- 
note in der Zeile unmittelbar vor der Fußnote steht und bringt diese Zeile 
ebenfalls auf die neue Seite. 
 
Merke: Fußnoten werden direkt hinter einem Absatz in den Text mittels der 
Anweisungen 'foot' und 'end' geschrieben, die 'pageform' an das Ende der 
Seite einfügt. Die Kennzeichnung der Fußnoten hat der Benutzer selbst vorzu- 
nehmen oder man kann sie mit Hilfe von 'count'- und 'value'-Anweisungen 
durchnumerieren (siehe nächsten Abschnitt). 
 
 
 
Fußnoten numerieren: Zählen lassen 
 
Bei vielen Fußnoten in einem Text ist es nicht möglich, die Fußnoten beim 
Schreiben des Textes entsprechend zu beschriften. Für diesen Fall und um auf 
die Fußnote im Text nochmals Bezug nehmen zu können, bietet 'pageform' die 
Möglichkeit an, die Fußnoten zu numerieren. 
 
Durch die 'count'-Anweisung wird 'pageform' veranlaßt, einen internen Zähler 
(beginnend bei dem Wert 0) zu erhöhen und diesen Wert anstatt der 'count'- 
Anweisungen in den Text einzusetzen. Beispiel: 
 
\#count\# 
 
setzt den Wert 1 anstatt der Anweisung ein (Anmerkung: trifft 'lineform' auf 
eine 'count'-Anweisung, so wird die Zeile berechnet, als ob drei Ziffern 
anstatt der Anweisung ständen). Jede weitere 'count'-Anweisung erhöht den 
internen Zähler und der Zählerwert wird wiederum eingesetzt: 
 
\#count\# 
 
setzt den Wert 2 ein usw. Dadurch ist es möglich, beliebige Textteile 
(Kapitel, mathematische Sätze u.a.m.) fortlaufend zu numerieren, ohne auf 
die Numerierung beim Schreiben und Ändern des Textes zu achten. 
 
Mit der 'value'-Anweisung kann man den letzten erreichten count-Wert noch- 
mals einsetzen. Das ist insbesondere für Fußnoten sinnvoll einsetzbar. 
Beispiel: 
 
     Bla Bla Bla (\#count\#) 
     \#foot\# 
     Eine Fußnote 
     \#end\# 
     ... 
 
Das Resultat würde folgendermaßen aussehen: 
 
     Bla Bla Bla (3) 
     .... 
 
     _____ 
     (3) Eine Fußnote 
 
Man beachte, daß in diesem Fall die 'value'-Anweisung der 'count'-Anweisung 
folgen muß, ohne das eine weitere 'count'-Anweisung dazwischen steht. Das 
liegt - wie bereits erwähnt - daran, daß die 'value'-Anweisung immer den 
letzten 'count' Wert einsetzt. 
 
Das kann man umgehen, indem die 'count'- und 'value'-Anweisungen mit einem 
TEXT-Parameter versehen werden, der als Kennzeichnung dient. Beispiel: 
 
     \#count ("Merk1")\# 
 
arbeitet ebenso wie 'count' ohne Parameter (setzt also hier den Wert 4 ein), 
aber zusätzlich vermerkt 'pageform' den aktuellen Zählerwert neben dem Kenn- 
zeichen. Nun ist es mit der 'value'-Anweisung möglich, den vermerkten Zähler- 
wert durch Angabe des Kennzeichens an beliebigen Stellen im Text zu reprodu- 
zieren (auch wenn der interne Zähler weitergezählt wurde). Beispiel: 
 
     \#count\#\#count\# 
     \#value("Merk1")\# 
 
Die ersten zwei 'count'-Anweisungen produzieren - wie beschrieben - die 
Werte 5 bzw. 6. Die 'value'-Anweisung dagegen setzt den vermerkten Wert 4 
ein. 
 
Dies ist insbesondere sinnvoll, wenn man im Text auf eine Fußnote verweisen 
will. Beispiel: 
 
     Bla Bla. Siehe auch Anmerkung (\#value ("Waldschrat")\#). Bla 
     ... 
     ... 
     Bla Bla Bla (\#count ("Waldschrat")\#) 
     \#foot\# 
     (\#value ("Waldschrat")\#) Waldschrate kommen in vier Farben vor: 
                              Rot, schwarz, grün und blau/gelb. 
     \#end\# 
 
Manchmal ist es notwendig (ebenso wie bei der Seitennummer), den internen 
Zähler neu zu setzen. Beispiel: 
 
   \#setcount (13)\#\#count ("aha!")\# 
 
produziert den Wert 13. 
 
Merke: Die 'count'-Anweisung setzt einen internen Zähler in die Druckdatei 
ein. Durch die #ib#'value'-Anweisung#ie# werden gespeicherte Werte einge- 
setzt, was man bei Fußnoten ausnutzen kann. 
 
 
 
Querverweise mit 'topage'/'goalpage' 
 
Mit den Anweisungen 'topage' und 'goalpage' sind Querverweise möglich, die 
von 'pageform' in die Druckdatei eingefügt werden. 
 
Mit Hilfe von Querverweisen soll auf andere Stellen im Text verwiesen werden, 
was nur bei längeren Texten üblich ist. Um dem Leser die mühselige Suche 
nach der Textstelle zu ersparen, gibt man in der Regel die Seitennummer an. 
Leider steht die Seitennummer vor der Fertigstellung des Textes meist noch 
nicht fest. Auch in diesem Fall kann 'pageform' helfen. Die 'topage'- An- 
weisung verweist auf eine andere Seite im Text, an der sich eine Anweisung 
'goalpage' befinden muß. Anstatt der Anweisung 'topage' wird die Seitennum- 
mer der Seite eingesetzt, auf der sich 'goalpage' befindet. Damit jedes 
'topage' auch (sein) entsprechendes 'goalpage' findet, wird bei beiden An- 
weisungen ein TEXT-Parameter angegeben. Beispiel: 
 
   Man schreibt: ... siehe auch auf Seite \#topage("verweis1")\# 
   ... 
   Auf einer anderen Seite befindet sich \#goalpage("verweis1")\# 
 
Nach 'Seite' wird die entsprechende Seitennummer eingesetzt. 
 
Es ist möglich, mehrmals auf die gleiche (Ziel-) Seite zu verweisen, man muß 
nur darauf achten, daß immer das gleiche Merkmal (TEXT-Parameter) verwandt 
wird. 
 
Merke: Mit den 'topage'- und 'goalpage'-Anweisungen sind Seitenquerverweise 
möglich. Für 'topage' wird die Seitennummer eingesetzt, auf der 'goalpage' 
steht. 
 
 
 
Formatierung von Spalten: 'columns' 
 
Mit der 'columns'-Anweisung ist es möglich, einen Text in Spalten zu forma- 
tieren ("Zeitungsdruck"). 
 
Durch die Angabe der 'columns'-Anweisung wird 'pageform' aufgefordert, den 
Text in Spalten zu formatieren. Die Spaltenbreite muß der Benutzer mit der 
'limit'-Anweisung einstellen. Beispiel: 
 
   \#limit (18.0)\# 
   ... 
   \#columns (2, 2.0)\#\#limit (8.0)\# 
   ... 
 
Anfangs schreibt der Benutzer mit einer Zeilenbreite von 18 cm. Dann fordert 
er mit der 'columns'-Anweisung zweispaltigen Druck an (zwischen den Spalten 
soll 2 cm Abstand sein). Somit muß die 'limit'-Anweisung auf 8 cm einge- 
stellt werden. 
 
Die interaktive Spaltenformatierung wird von 'pageform' wie gewohnt vorgenom- 
men. Auf dem Bildschirm erscheint nun das Spaltenende, wobei die Nummer der 
Spalte angezeigt wird. Fußnoten werden spaltenweise eingeordnet und müssen 
somit die gleiche Zeilenbreite haben, wie die restlichen Spalten. 
 
'pageform' erzeugt in der Druckdatei die Spalten hintereinander. Das folgende 
Beispiel zeigt einen Ausschnitt aus der Druckdatei mit Kopf- und Fußzeilen 
bei einem zweispaltigen Druck: 
 
   head-Zeilen 
   xx 
   xx 
   xx 
   bottom-Zeilen 
   \#page\#\#------- Ende Seite 1 Spalte 1 ----\# 
   xx 
   xx 
   xx 
   \#page\#\#------- Ende Seite 1 Spalte 2 ----\# 
 
Die zweite Spalte erscheint also ohne Kopf- und Fußzeilen, die jedoch bei der 
Berechnung berücksichtigt werden. Man beachte, daß die Kopf- und Fußzeilen 
über die Spalten gehen können. Dies erreicht man durch geeignete 'limit'- 
Anweisungen in den genannten Bereichen. Hochwertige Drucker plazieren die 
zweite Spalte im Druckbild neben die erste. Bei preiswerteren Druckern muß 
man die Spalten nebeneinander kleben. 
 
Es ist zwar prinzipiell möglich, die Spalten in der Druckdatei nebeneinander 
zu schreiben. Jedoch hätte das Druckerprogramm Schwierigkeiten, diese neben- 
einander zu drucken, ohne daß z.B. ein Schrifttypwechsel in einer Spalte 
Auswirkungen auf eine Benachbarte hat. Praktischer Tip: Bei Druckern mit 
"Traktorführung" kann man erst alle ersten Spalten drucken, dann das Papier 
"von Hand" zurückdrehen und die zweiten Spalten drucken usw. 
 
Alle Anweisungen funktionieren beim spaltenweisen Formatieren wie üblich. Die 
'free'-Anweisung z.B. hält entsprechenden Platz in einer Spalte frei. Eine 
Ausnahme bildet die 'page'-Anweisung. Sie vollzieht hier ein Spaltenende. Die 
'page'-Anweisung mit einem Parameter (welcher die Seitennummer der nächsten 
Seite angibt), vollzieht dagegen ein Seitenende. 
 
Die 'columns end'-Anweisung beendet die spaltenweise Formatierung. Es ist 
zweckmäßig, unmittelbar vor der 'columns'- und hinter der 'columns end'- 
Anweisung eine 'page'-Anweisung zu schreiben. 
 
Überschriften (bzw. Textblöcke) über mehrere Spalten hinweg sind nur in der 
ersten Seite direkt hinter der 'columns'-Anweisung möglich. Beispiel: 
 
   \#page\# 
   \#limit (18.0)\# 
   HEAD 
   Breite Überschrift 
   \#columns (2, ...)\#\#limit (8.0)\# 
   XX 
   XX 
   XX 
   Bottom 
   \#page\#\#------- Ende Seite 1 Spalte 1 ----\# 
   XX 
   XX 
   XX 
   \#page\#\#------- Ende Seite 1 Spalte 2 ----\# 
 
Die Zeilen für die zweispaltige Überschrift werden berücksichtigt. Dies gilt 
jedoch nur unmittelbar hinter der 'columns'-Anweisung. Will man diesen Effekt 
nochmals haben, beendet man mit 'columns end', schreibt die 'page'-Anweisung, 
die breite Überschrift und schaltet die 'columns'-Anweisung wieder ein usw. 
 
Merke: Die Anweisungen 'columns'- und 'columns end' bewirken ein spalten- 
weises Formatieren des Textes durch 'pageform'. Die Spaltenbreite ('limit'- 
Anweisung) hat der Benutzer selbst einzustellen. 
 
 
 
4. Stichwortverzeichnisse erstellen: 'index'-Kommando 
 
Das Programm 'index' kann Stichwort- und Inhaltsverzeichnisse erstellen. 
Stichwortverzeichnisse#ie# können sortiert werden. Mehrere Stichwortver- 
zeichnisse können durch 'index merge' zusammengeführt werden. 
 
 
 
Übersicht über die Arbeitsweise von 'index' 
 
Durch den Aufruf von 
 
     index ("datei.p") 
 
werden durch Indexanweisungen gekennzeichnete Worte in Dateien, den soge- 
nannten Indexdateien, gespeichert. 
 
Anweisung                  Zweck 
 
  ib                   Anfang Index 
                       (folgende Worte werden bis zur 'ie'-Anweisung in den 
                       Index übernommen) 
  ie                   Ende eines Index 
 
Solche Verzeichnisse von Worten werden im EUMEL-System allgemein als Index 
bezeichnet. Nachdem eine oder mehrere Indexdateien aus einer Druckdatei 
erstellt sind, werden die Indexdateien auf Anfrage alphabetisch sortiert. 
Bei einem Inhaltsverzeichnis sollte man die Sortierung natürlich ablehnen. 
 
Nach der Sortierung werden gleiche Einträge automatisch zusammengefaßt und 
die entsprechenden Seitennummern nacheinander aufgeführt. 
 
Praktischer Tip: Will man nur eine Sortierung, aber keine Zusammenfassung 
von Einträgen, dann lehnt man die Sortieranfrage ab. Anschließend kann man 
die Indexdatei mit 'lex sort ("indexdatei namen")' sortieren. Hierbei 
bleiben gleiche Einträge erhalten. 
 
Das Programm 
 
     index merge ("index.i1", "index.i2") 
 
erlaubt es, zwei durch 'index' erzeugte Verzeichnisse zusammenzuführen. 
'index' kann ebenfalls benutzt werden, um ein Inhaltsverzeichnis und/oder 
ein Verzeichnis aller Abbildungen zu erstellen oder Literaturhinweise zu 
überprüfen. 
 
Die Worte, die durch 'index' in einen Index übernommen werden sollen, müssen 
in der Eingabedatei (der Druckdatei aus 'pageform') für 'index' durch An- 
weisungen gekennzeichnet werden. Die Form der Anweisungen entspricht der 
ELAN-Syntax (analog den Anweisungen für 'lineform', 'pageform' und EUMEL- 
Drucker). Solche #ib(1,"ff")#Indexanweisungen#ie# werden von den anderen 
Textbe- und -verarbeitungs Programmen ('lineform', 'pageform', EUMEL- 
Drucker) ignoriert. Man kann also bei dem Schreiben mit dem Editor gleich 
festlegen, welche Worte in einen Index aufgenommen werden sollen. 
 
 
 
Worte kennzeichnen: 'ib'/'ie' 
 
Da in einem Index - neben dem eigentlichen Worteintrag - die Seitennummer 
enthalten sein soll, arbeitet das Programm 'index' nur mit einer Druckdatei, 
d.h. einer Ausgabedatei von 'pageform'. Die Indexworte werden in Indexda- 
teien gesammelt. Die Indexdateien erhalten den Namen der zu bearbeitenden 
Datei, an den ".i" und die Nummer des Index angefügt wird. Beispiel: 
 
  ... Hier wird eine Eigenschaft des \#ib(1)\#EUMEL-Systems\#ie(1)\# beschrieben. 
 
(Die durch die Anweisungen 'ib' und 'ie' gekennzeichneten Worte werden mit 
der dazugehörigen Seitennummer in die erste Indexdatei geschrieben.) 
 
Die Einträge in einer Indexdatei werden von den Seitennummern durch min- 
destens drei Punkte getrennt. 
 
Werden diese nicht gewünscht, kann man sie leicht mit dem Editor entfernen. 
Beachte, daß man nur bei einer äquidistanten Schrift ein rechtsbündiges 
Verzeichnis erhalten kann. 
 
Es gibt die Möglichkeit, bis zu neun unterschiedliche Indexdateien zu er- 
stellen, z.B. durch 
 
     \#ib (1)\# und \#ie (1)\# 
 
gekennzeichnete Worte gehen in die Indexdatei mit der Nummer 1, durch 
 
     \#ib (9)\# und \#ie (9)\# 
 
gekennzeichnete Worte gehen in die Indexdatei mit der Nummer 9. Als Erleich- 
terung für diejenigen, die nur einen Index erstellen müssen, dürfen die 'ib'- 
und 'ie'-Anweisungen ohne Parameter benutzt werden, welches gleichbedeutend 
ist mit 'ib(1)' und 'ie(1)'. 
 
Die durch 'ib'- und 'ie'-Anweisungen gekennzeichneten Worte können auch über 
Zeilengrenzen (mit Silbentrennungen) gehen. Beispiel: 
 
     .... \#ib\#schöne Index-An- 
     weisungen\#ie\# ... 
 
'index' zieht getrennte Worte zusammen (hier: 'schöne Index-Anweisungen'). 
Will man einige Worte in verschiedenen Indexdateien haben, darf man die 'ib'- 
und 'ie'-Anweisungen auch "schachteln". Dies kann man besonders bei Kapitel- 
überschriften nutzen. Beispiel (vergl. auch die Überschrift dieses Ab- 
schnitts): 
 
     \#ib(9)\#Worte kennzeichnen: '\#ib\#ib\#ie\#'/'\#ib\#ie\#ie\#'\#ie(9)\# 
 
In diesem Beispiel wird das Inhaltsverzeichnis in die Indexdatei '9' ge- 
bracht, während der "allgemeine" Index in der Indexdatei '1' gesammelt wird. 
 
 
 
Nebeneinträge erzeugen 
 
Es ist möglich, an die Seitennummer eines Eintrags einen beliebigen Text 
anfügen zu lassen. Beispiele: 
 
  EUMEL-System ... 27ff. 
  Monitor ........ 13(Def.) 
  EUMEL-Editor ... 2(Kap.4) 
 
Dies wird durch die generische Form der 'ib'-Anweisung ermöglicht: 
 
  ... der \#ib(1,"(Kap.4)")\#EUMEL-Editor\#ie\# ist gut geeignet, 
  Texte zu erstellen ... 
 
(erzeugt den letzten obigen Eintrag). 
 
An einen Eintrag kann ein weiterer TEXT angefügt werden, um etwa Unterein- 
träge zu bilden: 
 
  EUMEL-System .............. 27 
  EUMEL-System, kapitales ... 28 
  EUMEL-System, schönes ..... 29 
 
Das wird ebenfalls durch eine andere Form der 'ie'-Anweisung ermöglicht: 
 
  ... ist das \#ib\#EUMEL-System\#ie(1,", schönes")\# wirklich ein
  schönes System ... 
 
(erzeugt den letzten obigen Eintrag). 
 
Nach der Erstellung einer Indexdatei können - nach interaktiver Anfrage - die 
Einträge sortiert werden. Die Sortierung erfolgt alphabetisch nach DIN 5007, 
Abschnitt 1 und 3.2 (Umlaute werden "richtig" eingeordnet). 
 
Wie bereits erwähnt, kann 'index' vielseitig eingesetzt werden: 
 
a) Erstellung von Stichwortverzeichnissen: 
   Wie bereits beschrieben. 
 
b) Erstellung von Inhaltsverzeichnissen: 
   Kapitelüberschriften mit eigenen Indexanweisungen klammern und durch 
   'index' wie beschrieben verarbeiten. Beispiel: 
 
      \#ib(8)\#9.1.3 Das abenteuerliche Leben von Micky Maus unter 
      besonderer Berücksichtigung seiner Geburtsstadt Entenhausen\#ie(8)\# 
 
   Dann ist man sicher, daß das Inhaltsverzeichnis bezüglich Seitennummern 
   und Kapitelüberschriften korrekt ist. 
 
c) Erstellung von Abbildungsverzeichnissen: 
   Abbildungsüber- bzw. -unterschriften wie Inhaltsverzeichnisse verarbeiten. 
 
d) Überprüfung von Literaturhinweisen auf Vollständigkeit: 
   Man klammert alle Literaturhinweise mit extra Indexanweisungen (Beispiel: 
   \#ib(9)\#/Meier82/\#ie(9)\#) und überprüft dann mit Hilfe dieser Indexdatei 
   die Literaturverweise. Dann ist man sicher, daß alle Literaturverweise im 
   Text auch in der Literaturaufstellung stehen. 
 
 
 
Indexdateien zusammenführen: 'index merge' 
 
Durch das Programm 'index merge' kann eine Indexdatei in eine zweite "einge- 
mischt" werden. Es ist somit möglich, einen Index zu erstellen, der sich über 
mehrere Dateien erstreckt, indem man 'index' die Druckdateien dieser Dateien 
bearbeiten läßt und anschließend die entstandenen Indexdateien mit 'index 
merge ' zusammenfaßt. Indexdateien können ggf. mit dem Editor bzw. 'lineform' 
und/ oder 'pageform' bearbeitet und anschließend gedruckt werden. Beispiel: 
 
     index merge ("1.kapitel.i1", "2.kapitel.i1") 
 
Hier wird die Indexdatei des '1.kapitel' in die Indexdatei des '2.kapitel' 
eingeordnet und auf Wunsch sortiert. 
 
Beachte, daß 'index' und 'index merge' Kommandos und keine Anweisungen sind. 
 
Merke: 'index' verarbeitet eine Druckdatei (Zusatz: ".p") und erzeugt eine 
oder mehrere Indexdateien (Zusatz: ".i<nummer>"). Die in einen Index zu 
übernehmenden Worte müssen im Text durch die 'ib'- und 'ie'-Anweisungen 
eingefaßt sein. 
 
 
 
5. Drucken: 'print' 
 
Der EUMEL-Drucker, der mit dem Kommando 'print' angesprochen wird, ist eine 
Software-Schnittstelle zu einem angeschlossenem Drucker. In diesem Kapitel 
wird erklärt, wie man mit dem EUMEL-Drucker eine Datei druckt und welche 
speziellen Anweisungen den Drucker steuern. 
 
Jeder Drucker erbringt "hardwaremäßig" unterschiedliche Leistungen (z.B. 
Randausgleich, Unterstreichung). Diese Leistungen werden durch Eingabe 
spezieller Zeichenfolgen veranlaßt, die zwar genormt sind, aber von den Druk- 
kerherstellern nicht eingehalten werden oder unterschiedlich interpretiert 
werden. 
 
Um vom EUMEL-System unterschiedliche Drucker auf gleiche Weise ansprechen 
zu können, wurde eine Software-Schnittstelle geschaffen, die EUMEL-Drucker 
genannt wird. Der EUMEL-Drucker akzeptiert eine Datei und veranlaßt, daß 
diese in geeigneter Weise gedruckt wird. Weiterhin beachtet der EUMEL- 
Drucker die Anweisungen der Textkosmetik. Die Form der Anweisungen der 
Textkosmetik und des EUMEL-Druckers sind gleich. 
 
 
 
Eine Datei drucken: 'print'-Kommando 
 
Mit dem Kommando 
 
      print 
 
kann dem EUMEL-Drucker eine Datei zum Drucken übergeben werden. Beispiel: 
 
      print ("Drucker Beschreibung") 
 
In der Regel ist im EUMEL-System (Multi-User) ein "Spooler" installiert, so 
daß sofort mit der Arbeit fortgefahren werden kann. Der EUMEL-Drucker ar- 
beitet in diesem Fall parallel zu anderen Arbeiten des Nutzers. 
 
 
 
Anweisungen für den EUMEL-Drucker 
 
Ein Text (eine Datei) kann vom Drucker auch ohne Anweisungen gedruckt 
werden, etwa für Probedrucke. Für diesen Fall hat der Drucker vernünftige 
Voreinstellungen. Für einen "normalen" Text braucht ein Benutzer keine spe- 
ziellen Druckeranweisungen in den zu druckenden Text einzufügen, denn die 
Anweisungen für die Textkosmetik reichen zur Druckersteuerung aus. Nur wenn 
besondere Leistungen verlangt werden, wie z.B. Blocksatz oder den gedruckten 
Text an eine bestimmte Stelle zu plazieren, sind Druckeranweisungen notwen- 
dig. 
 
Werden vom Drucker Leistungen verlangt, die hardwaremäßig nicht vorhanden 
sind, so sorgt der EUMEL-Drucker dafür, daß eine möglichst äquivalente 
Leistung erbracht wird. Wird beispielsweise ein nicht vorhandener Schrifttyp 
angefordert, wird mit dem Standard-Schrifttyp der jeweiligen Installation 
gedruckt. 
 
Damit ist es möglich, einen Text auf einem Drucker zu drucken, der den ge- 
forderten Typ nicht kennt und der eigentlich für einen anderen Drucker 
bestimmt ist. 
 
Wie bereits erwähnt, beachtet der EUMEL-Drucker die gleichen Anweisungen wie 
die Textkosmetik-Programme. Eine 'type'-Anweisung beispielsweise, welches 
einen bestimmten Schrifttyp anfordert, wird also auch vom EUMEL-Drucker als 
Befehlsfolge an den angeschlossenen Hardware-Drucker übergeben (sofern der 
Schrifttyp auf dem Drucker realisierbar ist). Wie die Anweisungen ge- 
schrieben werden müssen, wird in der Beschreibung der Textkosmetik ge- 
schildert. 
 
Anweisungen werden nicht gedruckt. Besteht eine Zeile nur aus Anweisungen, 
so wird diese Zeile vom EUMEL-Drucker nicht gedruckt. Im Gegensatz zu den 
Programmen der Textkosmetik werden unbekannte oder fehlerhafte Anweisungen 
vom EUMEL-Drucker ohne Fehlermeldung "verschluckt". Alle Anweisungen werden 
zum frühest möglichen Zeitpunkt ausgeführt, haben also u.U. bereits Aus- 
wirkungen auf die Zeile, in der sie stehen. 
 
Einige Anweisungen sind speziell nur für den EUMEL-Drucker vorhanden. 
Diese werden in diesem Kapitel erklärt bzw. werden in der Anweisungs-Über- 
sicht mit aufgeführt. 
 
Neben den "normalen" Anweisungen, die nur in "\#"-Zeichen eingeschlossen 
werden, gibt es noch zwei andere Formen: 
 
a) Kommentar-Anweisungen: 
   Werden in "\#-" und "\#"-Zeichen eingeschlossen. Solche Anweisungen 
   werden ignoriert. Beispiel: 
 
        \#---- Ende der Seite 1 ---\# 
 
b) Spezielle Druckeranweisungen: 
   Werden in "\#/" und "\#"-Zeichen eingefaßt. Die von diesen Anweisungs- 
   Zeichen eingeschlossenen Druckerbefehlen werden unverändert (ohne die 
   "\#/" und "\#"-Zeichen) an den Drucker weitergereicht. Beispiel: 
 
        \#/C05\#                    (* C05 geht an den Drucker *) 
 
   Solche Anweisungen werden manchmal benötigt, um spezielle Druckereigen- 
   schaften auszunutzen, die schwer oder garnicht im EUMEL-Drucker reali- 
   sierbar sind. 
 
Anmerkung: Diese Anweisungen werden, wie die normalen Anweisungen auch, bei 
der Berechnung einer Zeile nicht berücksichtigt und nicht gedruckt. 
 
Merke: Der EUMEL-Drucker übernimmt die Anpassung an spezielle Hardware- 
Drucker. Er beachtet die gleichen Anweisungen wie die Textkosmetik-Programme. 
Zusätzlich gibt es noch einige wenige spezielle Druckeranweisungen. 
 
 
 
Blocksatz drucken: 'block' 
 
Die Anweisung 'block' bewirkt einen Blocksatz beim Druck. 
 
Fügt man in den Text (meist am Anfang einer Datei) die Anweisung 
 
     \#block\# 
 
ein, druckt der Drucker ab dieser Stelle alle Zeilen, die nicht mit einem 
Absatzkennzeichen versehen sind, im Blocksatz. Dies heißt, daß durch Ver- 
größern der Wortabstände alle Zeilen an der gleichen Position enden (rechter 
Randausgleich). Preiswerte Drucker können dies nur durch Einfügen ganzer 
Leerzeichen zwischen den Worten vornehmen, was sich oft beim Lesen störend 
bemerkbar macht. Bei qualitativ hochwertigen Druckern wird dagegen der 
Blocksatz durch Einfügen kleinerer Abstände zwischen den Worten oder sogar 
zwischen den Zeichen erreicht. 
 
Merke: Die Anweisung 'block' bewirkt den Blocksatz beim Druck. 
 
 
Schreibfeld verschieben: 'start' 
 
Durch die Anweisung 'start' ist es möglich, das Schreibfeld beim Druck auf 
dem Papier an eine andere Stelle zu plazieren. 
 
Der EUMEL-Drucker plaziert das Schreibfeld auf einem Drucker automatisch der- 
art, daß ein genügender Rand verbleibt. Diese Voreinstellung ist natürlich 
abhängig vom Drucker und der Installation. Mit der 'start'-Anweisung kann 
die automatische Einstellung verändert werden. Beispiel: 
 
     \#start (1.0, 2.0)\# 
 
legt die linke, obere Ecke des Schreibfeldes fest (vom linken Rand 1 cm, vom 
oberen Rand 2 cm). 
 
Merke: Die 'start'-Anweisung legt den linken oberen Rand des Schreibfeldes 
fest. 
 
 
 
Zentrieren 
 
Mit dem '#ib#center#ie#'-Kommando kann man eine Zeile in der Mitte der Zeile 
drucken lassen. 
 
Das 'center'-Kommando zentriert die Schrift einer Zeile. Beispiel: 
 
\#center\#Diese Zeile ist zentriert 
 
Dies Kommando ist nur bei Proportionalschriften sinnvoll einzusetzen, da man 
bei einer äquidistanten Schrift man direkt auf dem Bildschirm sehen kann, 
wie der Text auf einer Zeile plaziert ist. 
 
Merke: 'center' zentriert eine Zeile beim Drucken. 
 
 
 
6. Textkosmetik-Makros 
 
Makros dienen als Abkürzung für immer wiederkehrende Textteile und/oder 
Kommandos. 
 
Textkosmetik-Makros kommen zum Einsatz bei 
 
- immer wiederkehrenden Textteilen; 
 
- immer wiederkehrenden Anweisungssequenzen; 
 
- bei der Erstellung von Manuskripten, deren endgültige Form man anfänglich 
  noch nicht weiß oder die man noch ändern will. 
 
Die Definition von einem oder mehreren Makros wird mit dem Editor vorgenom- 
men. Diese Makro-Datei wird dann geladen. Von diesem Augenblick an "kennen" 
'lineform'/'autoform' und 'pageform' die Makros (d.h. die Textzeilen und/ 
oder Anweisungen, die sich unter dem dem Makronamen "verbergen"). 
 
'lineform'/'autoform' beachten die Anweisungen, die in den Makros enthalten 
sind. Man beachte, daß die Anweisungen und Textzeilen, die in den Makros ent- 
halten sind, nicht in der Datei erscheinen. Erst 'pageform' setzt diese in 
die Druckdatei ein. 
 
 
Ein Beispiel 
 
Hier wird ein einfaches Beispiel für einen Briefkopf gezeigt. 
 
Angenommen, die Firma 'Meier' schreibt mit dem EUMEL-System ihre Geschäfts- 
briefe. Sie hat einen Drucker zur Verfügung, mit dem man auch die Briefköpfe 
erstellen kann. Für den Briefkopf schreibt die Junior-Chefin ein Makro'kopf' 
in eine Datei 'macro definitionen': 
 
  \#*kopf\# 
  \#type("fett und gross")\#  Firma Meier 
  \#type("fett")\#            Gemischtwaren in kleinen Mengen 
  \#type("klein")\#           Straße 
                            Stadt 
  \#type ("normal")\# 
  \#*macro end\# 
 
Der Name des Makros ist 'kopf'. Man beachte, daß eine Makro-Definition mit 
dem Namen des Makros beginnen müssen. Der Makroname muß mit einem '*' 
gekennzeichnet werden, um ihn von "normalen" Text-Anweisungen unterscheiden 
zu können. Jedes Makro wird mit einer 'macro end'-Anweisung beendet 
(es dürfen mehrere Makros hintereinander in die Datei geschrieben werden). 
 
Nun muß die Junior-Chefin das so definierte Makro 'laden': 
 
   load macros ("macro defintionen") 
 
Zur Kontrolle kann sie sich die "geladenen" Makros in einen Datei ausgeben 
lassen: 
 
   list macros ("kontroll datei") 
 
Nun kann die Junior-Chefin ihrem Sekretär sagen, daß er von jetzt ab ein 
neues Kommando zur Verfügung hat, welches einen Briefkopf in jeden Brief 
drucken kann (mit dem Namen 'kopf'). Der Sekretär schreibt also nun 
folgenden Brief: 
 
\#kopf\# 
 
Sehr geehrte Frau .... 
usw. 
 
Nachdem er mit 'lineform' den Brief zeilenweise formatiert hat, kontrolliert 
er die formatierte Datei. Hier hat sich noch nichts verändert, die neue An- 
weisung 'kopf' steht unverändert in der Datei. ('lineform' beachtet zwar 
alle Anweisungen und Textzeilen eines Makros, setzt diese jedoch nicht in 
die Datei ein). 
 
Nun formatiert der Sekretär die Datei, welche den Brief enthält, mit 'page- 
form'. In der Druckdatei ist nun die Anweisung 'kopf' verschwunden, dafür 
stehen aber nun die Zeilen des Makrorumpfes ('pageform' setzt die Zeilen des 
Makros in die Druckdatei ein): 
 
  \#type("fett und gross")\#  Firma Meier 
  \#type("fett")\#            Gemischtwaren in kleinen Mengen 
  \#type("klein")\#           Straße 
                            Stadt 
  \#type ("normal")\# 
 
 
  Sehr geehrte Frau ... 
  usw. 
 
Merke: Makros sind bei der Verwendung von wenigen Text- und/oder Anweisungs- 
folgen nützlich, die immer in der gleichen Form benötigt werden. 
 
 
Ein Beispiel mit Makro-Parametern 
 
Unsere Junior-Chefin fällt nun auf, daß sie ihr Makro noch etwas verbessern 
kann. Sie will noch das Datum mit in den Briefkopf aufnehmen. Somit editiert 
sie ihre Makro-Datei folgendermaßen (man beachte die '$'-Zeichen): 
 
  \#*kopf ($1)\# 
  \#type("fett und gross")\#  Firma Meier 
  \#type("fett")\#            Gemischtwaren in kleinen Mengen 
  \#type("klein")\#           Straße 
                            Stadtname 
  \#type ("normal")\# 
 
                                        Stadtname, den $1 
  \#*macro end\# 
 
Damit hat sie dem 'kopf'-Makro einem Parameter gegeben ('$1'; die Parameter 
werden numeriert. Ein zweiter Parameter würde '$2' heißen usw.). 
 
Der Sekretär muß nun die Anweisung 'kopf' mit dem jeweiligen Datum in einen 
Brief schreiben: 
 
   \#kopf ("9.1.1984")\# 
 
'pageform' setzt nun das angegebene Datum direkt hinter 'Stadtname, den' in 
den Briefkopf ein (in der Druckdatei). Beachte, daß nur TEXT-Denoter als 
aktuelle Parameter eines Makros erlaubt sind. 
 
Merke: Durch die Makro-Parameter ist es also möglich, immer wiederkehrende 
Textteile in Schriftstücke einsetzen zu lassen, die sich nur in Kleinigkei- 
ten unterscheiden. 
 
 
Ein Beispiel für Manuskripte 
 
Hier wird gezeigt, wie man mit Makros Anweisungen formulieren kann, die aus- 
sagen, um was es sich bei einem Text handelt und nicht, wie es behandelt 
werden soll. 
 
Bei Manuskripten für Artikel, Bücher und Manuals weiß ein Autor oft vorher 
nicht, in welchem Format das Manuskript gedruckt werden wird. Zu diesem 
Zweck ist es ebenfalls nützlich, die Makros zu verwenden. Beispiel: 
 
   \#*kapitel anfang ($1)\# 
   \#free (2.0)\# 
   \#type ("gross und fett")\#\#ib (9)\#$1\#ie (9)\#\#type ("normal")\# 
 
   \#*macro end\# 
 
In diesem Beispiel wird ein Makro für den Anfang eines Kapitels definiert. 
Zwischen zwei Kapiteln soll hier zwei cm Zwischenraum bleiben, die Kapitel- 
Überschrift (als Parameter) wird in einer grösseren Schrift gedruckt. Zu- 
sätzlich wird die Überschrift in den 9. Index aufgenommen für ein Inhalts- 
verzeichnis. Nach der Überschrift wird eine Leerzeile eingeschoben, bevor 
der "richtige" Text anfängt. 
 
Ein(e) Anwender(in) dieses Makros schreibt also z.B. folgende Anweisung: 
 
   \#kapitel anfang ("Ein Beispiel fuer Manuskripte")\# 
 
(Beachte, daß die Kapitel-Überschrift nicht länger als eine Textzeile sein 
darf. Das liegt daran, das 'lineform'/'autoform' zwar die Zeile bearbeitet, 
aber nicht in den Text einsetzt. 'pageform' setzt also die unveränderte 
-  nicht aufgebrochene Textzeile - ein). 
 
Man kann nun Makros für die meisten Textstrukturen definieren. Schreibkräfte 
brauchen dann in der Regel die meisten der Text-Anweisungen nicht zu kennen, 
sondern nur noch eine Anzahl von einfachen Makro-Anweisungen. 
 
Die Makro-Definitionen können jederzeit geändert werden, um wechselnden 
Bedürfnissen angepaßt zu werden (z.B. wenn ein Verlag ein bestimmtes 
Schreibformat verbindlich vorschreibt). In diesem Fall brauchen nicht alle 
Text-Dateien geändert zu werden, sondern nur die Makro-Definitionen. 
 
Ein weiterer Vorteil einer solchen Vorgehensweise ist, daß die Makro-Anwei- 
sungen in diesem Fall angeben, was eine bestimmte Text-Struktur ist, und 
nicht, wie die Struktur behandelt werden soll. 
 
Anmerkung: 
In eine Makro-Definition sollte man ggf. 'limit'-, 'type'- und 'linefeed'- 
Angaben einsetzen, um die Makros unabhängig von der Aufrufstelle zu machen. 
Ggf. sollte man die Datei vorher mit 'lineform' bearbeiten, um Trennungen 
vorzunehmen. 
 
Merke: Makros dienen zur flexiblen Behandlung von Text-Strukturen, indem 
Makros definiert werden, die angeben, um was es sich dabei handelt. 
 
 
 
Beschreibung der Makro-Kommandos 
 
Mit dem Kommando 
 
   load macros ("macro datei") 
 
kann eine Datei, in denen die Makro-Definitionen enthalten sind, in den 
Makro-Speicher des Textsystems geladen werden. Ist dies fehlerfrei erfolgt, 
kann man 'lineform'/'autoform' Dateien übergeben, die die definierten Makro- 
Anweisungen "kennen" und befolgen. 'pageform' setzt bei Antreffen einer 
Makro-Anweisung den Makrorumpf in die Ausgabe-Datei ein. 
 
Die Definition eines Makros erfolgt mit dem Makronamen, der von Anweisungs- 
zeichen eingeschlossen ist. Um Makro-Anweisungen von "normalen" Textkosmetik- 
Anweisungen zu unterscheiden, müssen diese nach dem ersten Anweisungszeichen 
mit einem '*' gekennzeichnet werden. Beispiel: 
 
   \#*macro eins\# 
   Makrorumpf mit "normalen" Kommandos, wie z.B. 
      \#type ("x")\# 
   \#*macro end\# 
 
Der Aufruf eines Makros, welcher z.B. in einer von 'lineform' zu bearbeiten- 
den Datei steht, unterscheidet sich nicht von einer "normalen" Textanweisung. 
Beispiel: 
 
   ... \#macro eins\# ... 
 
Hat das Makro Parameter (bei der Definition mit '$'-Zeichen durchnumeriert), 
müssen beim Aufruf TEXT-Parameter eingesetzt werden (also in Anführungs- 
strichen). Beispiel: 
 
   \#*macro zwei ($1)\# 
   ... $1 ... 
   \#*macro end\# 
 
   (* Aufruf: *) 
 
   \#macro zwei ("ein einzusetzender Text")\# 
 
Anmerkung: 
Bei Makros gibt es keine generischen Anweisungen. Makros, die gleiche Namen 
haben, aber sich durch die Anzahl der Parameter unterscheiden, sind also 
nicht erlaubt. 
 
Beachten Sie ferner, daß Makro-Texte so verwendet werden, wie diese mit 
'load macros' geladen werden. Beispiel: 
 
   \#*a\# 
   \#on("underline")\# 
   \#*macro end\# 
 
   \#*b\# 
   \#off("underline")\# 
   \#*macro end\# 
 
Betätigt man in der Makro-Datei nach jeder Zeile die RETURN-Taste (Absatz), 
dann erhält man bei folgender Verwendung Fehlermeldungen von 'lineform': 
 
    ... \#a\#zu unterstreichender Text\#b\# ... 
 
weil hier Mitten im Satz Absätze erscheinen und 'lineform' bei jedem Absatz 
prüft, ob noch Modifikationen "offen" sind. In solchen Anwendungen sollte 
man also Makros ohne Absätze speichern. 
 
 
 
7. Anweisungs-Übersicht 
 
* block 
  Zweck: Blocksatz (rechter Randausgleich). Der Text einer Zeile wird durch 
         Vergrößern der Wortlücken auf die Zeilenlänge, die durch das 
         'limit'-Kommando eingestellt ist, verlängert. Es gelten folgende 
         Bedingungen: 
         a) Leerzeichen werden nicht verbreitert bei 
            - Zeilen mit Absatzzeichen; 
            - Mehrfache Leerzeichen; 
            - führende Leerzeichen (Einrückung); 
            - ein Leerzeichen hinter dem ersten Wort einer Zeile, wenn es auf 
              die Zeichen "]", ")", ".", "-", ":" endet. 
         b) Einrückungen werden äquidistant berechnet (Anzahl Zeichen * 
            Breite eines "Standard-Blanks"). Dies gilt nur für Proportional- 
            schriften und vor einer Absatzzeile. Es gilt als Einrückung: 
            - "Spiegelstrich" (Bindestrich und Leerzeichen am Anfang der 
              Zeile); 
            - Doppelpunkt als Ende des ersten Wortes (Position < 20); 
            - Schliessende Klammer oder Punkt als Ende des ersten Wortes, 
              wenn eine Ziffer davor steht (Position < 7); 
         c) Tabellen werden auch äquidistant berechnet. Dies gilt ebenfalls 
            nur für Proportionalschriften und vor einer Absatzzeile. Es gilt 
            als Teil einer Tabelle: 
            - Position des letzten Mehrfachblank. 
 
* bottom 
  Zweck: Erzeugen von "Fußzeilen" am Ende jeder Seite in der Druckdatei für 
         Untertitel und Seitennummern. Die Textzeilen zwischen den Anwei- 
         sungen 'bottom' und 'end' werden von 'pageform' am Ende jeder Seite 
         eingesetzt. 
 
* bottom even 
  Zweck: Definition von Fußzeilen für Seiten mit geraden Seitennummern. Es 
         gilt das unter 'bottom' gesagte. 
 
* bottom odd 
  Zweck: Definition von Fußzeilen für Seiten mit ungeraden Seitennummern. Es 
         gilt das bei 'bottom' gesagte. 
 
* center 
  Zweck: Zentrieren einer Zeile (Absatzzeile). 
 
* columns (INT CONST anzahl, REAL CONST luecke) 
  Zweck: Einschalten der Spaltenformatierung. 
 
* columnsend 
  Zweck: Ausschalten der Spaltenformatierung. 
 
* count 
  Zweck: Erhöhung eines internen Zählers und Einsetzen des Wertes anstatt 
         der Anweisung in die Druckdatei. 
 
* count (TEXT CONST merkmal) 
  Zweck: Wie obiges 'count', jedoch wird der Wert des Zählers vermerkt, so 
         daß er mit 'value' wieder erfragt werden kann. 
 
* end 
  Zweck: Beendet die Defintion von 'head', 'bottom' oder Fußnotenbereichen. 
 
* foot 
  Zweck: Definieren von Fußnoten. Es werden die aktuellen Werte von 'limit', 
         'linefeed' und 'type' für die Fußnote verwendet (vergl. 'bottom'- 
         Anweisung). 
 
* free (REAL CONST freier platz) 
  Zweck: Es werden 'freier platz' cm freigehalten. 
 
* goalpage (TEXT CONST merkmal) 
  Zweck: (Ziel-) Verweis für Seitenquerverweise in Verbindung mit der Anwei- 
         sung 'topage'. 'merkmal' muß mit dem Parameter des entsprechenden 
         'topage' übereinstimmen. 
 
* head 
  Zweck: Definieren von Kopfzeilen, die von 'pageform' am Anfang jeder Seite 
         eingefügt werden. Es gilt das unter 'bottom' gesagte. 
 
* head even 
  Zweck: Definieren von Kopfzeilen für Seiten mit geraden Seitennummern. Es 
         gilt das unter 'bottom' gesagte. 
 
* head odd 
  Zweck: Definieren von Kopfzeilen für Seiten mit ungeraden Seitennummern. 
         Es gilt das unter 'bottom' gesagte. 
 
* ib 
  Zweck: Arbeitet wie 'ib (1)', man darf aber den Parameter weglassen. 
 
* ib (INT CONST index nummer) 
  Zweck: Indexanfang einer oder mehrerer Indexworte bis zur entsprechenden 
         'ie'-Anweisung. Die Worte zwischen 'ib' und 'ie' werden in die 
         Indexdatei geschrieben. 'index nummer' gibt die Indexdatei an. 
 
* ib (INT CONST index nummer, TEXT CONST seitennummer zusatz) 
  Zweck: Indexanfang mit Zusatztext für die Seitennummer. Das oben gesagte 
         gilt entsprechend. 'seitennummer zusatz' wird unmittelbar hinter 
         die Seitennummer angefügt. 'seitennummer zusatz' muß in jeder 'ib'- 
         Anweisung neu gesetzt werden. 
 
* ie 
  Zweck: Arbeitet wie 'ie (1)', man darf aber den Parameter weglassen. 
 
* ie (INT CONST index nummer) 
  Zweck: Abschluß eines Index. Ein Index darf nicht über Absatz- und Seiten- 
         grenzen gehen. Ein Index über mehr als zwei Zeilen ist ebenfalls 
         aus Sicherheitsgründen (vergessene Abschlußanweisung) nicht erlaubt. 
         
* ie (INT CONST index nummer, TEXT CONST index zusatz) 
  Zweck: Es wird 'index zusatz' an die durch die Index-Anweisungen einge- 
         faßten Worte angefügt. Beispiel: 
 
            \#ib (1)\#EUMEL-System\#ie(1, ", kapitales")\# ist 
            schön. 
 
         Erscheint als 'EUMEL-System, kapitales ... 4' in der Indexdatei. 
         Diese Anweisung dient also dazu, auch Sub-Indizes zu ermöglichen. 
 
* limit (REAL CONST wert) 
  Zweck: Einstellen einer neuen Zeilenbreite in cm. Die Zeilenbreite gilt 
         solange, bis sie durch ein erneute 'limit'-Anweisung verändert wird. 
 
* linefeed (REAL CONST wert) 
  Zweck: Einstellen eines neuen Zeilenvorschubs in Abhängigkeit vom einge- 
         stellten Schrifttyp. 
 
* material (TEXT CONST mat) 
  Zweck: Angabe von installationsspezifischen Merkmalen für den Drucker. 
 
* off (TEXT CONST modification) 
  Zweck: Abschalten einer Modifikation. 
 
* on (TEXT CONST modification) 
  Zweck: Einschalten einer Modifikation. Folgende Modifikationen sind zur 
         Zeit möglich: 
              bold        (Fettdruck) 
              italic      (Kursivdruck) 
              underline   (Unterstreichung) 
              revers      (Weiß auf Schwarz) 
 
* page 
  Zweck: Anfang einer neuen Seite. 'page' muß als letztes auf einer Zeile 
         stehen. 
 
* page (INT CONST nr) 
  Zweck: Anfang einer neuen Seite mit 'nr' Seitennummer. 
 
* page length (REAL CONST cm) 
  Zweck: Einstellen der Seitenlänge in cm. 
 
* page nr (TEXT CONST seitennr zeichen, start) 
  Zweck: Einstellen eines neuen Seitennr-Zeichens und Anfangwerts bzw. 
         setzen der Seitennummer des bereits vorhandenen Seitenzeichens 
         ("%"). Neben dem vorhandenen "%"-Zeichen können zwei zusätzliche 
         (beliebige, aber von den "\#"-Zeichen unterschiedliche) Seiten- 
         zeichen definiert werden. 
 
* papersize (REAL CONST width, length) 
  Zweck: Angabe der Papiergröße des Druckers in cm. 
 
* print (INT CONST von, bis) 
  Zweck: Teilausdruck einer Datei. Der Drucker verarbeitet die Datei, bis er 
         an die Seite 'von' angelangt ist. Dann druckt er die Seiten bis 
         einschließlich 'bis'. Beachte, daß der EUMEL-Drucker die Seiten 
         immer ab 1 durchzählt (und eine eventuelle Seitennumerierung nicht 
         beachtet). 
 
* start (REAL CONST x, y) 
  Zweck: Legt den linken, oberen Eckpunkt des Schreibfeldes fest. Die 
         Angaben erfolgen in cm. 
 
* topage (TEXT CONST merkmal) 
  Zweck: Verweis auf eine Seite mit der Anweisung 'goalpage' und dem 
         gleichen 'merkmal'. Für 'topage' wird die Seitennummer von 
         'goalpage' eingesetzt. 
 
* type (TEXT CONST schrifttyp name) 
  Zweck: Einstellen eines anderen Schrifttyps. Die verfügbaren Schriftarten 
         und deren Namen sind installationsspezifisch und deshalb hier nicht 
         beschrieben. 
 
* value 
  Zweck: Einsetzen des letzten 'count' Wertes. 
 
* value (TEXT CONST merkmal) 
  Zweck: Erfragen des mit 'count' gespeicherten Zählerwertes für 'merkmal' 
         und Einsetzen dieses Wertes durch 'pageform' in die Druckdatei. 
 
 
 
7. Kommando-Übersicht 
 
autoform 
    PROC autoform 
    Zweck: Aufruf von 'autoform' unter Verwendung des letzten eingestellten 
           Dateinamens. 
 
    PROC autoform (TEXT CONST datei) 
    Zweck: 'lineform' mit automatischer Silbentrennung. Nur die vorgenomme- 
           nen Trennungen werden auf dem Bildschirm angezeigt. 
 
    PROC autoform  (FILE VAR f, TEXT CONST type name, REAL CONST width) 
    Zweck: Wie oben, jedoch auf einer Datei. 
 
index 
    PROC index (TEXT CONST eingabe datei) 
    Zweck: Erstellen von Indexdateien aus einer Druckdatei wie beschrieben. 
           Eine Indexdatei erhält den Namen der zu bearbeitenden Datei mit 
           dem Zusatz ".i" und der entsprechenden Indexnummer. Hat das 
           Programm 'index' die Druckdatei bearbeitet, werden die in die 
           Indexdatei geschriebenen Einträge alphabetisch sortiert (nach 
           Anfrage). Gleiche Einträge werden zusammengezogen: ein gleich- 
           lautender Eintrag wird entfernt, seine Seitennummer wird jedoch 
           an den bereits vorhandenen mit einem Komma aggefügt. 
 
           Die Sortierung entspricht DIN 5007: 
           - Die Sortierreihenfolge enspricht 'ABC...Z', wobei große und 
             kleine Buchstaben gleich behandelt werden. 
           - Weitere Entsprechungen: 
             ö = oe, ä = ae, ü = ue 
             Ö = Oe, Ü = Ue, Ä = Ae, Ä = ä, Ü = ü, Ö = ö, ß = ss 
             Dadurch wird z.B. 'muß' vor 'Muster' einsortiert und 'Goethe' 
             ist gleich 'Göthe'. 
           - Alle Sonderzeichen (außer " " und "-") werden ignoriert. 
           - Ein Leerzeichen und ein Bindestrich zwischen Worten werden 
             gleich behandelt. Beispiel: 
 
             'EUMEL System' und 'EUMEL-System' sind also gleich. 
 
           Es sind z.Z. max. neun unterschiedliche Indexdateien vorgesehen. 
           Der Name einer Indexdatei ergibt sich aus dem Namen der zu bear- 
           beitenden Druckdatei, wobei '.p' durch '.i' mit der entsprechen- 
           den Ziffer ersetzt wird. Beispiel (für Indizes mit 
           'index nummer' = 1, z.B. \#ib\# ... \#ie\#): 
 
                skript.p  --> skript.i1 
 
index merge 
    PROC index merge (TEXT CONST von, hinzu) 
    Zweck: Einmischen der Indizes der Indexdatei 'von' in die Indexdatei 
           'hinzu'. Beide Indexdateien müssen vorhanden sein. Dabei wird 
           'von' vor dem ersten Satz von 'hinzu' eingefügt und anschließend 
           ggf. sortiert. 
 
list macros 
   PROC list macros (TEXT CONST datei) 
   Zweck: Ausgabe der "geladenen" Makros in die Datei 'datei'. 'datei' darf 
          vorher nicht existieren, wird also von 'list macros' eingerichtet. 
          Die "geladenen" Makros bleiben unberührt. Man kann die mit 'list 
          macros' in die Datei 'datei' geschriebenen Makro-Definitionen ggf. 
          verändern und erneut mit 'load macros' laden. 
   Fehlerfall: 
      * file already exists 
        Ausgabe-Datei 'datei' ist bereits vorhanden. 
 
lineform 
    PROC lineform 
    Zweck: Der zuletzt verwandte Dateiname wird benutzt. Beispiel: 
 
              edit ("test") 
              ... 
              lineform  (* wird zu 'lineform ("test") *) 
 
    PROC lineform (TEXT CONST dateiname) 
    Zweck: Formatieren einer Datei zeilenweise. 
 
    PROC lineform  (FILE VAR f, TEXT CONST type name, REAL CONST width) 
    Zweck: Aufruf von 'lineform' von einem Programm. 
 
load macros 
   PROC load macros (TEXT CONST datei) 
   Zweck: Lädt Makro-Definitionen in den Makro-Speicher des Textsystems. Die 
          Definitionen müssen in der Datei 'datei' enthalten sein (mit dem 
          Editor erstellen). Es können mehrere Definitionen in der Datei ent- 
          halten sein. Um den Makro-Speicher zu leeren, übergibt man eine 
          leere 'datei'. 
 
          Eine Makro-Definition besteht aus einem 
          - Makro-Kopf: 
            Muß alleine auf einer Zeile stehen. Der Makro-Kopf fängt mit 
            '\#*'-Zeichen an und wird mit '\#' beendet. Beispiel: \#*ein macro\# 
            Der Name eines Macros muß (wie alle andern Anweisungen auch) 
            mit kleinen Buchstaben geschrieben werden. Leerzeichen spielen 
            keine Rolle. 
            Eventuelle Parameter müssen in Klammern (bei mehreren durch 
            Kommata getrennt) und mit einem $-Zeichen numeriert werden. 
            Beispiel: 
               \#*macro1 ($1)\# 
               \#*macro 2 ($1, $2)\# 
 
          - Makro-Rumpf: 
            Besteht aus beliebig vielen Text-Zeilen, die Kommandos enthalten 
            können. Parameter (also das $-Zeichen mit anschließender Nummer) 
            werden bei Aufruf eines Makros ersetzt. In einem Makro-Rumpf 
            darf keine Makro-Anweisung erscheinen, die noch nicht definiert 
            wurde (sog. "Vorwärts-Referenzen"). 
 
          - Makro-Ende: 
            besteht aus der Anweisung 
               \#*macro end\# 
            und muß wie der Makro-Kopf alleine auf einer Zeile stehen. 
 
   Fehlerfälle: 
     * file does not exists 
       Die Eingabe-Datei 'datei' ist nicht vorhanden. 
     * macro store overflow (number lines) 
       Es passen zur Zeit nicht mehr als 1 000 Zeilen in den Makro-Speicher. 
     * macro store overflow (number macros) 
       Es passen zur Zeit nicht mehr als 100 Makro-Defintionen in den 
       Makro-Speicher. 
 
pageform 
    PROC pageform 
    Zweck: Wie beschrieben, jedoch ohne Parameter. Die zuletzt benutzte 
           Datei wird bearbeitet. Für die Druckdatei wird dieser Dateiname, 
           an den ".p" angehängt wird, eingesetzt. Beispiel: 
 
              edit ("test") 
              ... 
              pageform  (* wird zu 'pageform ("test", "test.p")' 
                           ergaenzt *) 
 
     PROC pageform (TEXT CONST dateiname) 
     Zweck: Wie beschrieben, wobei der Parameter für die Druckdatei ergänzt 
            wird (an 'dateiname' wird '.p' angehängt). Beispiel: 
 
               pageform ("test") 
               (* wird zu 'pageform ("test", "test.p")' ergaenzt *) 
 
     PROC pageform (TEXT CONST dateiname, druckdatei) 
     Zweck: Wie oben. 
 
print 
     PROC print (TEXT CONST datei) 
     Zweck: Druck der Datei 'datei' unter Berücksichtigung von Anweisungen. 
 


