                        EUMEL-Benutzerhandbuch 
 
                        TEIL 8: Standardpakete                      
 
 
1. Übersicht 
 
Hier werden die im EUMEL-System verfügbaren Prozeduren und Operatoren aufge- 
führt, die nicht bereits in anderen Teilen des Benutzerhandbuchs beschrieben 
wurden. 
 
Die meisten der hier beschriebenen Objekte werden nicht vom ELAN-Compiler, 
sondern von vorübersetzten Moduln (PACKETs) realisiert (vergl. dazu auch den 
Quellcode). Die in diesem Teil beschriebenen Prozeduren und Operatoren 
weisen einige wenige Modifikationen, aber beträchtliche Erweiterungen gegen- 
über dem Standard auf, um sie für die Zwecke des EUMEL-Systems anzupassen. 
Hier werden nur diejenigen Objekte aufgeführt, die bei einer System-Aus- 
lieferung dem EUMEL-System beigefügt sind. Jeder Installation ist es frei- 
gestellt, diesen "EUMEL-Standard" zu erweitern oder zu modifizieren. 
 
Die Operationen des EUMEL-Standards lassen sich in verschiedene Klassen - 
je nach Aufgabenbereich - ordnen. 
 
 
 
Ein-/Ausgabe 
 
Die Ein-/Ausgabe erfolgt im EUMEL-System in der Regel auf dem Terminal des 
Benutzers. Sie kann aber auch in einen File umgeleitet werden. 
 
Die Ein-/Ausgabe eines Programms erfolgt in der Regel auf dem Terminal des 
Benutzers, welches einem Prozeß zugeordnet ist. Die Eingabe vom Bildschirm 
kann man mit den Prozeduren 
 
     get 
 
programmieren, welche INT, REAL und TEXT-Werte einlesen. Bei der Eingabe 
kann der Eingabetext editiert werden (Zeichen löschen, einfügen, über- 
schreiben oder Lernsequenzen abrufen). Die Ausgabe erfolgt mit den Proze- 
duren   
 
     put 
 
(für INT-, REAL- und TEXT-Werte). Von den 'put'-Prozeduren wird ein Leer- 
zeichen an eine Ausgabe angefügt, um diese von der vorhergehenden zu trennen. 
Zusätzlich existiert die 
 
     write 
 
Prozedur, welche an die Ausgabe kein Leerzeichen anfügt. Mit 
 
     line 
 
kann man eine Positionierung auf eine neue Zeile bei der Ein-/Ausgabe er- 
wirken. Mit 
 
     getline 
     putline 
 
kann eine ganze Zeile eingelesen bzw. ausgegeben werden. 
 
Wie bereits erwähnt, erfolgt die Ein-/Ausgabe in der Regel auf dem Terminal 
des Benutzers. Es ist jedoch möglich, die Ein-/Ausgabe dieser Prozeduren 
"umzuleiten". Diese Umleitung erfolgt in eine oder von einer Datei. Dazu 
gibt es die Prozeduren 
 
     online               (* liefert TRUE, wenn die Task an ein Terminal 
                             gekoppelt ist *) 
     sysout ("name")      (* Ausgabe erfolgt in die Datei 'name'. 'sysout 
                             ("")' schaltet auf das Terminal zurück *) 
     sysout               (* Liefert den Namen der eingestellten 'sysout'- 
                             Datei. Wird "" geliefert, ist man an ein 
                             Terminal gekoppelt *) 
     sysin ("name")       (* Umschaltung der Eingabe vom Terminal auf die 
                             Datei 'name'. sysin ("")' schaltet auf das 
                             Terminal zurück *) 
     sysin                (* Liefert den Namen der eingestellten 'sysin'- 
                             Datei. Wird "" geliefert, ist man an ein 
                             Terminal gekoppelt *) 
 
Wie bereits erwähnt, ist die Umschaltung nur für die Prozeduren 'get' und 
'put'/'write', sowie 'getline' und 'putline' und die Prozedur 'line' möglich. 
(Die folgenden Prozeduren haben immer eine Wirkung auf das Benutzer- 
Terminal). Die Prozedur 
 
     out 
 
schreibt wie 'write' einen Text auf den Bildschirm (läßt sich aber nicht 
"umleiten"). 
 
     cout 
 
schreibt einen INT-Wert an die aktuelle Cursor-Position auf den Bildschirm 
und positioniert anschließend auf diese Position wieder zurück. Diese 
Prozedur wird vorwiegend für Kontroll-Ausgaben (z.B. Zeilennummern) benutzt. 
Ist die Task nicht angekoppelt, geht die Ausgabe ins "Leere"; das Programm 
der Task läuft also weiter (im Gegensatz zu 'put' auf den Bildschirm). Mit 
der Prozedur   
 
     cursor 
 
kann - neben der Möglichkeit des Arbeitens mit Steuerzeichen - auf eine 
bestimmte Position des Bildschirms positioniert werden. Mit 
 
     get cursor 
 
kann die aktuelle Position des Cursors auf dem Terminal des Benutzers er- 
fragt werden. Mit Hilfe der Prozedur 
 
     inchar 
 
kann ein Zeichen vom Bildschirm gelesen werden. Der Prozeß wartet solange, 
bis ein Zeichen eingegeben wird. Dagegen wird bei 
 
     incharety 
 
niltext geliefert, wenn kein Zeichen eingegeben wurde. Eine weitere 'inchare- 
ty'-Prozedur wartet zusätzlich noch eine angebbare Zeitdauer, ob ein Zeichen 
eingegeben wird. Der Operator 
 
     TIMESOUT 
 
stellt einen TEXT mehrfach auf dem Bildschirm dar. Die Prozedur 
 
     page 
 
positioniert auf einen "neuen Bildschirm": der Bildschirm wird gelöscht und 
der Cursor befindet sich anschließend in der linken oberen Ecke des Bild- 
schirms. 
 
 
 
Manipulation von Texten 
 
Ein Text kann im EUMEL-System bis zu 32 000 Zeichen haben. Für TEXTe 
stehen neben der Zuweisung die Vergleichsoperatoren 
 
     = , < , <= , > , >= , <> 
 
zur Verfügung. Dabei ist die lexikographische Reihenfolge der Zeichen (vergl. 
EUMEL-Zeichensatz) zu beachten. Zur Verkettung zweier TEXTe ist der 
 
     + 
 
Operator vorhanden. Der Operator 
 
     * 
 
nimmt eine Vervielfachung eines TEXTes vor. Der Operator 
 
     CAT 
 
konkateniert den linken mit dem rechten Operanden und weist das Resultat dem 
linken Operanden zu. Die Prozeduren 
 
     pos 
 
liefern die Position des ersten Auftretens eines TEXTes oder einer 
Zeichenklasse in einem anderen TEXT. Die Prozeduren 
 
     code 
 
konvertieren ein Zeichen in einen INT-Wert und umgekehrt (vergl. dazu den 
EUMEL-Zeichensatz) und dienen z.B. zur Behandlung von Zeichen, die nicht 
auf einer Tastatur zu finden sind. Die Prozedur 
 
     compress 
 
schneidet führende und nachfolgende Leerzeichen eines TEXTs ab, während 
 
     delete char              (* ein Zeichen loeschen  *) 
     insert char              (* ein Zeichen einfuegen *) 
 
ein Zeichen einfügt bzw. löscht. Mit 
 
     change 
 
kann bei dem erstmaligen Auftreten eines Teiltextes in einem TEXT dieser 
ersetzt werden. Mit 
 
     change all 
 
kann jedesmal, wenn ein Teiltext in einem TEXT auftritt, dieser durch einen 
anderen Text ersetzt werden. 
 
     LENGTH           (* oder *) 
     length 
 
liefert die Länge (d.h. die Anzahl der Zeichen in einem TEXT einschließlich 
der Leerzeichen) eines TEXTes. Mit 
 
     replace 
 
kann eine Ersetzung eines Teiltextes erzielt werden. Im Gegensatz zu 
'replace' kann sich bei 'change' die Länge des Textes ändern. Mit 
 
     SUB 
     subtext 
 
kann ein Zeichen ('SUB') oder ein Teiltext ('subtext') aus einem Text geholt 
werden. 
 
TEXTe werden im EUMEL-System über einen Heap realisiert, d.h. nicht wie 
andere Objekte auf einem Stack. Das hat u.a. zur Folge, daß TEXT-"Leichen" 
auf dem Heap nicht automatisch beseitigt werden. Darum kann der benötigte 
Speicherplatz durch TEXT-Operationen anwachsen. Der Heap kann nun von 
unnötigem Speicherplatz durch die Prozedur 
 
     collect heap garbage 
 
bereinigt werden. Die Größe des Heaps (in KB) kann durch die Prozedur 
 
     heap size 
 
erfragt werden. Übrigens überprüft der Standard-Monitor nach jedem Kommando 
die Heap-Größe und veranlaßt eine Bereinigung des Heaps, wenn dieser um 
mindestens 4 KB gewachsen ist. 
 
 
 
Mathematische Operationen 
 
Folgende mathematische Prozeduren bzw. Operatoren stehen im EUMEL zur Zeit 
zur Verfügung (manche Prozeduren stehen in mehr als einer Version zur 
Verfügung, z.B. die sin-Prozedur für Radiant und Winkelgrad): 
 
     **                  (* Exponentiation                            *) 
     abs                 (* Absolutbetrag                             *) 
     arctan              (* Arcus Tangens-Funktion                    *) 
     cos                 (* Kosinus-Funktion                          *) 
     e                   (* Eulersche Zahl (2.718282)                 *) 
     pi                  (* Die Zahl pi (3.141593)                    *) 
     exp                 (* Exponential-Funktion                      *) 
     floor               (* REAL mit abgeschnittenen Nachkommastellen *) 
     frac                (* Nachkommastellen eines REALs              *) 
     random, 
     initialize random   (* Zufallszahlen                             *) 
     ln, log2, log10     (* Logarithmus-Funktionen                    *) 
     max, min            (* Minimum bzw. Maximum zweier Werte         *) 
     MOD                 (* Modulo-Funktion                           *) 
     round               (* Rundung                                   *) 
     sign                (* Vorzeichen feststellen                    *) 
     sin                 (* Sinus-Funktion                            *) 
     sqrt                (* Wurzel-Funktion                           *) 
     tan                 (* Tangens-Funktion                          *) 
 
 
 
Konvertierungs-Operationen 
 
Mit den Prozeduren 
 
     text 
 
kann aus einem INT- bzw. REAL-Wert ein TEXT, während mit 
 
     int 
 
aus einem REAL- bzw. TEXT-Wert ein INT und mit 
 
     real 
 
aus einem INT- bzw. TEXT-Wert ein REAL gemacht werden kann. Mit 
 
     last conversion ok 
 
kann abgefragt werden, ob die letzte Umwandlung ohne Fehler bzw. fehlerhaft 
vorgenommen wurde. Mit 
 
     decimal exponent 
 
kann der Exponent eines REAL-Wertes ausgeblendet werden. 
 
 
 
Kommando-Dialog 
 
Die Prozeduren für den Kommando-Dialog dienen zur bequemen Programmierung 
von interaktiven Anfragen an einen Benutzer eines Programms. (Diese 
Prozeduren werden u.a. auch vom Monitor verwendet). Der Kommando-Dialog 
ist im Normalfall eingeschaltet. Mit der Prozedur 
 
     command dialogue 
 
kann man den Kommando-Dialog ein- bzw. ausschalten. Mit der Prozedur 
 
     say 
 
kann - sofern der Kommando-Dialog eingeschaltet ist - ein Text auf dem 
Bildschirm ausgegeben werden. Sofern der Kommando-Dialog eingeschaltet ist, 
schreibt die Prozedur 
 
     yes 
 
einen Text auf den Bildschirm des Benutzers. An den Text wird '(j/n) ?' 
angefügt. Die Prozedur 'yes' liefert den Wert TRUE, sofern der Benutzer auf 
die Frage mit dem Zeichen "j" antwortet und den Wert FALSE, sofern die 
Antwort "n" lautete. Die Prozedur 
 
     no 
 
arbeitet wie 'NOT yes'. 
 
 
 
Verschiedenes 
 
Mit den Prozeduren 
 
     stop 
     errorstop 
 
kann ein Abbruch (letztere mit Meldung; vergl. Fehlerbehandlung im System- 
handbuch) erreicht werden. Die Prozedur 
 
     clock 
 
liefert Zeitwerte als REAL-Wert, nämlich die verbrauchte CPU-Zeit einer Task 
oder die aktuelle Uhrzeit (inklusive Datum). Die Prozedur 
 
     time of day 
 
liefert die aktuelle Uhrzeit. Mit den Konvertierungsprozeduren 
 
     date 
     time 
 
können die Werte der Prozedur 'clock' in eine lesbare Form gebracht werden. 
Mit der Prozedur 
 
     pause 
 
kann eine bestimmte Zeitdauer gewartet werden, ohne den Prozessor zu be- 
lasten. Die Wartezeit wird abgebrochen, wenn die Zeitgrenze erreicht ist 
oder sobald ein Zeichen am Terminal des Benutzers eingegeben wurde. Dieses 
Zeichen wird nicht verarbeitet. 
 
 
 
2. Die EUMEL-Standardpakete 
 
Die elementaren Datentypen BOOL, INT, REAL, TEXT und die entsprechenden Zu- 
weisungsoperatoren werden hier nicht angegeben. 
 
= 
   BOOL OP = (INT CONST a, b) 
   Zweck: Vergleich. 
 
   BOOL OP = (REAL CONST a, b) 
   Zweck: Vergleich. 
 
   BOOL OP = (TEXT CONST left, right) 
   Zweck: Vergleich von zwei Texten auf Gleichheit (Texte mit ungleichen 
          Längen sind immer ungleich). 
 
< 
   BOOL OP < (INT CONST a, b) 
   Zweck: Vergleich auf kleiner. 
 
   BOOL OP < (REAL CONST a, b) 
   Zweck: Vergleich auf kleiner. 
 
   BOOL OP < (TEXT CONST left, right) 
   Zweck: Vergleich zweier Texte auf kleiner ('left' kommt lexikographisch 
          vor 'right'). 
 
> 
   BOOL OP > (INT CONST a, b) 
   Zweck: Vergleich auf größer. 
 
   BOOL OP > (REAL CONST a, b) 
   Zweck: Vergleich auf größer. 
 
   BOOL OP > (TEXT CONST left, right) 
   Zweck: Vergleich zweier Texte auf größer ('left' kommt lexikographisch 
          nach 'right'). 
 
<= 
   BOOL OP <= (INT CONST a, b) 
   Zweck: Vergleich auf kleiner gleich. 
 
   BOOL OP <= (REAL CONST a, b) 
   Zweck: Vergleich auf kleiner gleich. 
 
   BOOL OP <= (TEXT CONST left, right) 
   Zweck: Vergleich von zwei Texten auf kleiner gleich ('left' kommt 
          lexikographisch vor oder ist gleich 'right'). 
 
>= 
   BOOL OP >= (INT CONST a, b) 
   Zweck: Vergleich auf größer gleich. 
 
   BOOL OP >= (REAL CONST a, b) 
   Zweck: Vergleich auf größer gleich. 
 
   BOOL OP >= (TEXT CONST left, right) 
   Zweck: Vergleich zweier Texte auf größer gleich ('left' kommt lexiko- 
          graphisch nach oder ist gleich 'right'). 
 
<> 
   BOOL OP <> (INT CONST a, b) 
   Zweck: Vergleich auf Ungleichheit. 
 
   BOOL OP <> (REAL CONST a, b) 
   Zweck: Vergleich auf Ungleichheit. 
 
   BOOL OP <> (TEXT CONST left, right) 
   Zweck: Vergleich von zwei Texten auf Ungleichheit (Texte mit ungleichen 
          Längen sind stets ungleich). 
 
+ 
   INT OP + (INT CONST a) 
   Zweck: Monadischer Operator (Vorzeichen, ohne Wirkung). 
 
   REAL OP + (REAL CONST a) 
   Zweck: Monadischer Operator (Vorzeichen, ohne Wirkung). 
 
   INT OP + (INT CONST a, b) 
   Zweck: Addition. 
 
   REAL OP + (REAL CONST a, b) 
   Zweck: Addition. 
 
   TEXT OP + (TEXT CONST left, right) 
   Zweck: Verkettung der Texte 'left' und 'right' in dieser Reihenfolge. Die 
          Länge des Resultats ergibt sich aus der Addition der Längen der 
          Operanden. 
 
- 
   INT OP - (INT CONST a) 
   Zweck: Vorzeichen-Umkehrung. 
 
   REAL OP - (REAL CONST a) 
   Zweck: Vorzeichen-Umkehrung. 
 
   INT OP - (INT CONST a, b) 
   Zweck: Subtraktion. 
 
   REAL OP - (REAL CONST a, b) 
   Zweck: Subtraktion. 
 
* 
   INT OP * (INT CONST a, b) 
   Zweck: Multiplikation. 
 
   REAL OP * (REAL CONST a, b) 
   Zweck: Multiplikation. 
 
   TEXT OP * (INT CONST times, TEXT CONST source) 
   Zweck: 'times' fache Erstellung von 'source' und Verkettung. Dabei muß 
 
              times >= 0 
 
          sein, sonst wird 'niltext' geliefert. 
 
/ 
   REAL OP / (REAL CONST a, b) 
   Zweck: Division. 
   Fehlerfall: 
       * Division durch 0 
 
** 
   INT OP ** (INT CONST arg, exp) 
   Zweck: Exponentiation mit 'exp' >= 0 
   Fehlerfälle: 
      * INT OP ** : negative exponent 
          Ein negativer Exponent ist nicht zugelassen. 
      * 0 ** 0 is not defined 
          'arg' und 'exp' dürfen nicht beide 0 sein. 
 
   REAL OP ** (REAL CONST arg, exp) 
   Zweck: Exponentiation. 
   Fehlerfälle: 
      * hoch mit negativer basis 
          Der 'exp' muß >= 0.0 sein. 
      * 0**0 geht nicht 
          'arg' und 'exp' dürfen nicht gleichzeitig 0.0 sein. 
 
   REAL OP ** (REAL CONST arg, INT CONST exp) 
   Zweck: Exponentiation. 
   Fehlerfall: 
      * 0.0 ** 0 geht nicht 
 
abs 
   INT PROC abs (INT CONST argument) 
   Zweck: Absolutbetrag eines INT-Wertes. 
 
   INT OP ABS (INT CONST argument) 
   Zweck: Absolutbetrag eines INT-Wertes. 
 
   REAL PROC abs (REAL CONST value) 
   Zweck: Absolutbetrag eines REAL-Wertes. 
 
   REAL OP ABS (REAL CONST value) 
   Zweck: Absolutbetrag eines REAL-Wertes. 
 
AND 
   BOOL OP AND (BOOL CONST a, b) 
   Zweck: Logisches und. 
 
arctan 
   REAL PROC arctan (REAL CONST x) 
   Zweck: Arcus Tangens-Funktion. Liefert einen Wert in Radiant. 
 
arctand 
   REAL PROC arctand (REAL CONST x) 
   Zweck: Arcus Tangens-Funktion. Liefert einen Wert in Grad. 
 
CAT 
   OP CAT (TEXT VAR left, TEXT CONST right) 
   Zweck: Hat die gleiche Wirkung wie 
 
              left := left + right 
 
          Hinweis: Der Operator 'CAT' hat eine geringere Heap-Belastung als 
          die Operation mit expliziter Zuweisung. 
 
change 
   PROC change (TEXT VAR destination, TEXT CONST old, new) 
   Zweck: Ersetzung des (Teil-) TEXTes 'old' in 'destination' durch 'new' bei 
          dem erstmaligen Auftreten. Ist 'old' nicht in 'source' vorhanden, 
          so wird keine Meldung abgesetzt (Abweichung vom Standard). Beachte, 
          daß sich dabei die Länge von 'destination' verändern kann. 
          Beispiel: 
 
              TEXT VAR mein text :: "EUMEL-Benutzerhandbuch"; 
              change (mein text, "Ben", "N"); (* EUMEL-Nutzerhandbuch *) 
 
PROC change (TEXT VAR destination, INT CONST from, to, TEXT CONST new) 
   Zweck: Der TEXT 'new' wird in den TEXT 'destination' anstatt des TEXTes, 
          der zwischen 'from' und 'to' steht, eingesetzt. Beachte, daß sich 
          dabei die Länge von 'destination' ändern kann. Beispiel: 
 
              TEXT VAR mein text :: "EUMEL-Benutzerhandbuch"; 
              change (mein text, 7, 9, "N");   (* wie oben *) 
 
change all 
   PROC change all (TEXT VAR destination, TEXT CONST old, new) 
   Zweck: Der Teiltext 'old' wird durch 'new' in 'destination' ersetzt. Im 
          Unterschied zur 'change'-Prozedur findet die Ersetzung nicht nur 
          bei dem erstmaligen Auftreten von 'old' statt, sondern so oft, wie 
          'old' in 'destination' vorhanden ist. Beispiel: 
 
 
              TEXT VAR x :: "Das ist ein Satz"; 
              change all (x, " ", "");     (* DasisteinSatz *) 
 
clock 
   REAL PROC clock (INT CONST index) 
   Zweck: Datum und Uhrzeit werden vom EUMEL-System für alle Tasks geführt. 
          Neben einer Uhr ('Realzeituhr'), die das Datum und die aktuelle 
          Uhrzeit enthält, wird eine Uhr für die von der Task verbrauchte 
          CPU-Zeit geführt ('CPU-Zeituhr'). Beide Zeiten werden vom System 
          als REALs realisiert. Die Prozedur 'clock' liefert die aktuellen 
          Werte dieser Uhren. Bei 'index = 0' wird die akkumulierte CPU-Zeit 
          der Task, bei 'index = 1' der Wert der Realzeituhr geliefert. 
 
          Mit den REAL-Werten der Uhren kann ohne weiteres gerechnet werden, 
          jedoch sind nur Werte > 0 definiert. Die REAL-Werte der Realzeit- 
          uhr beginnen beim 1.1.1900 um 0 Uhr. Es sind nur Werte für dieses 
          Jahrhundert zugelassen. Werte der Realzeituhr in lesbarer Form 
          kann man durch die Konvertierungsprozeduren 'date' (für den 
          aktuellen Tag) und 'time of day' (Uhrzeit) erhalten. 
 
          Um die benötigte CPU-Zeit eines Programms zu berechnen, muß man 
          die CPU-Zeituhr zweimal abfragen. Um solche Zeiten in lesbarer 
          Form zu erhalten, kann man die Konvertierungsprozedur 'time' 
          verwenden. Beispiel: 
 
              REAL CONST anfang :: clock (0); 
              berechnungen; 
              REAL CONST ende   :: clock (0); 
              put ("benoetigte CPU-Zeit:"); 
              put (time (ende - anfang)) 
 
code 
   TEXT PROC code (INT CONST code) 
   Zweck: Wandelt einen INT-Wert 'code' in ein Zeichen um. 'code' muß 
 
              1 <= code <= 254 
 
          sein. 
 
   INT PROC code (TEXT CONST text) 
   Zweck: Wandelt ein Zeichen 'text' in einen INT-Wert um. Ist 
 
              LENGTH text <> 1 
 
          dann wird der Wert -1 geliefert (also bei mehr als ein Zeichen 
          oder niltext). 
 
collect heap garbage 
   PROC collect heap garbage 
   Zweck: Bereinigung des Heaps von nicht mehr benötigten TEXTen. 
 
command dialogue 
   PROC command dialogue (BOOL CONST status) 
   Zweck: Ein- bzw. Ausschalten des Kommando-Dialogs. Ist der Kommando- 
          dialog eingeschaltet, dann funktionieren z.B. die Prozeduren 'yes' 
          bzw. 'no' und ein Aufruf der Prozedur 'errorstop' liefert eine 
          Fehlermeldung auf dem Terminal. Ist der Kommandodialog ausge- 
          schaltet, wird z.B. durch die Prozedur 'yes' kein Text ausgegeben 
          (es wird TRUE geliefert) und errorstop erzeugt keine Fehler- 
          meldungen. 
 
   BOOL PROC command dialogue 
   Zweck: Liefert den Wert TRUE, wenn der Kommando-Dialog eingeschaltet 
          ist, andernfalls FALSE. 
 
compress 
   TEXT PROC compress (TEXT CONST text) 
   Zweck: Liefert den TEXT 'text' ohne führende und nachfolgende Leerzeichen. 
 
cos 
   REAL PROC cos (REAL CONST x) 
   Zweck: Kosinus-Funktion. 'x' muß in Radiant angegeben werden. 
 
cosd 
   REAL PROC cosd (REAL CONST x) 
   Zweck: Cosinus-Funktion. 'x' muß in Winkelgrad angegeben werden. 
 
cout 
   PROC cout (INT CONST number) 
   Zweck: Schreibt 'number' an die aktuelle Cursor-Position auf den Bild- 
          schirm. Anschließend wird an diese Position wieder zurück positio- 
          niert. 'number' muß > 0 sein. Paßt 'number' nicht mehr auf die 
          Zeile, so ist die Wirkung von 'cout' nicht definiert. 'cout' gibt 
          den Wert von 'number' nur aus, wenn genügend freie Kanal-Kapazität 
          für diese Ausgabe vorhanden ist. Das hat zur Folge, daß Programme 
          nicht auf die Beendigung einer Ausgabe von 'number' warten müssen 
          und ggf. Ausgaben überschlagen werden. 
 
cursor 
   PROC cursor (INT CONST column, row) 
   Zweck: Positioniert den Cursor auf dem Bildschirm, wobei 'column' die 
          Spalte und 'row' die Zeile angibt. Die zulässigen Bereiche von 
          'column' und 'row' sind geräteabhängig. Zur Zeit gilt auf allen 
          EUMEL-Geräten  
 
              1 <= column <= 80 
              1 <= row <= 24 
 
date 
   TEXT PROC date (REAL CONST time) 
   Zweck: Konvertierungsprozedur für das Datum, welches sich aus dem Aufruf 
          der Prozedur 'clock (1)' ergibt. Das Datum wird in der Form 
          'tt.mm.jj' geliefert. Beispiel: 
 
              put (date (clock (1)))  (* z.B.: 24.12.82 *) 
 
 
   REAL PROC date (TEXT CONST datum) 
   Zweck: Konvertierungsprozedur für ein Datum in der Form 'tt.mm.jj'. 
          Liefert einen REAL-Wert, wie ihn die Prozedur 'clock (1)' liefern 
          würde. Beispiel: 
 
              put (date ("24.12.82")) (* 6.270670e10 *) 
 
   TEXT PROC date 
   Zweck: Liefert das Tagesdatum. Wirkt wie 'date (clock (1))', ist jedoch 
          erheblich schneller. 
 
day 
   REAL CONST day 
   Zweck: Liefert die Anzahl der Sekunden eines Tages (86 400.0). 
 
decimal exponent 
   INT PROC decimal exponent (REAL CONST mantisse) 
   Zweck: Liefert aus einem REAL-Wert den dezimalen Exponenten als INT-Wert. 
 
DECR 
   OP DECR (INT VAR left, INT CONST right) 
   Zweck: Wirkt wie left := left - right 
 
   OP DECR (REAL VAR left, REAL CONST right) 
   Zweck: Wirkt wie left := left - right 
 
delete char 
   PROC delete char (TEXT VAR string, INT CONST delete pos) 
   Zweck: Löscht ein Zeichen aus dem Text 'string' an der Position 'delete 
          pos'. Für 
 
              delete pos <= 0 
 
          oder 
 
              delete pos > LENGTH string 
 
          wird keine Aktion vorgenommen. 
 
DIV 
   INT OP DIV (INT CONST a, b) 
   Zweck: INT-Division. 
   Fehlerfall: 
      * DIV by 0 
          Division durch Null. 
 
e 
   REAL CONST e 
   Zweck: Eulersche Zahl (2.718282). 
 
errorstop 
   PROC errorstop (TEXT CONST error message) 
   Zweck: Abbruch unter Ausgabe einer Fehlermeldung (vergl. Fehlerbehand- 
          lung). 
 
exp 
   REAL PROC exp (REAL CONST z) 
   Zweck: Exponentialfunktion. 
 
floor 
   REAL PROC floor (REAL CONST real) 
   Zweck: Schneidet die Nachkommastellen des REAL-Wertes 'real' ab. 
 
frac 
   REAL PROC frac (REAL CONST z) 
   Zweck: Liefert die Stellen eines REAL-Wertes hinter dem Dezimalpunkt. 
 
get 
   PROC get (INT VAR number) 
   Zweck: Einlesen eines INT-Wertes vom Bildschirm. Der einzulesende INT- 
          Wert kann bei der Eingabe vom Terminal editiert werden. Die 
          Eingabe kann vom Benutzer-Terminal so umgeleitet werden, daß sie 
          von einer Datei aus erfolgt (vergl. 'sysin'). 
 
   PROC get (REAL VAR value) 
   Zweck: Einlesen eines REAL-Wertes vom Bildschirm. Der einzulesende 
          REAL-Wert kann bei der Eingabe vom Terminal editiert werden. Die 
          Eingabe kann vom Benutzer-Terminal so umgeleitet werden, daß sie 
          von einer Datei aus erfolgt (vergl. 'sysin'). 
 
   PROC get (TEXT VAR word) 
   Zweck: Liest einen Text in die Variable 'word' mit maximal 255 Zeichen. 
          Es werden solange Zeichen vom Terminal gelesen, bis ein Leer- 
          zeichen oder ein Positionierungszeichen eingegeben wird. Dabei 
          werden führende Leerzeichen übergeben. Der einzulesende Text kann 
          bei der Eingabe editiert werden. Eine leere Eingabe ist nicht 
          erlaubt. Die Eingabe kann vom Benutzer-Terminal so umgeleitet 
          werden, daß sie von einer Datei aus erfolgt (vergl. 'sysin'). 
 
   PROC get (TEXT VAR word, INT CONST laenge) 
   Zweck: Liest einen Text vom Bildschirm mit der Länge 'laenge' oder bis 
          ein Positionierungszeichen angetroffen wird. Der einzulesende Wert 
          kann bei der Eingabe editiert werden. Dabei gilt: 
 
              1 <= laenge <= 255 
 
   PROC get (TEXT VAR word, TEXT CONST separator) 
   Zweck: Liest einen Text vom Bildschirm, bis ein Zeichen 'separator' ange- 
          troffen oder ein Positionierungszeichen eingegeben wird. Der ein- 
          zulesende Text kann bei der Eingabe editiert werden. 
 
get cursor 
   PROC get cursor (INT VAR x, y) 
   Zweck: Erfragung der aktuellen Cursor-Position. Die Koordinaten des Cur- 
          sors werden in 'x' und 'y' geliefert. Die aktuelle Cursor-Position 
          ist nach Ausgabe von 'HOME' (Code = 1) oder einer Positionierung 
          des Cursors mit der Prozedur 'cursor' stets definiert. Die Proze- 
          dur 'get cursor' liefert jedoch undefinierte Werte, wenn über den 
          rechten Rand einer Zeile hinausgeschrieben wurde (die Wirkung 
          einer solchen Operation hängt von der Hardware eines Terminals ab). 
 
getline 
   PROC get line (TEXT VAR line) 
   Zweck: Das System wartet auf eine Zeile vom Bildschirm (max. 255 Zeichen). 
          Eine leere Eingabe ist nicht möglich. Die Eingabe kann vom Benut- 
          zer-Terminal so umgeleitet werden, daß sie von einer Datei aus 
          erfolgt (vergl. 'sysin'). 
 
heap size 
   INT PROC heap size 
   Zweck: Informationsprozedur für die Größe (in KB) des TEXT-Heaps. 
 
hour 
   REAL CONST hour 
   Zweck: Liefert die Anzahl der Sekunden einer Stunde (3600.0). 
 
inchar 
   PROC inchar (TEXT VAR character) 
   Zweck: Wartet solange, bis ein Zeichen von der Tastatur eingegeben wird, 
          und schreibt dieses Zeichen in die Variable 'character'. 
 
incharety 
   TEXT PROC incharety 
   Zweck: Versucht, ein Zeichen von der Tastatur zu lesen. Wurde kein 
          Zeichen eingegeben, wird niltext geliefert. 
 
   TEXT PROC incharety (INT CONST time limit) 
   Zweck: Versucht, ein Zeichen vom Bildschirm zu lesen. Dabei wird maximal 
          eine 'time limit' lange Zeit auf das Zeichen gewartet (gemessen in 
          Zehntel-Sekunden). 
 
INCR 
   OP INCR (INT VAR left, INT CONST right) 
   Zweck: Wirkt wie left := left + right 
 
   OP INCR (REAL VAR left, REAL CONST right) 
   Zweck: Wirkt wie left := left + right 
 
initialize random 
   PROC initialize random (INT CONST value) 
   Zweck: Initialisieren der 'random'-Prozedur, um nicht reproduzierbare 
          Zufallszahlen zu bekommen. Diese 'init random'-Prozedur gilt für 
          den "INT-Random Generator". 
 
   PROC initialize random (REAL CONST z) 
   Zweck: Initialisieren der 'random'-Prozedur mit verschiedenen Werten für 
          'z', um nicht reproduzierbare Zufallszahlen zu bekommen. Diese 
          Prozedur gilt für den "REAL-Random Generator". 
 
insert char 
   PROC insert char (TEXT VAR string, TEXT CONST char, INT CONST insert pos) 
   Zweck: Fügt ein Zeichen 'char' in den Text 'string' an der Position 
          'insert pos' ein. Für 
 
              insert pos > LENGTH string + 1 
 
          wird keine Aktion vorgenommen. Daher ist es möglich, mit dieser 
          Prozedur auch am Ende eines Textes (Position: LENGTH string + 1) 
          ein Zeichen anzufügen. 
 
int 
   INT PROC int (REAL CONST a) 
   Zweck: Konvertierungsprozedur. 
 
   INT PROC int (TEXT CONST number) 
   Zweck: Umwandlung eines Textes in einen INT-Wert. Der Text 'number' darf 
          ein "+"- oder "-"-Zeichen vor den Ziffern enthalten. Führende 
          Blanks werden überlesen. Enthält 'number' an einer Position ein 
          Zeichen, das nicht umgewandelt werden kann, so wird die Umwand- 
          lung gestoppt und der bis dahin umgewandelte Wert (bzw. der Wert 0) 
          geliefert. 
 
last conversion ok 
   BOOL PROC last conversion ok 
   Zweck: Liefert den Wert TRUE, sofern die letzte Konvertierungsprozedur 
          nicht auf einen Fehler bei der Umwandlung gestoßen ist, andernfalls 
          FALSE. 
 
length 
   INT PROC length (TEXT CONST text) 
   Zweck: Anzahl von Zeichen ("Länge") von 'text' einschließlich Leerzeichen. 
 
LENGTH 
   INT OP LENGTH (TEXT CONST text) 
   Zweck: Anzahl von Zeichen ("Länge") von 'text' einschließlich Leerzeichen. 
 
line 
   PROC line 
   Zweck: Es wird zum Anfang einer neuen Zeile positioniert. 
 
   PROC line (INT CONST number) 
   Zweck: Es werden 'number' Zeilenwechsel vorgenommen. 
 
ln 
   REAL PROC ln (REAL CONST x) 
   Zweck: Natürlicher Logarithmus. 
   Fehlerfall: 
      * ln mit nicht positiver Zahl 
          Nur echt positive Argumente sind zulässig. 
 
log2 
   REAL PROC log2 (REAL CONST z) 
   Zweck: Logarithmus zur Basis 2. 
   Fehlerfall: 
      * log2 mit negativer zahl 
          Nur echt positive Argumente sind zulässig. 
 
log10 
   REAL PROC log10 (REAL CONST x) 
   Zweck: Logarithmus zur Basis 10. 
   Fehlerfall: 
      * log10 mit negativer zahl 
          Nur echt positive Argumente sind zulässig. 
 
max 
   INT PROC max (INT CONST first, second) 
   Zweck: Liefert den Größten der beiden INT-Werte. 
 
   REAL PROC max (REAL CONST first, second) 
   Zweck: Liefert den Größten der beiden REAL-Werte. 
 
maxint 
   INT CONST maxint 
   Zweck: Größter INT-Wert im EUMEL-System (32 767). 
 
maxreal 
   REAL CONST maxreal 
   Zweck: Größter REAL-Wert im EUMEL-System (9.999999999999e126). 
 
max text length 
   INT CONST max text length 
   Zweck: Maximale Anzahl von Zeichen in einem TEXT (32 000). 
 
min 
   INT PROC min (INT CONST first, second) 
   Zweck: Liefert den Kleinsten der beiden INT-Werte. Beispiele: 
 
              min (3.0,  2.0) ==> 2.0 
              min (-2.0, 3.0) ==> -2.0 
 
   REAL PROC min (REAL CONST first, second) 
   Zweck: Liefert den Kleinsten der beiden REAL-Werte. 
 
MOD 
   INT OP MOD (INT CONST left, right) 
   Zweck: Liefert den Rest einer INT-Division. Beispiele: 
 
             3 MOD 2 ==> 1 
            -3 MOD 2 ==> 1 
 
   Fehlerfall: 
      * DIV by 0 
          Division durch 0 ist verboten. 
 
   REAL OP MOD (REAL CONST left, right) 
   Zweck: Modulo-Funktion für REALs (liefert den Rest). Beispiele: 
 
             5.0 MOD 2.0 ==> 1.0 
             4.5 MOD 4.0 ==> 0.5 
 
no 
   BOOL PROC no (TEXT CONST question) 
   Zweck: Wirkt wie 
 
              NOT yes 
 
NOT 
   BOOL OP NOT (BOOL CONST a) 
   Zweck: Logische Negation. 
 
online 
   BOOL PROC online 
   Zweck: Liefert TRUE, wenn die Task mit einem Terminal gekoppelt ist. 
 
OR 
   BOOL OP OR (BOOL CONST a, b) 
   Zweck: Logisches oder. 
 
out 
   PROC out (TEXT CONST text) 
   Zweck: Ausgabe eines Textes auf dem Bildschirm. Im Unterschied zu 'put' 
          wird kein Blank an den ausgegebenen Text angefügt. 'out' kann 
          nicht umgeleitet werden (vergl. 'sysout'). 
 
out subtext 
   PROC out subtext (TEXT CONST source, INT CONST from) 
   Zweck: Ausgabe eines Teiltextes von 'source' von der Position 'from' bis 
          Textende. Es wird keine Aktion vorgenommen für 
 
              from > LENGTH source 
 
   PROC out subtext (TEXT CONST source, INT CONST from, to) 
   Zweck: Ausgabe eines Teiltextes von 'source' von der Position 'from' bis 
          zur Position 'to'. Für 
 
              to > LENGTH source 
 
          wird für die fehlenden Zeichen Leerzeichen (blanks) ausgegeben. 
 
page 
   PROC page 
   Zweck: Es wird zum Anfang einer neuen Seite positioniert (hier: linke 
          obere Ecke des Bildschirms, wobei der Bildschirm gelöscht wird). 
 
pause 
   PROC pause (INT CONST time limit) 
   Zweck: Wartet 'time limit' in Zehntel-Sekunden. Bei negativen Werten ist 
          die Wirkung nicht definiert. Die Wartezeit wird nicht nur durch 
          das  Erreichen der Grenze abgebrochen, sondern auch durch die 
          Eingabe eines beliebigen Zeichens. 
 
pi 
   REAL CONST pi 
   Zweck: Die Zahl pi (3.141593). 
 
pos 
   INT PROC pos (TEXT CONST source, pattern) 
   Zweck: Liefert die erste Position des ersten Zeichens von 'pattern' in 
          'source', falls 'pattern' gefunden wird. Wird 'pattern' nicht 
          gefunden oder ist 'pattern' niltext, so wird der Wert '0' ge- 
          liefert. Beispiel: 
 
               TEXT VAR t1 :: "abcdefghijk...xyz", 
                        t2 :: "cd"; 
               ... pos (t1, t2) ... (* liefert 3 *) 
               ... pos (t2, t1) ... (* liefert 0 *) 
 
   INT PROC pos (TEXT CONST source, pattern, INT CONST from) 
   Zweck: Wie obige Prozedur, jedoch wird erst ab der Position 'from' ab 
          gesucht. Dabei gilt folgende Einschränkung: 
 
               length (pattern) < 255 
 
INT PROC pos (TEXT CONST source, low char, high char, INT CONST from) 
   Zweck: Liefert die Position des ersten Zeichens 'x' in 'source' ab der 
          Position 'from', so daß 
 
              low char <= x <= high char 
 
          'low char' und 'high char' müssen TEXTe der Länge 1 sein. Wird 
          kein Zeichen in 'source' in dem Bereich zwischen 'low char' und 
          'high char' gefunden, wird der Wert '0' geliefert. Beispiel: 
 
         (* Suche nach dem ersten Zeichen <> blank nach einer Leerspalte *) 
         TEXT VAR zeile :: "BlaBla       Hier gehts weiter"; 
         INT VAR pos erstes blank :: pos (zeile, " "), 
          ende leerspalte  :: pos (zeile, ""33"", ""254"", pos erstes blank); 
 
put 
   PROC put (INT CONST number) 
   Zweck: Ausgabe eines INT-Wertes auf dem Bildschirm. Anschließend wird 
          ein Leerzeichen ausgegeben. Die Ausgabe kann umgeleitet werden 
          (vergl. 'sysout'). 
 
   PROC put (REAL CONST real) 
   Zweck: Ausgabe eines REAL-Wertes auf dem Bildschirm. Anschließend wird 
          ein Leerzeichen ausgegeben. Die Ausgabe kann umgeleitet werden 
          (vergl. 'sysout') 
 
   PROC put (TEXT CONST text) 
   Zweck: Ausgabe eines Textes auf dem Bildschirm. Nach der Ausgabe von 
          'text' wird ein Blank ausgegeben, um nachfolgenden Ausgaben auf 
          der gleichen Zeile voneinander zu trennen. Hardwareabhängig sind 
          die Aktionen, wenn eine Ausgabe über eine Zeilengrenze (hier: 
          Bildschirmzeile) vorgenommen wird. Meist wird die Ausgabe auf der 
          nächsten Zeile fortgesetzt. Die Ausgabe kann umgeleitet werden 
          (vergl. 'sysout'). 
 
putline 
   PROC putline (TEXT CONST text) 
   Zweck: Ausgabe von 'text' auf dem Bildschirm. Nach der Ausgabe wird auf 
          den Anfang der nächsten Zeile positioniert. Gibt man TEXTe nur mit 
          'putline' aus, so ist gesichert, daß jede Ausgabe auf einer neuen 
          Zeile beginnt. Hardwareabhängig sind die Aktionen, wenn eine Aus- 
          gabe über eine Zeilengrenze (hier: Bildschirmzeile) vorgenommen 
          wird. Meist wird die Ausgabe auf der nächsten Zeile fortgesetzt. 
          Die Ausgabe kann umgeleitet werden (vergl. 'sysout'). 
 
random 
   INT PROC random (INT CONST lower bound, upper bound) 
   Zweck: Pseudo-Zufallszahlen-Generator im Intervall 'upper bound' und 
          'lower bound' einschließlich. Es handelt sich hier um den "INT 
          Random Generator". 
 
   REAL PROC random 
   Zweck: Pseudo-Zufallszahlen-Generator im Intervall 0 und 1. Es handelt 
          sich hier um den "REAL Random Generator". 
 
real 
   REAL PROC real (INT CONST a) 
   Zweck: Konvertierungsprozedur. 
 
   REAL PROC real (TEXT CONST text) 
   Zweck: Konvertierung eines TEXTes 'text' in einen REAL-Wert. Achtung: Zur 
          Zeit werden keine Überprüfungen vorgenommen, d.h. in dem TEXT 
          muß ein REAL-Wert stehen. 
 
replace 
   PROC replace (TEXT VAR destination, INT CONST position, TEXT CONST source) 
   Zweck: Ersetzung eines Teiltextes in 'destination' durch 'source' an der 
          Position 'position' in 'destination'. Es muß gelten 
 
              1 <= position <= LENGTH destination 
 
          d.h. 'position' muß innerhalb von 'destination' liegen und 'source' 
          muß  von der Position 'position' ab in 'destination' einsetzbar 
          sein. Dabei bleibt die Länge von 'destination' unverändert. 
 
round 
   REAL PROC round (REAL CONST real, INT CONST digits) 
   Zweck: Runden eines REAL-Wertes auf 'digits' Stellen. Für positive Werte 
          wird auf Nachkommastellen gerundet. Beispiel: 
 
              round (3.14159, 3) 
 
          liefert '3.142'. Für negative 'digits'-Werte wird auf Vorkomma- 
          stellen gerundet. Beispiel: 
 
              round (123.456, -2) 
 
          liefert '100.0'. Abweichung vom Standard: Es wird mit 'digits'- 
          Ziffern gerundet. 
 
say 
   PROC say (TEXT CONST message) 
   Zweck: Sofern der Kommando-Dialog eingeschaltet ist (vergl. 'command 
          dialogue'), wird der TEXT 'message' an die augenblickliche Cursor- 
          Position geschrieben. 
 
sign 
   INT PROC sign (INT CONST argument) 
   Zweck: Feststellen des Vorzeichens eines INT-Wertes. Folgende Werte 
          werden geliefert: 
 
              argument > 0     ==> 1 
              argument = 0     ==> 0 
              argument < 0     ==> -1 
 
   INT OP SIGN (INT CONST argument) 
   Zweck: Feststellen des Vorzeichens eines INT-Wertes. 
 
   INT PROC sign (REAL CONST number) 
   Zweck: Feststellen des Vorzeichens eines REAL-Wertes. 
 
   INT OP SIGN (REAL CONST number) 
   Zweck: Feststellen des Vorzeichens eines REAL-Wertes. 
 
sin 
   REAL PROC sin (REAL CONST x) 
   Zweck: Sinus-Funktion. 'x' muß in Radiant (Bogenmaß) angegeben werden. 
 
sind 
   REAL PROC sind (REAL CONST x) 
   Zweck: Sinus-Funktion. 'x' muß im Winkelgrad angegeben werden. 
 
smallreal 
   REAL PROC smallreal 
   Zweck: Kleinster darstellbarer REAL-Wert im EUMEL-System für den 
 
              1.0 - smallreal <> 1.0 
              1.0 + smallreal <> 1.0 
 
          gilt (1.0E-12). 
 
sqrt 
   REAL PROC sqrt (REAL CONST z) 
   Zweck: Wurzel-Funktion. 
   Fehlerfall: 
      * sqrt von negativer Zahl 
          Das Argument muß größer gleich 0.0 sein. 
 
stop 
   PROC stop 
   Zweck: Abbruch (vergl. Fehlerbehandlung). 
 
SUB 
   TEXT OP SUB (TEXT CONST text, INT CONST pos) 
   Zweck: Liefert ein Zeichen aus 'text' an der Position 'pos'. Entspricht 
 
              subtext (text, pos, pos) 
 
          Anmerkung: Effizienter als obiger Prozedur-Aufruf. Für 
 
              pos <= 0 
              pos > LENGTH text 
 
          wird niltext geliefert. 
 
subtext 
   TEXT PROC subtext (TEXT CONST source, INT CONST from) 
   Zweck: Teiltext von 'source', der bei der Position 'from' anfängt. Die 
          Länge des Resultats ergibt sich also zu 
 
              LENGTH source - from + 1 
 
          d.h. von der Position 'from' bis zum Ende von 'source'. 'from' muß 
          innerhalb von 'source' liegen. Ist from < 1, dann wird 'source' 
          geliefert. Falls from > LENGTH source ist, wird niltext geliefert. 
 
   TEXT PROC subtext (TEXT CONST source, ITT CONST from, to) 
   Zweck: Teiltext von 'source' von der Position 'from' bis einschließlich 
          der Position 'to'. Die Länge des Resultats ist also  
 
              from - to + 1 
 
          Dabei muß gelten 
 
              1 <= from <= to <= LENGTH source 
 
          d.h. die Positionen 'from' und 'to' müssen in dieser Reihenfolge 
          innerhalb von 'source' liegen. Ist 
 
              to >= LENGTH source 
 
          wird 'subtext (source, from)' ausgeführt. Für die Bedingungen für 
          'from' siehe vorstehende Beschreibung von 'subtext'. 
 
sysin 
   PROC sysin (TEXT CONST file name) 
   Zweck: Eingabe-Routinen ('get', 'getline' und 'line') lesen nicht mehr 
          vom Benutzer-Terminal, sondern aus der Datei 'file name'. 
 
   TEXT PROC sysin 
   Zweck: Liefert den Namen der eingestellten 'sysin'-Datei. "" bezeichnet 
          das Benutzer-Terminal. 
 
sysout 
   PROC sysout (TEXT CONST file name) 
   Zweck: Ausgabe-Routinen ('put', 'putline', 'write', 'line') gehen nicht 
          mehr zum Benutzer-Terminal, sondern in die Datei 'file name'. 
 
   TEXT PROC sysout 
   Zweck: Liefert den Namen der eingestellten 'sysout'-Datei. "" bezeichnet 
          das Benutzer-Terminal. 
 
tan 
   REAL PROC tan (REAL CONST x) 
   Zweck: Tangens-Funktion. 'x' muß in Radiant angegeben werden. 
 
tand 
   REAL PROC tand (REAL CONST x) 
   Zweck: Tangens-Funktion. 'x' muß in Winkelgrad angegeben werden. 
 
text 
   TEXT PROC text (INT CONST number) 
   Zweck: Umwandlung eines INT-Wertes in einen Text. Negative Werte werden 
          mit einem "-"-Zeichen geliefert. 
 
   TEXT PROC text (INT CONST number, laenge) 
   Zweck: Umwandlung eines INT-Wertes 'number' in einen Text mit der Länge 
          'laenge'. Für 
 
              LENGTH (text (number)) < laenge 
 
          werden die Ziffern rechtsbündig in einen Text mit der Länge 
          'laenge' eingetragen. Fehlende Ziffern der gewünschten 'laenge' 
          werden im TEXT vorne mit Leerzeichen aufgefüllt. Für 
 
              LENGTH (text (number)) > laenge 
 
          wird ein Text mit der Länge 'laenge' geliefert, der mit 
          "*"-Zeichen gefüllt ist. 
 
   TEXT PROC text (REAL CONST real) 
   Zweck: Konvertierung eines REAL-Wertes in einen TEXT. Ggf. wird der TEXT 
          in Exponenten-Darstellung geliefert. 
 
   TEXT PROC text (REAL CONST real, laenge) 
   Zweck: Siehe oben. 'laenge' gibt die Anzahl von Zeichen an. 
 
   TEXT PROC text (REAL CONST real, INT CONST laenge, fracs) 
   Zweck: Konvertierung eines REAL-Wertes in einen TEXT. Dabei gibt 'laenge' 
          die Länge des Resultats einschließlich des Dezimalpunktes und 
          'fracs' die Anzahl der Dezimalstellen an. Kann der REAL-Wert nicht 
          wie gewünscht dargestellt werden, wird 
 
              laenge * "*" 
 
          geliefert. 
 
   TEXT PROC text (TEXT CONST source, INT CONST laenge) 
   Zweck: Teiltext aus 'source' mit der Länge 'laenge', beginnend bei der 
          Position 1 von 'source'. Es muß gelten 
 
              1 <= laenge <= LENGTH source 
 
          d.h. der gewünschte Teiltext muß aus 'source' ausblendbar sein. 
          Wenn 
 
              laenge > LENGTH source 
 
          die Länge des gewünschten Resultats ist größer als die Länge von 
          'source' ist, wird der zu liefernde TEXT mit der an 'laenge' 
          fehlenden Zeichen mit Leerzeichen aufgefüllt. 
 
   TEXT PROC text (TEXT CONST source, INT CONST laenge, from) 
   Zweck: Teiltext aus 'source' mit der Länge 'laenge', beginnend an der 
          Position 'from' in dem TEXT 'source'. Entspricht 
 
              text (subtext (source, from, LENGTH source), laenge) 
 
          Es muß 
 
              laenge >= 0 
              1 <= from <= LENGTH source 
 
          gelten, d.h. 'from' muß eine Position angeben, die innerhalb von 
          'source' liegt. Für 
 
              laenge > LENGTH source - from + 1 
 
          also wenn die angegebene Länge 'laenge' größer ist als der auszu- 
          blendende Text, wird das Resultat rechts mit Leerzeichen aufge- 
          füllt. Wenn 
 
              laenge < LENGTH source - from + 1 
 
          d.h. wenn die angegebene Länge kleiner ist als der Teiltext von 
          'from' bis zum letzten Zeichen von 'source', wird das Resultat mit 
          der Länge 
 
              LENGTH source - from + 1 
 
          geliefert. 
 
time 
   TEXT PROC time (REAL CONST time) 
   Zweck: Konvertierungsprozedur für die Zeiten der CPU-Zeituhr. Liefert die 
          Zeiten in der Form 'hh:mm:ss.s'. Vergl. dazu 'clock'. 
 
   TEXT PROC time (REAL CONST value, INT CONST laenge) 
   Zweck: Konvertiert die Zeit in externe Darstellung. Für die 'laenge'- 
          Werte ergibt sich: 
 
              laenge = 10              (*   hh:mm:ss.s *) 
              laenge = 12              (*  hhh:mm:ss.s *) 
 
REAL PROC time (TEXT CONST time) 
   Zweck: Konvertierungsprozedur für Texte der CPU-Zeituhr in REAL-Werte. 
 
time of day 
   TEXT PROC time of day (REAL CONST time) 
   Zweck: Konvertierungsprozedur für REALs, wie sie die Realzeituhr 
          liefert. Es wird die Tageszeit in der Form 'hh:mm' geliefert. 
          Beispiel: 
 
              put (time of day (clock (1)))  (* z.B.: 17:25 *) 
 
 
   TEXT PROC time of day 
   Zweck: Liefert die aktuelle Tageszeit. Entspricht 
 
              time of day (clock (1)) 
 
TIMESOUT 
   OP TIMESOUT (INT CONST times, TEXT CONST text) 
   Zweck: Ausgabe eines TEXTes 'text' 'times'mal. An die Ausgabe wird im 
          Gegensatz zu 'put' kein Leerzeichen angefügt. Es wird kein Text 
          ausgegeben für 
 
              times < 1 
 
write 
   PROC write (TEXT CONST text) 
   Zweck: Gibt 'text' ohne Trennblank aus ('put' mit Trennblank). Läßt sich 
          im Gegensatz zu 'out' in eine Datei umleiten (vergl. 'sysout'). 
 
XOR 
   BOOL OP XOR (BOOL CONST a, b) 
   Zweck: Exklusives oder. 
 
yes 
   BOOL PROC yes (TEXT CONST question) 
   Zweck: Sofern der Kommando-Dialog (vergl. 'command dialogue') einge- 
          schaltet ist, wird der TEXT 'question' auf dem Bildschirm des 
          Benutzers geschrieben. Der TEXT 'question' wird dabei mit einem 
          Fragezeichen ergänzt. Der Benutzer kann nun am Terminal mit den 
          Zeichen 'j' oder 'n' antworten (oder: 'J', 'N', 'y', 'n', 'Y', 
          'N'). Nach Eingabe eines dieser Zeichen wird von der Prozedur 
          'yes' auf eine neue Zeile positioniert. Die Prozedur 'yes' liefert 
          den Wert TRUE bei der Eingabe von 'j' und den Wert FALSE bei der 
          Eingabe von 'n'. Ist der Kommando-Dialog nicht eingeschaltet, 
          liefert die Prozedur 'yes' den Wert TRUE. 

