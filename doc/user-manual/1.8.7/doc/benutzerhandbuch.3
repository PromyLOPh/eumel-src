#start(5.0,1.5)##pagenr("%",1)##setcount(1)##block##pageblock##count per page# 
#headeven# 
#lpos(0.0)##cpos(5.5)##rpos(11.0)# 
#table# 
                     EUMEL-Benutzerhandbuch    
#fillchar(" ")# 
#on("u")#       #off("u")# 
#table end##clear pos# 
 
#end# 
#headodd# 
#lpos(0.0)##cpos(5.5)##rpos(11.0)##fillchar(" ")# 
#table# 
     Teil 3: Der Monitor    
#fillchar(" ")# 
#on("u")#       #off("u")# 
#table end##clear pos# 
 
#end# 
#bottomeven# 
 
#lpos(0.0)##cpos(5.5)##rpos(11.0)# 
#table# 
#fillchar(" ")# 
#on("u")#       #off("u")# 
#fillchar(" ")# 
3 - %         GMD 
#tableend##clearpos# 
#end# 
#bottomodd# 
 
#lpos(0.0)##cpos(5.5)##rpos(11.0)# 
#table# 
#fillchar(" ")# 
#on("u")#       #off("u")# 
#fillchar(" ")# 
GMD        3 - % 
#tableend##clearpos# 
#end# 
 
TEIL 3: Der Monitor 
#free(1.0)# 
#ib(9)#3.1. Der Monitor#ie(9)# 
#free(1.0)# 
 
   
  Der Monitor nimmt die Kommandos des Benutzers entgegen, die dieser innerhalb
  seiner Task gibt. In diesem Kapitel sind die gebräuchlichen Kommandos zur Text­
  verarbeitung beschrieben. 
 
                     
#free(1.0)# 
 
Der #ib#Monitor#ie# ist der Empfänger der Kommandos in einer EUMEL-Task. Jede Task
und somit jeder aktive Benutzer eines EUMEL-Systems verfügt über einen eigenen
Monitor. Halten Sie sich an dieser Stelle vor Augen:  
#on("i")##on("b")# 
 
 
Der SUPERVISOR ist die Task, die die Aufsicht über
alle weiteren Tasks des EUMEL-Systems hat. 
 
Der Monitor ist der Befehlsempfänger in Ihrer Task.
Jede Task hat einen Monitor. 
 
#goalpage("Mon-kdo")# 
Der Monitor in Ihrer Task macht sich direkt bemerkbar durch die Zeile: 
 
____________________________________________________________________________ 
 
#ib#gib kommando#ie# : 
____________________________________________________________________________ 
 
 
Die Kommandos der Monitor-Ebene, die Sie an dieser Stelle eingeben können,
lassen sich in Gruppen ordnen: 
#on("b")# 
 
 
Informationskommandos #off("b")# 
 
     #ib#storage info#ie#                 Belegten Speicherplatz anzeigen. 
     #ib#task info#ie#                    Im System befindliche Tasks anzeigen. 
     #ib#task status#ie#                  Zustand der Task anzeigen. 
 
 
#on("b")# 
Kommandos zur Tasksteuerung #off("b")# 
 
     #ib#break#ie#                        Task abkoppeln. 
     #ib#end#ie#                          Task löschen. 
     #ib#global manager#ie#               Task zum Manager machen, d.h. 
                                  Sohn-Tasks können eingerichtet 
                                  werden. 
 
 
#on("b")# 
Kommandos zur Dateibearbeitung #off("b")# 
 
     #ib#copy#ie# ("dateiname","kopie")   Datei kopieren. 
     #ib#edit#ie# ("dateiname")           Editor aufrufen. 
     #ib#forget#ie# ("dateiname")         Datei löschen. 
     #ib#list#ie#                         Dateien auflisten. 
     #ib#rename#ie# ("dateiname","neu")   Datei umbenennen. 
 
#on("b")# 
Transport von Dateien#off("b")# 
 
     #ib#fetch#ie# ("dateiname")          Datei von Vater-Task holen. 
     #ib#erase#ie# ("dateiname")          Datei in Vater-Task löschen. 
     #ib#save#ie# ("dateiname")           Datei zu Vater-Task senden. 
 
 
#on("b")# 
Archiv-Kommandos#off("b")# 
 
     #ib#archive#ie# ("name")             Archivlaufwerk reservieren. 
     #ib#fetch#ie# ("dateiname",archive)  Datei von Archiv holen. 
     #ib#save#ie# ("dateiname",archive)   Datei auf Archiv schreiben. 
     #ib#list (archive)#ie#               Inhalt des Archivs listen. 
     #ib#check#ie# ("dateiname",archive)  Datei auf Lesbarkeit prüfen. 
     #ib#clear#ie# (archive)              Archiv löschen/umbenennen. 
     #ib#format (archive)#ie#             Archivdiskette für Benutzung 
                                  vorbereiten. 
 
#on("b")# 
Textverarbeitung                     #off("b")# 
 
     #ib#list fonts#ie#                   Nennt die eingestellten
                                  Schrifttypen. 
     #ib#fonttable#ie#                    Stellt die gewünschte Fonttabelle ein. 
     #ib#lineform#ie# ("dateiname")       Zeilenweise formatieren. 
     #ib#autoform#ie# ("dateiname")       Automatische Zeilenformatierung. 
     #ib#pageform#ie# ("dateiname")       Seitenweise formatieren. 
     #ib#autopageform#ie# ("dateiname")   Automatische Seitenformatierung. 
     #ib#index#ie# ("dateiname.p")        Stichwortverzeichnis erzeugen. 
     #ib#outline#ie# ("dateiname")        Übersicht bzw. Kurzfassung eines
                                  Textes erstellen. 
     #ib#print#ie# ("dateiname")          Datei drucken. 
 
 
 
#on("b")# 
Passwortschutz                     #off("b")# 
 
     #ib#task password#ie# ("geheim")     Passwort für existierende Task festlegen. 
     #ib#begin password#ie# ("geheim")    Passwort für neue Task festlegen. 
     #ib#family password#ie# ("geheim")   Passwort für mehrere Tasks 
                                  festlegen. 
     #ib#enter password#ie# ("geheim")    Passwort für Datei festlegen. 
 
#page# 
3.1.1. Informationskommandos 
#free(1.0)# 
 
   
  Mit den Informationskommandos können Informationen zur eigenen Task bzw. zum
  gesamten System abgerufen werden. 
                                         
#free(0.5)# 
 
Bereits von Teil 2 bekannt sind die Informationskommandos 'ESC s' und 'ESC t'. Auf
der Monitor-Ebene ist die abkürzende Schreibweise nicht voreingestellt. 
 
____________________________________________________________________________ 
 
gib kommando : 
storage info 
 
____________________________________________________________________________ 
 
 
gibt Auskunft über den belegten Speicherplatz auf dem EUMEL-Hintergrundspeicher. 
 
____________________________________________________________________________ 
 
gib kommando : 
task info 
 
____________________________________________________________________________ 
 
 
gibt Auskunft über die Namen der im EUMEL-System befindlichen Tasks und die
Struktur des Taskbaums. 
#page# 
Auf Monitor-Ebene kann durch zusätzliche Angabe einer Zahl zwischen 1 und 3
Zusatzinformation angefordert werden. 
 
____________________________________________________________________________ 
 
gib kommando : 
task info (2) 
 
____________________________________________________________________________ 
 
liefert: 
 
____________________________________________________________________________ 
26.11.86   10:10                          CPU    PRIO CHAN STATUS 
SUPERVISOR........................... 0001:08:50   0   -   wait 
    -................................ 0000:00:08   0   2   i/o 
    -................................ 0000:01:45   0   -   wait 
    SYSUR............................ 0000:01:48   0   -   wait 
        configurator................. 0000:00:43   0   -   wait 
        OPERATOR..................... 0000:00:03   0   -   i/o 
            shutup dialog............ 0000:03:08   0   -   i/o 
        ARCHIVE...................... 0000:03:03   0  31   wait 
UR................................... 0000:00:43   0   -   wait 
    PUBLIC........................... 0000:01:26   0   -   i/o 
        agfa......................... 0000:00:11   0   -   i/o 
        werner....................... 0000:06:00   0   -   -busy- 
 
 
____________________________________________________________________________ 
 
 
 
 
'task info (1)' entspricht dabei dem Kommando ohne Parameterangabe, '(2)' liefert
zusätzlich die verbrauchte CPU-Zeit (=reine Rechenzeit), die Priorität, den Kanal
(siehe S.#topage("Kanal")#) und den Taskstatus für jede Task des Systems. '(3)' liefert neben diesen
Angaben auch noch den belegten Speicherplatz jeder Task. Die Ausführung von task
info (3) ist sehr zeitaufwendig! 
 
Um insbesondere den belegten Speicherplatz der eigenen Task anzusehen, aber auch
die übrigen der oben erwähnten Angaben, benutzt man das Kommando: 
 
____________________________________________________________________________ 
 
      gib kommando : 
      task status 
 
24.12.86 18:30   TASK: wenni 
 
Speicher: 1000K 
CPU-Zeit: 0000.01:11 
Zustand : -busy-, (Prio 1), Kanal 1 
 
      gib kommando : 
 
____________________________________________________________________________ 
#page# 
3.2. Tasksteuerung 
#free(1.0)# 
Task abkoppeln 
#free(1.0)# 
 
   
  Mit dem Kommando 'break' wird eine Task vom Terminal abgekoppelt. 
 
                                   
#free(1.0)# 
 
Durch die Eingabe des Kommandos 'break' auf Monitor-Ebene wird die Task vom
Terminal abgekoppelt. Dieses Kommando bewirkt ansonsten keine Veränderungen. 
 
____________________________________________________________________________ 
 
gib kommando : 
break 
 
____________________________________________________________________________ 
 
 
 
Statt 'break' einzutippen, können Sie auch die Tastenkombination 
 
#center#<ESC> <q> 
 
benutzen. 
 
#page# 
 
Eine Manager-Task erzeugen 
#free(1.0)# 
 
   
  Eine Task kann zum #ib#Manager#ie#, d.h. zum Kommunikationspartner anderer Tasks,
  erklärt werden. Insbesondere zwischen Manager-Tasks und anderen, die
  zueinander in Vater-Sohn-Beziehung stehen, ist ein einfacher Dateitransfer
  möglich (siehe S.#topage("Dateitrans")#). 
                           
#free(1.0)# 
 
Normalerweise werden Benutzertasks als Sohn der Task PUBLIC eingerichtet. Es
kann jedoch wünschenswert sein, selbst eine Task-Hierarchie aufzubauen und eine
vorhandene Task zum Vater einer oder mehrerer in Zukunft einzurichtender Tasks zu
machen, um somit auch eine Dateihierarchie mit den benötigten Operationen zu
erhalten. Dazu wird diese Task zum 'Manager' erklärt:#goalpage("globalmanager")# 
 
____________________________________________________________________________ 
 
gib kommando: 
global manager 
 
____________________________________________________________________________ 
 
 
Durch das '#ib#global manager#ie#'-Kommando wird implizit ein 'break'-Kommando gege­
ben, so daß Sie nach Eingabe dieses Kommandos wieder ein Supervisor-Kommando
geben können. Wenn Sie nun zu irgendeinem Zeitpunkt diese (zunächst potentielle)
Vater-Task wieder ankoppeln ('continue'-Kommando), meldet sich die Task nicht
wie gewohnt mit 'gib kommando :', sondern mit: 
 
____________________________________________________________________________ 
 
maintenance : 
 
____________________________________________________________________________ 
 
 
um anzudeuten, daß es sich um eine Manager-Task handelt. 
 
Um eine Sohn-Task unterhalb einer Manager-Task einzurichten, wird zur Erzeu­
gung dieser neuen Task nicht nur der gewünschte Name, sondern auch der Name der
Vater-Task angegeben.#u#1)#e# 
#foot# 
#u#1)#e# Falls keine Vater-Task angegeben wird, so ist die neue Task Sohn der
Manager-Task 'PUBLIC'. 
#end# 
 
____________________________________________________________________________ 
 
                                           Terminal 2  
 
 
                      EUMEL Version 1.8/M 
 
 
        gib supervisor kommando: 
        begin("sohntask","vatertask") 
 
 
 
   ESC ? --> help 
   ESC b --> begin("")            ESC h --> halt 
   ESC c --> continue("")         ESC s --> storage info 
   ESC q --> break                ESC t --> task info 
 
 
____________________________________________________________________________ 
 
 
 
 
In dieser Sohn-Task können dann mit einfachen Kommandos Dateien von der
Vater-Task geholt und zur Vater-Task geschickt werden. 
 
Soll eine Task für alle anderen Tasks, nicht nur für Sohn-Tasks, des Gesamtsystems
als Kommunikationspartner erreichbar sein, so muß diese Task als freier Manager
deklariert werden: 
 
____________________________________________________________________________ 
 
gib kommando: 
#ib#free global manager#ie# 
 
____________________________________________________________________________ 
 
 
Auf eine solche Task kann von #on("u")#jeder#off("u")# anderen Task aus zugegriffen werden, ansonsten
gilt das für gewöhnliche Manager-Tasks gesagte. 
#page# 
Task löschen 
#free(1.0)# 
 
   
  Eine Task kann mit dem '#ib#end#ie#' Kommando gelöscht werden (und mit ihr alle Daten). 
   
  #free(0.5)# 
Normale Benutzertasks werden meistens zweck- oder themengebunden eingerichtet.
Sind die Aufgaben im Zusammenhang mit einer solchen Task erledigt, so sollte die
Task gelöscht werden, nachdem alle Daten von Bedeutung auf Diskette gesichert
wurden. 
 
____________________________________________________________________________ 
 
gib kommando : 
end 
 
____________________________________________________________________________ 
 
Wie bei allen Löschungen im EUMEL-System folgt eine Kontrollfrage durch den
Monitor: 
 
____________________________________________________________________________ 
 
gib kommando : 
end 
task "taskname" löschen (j/n) ? 
 
 
____________________________________________________________________________ 
 
 
Nur bei der positiven Antwort wird gelöscht, alle Dateien sind unwiderruflich verlo­
ren. Als positive Antwort auf derartige Abfragen wirken: 
 
#center#<j> <J> <y> <Y> 
 
<n> bzw. <N> unterdrücken die angebotene Aktion, andere Eingaben werden abgewie­
sen. 
 
#on("b")# 
ACHTUNG:   Wird eine Manager-Task gelöscht, so werden alle Sohn- Enkel- etc.
           Tasks ohne zusätzliche Nachfrage gelöscht, falls die Sicherheitsabfrage
           mit 'j' beantwortet wurde.  #off("b")# 
#page# 
3.3. Dateibearbeitung 
#free(1.0)# 
Datei einrichten 
#free(1.0)# 
 
   
  Mit dem Editoraufruf 'edit' wird eine neue Datei eingerichtet, bzw. eine existierende
  Datei zur Bearbeitung am Bildschirm gezeigt. 
 
 
 
#free(0.5)# 
 
Eine Datei enthält Texte, die logisch zusammengehören und sie wird über ihren
Namen eindeutig gekennzeichnet. 
 
Das EUMEL-System speichert einmal geschriebene Texte, bis sie vom Benutzer
gelöscht werden. In der Regel wird nicht nur ein (langer) Text oder ein Programm­
text geschrieben, sondern mehrere und unterschiedliche. Um diese auseinanderhalten
zu können, versehen wir sie jeweils mit einem Namen, der frei gewählt werden kann.
Beispiele für Namen: 
 
 
   "Brief vom 1.12.86" 
   "1. Kapitel meines Buches" 
 
 
Eine Sammlung von Zeichen (also im Normalfall unsere geschriebenen Texte), die mit
einem Namen versehen worden ist, nennt man eine #ib##on("b")#Datei#ie##off("b")#. Der Editor erstellt also eine
Datei, wenn wir einen Text schreiben. Eine Datei kann bis zu 4 000 Zeilen fassen,
wobei jede bis zu 32 000 Zeichen lang sein darf. 
 
 
Einrichten der ersten #ib#Datei#ie# in Ihrer Task: 
 
Der erste Schritt sollte darin bestehen, daß Sie sich einen vernünftigen Dateinamen
ausdenken. Das EUMEL-System legt Ihnen praktisch keine Beschränkungen über
Länge oder Form des Dateinamens auf, deshalb sollten Sie sich angewöhnen, Ihre
Dateien so zu benennen, daß Sie anhand des Namens auch nach einer Woche oder
länger noch erahnen können, was diese Datei enthält. 
 
Ein guter Name für die erste Datei wäre zum Beispiel: "meine erste Datei" oder
"werners test vom 1.12.86". Im weiteren Text steht nur "dateiname" o. ä.. Setzen Sie
dafür den von Ihnen gewählten Namen ein. 
 
____________________________________________________________________________ 
 
gib kommando: 
edit ("dateiname") 
 
____________________________________________________________________________ 
 
____________________________________________________________________________ 
 
gib kommando: 
edit ("dateiname") 
 
"dateiname" neu einrichten (j/n)? 
 
____________________________________________________________________________ 
 
Drücken Sie 'j', so wird eine neue Datei unter dem von Ihnen eingegebenen Namen
eingerichtet. Die Datei ist zunächst leer: 
 
____________________________________________________________________________ 
 ................... dateiname .................... Zeile 1 
 
____________________________________________________________________________ 
 
 
 
Welche Möglichkeiten Sie bei der Bedienung des Editors haben, können Sie in Teil 4
nachschlagen. Schreiben Sie an dieser Stelle nur einige Worte in die Datei, anhand
derer der Dateiinhalt wiederzuerkennen ist. Sie können die Tastatur genauso benutzen
wie die einer Schreibmaschine. 
 
____________________________________________________________________________ 
 ................... dateiname .................... Zeile 1 
Inhalt der ersten Datei. 1234567890 
 
____________________________________________________________________________ 
 
 
Die Datei sollte an dieser Stelle wieder geschlossen werden. 
 
Drücken Sie dazu <ESC> <q>. 
 
Dabei ist gleichgültig, wo der Cursor steht. 
 
Wiederholen Sie das Neuanlegen einer Datei mit einer zweiten Datei "anderer datein­
ame". Bitte schreiben Sie wiederum einige Zeichen in die Datei. 
 
____________________________________________________________________________ 
 
gib kommando : 
edit ("anderer dateiname") 
 
____________________________________________________________________________ 
 
 
Vorschlag zur Eingabe: 
 
____________________________________________________________________________ 
 
 .............. anderer dateiname ................. Zeile 1 
Halten Sie irgendeine Taste gedrücktttttttttttttttt 
 
____________________________________________________________________________ 
 
 
Beenden Sie die Arbeit ebenfalls mit <ESC> <q> . 
 
 
#page# 
Dateinamen auflisten 
#free(1.0)# 
 
   
  Mit dem Kommando 'list' werden die Dateinamen der Dateien in der Task aus­
  gegeben. 
 
                                   
#free(1.0)# 
 
Vor jedem Dateinamen wird das Datum der letzten Bearbeitung der Datei angezeigt. 
 
____________________________________________________________________________ 
 
gib kommando: 
list 
 
____________________________________________________________________________ 
 
bewirkt: 
____________________________________________________________________________ 
 
 ..................... list ....................... Zeile 1     
 
01.08.86       "dateiname" 
01.08.86       "anderer dateiname" 
 
____________________________________________________________________________ 
 
 
 
Auch bei dieser Auflistung der Dateinamen handelt es sich um eine EUMEL-Datei
 (allerdings um eine schreibgeschützte), die Ausgabe wird also wie gewohnt durch
 das Kommando  <ESC> <q> beendet. 
#page# 
Datei duplizieren 
#free(1.0)# 
 
   
  Mit dem Kommando 'copy' wird eine existierende Datei dupliziert. 
 
                                   
#free(1.0)# 
 
Eine existierende Datei kann dupliziert werden durch das Kommando : 
 
____________________________________________________________________________ 
 
gib kommando: 
copy ("dateiname","kopiename") 
 
____________________________________________________________________________ 
 
 
Durch dieses Kommando wird eine Kopie der Datei "dateiname" unter dem Namen
"kopiename" angelegt, der Inhalt der beiden Dateien ist zunächst identisch. Kontrol­
lieren Sie die Richtigkeit dieser Behauptung, indem Sie nachsehen, ob der Inhalt der
kopierten Datei gleich dem Inhalt der Ursprungsdateiname ist: 
 
____________________________________________________________________________ 
 
gib kommando: 
edit ("kopiename") 
 
____________________________________________________________________________ 
#page# 
Dateinamen ändern 
#free(1.0)# 
 
   
  Mit dem Kommando 'rename' wird der Name einer Datei geändert. 
 
                                   
#free(1.0)# 
 
Sollte Ihnen der Name einer Datei nicht gefallen, so besteht die Möglichkeit, den
Namen zu ändern: 
 
____________________________________________________________________________ 
 
gib kommando: 
rename ("dateiname","neuer dateiname") 
 
____________________________________________________________________________ 
 
 
#page# 
Datei löschen 
#free(1.0)# 
 
   
  Mit dem Kommando 'forget' wird eine Datei gelöscht. 
 
                                   
#free(1.0)# 
 
Das Löschen einer Datei wird durch das Kommando: 
 
____________________________________________________________________________ 
 
gib kommando: 
forget ("neuer dateiname") 
 
____________________________________________________________________________ 
 
eingeleitet. Aus Gründen der Sicherheit erfolgt vor der Ausführung des Kommandos
jedoch die Abfrage: 
 
____________________________________________________________________________ 
 
gib kommando: 
forget ("neuer dateiname") 
 
"dateiname" löschen ? (j/n) 
 
____________________________________________________________________________ 
 
Als positive Antwort auf derartige Abfragen wirken: <j> <J> <y> <Y> 
 
<n> bzw. <N> unterdrücken die angebotene Aktion, andere Eingaben werden abgewie­
sen. 
 
#page# 
Dateien verschicken 
#free(1.0)# 
#goalpage("Dateitrans")# 
 
   
  Dateien können zur Vater-Task geschickt und von der Vater-Task geholt werden. 
              
#free(1.0)# 
 
Die Vereinbarung, daß Dateien in einer Task lokal sind, d.h. daß nur in dieser Task
Zugriff auf die Daten möglich ist, ist häufig zu einschränkend. So kann es zweck­
mäßig sein, von mehreren Arbeitsplätzen (= Tasks) aus die wesentlichen Ergebnisse
an einer zentralen Stelle zu sammeln oder Ergebnisse aus Tasks, die nur kurzzeitig
für eine spezielle Aufgabe eingerichtet wurden, länger aufzubewahren. 
 
Zu diesem Zweck wird eine Benutzertask zum Manager erklärt (siehe S.#topage("globalmanager")#) und es
werden Söhne dieser Task eingerichtet. 
#page# 
Datei zur Vater-Task schicken 
#free(1.0)# 
 
   
  Mit dem Kommando 'save' wird die Kopie einer Datei zur Vater-Task geschickt. 
 
                                   
#free(1.0)# 
 
____________________________________________________________________________ 
 
gib kommando: 
save ("dateiname") 
 
____________________________________________________________________________ 
 
Wird eine Datei an die Vater-Task gesendet, wird eine Kopie der Ursprungsdateina­
me unter dem Namen 'dateiname' in der Vater-Task eingerichtet. Danach sind diese
beiden, zunächst gleichen Dateien unabhängig voneinander. Änderungen, welcher Art
auch immer, haben keinen Einfluß auf die namensgleiche Kopie in der anderen Task. 
 
Falls in der Vater-Task bereits eine Datei mit dem Namen 'dateiname' existiert, sei
es durch Zufall oder weil bereits einmal eine 'save'-Operation durchgeführt worden
ist, erfolgt eine Abfrage: 
 
____________________________________________________________________________ 
 
gib kommando: 
save ("dateiname") 
 
"dateiname" überschreiben ? (j/n) 
 
____________________________________________________________________________ 
 
Nur wenn die positive Eingabe 'j' erfolgt, wird die Datei in der Vater-Task durch die
eigene Datei überschrieben. 
#page# 
Datei von der Vater-Task holen 
#free(1.0)# 
 
   
  Mit dem Kommando 'fetch' wird die Kopie einer Datei von der Vater-Task geholt. 
 
                                   
#free(1.0)# 
 
Entsprechend dem Versenden einer Dateikopie können Sie eine Kopie von der Vater­
Task holen und ggf., natürlich nach Abfrage, Ihre Datei dieses Namens überschrei­
ben. 
 
____________________________________________________________________________ 
 
gib kommando: 
fetch ("dateiname") 
 
____________________________________________________________________________ 
 
#page# 
Datei in der Vater-Task löschen 
#free(1.0)# 
 
   
  Mit dem Kommando 'erase' wird eine Datei in der Vater-Task gelöscht. 
 
                                   
#free(1.0)# 
 
Soll eine Datei in der Vater-Task gelöscht werden, so kann dieses, dem 'forget'-
Kommando analoge Kommando, in der Sohn-Task gegeben werden: 
 
____________________________________________________________________________ 
 
gib kommando: 
erase ("dateiname") 
 
____________________________________________________________________________ 
 
Falls die Datei in der Vater-Task existiert, wird sie nach Kontrollfrage gelöscht. 
 
____________________________________________________________________________ 
 
gib kommando: 
erase ("dateiname") 
"dateiname" loeschen (j/n)  j 
 
gib kommando : 
 
 
____________________________________________________________________________ 
 
 
      Anm:  Die Task 'PUBLIC' ist grundsätzlich eine Manager-Task. Da Benut­
      zer-Tasks als Sohn von '#ib#PUBLIC#ie#' eingerichtet werden, falls Sie nicht als
      Sohn einer besonderen Manager-Task eingerichtet wurden, beziehen sich
      'fetch'-, 'save'- und 'erase'-Kommandos auf 'PUBLIC'. 
#page# 
3.4. Das Archiv 
#free(1.0)# 
 
   
  Das Archiv dient der Speicherung von Dateien auf Disketten (Sicherung). 
                      
#free(1.0)# 
 
Das #ib#Archiv#ie# übernimmt im EUMEL-System die Verwaltung der langfristigen Daten­
haltung. Das Archiv sollen Sie benutzen, um: 
 
-  Sicherungskopien wichtiger Dateien außerhalb des Rechners zu besitzen; 
 
-  nicht benötigte Dateien außerhalb einer Task zu halten (Speicherplatzersparnis!); 
 
-  Dateien auf andere Rechner zu übertragen. 
 
Das Archiv wird im EUMEL-System durch die Task 'ARCHIVE', die das Disketten­
laufwerk des Rechners verwaltet, realisiert. Die Steuerung durch eine Task hat für Sie
die erfreuliche Folge, daß die Handhabung des Archivs sich kaum von den schon
bekannten Dateioperationen unterscheidet. In den Kommandos wird zusätzlich ange­
geben, daß das Archiv angesprochen werden soll. 
 
#page# 
Archiv-Kommandos 
#free(1.0)# 
 
   
  Der Arbeitsablauf bei Benutzung des Archivs besteht immer aus der Reservierung,
  dem Lese- oder Schreibzugriff und der Freigabe des Archivs nach Ende der
  Arbeit. Jede Arbeit mit dem Archiv beginnt mit dem Reservierungskommando. 
 
   
#free(1.0)# 
 
Als ersten Schritt der Archivbenutzung müssen Sie das Archiv reservieren, das heißt
der Verwaltung Ihres EUMEL-Systems mitteilen, daß Sie die Task 'ARCHIVE', die
der Steuerung des Diskettenlaufwerks dient, für Ihre Task arbeiten lassen. Solange für
Ihre Task das Archiv reserviert ist, kann keine andere Task das Archivlaufwerk benut­
zen. 
 
Für die Reservierung müssen Sie bei Benutzung einer schon vorbereiteten oder sogar
beschriebenen Diskette den Namen dieser Archivdiskette kennen (er sollte auf dem
Diskettenaufkleber stehen) oder vor Benutzung einer neuen Diskette einen Namen
festlegen (und auf dem Aufkleber vermerken). Wie gewohnt gibt es keine Vorschrif­
ten für die Namensgebung. 
 
Erst nachdem Sie das Reservierungskommando gegeben haben: 
 
____________________________________________________________________________ 
 
gib kommando: 
archive ("diskettenname") 
 
____________________________________________________________________________ 
 
 
sollten Sie die Diskette in das Laufwerk einschieben, um zu verhindern, daß ein
anderer Benutzer, der das Archiv bereits für sich reserviert hat, auf Ihrer zufällig
gleichnamigen Datei arbeitet. 
 
 
Eine Datei wird mit dem Kommando: 
 
____________________________________________________________________________ 
 
save ("dateiname",archive) 
 
 
____________________________________________________________________________ 
 
 
auf eine Diskette geschrieben und mit dem Kommando: 
 
____________________________________________________________________________ 
 
fetch ("dateiname",archive) 
 
____________________________________________________________________________ 
 
 
von einer Diskette geholt. 
 
Das Inhaltsverzeichnis einer Diskette erhalten Sie durch: 
 
____________________________________________________________________________ 
 
list (archive) 
 
____________________________________________________________________________ 
 
#page# 
Benutzung einer neuen Archivdiskette 
#free(1.0)# 
 
   
  Eine neue Diskette muß für die Benutzung vorbereitet (formatiert) werden. 
 
   
 
#free(1.0)# 
Vor der erstmaligen Benutzung einer Archivdiskette muß diese formatiert, d.h. in
Spuren und Sektoren für die Positionierung des Schreib-/Lesekopfes des Disketten­
laufwerks eingeteilt werden, um überhaupt ein Beschreiben der Diskette zu ermög­
lichen. Die Einteilung ist geräteabhängig, häufige Formate sind: 
 
              40 Spuren zu je 9 Sektoren (360 K) 
              80 Spuren zu je 9 Sektoren (720 K). 
 
Die #on("b")#Erst#off("b")#benutzung einer #ib#Archivdiskette#ie# erfordert nach der Reservierung des Archivs
das Kommando: 
 
____________________________________________________________________________ 
 
gib kommando: 
format (archive) 
 
____________________________________________________________________________ 
 
 
Erst nach einer Kontrollabfrage: 
 
____________________________________________________________________________ 
 
gib kommando: 
format (archive) 
 
Archiv "diskettenname" formatieren ? (j/n) 
 
____________________________________________________________________________ 
 
wird tatsächlich formatiert und die Diskette steht mit dem Namen "diskettenname" für
Archivoperationen zur Verfügung. 
 
#on("b")# 
ACHTUNG:   Wird eine bereits beschriebene Diskette noch einmal formatiert, so sind
           alle Daten, die auf der Diskette waren, verloren.#off("b")# 
 
 
Bei einigen Rechnern ist es möglich, die Formatierung zu variieren. Falls beim Forma­
tieren auf einem solchen Rechner ein anderes als das Standardformat erzeugt werden
soll, so ist die Codierung des gewünschten Formats mitanzugeben. 
 
 
Beispiel:    Für ein Gerät mit 5μ Zoll Disketten wäre z.B. einstellbar: 
             code 0 : Standardformat 
             code 1 : 40 Spuren 
             code 2 : 80 Spuren 
             code 3 : High Density 
 
            'format (archive)' erzeugt ebenso wie 'format (0,archive)' eine standard­
             formatierte Diskette, 'format (3,archive)' erzeugt eine High Density
             Formatierung. 
#page# 
Diskette löschen / umbenennen 
#free(1.0)# 
 
   
  Bereits benutzte Disketten können wieder gelöscht und auch umbenannt werden. 
 
   
#free(1.0)# 
 
Falls Sie den Inhalt einer beschriebenen Archivdiskette löschen oder den Namen einer
Diskette ändern wollen, müssen Sie das Archiv unter dem gewünschten Namen reser­
vieren: Falls Sie den Inhalt löschen möchten, tun Sie das unter dem bisherigen und
bestehenden Namen. Falls Sie die Diskette umbenennen wollen, reservieren Sie das
Archiv unter dem neuen gewünschten Namen. Beachten Sie, daß durch das Umbe­
nennen eines Archivs alle darauf befindlichen Dateien gelöscht werden. Anschließend
geben Sie das Kommando: 
 
____________________________________________________________________________ 
 
gib kommando: 
#ib#clear#ie# (archive) 
 
____________________________________________________________________________ 
 
Durch die Ausführung des Kommandos erhält die eingelegte Diskette den in der
Reservierung angegebenen Namen. Das Inhaltsverzeichnis, das sich auf der Diskette
befindet, wird gelöscht. Damit sind die Daten, die sich eventuell auf dieser Diskette
befanden, nicht mehr auffindbar. Die Diskette entspricht einer neu formatierten Disket­
te#u#1)#e#. #foot# 
#u#1)#e# Das Kommando 'format' enthält implizit 'clear'. 
#end# 
Eine Neuformatierung ist demnach bei Wiederverwendung der Diskette nicht notwen­
dig. 
 
#page# 
Inhaltsverzeichnis der Diskette 
#free(1.0)# 
 
   
  Mit 'list (archive)' werden die Dateien auf der Diskette angezeigt. 
 
   
#free(1.0)# 
 
Eine formatierte Diskette kann nach der Archivanmeldung gelesen oder beschrieben
werden. Um zu sehen, welche Dateien auf der Diskette zu holen (= lesen) sind bzw.
wieviel Platz zum Beschreiben vorhanden ist, ist es zweckmäßig, zunächst das In­
haltsverzeichnis der Diskette zu betrachten. 
 
____________________________________________________________________________ 
 
gib kommando: 
list (archive) 
 
____________________________________________________________________________ 
 
Beispiel: 
 
____________________________________________________________________________ 
 
 ............diskettenname (100 K belegt von 720 K)..............  
 
01.05.86   25 K  "rechnungen april" 
01.06.86   23 K  "rechnungen mai" 
01.07.86   20 K  "rechnungen juni" 
01.08.86   32 K  "rechnungen juli" 
 
____________________________________________________________________________ 
#page# 
Lesen und Schreiben auf Diskette 
#free(1.0)# 
 
   
  Lesen und Schreiben auf der Diskette entspricht den bekannten Operationen zum
  Senden und Holen von Dateien. 
 
   
 
#free(1.0)# 
Das Schreiben einer Datei auf Diskette entspricht dem Übersenden einer Datei an die
Vater-Task. Einziger Unterschied ist, daß Sie das Ziel explizit angeben müssen: 
 
____________________________________________________________________________ 
 
gib kommando: 
#ib#save#ie# ("dateiname",archive) 
 
____________________________________________________________________________ 
 
Entsprechend funktioniert auch das Lesen einer Datei von der Diskette: 
 
____________________________________________________________________________ 
 
gib kommando: 
fetch ("dateiname",archive) 
 
____________________________________________________________________________ 
 
Wie auch bei der Kommunikation zwischen Sohn- und Vater-Task werden nur
Kopien der Dateien geholt bzw. geschrieben. 
#page# 
Wechsel der Archivdiskette 
#free(1.0)# 
Bei Einlegen einer anderen Archivdiskette müssen Sie erneut das Kommando 
 
____________________________________________________________________________ 
 
gib kommando: 
archive ("diskettenname") 
 
____________________________________________________________________________ 
 
geben, da mit der Archivreservierung zugleich die Prüfung von Diskettenname und
-Inhaltsverzeichnis vorbereitet wird. 
#page# 
Beenden der Archivreservierung 
#free(1.0)# 
 
   
  Nach Benutzung Archiv freigeben! 
 
   
#free(1.0)# 
 
Wenn Sie alle gewünschten Arbeiten mit dem Archiv fertiggestellt haben, geben Sie
das Archiv wieder frei. 
 
____________________________________________________________________________ 
 
gib kommando: 
#ib#release#ie# (archive) 
 
____________________________________________________________________________ 
 
Durch dieses Kommando kann die Task 'ARCHIVE' mit ihren Leistungen von einer
anderen Task in Anspruch genommen werden. Falls Sie dieses Kommando nicht
gegeben haben aber seit 5 Minuten keine Archivoperation ausgelöst haben, kann eine
andere Task durch die Anforderung 'archive("diskettenname")' das Archiv reservieren.
Durch diese Maßnahme wird verhindert, daß ein vergeßlicher Benutzer bei einem
System mit mehreren Benutzern das Archiv blockiert. 
#page# 
Fehlermeldungen des Archivs 
#free(1.0)# 
 
   
  Bei Archiv-Operationen kann es zu Fehlersituationen kommen. 
   
#free(1.0)# 
 
Versucht man, eine Datei vom Archiv zu holen, kann es vorkommen, daß das Ar­
chiv-System 
 
____________________________________________________________________________ 
 
#ib#Lese-Fehler (Archiv)#ie# 
 
____________________________________________________________________________ 
 
meldet und den Lese-Vorgang abbricht. Dies kann auftreten, wenn die Floppy
beschädigt oder aus anderen Gründen nicht lesbar ist (z.B. nicht justierte Disket­
ten-Geräte). In einem solchen Fall vermerkt das Archiv-System intern, daß die Datei
nicht korrekt gelesen werden kann. Das sieht man z.B. bei 'list (archive)'. Dort ist der
betreffende Datei-Name mit dem Zusatz 'mit Lese-Fehler' gekennzeichnet. Um
diese Datei trotzdem zu lesen, muß man sie unter ihrem Dateinamen mit dem Zusatz
'mit Lese-Fehler' lesen. 
 
____________________________________________________________________________ 
 
gib kommando: 
fetch ("dateiname mit Lese-Fehler") 
 
____________________________________________________________________________ 
 
Die Datei wird in diesem Fall trotz Lese-Fehler (Informationsverlust!) vom Archiv
gelesen. 
 
Um solche Fälle möglichst zu vermeiden, sieht das EUMEL-System die Möglichkeit
vor, Archive bzw. Archiv-Dateien nach Beschreiben zu prüfen. Das erfolgt mit dem
Kommando 
 
____________________________________________________________________________ 
 
gib kommando : 
#ib#check#ie# ("dateiname", archive) 
 
____________________________________________________________________________ 
 
 
Durch dieses Kommando werden eventuelle Lese-Fehler gemeldet. 
 
Weitere Fehlermeldungen des Archivs: 
 
* Lesen unmöglich (Archiv) 
  Die Archiv-Diskette ist nicht eingelegt oder die Tür des Laufwerks ist nicht ge­
  schlossen. 
=> Diskette einlegen bzw. Tür schließen. 
 
* Schreiben unmöglich (Archiv) 
  Die Diskette ist schreibgeschützt. 
=> falls wirklich gewünscht, Schreibschutz entfernen. 
 
* Archiv nicht angemeldet 
  Das Archiv wurde nicht angemeldet 
=> 'archive ("name")' geben. 
 
* Lese-Fehler (Archiv) 
  Siehe Lesen unmöglich 
 
* Schreibfehler (Archiv) 
  Die Diskette kann nicht (mehr) beschrieben werden. 
=> Andere Diskette verwenden. 
 
* Speicherengpass 
  Im System ist nicht mehr genügend Platz, um eine Datei vom Archiv zu laden, ggf.
=> ggf. Dateien löschen. 
 
* RERUN bei Archiv-Zugriff Das System wurde bei einer Archiv-Operation durch
  Ausschalten bzw. Reset unterbrochen. 
 
* "dateiname" gibt es nicht 
  Die Datei "dateiname" gibt es nicht auf dem Archiv. 
=> mit 'list(archive)' Archiv prüfen. 
 
* Archiv heißt ... 
  Die eingelegte Diskette hat einen anderen als den eingegebenen Archivnamen. 
=> Kommando 'archive' mit korrektem Namen geben. 
 
* Archiv wird von Task ... benutzt 
  Das Archiv wurde von einem anderen Benutzer reserviert. 
=> Abwarten. 
 
* "dateiname" kann nicht geschrieben werden (Archiv voll) 
  Die Datei ist zu groß für die eingelegte Diskette. 
=> Andere Diskette für diese Datei nehmen. 
 
* Archiv inkonsistent 
  Die eingelegte Diskette hat nicht die Struktur einer Archiv-Diskette. 
=> 'format (archive)' vergessen. 
 
* save/erase wegen Lese-Fehler verboten 
  Bei Archiven mit Lese-Fehler sind Schreiboperationen verboten, weil ein Erfolg
  nicht garantiert werden kann. 
 
 
 
3.5. Kommandos für mehrere Dateien 
#free(1.0)# 
 
   
  Durch Anwendung der besonderen Operatoren 'ALL' und 'SOME' können Sie
  mehrere Dateien mit einem Kommando behandeln. 
   
 
#free(1.0)# 
Oft ist es sehr zweckmäßig und erleichternd, einen Befehl für eine ganze Reihe von
Dateien wirken zu lassen, wie z.B. beim Archivieren, wenn Sie etwa alle während des
Tages veränderten Dateien mit deren neuen Stand auf Diskette schreiben möchten. 
 
Da Tasks einen Namen haben und jede Task ein Inhaltsverzeichnis ihrer Dateien
führt, ist es möglich, Listen von Dateien zu benennen. 
#page# 
Interne Tasknamen 
#free(1.0)# 
Wenn Sie eine andere als die eigene oder die Vater-Task ansprechen wollen, ist es
notwendig, den 'internen Tasknamen' anzugeben. Diese auf den ersten Blick etwas
undurchsichtige Forderung hat folgenden Hintergrund: 
 
Durch die in der Einleitung vorgestellte Baumstruktur des EUMEL-Systems ist es
ohne besondere Angaben nur möglich, Kommandos zu geben, die die eigene Task
('edit'..) oder die Vater-Task ('save'..) betreffen. Beim Archivieren zum Beispiel wäre
es demzufolge erforderlich, eine Datei über den Vater vom Vater vom Vater... an den
Sohn des Sohnes... zu schicken, damit die Datei endlich in der Task 'ARCHIVE'
landet. Statt dessen verwenden Sie eine Prozedur 'archive', die den internen Task­
bezeichner liefert. Damit wird die gewünschte Task intern identifiziert, ohne daß Sie
sich darum kümmern müssen. 
 
Wichtige Prozeduren, die interne Taskbezeichner liefern, sind: 
 
            myself           Bezeichner der eigenen Task 
            public           Bezeichner von PUBLIC 
            father           Bezeichner der Vater-Task#u##count##e# 
            archive          Bezeichner von ARCHIVE 
            printer          Bezeichner von PRINTER #foot# 
#u##value##e# Falls kein besonderer Manager eingerichtet wurde, liefern 'father' und 'public'
  natürlich dieselbe Task: PUBLIC. #end# 
#page# 
Dateiverzeichnisse 
#free(1.0)# 
Jede Task verfügt über ein Verzeichnis der in ihr befindlichen Dateien. Das Verzeich­
nis Ihrer eigenen Task können Sie mit dem 'list'-Kommando betrachten. Das Ver­
zeichnis einer anderen Task sehen Sie beispielsweise durch das Kommando 'list
(archive)'. In diesem Fall müssen Sie dem eigentlichen Kommando den internen
Taskbezeichner der gewünschten Task hinzugeben, um das Verzeichnis zu sehen. 
 
Um ein Verzeichnis in Verbindung mit anderen Kommandos benutzen zu können, gibt
es besondere Operatoren: 
 
      #ib#ALL#ie#         liefert das gesamte Verzeichnis 
      #ib#SOME#ie#        bietet das Verzeichnis zur Auswahl von Einträgen an. 
 
 
In Verbindung mit einem internen Taskbezeichner wird einer der beiden Operatoren
einem Monitor-Kommando als Parameter nachgestellt. Das Kommando wirkt dann
nacheinander auf alle im Verzeichnis enthaltenen Dateien. 
 
 
____________________________________________________________________________ 
 
gib kommando: 
fetch (ALL father) 
 
____________________________________________________________________________ 
 
Alle Dateien der Vater-Task werden nacheinander geholt, bei Namensgleichheit
erfolgt die bekannte Kontrollfrage, ob die gleichnamige Datei in der eigenen Task
überschrieben werden soll. 
 
Falls nur einige Dateien des Verzeichnisses bearbeitet werden sollen, wird der Opera­
tor 'SOME' dem Taskbezeichner vorangestellt: 
 
____________________________________________________________________________ 
 
gib kommando: 
fetch (SOME father) 
 
____________________________________________________________________________ 
 
 
Hier wird zunächst das Dateiverzeichnis der Task angeboten. Streichen Sie alle
Dateien, die auf der Diskette sind, aber nicht in Ihre Task geholt werden sollen, aus
dem Verzeichnis, indem Sie 
 
-  den Dateinamen mit Blanks überschreiben 
 
                 oder: 
 
-  die Zeile mit <HOP> <RUBOUT> löschen 
 
                 oder: 
 
-  mehrere Zeilen markieren, indem Sie zu Beginn des zu markierenden Bereichs
   'mark' betätigen und mit Hilfe der Cursor-Tasten den Beereich so weit wie benö­
   tigt ausdehnen. Im Anschluß daran können Sie diese Zeilen durch 
 
                <ESC> <RUBOUT> oder 
 
                <ESC> <p> 
 
    löschen. 
 
 
____________________________________________________________________________ 
 
 ..............................    .......................... #markoff# 
rechnungen april 
rechnungen mai 
rechnungen juni 
rechnungen juli 
 
 
 
____________________________________________________________________________ 
 
 
 
In obigem Beispiel werden nach dem Kommando 'ESC RUBOUT' (=Löschen der
markierten Zeilen) und dem Kommando 'ESC q' (=editieren beenden) die Dateien
'rechnungen juni' und 'rechnungen juli' vom Archiv geholt. 
 
Als weitere Vereinfachung gibt es die Prozedur 'all' als Abkürzung für 'ALL myself'. 
 
Beispiel: alle Dateien auf Archivdiskette schreiben. 
 
____________________________________________________________________________ 
 
gib kommando: 
save (all,archive) 
 
____________________________________________________________________________ 
 
 
Für Fortgeschrittene: 
 
Sie können auch aus den Verzeichnissen mehrerer Tasks ein neues Verzeichnis
bilden. Zu diesem Zweck sind folgende Mengenoperationen auf Verzeichnisse mög­
lich: 
 
     #ib#-#ie#  Differenzmenge 
     #ib#+#ie#  Vereinigungsmenge 
     #ib#/#ie#  Schnittmenge 
 
Beispiel: 
 
   fetch (ALL father - ALL myself) 
 
Alle Dateien der Vater-Task, die noch nicht in der eigenen Task sind, werden geholt. 
 
3.7. Passwortschutz 
#free(1.0)# 
 
   
  Das EUMEL- System ermöglicht Passwortschutz für Dateien, einzelne Tasks und
  ganze Zweige des Taskbaumes. 
   
#free(1.0)# 
 
Falls Sie sicherstellen wollen (oder müssen), daß Teile Ihres EUMEL-Systems vor
unberechtigter Benutzung geschützt sind, können Sie den Zugriff mit einem Passwort
regeln. 
 
Als Passwort können Sie jeden beliebigen Text nehmen. Bedenken Sie jedoch, daß
ein wirklich wirksamer Schutz nur dann gewährleistet ist, wenn Sie weder ein triviales
Passwort (etwa den eigenen Vornamen) auswählen, noch eines, das Sie selbst nicht
behalten. #u##count("1")#)#e# #foot# 
#u##value("1")#)#e# Man darf Passwörter nicht vergessen! Durch Passwörter geschützte Tasks kann
niemand - außer durch die Angabe des korrekten Passworts - wieder ankoppeln.
Hat man das Passwort vergessen, kann man nur noch die Task löschen. 
#end# 
 
ACHTUNG:   Es gibt ein besonderes Passwort im EUMEL-System: "-". Dieses
           Passwort verhindert, daß die Task in der es gegeben wurde (z.B. UR), an
           ein Terminal geholt wird, es darf folglich nicht für normale
           Manager-Tasks gegeben werden. 
#page# 
Eine Task mit Passwort schützen 
#free(1.0)# 
Das Monitor-Kommando '#ib#task password#ie#' sorgt dafür, daß eine Task fortan nur wieder
mit einem 'continue'-Kommando 'betreten' werden kann, wenn man vorher das
richtige Passwort angibt. 
 
____________________________________________________________________________ 
 
gib kommando: 
task password ("rosebud") 
 
____________________________________________________________________________ 
 
Versucht nun ein Benutzer, die mit dem Passwort geschützte Task mit dem 'conti­
nue'-Kommando an sein Terminal anzukoppeln, wird er zunächst nach dem #ib#Pass­
wort#ie# gefragt. Nur unter Angabe des Passworts wird die Task angekoppelt. 
 
Bei der Beantwortung des Passworts werden statt der eingegebenen Zeichen Punkte
auf den Bildschirm geschrieben. Durch Betätigen von ESC können die getippten
Zeichen lesbar gemacht werden. 
 
____________________________________________________________________________ 
 
            gib supervisor kommando: 
            continue("taskname") 
                  Passwort: ....... 
 
 
____________________________________________________________________________ 
 
 
Der Passwortschutz gewährleistet, daß kein unberechtigter Benutzer direkt an die
Dateien und Programme der Task gelangen kann. Es gibt jedoch noch zwei Situatio­
nen, die einen unberechtigten Zugang zu Dateien erlauben: 
 
a) Dateien in die Vater-Task schicken: 
   Transportiert man Dateien in die Vater-Task ('save'-Kommando) können Benut­
   zer auf diese Dateien zugreifen (sofern sie Zugang zu dieser Task haben). Dies
   kann man verhindern, indem man ein Datei-Passwort angibt. Man beachte, daß
   das Passwort für Dateien und das oben beschriebene Passwort für Tasks nichts
   miteinander zu tun haben. 
 
b) Dateien werden in eine Sohn-Task geholt: 
   Ist die Task als Vater-Task eingerichtet ('global manager'-Kommando), dann ist
   es möglich, von der Sohn-Task Dateien ('fetch'-Kommando) aus der Vater-
   Task zu holen, die mit einem Passwort geschützt ist. Darum muß man verhindern,
   daß unberechtigte Benutzer Söhne einer mit Passwort geschützten Task einrich­
   ten können. Das kann man mit dem Kommando 
 
____________________________________________________________________________ 
 
maintenance : 
#ib#begin password#ie# ("geheim") 
 
____________________________________________________________________________ 
 
 
   Wird dieses Kommando gegeben, wird man bei dem Versuch, eine Sohn-Task
   einzurichten, nach einem Passwort gefragt. Beachten Sie, daß das 'begin pass­
   word' nichts mit dem Task-Passwort und Datei-Passwort zu tun hat. 
 
 
Man kann einen ganzen Zweig eines EUMEL-Systems durch das Kommando 'family
password' vor unberechtigtem Zugriff schützen. Das Kommando: 
 
____________________________________________________________________________ 
 
maintenance: 
family password ("geheim") 
 
____________________________________________________________________________ 
 
wird dazu (wie gewohnt als Monitor-Kommando) in der Vater-Task des zu schüt­
zenden Zweigs des Taskbaumes gegeben. Damit ist das Passwort aller Söhne, Enkel
usw. dieser Task auf 'geheim' gesetzt, falls sie vorher kein Passwort oder das gleiche
Passwort wie die aufrufende Task haben. Eine Task in diesem Zweig, die bereits ein
eigenes, vom 'family password' verschiedenes Passwort besitzt, behält dieses eigene
Passwort. 
 
Bsp: Für 'PUBLIC' wird das Kommando '#ib#family password#ie# ("geheim")' gege­
     ben. Dann ist das Passwort von 'PUBLIC' und aller Tasks des Benutzerzweiges
     auf 'geheim' gesetzt. 
 
 
Es ist zu beachten, daß bei der Vergabe des 'family password' nur die aktuellen
Söhne der Task berücksichtigt werden. Söhne, die nach der Vergabe des 'family
password' eingerichtet werden, sind nicht durch dieses Passwort geschützt. 
 
Passwort löschen 
 
 
Um ein Passwort zu löschen, geben Sie das Passwort-Kommando mit "" als Para­
meter: 
 
____________________________________________________________________________ 
 
maintenance: 
begin password("") 
 
____________________________________________________________________________ 
 
 
Durch diese Angabe haben Sie den Passwort einen leeren Text als Parameter gege­
ben, der das bisherige Passwort 'überschreibt'. 
 
#page# 
Dateipasswort 
 
 
Etwas komplizierter gestaltet sich der Passwortschutz für einzelne Dateien einer
Manager-Task, da in dieser Anwendung eine Unterscheidung nach Schreib- und
Leseschutz vorgenommen wird. 
 
Da in dieser Anwendung nur einige Dateien der Vater-Task vor Lesen ('fetch'),
Schreiben ('save','erase') oder beidem geschützt werden sollen, benötigt diese Proze­
dur Angaben über Dateinamen, Schreibpasswort und Lesepasswort. 
 
____________________________________________________________________________ 
 
maintenance : 
enter password ("dateiname","schreibschutz","leseschutz") 
 
____________________________________________________________________________ 
 
Falls die Datei nicht gegen Lesen geschützt werden soll, wird (wie beim Löschen
eines Passworts) '""' als Lesepasswort angegeben. 
 
Falls Schreiben und/oder Lesen für eine Datei gänzlich verboten#u#1)#e# sein soll, so ist
"-" als entsprechendes Passwort anzugeben. 
#foot# 
1) Natürlich kann die Datei in der Manager-Task, der sie gehört, normal editiert
   werden. 
#end# 
 
Um von einer Sohn-Task eine Datei mit Passwortschutz in der Vater-Task zu lesen
oder zu schreiben muß vor dem 'fetch', 'save' oder 'erase' Kommando das 'enter
password' Kommando eineggeben werden: 
 
____________________________________________________________________________ 
 
gib kommando: 
enter password ("schreibpasswort/lesepasswort") 
 
____________________________________________________________________________ 
 
In der Sohn-Task wird also nur ein Passwort eingegeben. Falls wie oben ein '/' in
diesem Passwort enthalten ist, wird der erste Teil vor dem '/' als Schreibpasswort und
der zweite Teil als Lesepasswort geprüft. Falls kein '/' in dem Passwort enthalten ist,
wird das Wort sowohl als Schreib- als auch als Lesepasswort interpretiert. 
 
Beispiel: 
In einer Manager-Task wird eine Datei "texte" eingerichtet, die Textvorlagen enthält.
In einigen Sohn-Tasks soll diese Datei geholt (= gelesen) werden können. Die
bearbeitete, somit veränderte Datei darf aber nicht zurück in die Vater-Task ge­
schrieben werden. 
 
In der Vater-Task:  enter password ("texte","-","psw") 
 
 
In der Sohn-Task :  enter password ("psw") 
 
 
Falls das Passwort in einer Sohn-Task fehlerhaft oder gar nicht eingegeben wurde,
erscheint die Meldung : 
 
____________________________________________________________________________ 
 
      gib kommando : 
      fetch ("geschützte datei") 
FEHLER : Passwort falsch 
 
____________________________________________________________________________ 
 
 
Somit kann diese Datei nur von Benutzern, die das Lesepasswort kennen, geholt
werden. Ein Überschreiben der Datei ist nicht möglich, da das Schreibpasswort nicht 
gegeben werden kann ("-" !). 
#page# 
3.8.  Monitor-Kommandos 
#free(1.0)# 
ALL 
   THESAURUS OP ALL (TASK CONST task) 
   Liefert einen Thesaurus#u#1)#e#, der alle Dateinamen der angegebenen Task enthält
   (auch der Benutzer-Task 'myself'). 
#foot# 
1) Ein Thesaurus ist eine Liste, in diesem Zusammenhang eine Liste von Dateien.
   (Siehe auch 2.4. Die ELAN-Notation 
#end# 
   fetch (ALL father) 
 
   THESAURUS OP ALL (TEXT CONST datei) 
   Liefert einen Thesaurus, der die in 'datei' vorhandenen Dateinamen (jede Zeile ein
   Name) enthält. 
 
   fetch (ALL "dateiliste") 
 
archive 
   PROC archive (TEXT CONST archivname) 
   Anmeldung von Archiv-Operationen. 'archivname' wird zur Überprüfung für alle
   folgenden Archiv-Operationen verwandt, um die unberechtigte Benutzung eines
   Archivs zu verhindern. Die Anmeldung wird abgelehnt, wenn ein anderer Nutzer
   das Archiv belegt hat. 
 
 
   archive ("textdiskette") 
 
 
   TASK PROC archive 
   Liefert den internen Task-Bezeichner für die Verwendung in Dateikommandos. 
 
 
   save ("dateiname", archive) 
 
 
 
begin password 
   PROC begin password (TEXT CONST geheim) 
   Verhindert das unberechtigte Einrichten einer Sohn-Task. 
 
 
   begin password("gmd") 
 
 
break 
   PROC break 
   Die zum Terminal aktuell zugeordnete Task wird abgekoppelt. Sie wird damit zu
   einer Hintergrund-Task. 
 
 
brother 
   TASK PROC brother (TASK CONST task) 
   Liefert den internen Task-Bezeichner der angegebenen "Bruder"-Task. 
 
 
   list(brother) 
 
 
check 
   PROC check (TEXT CONST dateiname, TASK CONST task) 
   Überprüft, ob die Datei 'dateiname' auf dem Archiv lesbar ist. 
 
 
   check ("meine datei", archive) 
 
 
   PROC check (THESAURUS CONST t, TASK CONST task) 
   Überprüft, ob die in dem Thesaurus 't' enthaltenen Dateien auf dem Archiv lesbar
   sind. 
 
 
   check (ALL archive, archive) 
 
 
 
clear 
   PROC clear (TASK CONST task) 
   Löscht alle Dateien der Task 'ARCHIVE'und benennt die Diskette um, falls ein
   anderer als der bisherige Diskettenname bei der Reservierung angegeben wurde. 
 
 
   archive("disk1"); clear(archive) 
 
 
copy 
   PROC copy (TEXT CONST quelle, ziel) 
   Kopiert die Datei 'quelle' in eine neue Datei mit dem Namen 'ziel' in der
   Benutzer-Task. 
 
 
   copy("datei","neue datei") 
 
   Fehlerfälle: "ziel" existiert bereits 
                "quelle" gibt es nicht 
                 zu viele Dateien 
 
 
edit 
   PROC edit 
   a) Im Monitor: 
      Ruft den Editor mit den zuletzt verwandten Dateinamen auf. 
   b) Im Editor: 
      Der Dateiname wird erfragt. 
   Für jedes 'edit' gilt: 
   Wurde 'edit' zum ersten Mal aufgerufen, nimmt das Fenster den gesamten
   Bildschirm ein. Bei erneutem 'edit'-Aufruf wird ein Fenster nach rechts unten ab
   der aktuellen Cursor-Position eröffnet. 
 
   PROC edit (TEXT CONST dateiname) 
   Ruft den Editor mit 'dateiname' auf. 
 
 
   edit("handbuch teil3") 
 
 
 
   PROC edit (TEXT CONST dateiname, x, y, xbreite, yhöhe) 
   Wie obiger 'edit'-Aufruf, jedoch kann das Fenster, in dem 'dateiname' editierbar
   ist, gesetzt werden. Die Parameter definieren ein Editor-Fenster mit der linken
   oberen Ecke auf den Bildschirmkoordinaten 'x' und 'y' und einer Zeilenbreite
   'xbreite' und 'yhöhe' Zeilen. Wird der Editor mit 'edit ("dateiname")' aufgerufen,
   wird implizit 'edit ("dateiname", 1, 1, 79, 24)' aufgerufen. 
 
 
   edit("notiz",5,5,44,12) 
 
 
   PROC edit (THESAURUS CONST t) 
   Editieren aller in dem Thesaurus 't' enthaltenen Dateien nacheinander. 
 
 
   edit (ALL father) 
 
 
 
end 
   PROC end 
   Die zum Terminal aktuell gehörende Task wird abgebrochen und gelöscht. 
 
enter password 
   PROC enter password (TEXT CONST datei, schreibpass, lesepass) 
   Die angegebene Datei wird mit Schreib- und Lesepassword versehen. Die
   Passwörter werden in der eigenen Task nicht berücksichtigt. 
   Falls der Schutz total sein soll, so ist für die verbotene Operation "-" als
   Passwort anzugeben. 
 
 
   enter password ("daten","sicher","heit") 
 
 
   PROC enter password (TEXT CONST password) 
   Gibt Schreib- und Lesepasswort für den Austausch mit Manager-Task an. Falls
   zwei verschiedene Passwörter für Lesen und Schreiben vereinbart sind, so sind
   sie als ein Text durch "/" getrennt einzugeben. 
 
 
   enter password ("lese/schreibpasswort")  
 
 
erase 
   PROC erase (TEXT CONST datei) 
   Löscht eine Datei mit dem Namen 'name' in der unmittelbaren Vater-Task. 
 
 
   erase("alte datei") 
 
 
   Fehlerfälle: 
                "datei" gibt es nicht 
                 Passwort falsch 
 
   PROC erase (TEXT CONST name, TASK CONST manager) 
   Löscht eine Datei mit dem Namen 'name' in der Task 'manager'. 
 
 
   erase ("dateiname", father) 
 
 
   PROC erase (THESAURUS CONST thesaurus) 
   Löscht die im 'thesaurus' angegebenen Dateien in der Vater-Task. 
 
 
   erase (ALL myself) 
   (* löscht alle Dateien in der Vater-Task, die in der 
    Benutzer-Task vorhanden sind *) 
 
 
   PROC erase (THESAURUS CONST thesaurus, TASK CONST manager) 
 
 
   erase (all,father) 
   (* löscht alle Dateien in der Vater-Task, die in der 
    Benutzer-Task vorhanden sind *) 
 
 
 
father 
   TASK PROC father 
   Liefert den internen Task-Bezeichner der Vater-Task der Benutzer-Task. 
 
 
   list(father) 
 
 
   TASK PROC father (TASK CONST task) 
   Liefert den internen Task-Bezeichner von 'task'. 
 
 
   save ("dateiname", father (father)) 
   (* Kopiert 'dateiname' zum "Großvater" *) 
 
 
 
fetch 
   PROC fetch (TEXT CONST name) 
   Kopieren einer Datei von der Vater-Task in die Benutzer-Task 
 
 
   fetch("sicherungskopie") 
 
   Fehlerfälle: 
               "datei" gibt es nicht 
                Passwort falsch 
                zu viele Dateien 
 
 
   PROC fetch (TEXT CONST name, TASK CONST manager) 
   Kopieren einer Datei in die Benutzer-Task von 'manager'. 
 
 
   fetch ("dateiname", /"global") 
 
 
   PROC fetch (THESAURUS CONST thesaurus) 
   Holt alle im 'thesaurus' enthaltenen Dateien von der Vater-Task. 
 
 
   fetch (ALL) 
 
 
   PROC fetch (THESAURUS CONST thesaurus, TASK CONST manager) 
   Zweck: Holt alle im 'thesaurus' enthaltenen Dateien von der 'manager'-Task. 
 
 
   fetch (ALL /"global", /"global") 
 
 
forget 
   PROC forget (TEXT CONST datei) 
   Löschen einer Datei mit dem Namen 'name' in der Benutzer-Task. 
 
 
   forget ("alte datei") 
 
   Fehlerfälle: 
               "datei" gibt es nicht 
 
   PROC forget (THESAURUS CONST thesaurus) 
   Löscht die im 'thesaurus' enthaltenen Dateien in der Benutzer-Task. 
 
 
   forget (SOME myself) 
 
 
format 
   PROC format (THESAURUS CONST thes) 
   Formatieren von Disketten und Einstellen des Namens. 
 
 
   format(archive) 
 
 
   PROC format (INT CONST art, THESAURUS CONST thes) 
   Formatieren von Disketten im Nichtstandardformat des benutzten Geräts 
 
 
   format(2,archive) 
 
 
global manager 
   PROC global manager 
   Durch den Aufruf der Prozedur wird die Benutzer-Task zu einem Datei-
   Manager. Danach können Söhne dieser Task eingerichtet werden. 
 
 
list 
   PROC list 
   Listet alle Dateien der Benutzer-Task mit Namen und Datum des letzten Zugriffs
   auf dem Terminal auf. 
 
   PROC list (TASK CONST task) 
   Listet alle Dateien der angegebenen 'task' mit Namen und Datum der letzten
   Änderung auf dem Terminal auf. 
 
 
   list (father) 
 
 
 
myself 
   TASK PROC myself 
   Liefert den internen Task-Bezeichner der Benutzer-Task. 
 
 
   save (ALL myself, father) 
 
 
 
public 
   TASK PROC public 
   Liefert den internen Task-Bezeichner von "PUBLIC". 
 
 
   fetch ("dateiname", public) 
 
 
 
rename 
   PROC rename (TEXT CONST altername,neuername) 
   Umbenennen einer Datei von 'altername' in 'neuername'. 
 
 
   rename("altes handbuch","neues handbuch") 
 
 
save 
   PROC save (TEXT CONST dateiname) 
   Datei 'dateiname' wird an die unmittelbare Vater-Task übertragen. 
 
 
   save("neues handbuch") 
 
 
   Fehlerfälle: 
               "neues handbuch" gibt es nicht 
                zu viele Dateien 
                Passwort falsch 
 
   PROC save (TEXT CONST name, TASK CONST task) 
   Datei mit dem Namen 'name' in Task 'task' kopieren 
 
 
   save ("dateiname", /"global") 
 
 
   Fehlerfälle: 
               "dateiname" gibt es nicht 
                zu viele Dateien 
                Passwort falsch 
 
   PROC save (THESAURUS CONST thesaurus) 
   Kopiert die Dateien, die in 'thesaurus' enthalten sind, in die Vater-Task. 
 
 
   save (SOME myself) 
 
 
   PROC save (THESAURUS CONST thesaurus, TASK CONST manager) 
   Kopiert die Dateien, die in 'thesaurus' enthalten sind, in Task 'manager'. 
 
 
   save(SOME myself, /"global") 
 
 
SOME 
   THESAURUS OP SOME (THESAURUS CONST thesaurus) 
   Bietet den angegebenen 'thesaurus' zum Editieren an. Dabei können nicht
   erwünschte Namen gestrichen werden. 
 
   THESAURUS OP SOME (TASK CONST task) 
   Bietet einen THESAURUS von 'task' zum Editieren an. 
 
   THESAURUS OP SOME (TEXT CONST dateiname) 
   Bietet einen 'thesaurus', der aus 'dateiname' gebildet wird, zum Editieren an. 
 
 
task 
   TASK PROC task (TEXT CONST task name) 
   Liefert den internen Task-Bezeichner von 'task name'. 
 
 
   save ("dateiname", task ("PUBLIC")) 
                =     save ("dateiname", public) 
 
 
 
storage info 
   PROC storage info 
   Informationsprozedur über den belegten Hintergrund-Speicher. 
 
 
task info 
    PROC task info 
    Informiert über alle Tasknamen im System unter gleichzeitiger Angabe der
    Vater/Sohn-Beziehungen (Angabe durch Einrückungen). 
 
   PROC task info (INT CONST art) 
   Informiert über alle Tasks im System. Mit 'art' kann man die Art der Zusatz-
   Information auswählen. Für 'art' sind zur Zeit folgende Werte zugelassen: 
 
   art=1: entspricht 'task info' ohne Parameter, d.h. es gibt nur die Tasknamen
          unter Angabe der Vater/Sohn-Beziehungen aus. 
 
   art=2: gibt die Tasknamen aus. Zusätzlich erhalten Sie Informationen über die
          verbrauchte CPU-Zeit der Task, die Priorität, den Kanal, an dem die
          Task angekoppelt ist, und den eigentlichen Taskstatus. Hierbei bedeuten: 
 
          0    -busy-        Task ist aktiv. 
          1    i/o           Task wartet auf Beendigung des Outputs oder auf
                             Eingabe. 
          2    wait          Task wartet auf Sendung von einer anderen Task. 
          4    busy-blocked  Task ist rechenwillig, aber blockiert. 
          5    i/o -blocked  Task wartet auf I/O, ist aber blockiert. 
          6    wait-blocked  Task wartet auf Sendung, ist aber blockiert.
                             Achtung: Die Task wird beim Eintreffen einer
                             Sendung automatisch entblockiert. 
 
    art=3: wie 2, aber zusätzlich wird der belegte Speicher angezeigt. (Achtung:
           Prozedur ist zeitaufwendig!). 
 
 
   task info(2) 
 
 
task status 
   PROC task status 
   Informationsprozedur über den Zustand der eigenen Task. Informiert u.a. über 
   -  Name der Task, Datum und Uhrzeit; 
   -  verbrauchte CPU-Zeit; 
   -  belegten Speicherplatz; 
   -  Kanal, an den die Task angekoppelt ist; 
   -  Zustand der Task (rechnend u.a.m.); 
   -  Priorität. 
 
   PROC task status (TASK CONST t) 
   Wie obige Prozedur, aber über die Task mit dem internen Tasknamen 't'. 
 
 
   task status (father) 
 
 
 
task password 
   PROC task password (TEXT CONST geheim) 
   Einstellen eines Passworts für Benutzertask. Das Kommando 'task password' ist
   ein Monitor-Kommando. Ist eine Task mit einem Paßwort geschützt, so wird
   durch den Supervisor nach dem 'continue'-Kommando das Passwort angefragt.
   Nur nach Eingabe des richtigen Passworts gelangt man in die gewünschte Task.
   Das Passwort kann durch nochmaligen Aufruf von 'task password' geändert
   werden, z.B. wenn es in regelmäßigen Abständen geändert werden muß, um
   personenbezogene Daten zu schützen. 
 
   Es gibt keine Möglichkeit, ein einmal eingestelltes Passwort in Erfahrung zu
   bringen. Sollte das Passwort vergessen werden, kann somit die Task nur noch
   gelöscht werden. 
 
   Wird als Passwort ein '-'-Zeichen eingegeben, so wird verhindert, daß die
   betreffende Task jemals wieder mit dem 'continue'-Kommando angekoppelt
   werden kann. Dies ist z.B. für Manager-Tasks sinnvoll. 
 
 
   task password("mein geheimnis") 
 
 
+ 
   THESAURUS OP + (THESAURUS CONST links, rechts) 
   Vereinigungsmenge von 'links' und 'rechts'. 
 
   THESAURUS OP + (THESAURUS VAR thes, TEXT CONST name) 
   Nimmt den TEXT 'name' in den Thesaurus 'thes' auf. 
 
 
   save (SOME father + "rechnung", archive) 
 
 
 
- 
   THESAURUS OP - (THESAURUS CONST links, rechts) 
   Differenzmenge von 'links' und 'rechts'. 
 
   THESAURUS OP - (THESAURUS VAR thes, TEXT CONST name) 
   Liefert einen Thesaurus aus 'thes', aber ohne den Eintrag 'name'. 
 
 
   save (ALL myself - "rechnung", archive) 
 
 
 
/ 
   THESAURUS OP / (THESAURUS CONST links, rechts) 
   Zweck: Schnittmenge von 'links' und 'rechts'. 
 
 
   save(ALL myself / ALL father, archive) 
 
 
   TASK OP / (TEXT CONST task name) 
   Liefert aus einem Tasknamen den internen Tasknamen. '/' kann überall dort
   eingesetzt werden, wo ein interner Taskname verlangt wird. 
 
 
   fetch ("dateiname", /"global") 

