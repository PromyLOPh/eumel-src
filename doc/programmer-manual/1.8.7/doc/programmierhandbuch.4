#headandbottom("1","EUMEL-Benutzerhandbuch","TEIL 4 : Kommandosprache","4")# 
#pagenr("%",1)##setcount(1)##block##pageblock# 
#headeven# 
#center#EUMEL-Benutzerhandbuch 
#center#____________________________________________________________ 
 
#end# 
#headodd# 
#center#TEIL 4 : Kommandosprache 
#center#____________________________________________________________ 
 
#end# 
#bottomeven# 
#center#____________________________________________________________ 
4 - % #right#GMD 
#end# 
#bottomodd# 
#center#____________________________________________________________ 
GMD #right#4 - % 
#end# 
TEIL 4:  Kommandosprache 
 
In Teil 4 sind diejenigen Kommandos beschrieben, die erfahrungsgemäß eher der
Handhabung der Arbeitsumgebung zuzurechnen sind. Es ist den Verfassern bewußt,
daß Auswahl und Zusammenstellung recht willkürlich sind, weil eine klare Abgrenzung
zum Teil 5, welcher die Kommandos, die dem Thema: 'Programmierung' zugeordnet
werden, nicht möglich ist. 
 
Der Teil 4 ist in die Themen: 
 
- 4.1.                     Supervisor-Kommandos 
 
- 4.2.1                    Hilfs- und Informationsprozeduren 
 
- 4.2.2                    Thesaurus 
 
- 4.2.3                    Tasks 
 
- 4.2.4                    Handhabung von Dateien 
 
- 4.2.5                    Editor 
 
- 4.2.6                    Dateitransfer 
 
- 4.2.7                    Passwortschutz 
 
- 4.2.8                    Archiv 
 
gegliedert. Insbesondere zu 4.2.4 ist anzumerken, daß nur Kommandos, die ganze
Dateien betreffen hier erläutert sind. Kommandos, die Dateiinhalte betreffen (Suchen,
Ersetzen etc.) sind in 3.5, bzw. 5.3 beschrieben. 
#page# 

4.1  Supervisor 
 
Es gibt genau sieben vom Supervisor akzeptierte Kommandos. Diese Kommandos
können gegeben werden wenn nach dem Einschalten des Geräts oder dem Abkoppeln
einer Task die SV-Taste gedrückt wurde und die sogenannte EUMEL-Tapete
erscheint. 
 
____________________________________________________________________________ 
 
                                           Terminal 2  
 
 
                    EUMEL Version 1.8.1/M 
 
 
        gib supervisor kommando: 
          
 
 
 
   ESC ? --> help 
   ESC b --> begin("")            ESC h --> halt 
   ESC c --> continue("")         ESC s --> storage info 
   ESC q --> break                ESC t --> task info 
 
____________________________________________________________________________ 
 
 
 
 
Desweiteren kann <SV> in einer Task gedrückt werden, um durch <ESC> <h> einen
Programmabbruch einzuleiten. 
 
Im Gegensatz zu den im weiteren beschriebenen, durch ELAN Prozeduren realisierten
Kommandos, sind diese Supervisor-Kommandos nicht als Prozeduren im System und
mithin nicht durch 'help (...)' anzeigbar. 
#page# 
'begin' 
   #on("b")#PROC begin (TEXT CONST taskname) #off("b")# 
   Richtet eine neue Task als Sohn von PUBLIC ein. 
 
 
   #on("b")#PROC begin (TEXT CONST taskname, vatertask) #off("b")# 
   Richtet eine neue Task als Sohn der Task 'vatertask' ein, falls die Vater-Task
   eine Manager-Task ist. Falls diese Task keinen Managerstatus besitzt, passiert
   nichts! In diesem Falle muß das Kommando durch <SV> abgebrochen werden. 
 
 
   FEHLER :  "taskname" existiert bereits 
             "vatertask" gibt es nicht 
 
 
 
 
'continue' 
   #on("b")#PROC continue (TEXT CONST taskname) #off("b")# 
   Eine existierende Task wird an das Terminal des Benutzers angekoppelt. 
 
   FEHLER :  "taskname" gibt es nicht 
 
 
   Falls 'begin' oder 'continue' trotz korrekter Voraussetzungen kein Resultat zeigen,
   'hängt' die betroffene Task. Beim 'begin' Kommando kann das der Fall sein, falls
   die Vater-Task nicht durch 'break' abgekoppelt wurde, sondern mit < SV > verlas­
   sen wurde. In diesem Fall muß das Kommando durch <SV> abgebrochen werden,
   die Vater-Task angekoppelt und mit <ESC> <q> korrekt abgekoppelt werden. 
#page# 
'break' 
   #on("b")#PROC break #off("b")# 
   Das Terminal wird vom Rechner abgekoppelt. 
 
 
 
'halt' 
   #on("b")#PROC halt #off("b")# 
   Das laufende Programm der dem Terminal aktuell zugeordneten Task wird abge­
   brochen. 
 
   Falls in der an das Terminal gekoppelten Task ein laufendes Programm abgebro­
   chen werden soll, muß zunächst durch <SV> der Supervisor aufgerufen werden.
   Durch das Supervisor-Kommando 'halt' wird der Fehler 'halt from terminal'
   induziert. Das Programm wird wie durch jeden anderen Fehler abgebrochen, falls
   nicht 'disable stop' gesetzt wurde! 
 
 
 
#page# 
'storage info' 
   #on("b")#PROC storage info #off("b")# 
   Informationsprozedur über den belegten und den verfügbaren Hintergrund-Spei­
   cher des gesamten Systems in KByte#u#1)#e#. 
 
#foot# 
 
   1) Bei der derzeit aktuellen '+' Version EUMEL 1.8.1/M+ sind die beiden Anga­
      ben mit 4 zu multiplizieren ! 
#end# 
   Das Terminal wird unmittelbar abgekoppelt! 
 
 
 
'task info' 
   #on("b")#PROC task info #off("b")# 
   Informiert über alle Tasknamen im System unter gleichzeitiger Angabe der Vater/
   Sohn-Beziehungen durch Einrückungen. 
 
 
 
 
'help' 
   #on("b")#PROC help #off("b")# 
   Kurzbeschreibung der SV-Kommandos. 
#page# 

4.2  Monitor
 
Unter dem Stichwort Monitor-Kommandos sind an dieser Stelle Kommandos be­
schrieben, die ständig zur Handhabung der Arbeitsumgebung benutzt werden.
Gleichwohl sei sofort darauf hingewiesen, daß jedes ELAN Programm dem Monitor zur
Ausführung übergeben werden kann. Es gibt also keine speziellen Monitor-
Kommandos, sondern nur eine Reihe von Prozeduren (=Kommandos), die in dieser
Umgebung erfahrungsgemäß besonders häufig benutzt werden. 
 
 
#on("u")#4.2.1  Hilfs- und Informationsprozeduren#off("u")# 
 
- Pakete, Prozeduren       :  packets, bulletin , help 
  Parameter 
 
- Tasksystem zeigen        :  task info , task status 
 
- Speicherplatz zeigen     :  storage , storage info 
 
 
#on("u")#4.2.2  Thesaurus #off("u")# 
 
-  besondere Thesauri      :  ALL , all , SOME , remainder 
 
-  Verknüpfung             :  + , - ,  / 
 
 
#on("u")#4.2.3  Taskoperationen#off("u")# 
 
- besondere Tasknamen      :  archive , brother , father , myself 
                              printer , public , son , supervisor 
- Terminal abkoppeln       :  break 
- Task löschen             :  end 
- Manager-Task             :  global manager , free global manager 
- Umbenennen der Task      :  rename myself 
 
#page# 
#on("u")#4.2.4  Handhabung von Dateien #off("u")# 
 
                           :  copy , edit , forget , list , rename , show 
 
 
#on("u")#4.2.5  Editor #off("u")# 
 
- Editieren                :  edit , editget , show 
- Tastenbelegung           :  kommando auf taste (legen) , 
                              lernsequenz auf taste (legen) , 
                              std tastenbelegung , 
                              taste enthält kommando , 
                              word wrap 
 
 
#on("u")#4.2.6  Transfer #off("u")# 
 
- Datei holen              :  fetch , fetchall 
- Datei senden             :  save , saveall 
- Drucken                  :  print 
- Datei löschen            :  erase 
 
 
#on("u")#4.2.7  Passwortschutz #off("u")# 
 
- 'begin' absichern        :  begin password 
- 'continue' absichern     :  task password 
- Dateien absichern        :  enter password 
- Systemzweig sichern      :  family password 
 
 
#on("u")#4.2.8  Das Archiv #off("u")# 
 
- Reservieren/freigeben    :  archive , release 
- Formatieren              :  format 
- Löschen                  :  clear 
- Kontrollesen             :  check 
 
 
#page# 

4.2.1  Hilfsprozeduren 
 
Die drei Prozeduren listen ihre Ausgabe jeweils in eine temporäre Datei, die mit
'show' (s. 4.2.5) gezeigt wird. 
 
 
'packets' 
   #on("b")#PROC packets #off("b")# 
   Auflisten der Namen aller insertierten Pakete in der Task. 
 
 
 
 
 
 
'bulletin' 
   #on("b")#PROC bulletin (TEXT CONST paket name) #off("b")# 
   Listen aller in der DEFINES-Liste des Pakets mit dem Namen "paket name"
   enthaltenen Prozeduren. 
 
   FEHLER :  ... ist kein Paketname 
 
 
   #on("b")#PROC bulletin #off("b")# 
   Es wird eine Liste aller bisher insertierten Objekte erstellt. Diese Liste ist paket­
   weise sortiert. 'bulletin' zeigt also eine Liste #on("u")#aller#off("u")# Prozeduren an, die in der Task
   benutzt werden können. 
#page# 
'help' 
   #on("b")#PROC help (TEXT CONST name) #off("b")# 
   Listen aller Prozeduren / Operatoren mit dem Namen "name". Der Name des
   Packets in dessen Schnittstelle die Prozedur steht wird mit ausgegeben. 
 
   Falls es kein Objekt des erfragten Namens gibt, erfolgt die Ausgabe: 
 
   unbekannt "name". 
 
   Beispiel: 
____________________________________________________________________________ 
 
     gib kommando : 
     help("save") 
 
____________________________________________________________________________ 
 
 
   liefert: 
 
____________________________________________________________________________ 
 
PACKET nameset: 
 
      save........... (THESAURUS CONST, TASK CONST) 
      save........... (THESAURUS CONST) 
 
PACKET globalmanager: 
 
      save........... (DATASPACE CONST, TEXT CONST, TASK CONST) 
      save........... (TEXT CONST, TASK CONST) 
      save........... (TEXT CONST) 
      save........... 
 
____________________________________________________________________________ 
 
 
 
   Desweiteren kann auch nach Prozedurnamen gesucht werden, die nur annähernd
   bekannt sind, indem ein Suchmuster spezifiziert wird. Das Suchmuster besteht aus
   dem bekannten Teil des Namens und dem Operator '*', der vor und/oder nach
   dem Suchbegriff gesetzt werden kann. '*' bezeichnet eine beliebige (auch leere)
   Zeichenkette. 
 
   Beispiel: Gesucht werden die verschiedenen 'info' Prozeduren: 
 
____________________________________________________________________________ 
     gib kommando : 
     help("*info*") 
 
____________________________________________________________________________ 
 
 
 
____________________________________________________________________________ 
 
      taskinfo....... (INT CONST, INT CONST) 
      taskinfo....... (INT CONST, FILE VAR) 
      taskinfo....... (INT CONST) 
      taskinfo....... 
      editinfo....... (FILE VAR, INT CONST) 
      editinfo....... (FILE CONST)  --> INT 
      storageinfo.... 
 
____________________________________________________________________________ 
 
 
 
   Dieser Stern darf nicht mit dem 'joker' des 'Pattern Matching' verwechselt werden.
   In der 'help' Prozedur darf '*' #on("u")#nicht#off("u")# in den Suchbegriff eingesetzt werden, sondern
   nur an Wortanfang und -Ende gesetzt werden. 
 
 
#page# 

Informationsprozeduren 
 
'storage' 
   #on("b")#INT PROC storage (TASK CONST task) #off("b")# 
   Informationsprozedur über den logisch belegten Hintergrund-Speicher der Task.
   (Angabe in KByte, bzw. 4KB Einheiten bei der '+'-Version) 
 
 
____________________________________________________________________________ 
 
    gib kommando : 
    put(storage(myself)) 
    1234 
 
    gib kommando : 
 
____________________________________________________________________________ 
 
 
'storage info' 
   #on("b")#PROC storage info #off("b")# 
   Informationsprozedur über den belegten und den verfügbaren Hintergrund-Spei­
   cher des gesamten Systems. Die Ausgabe erfolgt in KByte, bei der aktuellen
   '+'-Version in 4 KByte Einheiten. 
 
 
____________________________________________________________________________ 
 
    gib kommando : 
    storage info 
    1234K von 12000K 
 
    gib kommando : 
____________________________________________________________________________ 
#page# 
 
'task info' 
   #on("b")#PROC task info #off("b")# 
   Informiert über alle Tasknamen im System unter gleichzeitiger Angabe der Vater/
   Sohn-Beziehungen (Angabe durch Einrückungen). 
 
 
   #on("b")#PROC task info (INT CONST art) #off("b")# 
   Informiert über alle Tasks im System. Mit 'art' kann man die Art der Zusatz-
   Information auswählen. 
 
   art=1: entspricht 'task info' ohne Parameter, d.h. es gibt nur die Tasknamen
          unter Angabe der Vater/Sohn-Beziehungen aus. 
 
   art=2: gibt die Tasknamen aus. Zusätzlich erhalten Sie Informationen über die
          verbrauchte CPU-Zeit der Task, die Priorität, den Kanal, an dem die
          Task angekoppelt ist, und den eigentlichen Taskstatus. Hierbei bedeuten: 
 
          0    -busy-        Task ist aktiv. 
          1    i/o           Task wartet auf Beendigung des Outputs oder auf
                             Eingabe. 
          2    wait          Task wartet auf Sendung von einer anderen Task. 
          4    busy-blocked  Task ist rechenwillig, aber blockiert#u#1)#e#. 
          5    i/o -blocked  Task wartet auf I/O, ist aber blockiert. 
          6    wait-blocked  Task wartet auf Sendung, ist aber blockiert. Ach­
                             tung: Die Task wird beim Eintreffen einer Sendung
                             automatisch entblockiert. 
        > 6    dead 
 
    art=3: wie 2, aber zusätzlich wird der belegte Speicher angezeigt. (Achtung:
           Prozedur ist zeitaufwendig!). 
 
#foot# 
 
1) Eine Blockierung kann von 'Scheduler' veranlaßt werden 
   (siehe Systemhandbuch) 
#end# 
 
#page# 
____________________________________________________________________________ 
 
    gib kommando : 
    task info(2) 
 
____________________________________________________________________________ 
 
 
 
    liefert: 
 
____________________________________________________________________________ 
 
 ............................ ............................... 
 15.05.87   10:39                         CPU    PRIO CHAN STATUS 
 SUPERVISOR.......................... 0000:19:47   0   -   wait 
    -................................ 0000:07:54   0   -   wait 
    SYSUR............................ 0000:34:02   0   -   wait 
        shutup dialog................ 0000:05:26   0   -   i/o 
        configurator................. 0000:04:17   0   -   wait 
        OPERATOR..................... 0000:00:14   0   -   i/o 
        ARCHIVE...................... 0000:10:33   0  31   wait 
        net.......................... 0006:41:56   0   -   wait 
            net timer................ 0000:02:48   2   -   i/o 
            net port................. 0000:40:23   0   7   wait 
        PRINTER...................... 0000:05:59   0   -   wait 
            -........................ 0000:00:11   0   -   wait 
 UR.................................. 0000:02:11   0   -   wait 
    PUBLIC........................... 0002:02:03   0   -   wait 
        task1........................ 0000:41:50   0   -   -busy- 
        task2........................ 0000:03:10   0   -   i/o 
        task3........................ 0000:57:28   0   1   -busy- 
 
____________________________________________________________________________ 
 
 
#page# 
 
 
   #on("b")#PROC task info (INT CONST art, FILE VAR infodatei) #off("b")# 
   Wie oben, die Ausgabe wird jedoch in die Datei 'infodatei' geschrieben. 
 
____________________________________________________________________________ 
 
    FILE VAR info := sequential file(output,"infodatei") ; 
    taskinfo(3, info); 
     
____________________________________________________________________________ 
 
 
   #on("b")#PROC task info ( INT CONST art, stationsnr) #off("b")# 
   Ermöglicht im Netzbetrieb 'task info' über die Station mit der Nummer 'stationsnr'. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    taskinfo(1,12) ; 
 
____________________________________________________________________________ 
#page# 
'task status' 
 
   #on("b")#PROC task status #off("b")# 
   Informationsprozedur über den Zustand der eigenen Task. Informiert über 
   -  Name der Task, Datum und Uhrzeit; 
   -  verbrauchte CPU-Zeit; 
   -  belegten Speicherplatz; 
   -  Kanal, an den die Task angekoppelt ist; 
   -  Zustand der Task (rechnend u.a.m.); 
   -  Priorität. 
 
   #on("b")#PROC task status (TASK CONST t) #off("b")# 
   Wie obige Prozedur, aber über die Task mit dem internen Tasknamen 't'. 
 
 
____________________________________________________________________________ 
 
   gib kommando : 
   task status (public) 
 
 15.05.87 10:30   TASK: PUBLIC 
 
 Speicher: 1234K 
 CPU Zeit: 0011.12:23 
 Zustand : wait, (Prio 0), Kanal - 
 
____________________________________________________________________________ 
#page# 
 
4.2.2  Thesaurus 
 
Ein #ib#Thesaurus#ie# ist ein #ib#Namensverzeichnis#ie#, das bis zu 200 Namen beinhalten kann.
Dabei muß jeder Namen mindestens ein Zeichen und darf höchstens 100 Zeichen
lang sein. Steuerzeichen (code < 32) in Namen werden umgesetzt (siehe 2.9.2). 
 
Thesauri werden unter anderem von der Dateiverwaltung benutzt, um das Dateiver­
zeichnis einer Task zu führen. 
 
Man kann einen Thesaurus selbst erstellen, indem eine Datei z.B. mit Namen von
Dateien gefüllt wird. Diese Datei kann dann als Thesaurus für weitere Aktionen die­
nen. 
 
 
 
- Thesaurus liefern        :  ALL , all , SOME , remainder 
- Auswählen                :  LIKE 
- Verknüpfen               :  + , - , / 
 
 
 
#on("b")#ACHTUNG#off("b")# :  Bei der Verwendung von Thesaurus Operationen in Verbindung mit
'fetch', 'save' etc. ist zu beachten, daß mit 'SOME', 'ALL' und 'all' zunächst nur eine
Auswahl aus einer Liste getroffen wird. Zusätzlich muß das Ziel oder die Quelle des
Dateitransfers vereinbart werden. 
 
Ein beliebter Fehler ist z.B.:   'fetch (ALL archive)'. 
 
Hier ist nicht weiter spezifiziert, von wo Dateien geholt werden sollen - also werden
sie von 'father' geholt!  (s. 4.2.5) 
 
Falls die Dateien vom Archiv geholt werden sollen, ist das Archiv als Quelle zu be­
nennen: 
 
Also : 'fetch (ALL archive, archive)' = Hole alle Dateien, die in dem Thesaurus von 
                                  'archive' sind von der Task 'archive'. 
#page# 
'ALL' 
   THESAURUS OP ALL (TASK CONST task) 
   Liefert einen Thesaurus, der alle Dateinamen der angegebenen Task enthält. 
 
 
 
   #on("b")#THESAURUS OP ALL (TEXT CONST dateiname) #off("b")# 
   Liefert einen Thesaurus, der die in der angegebenen Datei vorhandenen Namen
   (jede Zeile ein Name) enthält. 
 
 
 
 
'all' 
   #on("b")#THESAURUS PROC all #off("b")# 
   Liefert einen Thesaurus, der alle Dateinamen der eigenen Task enthält. Entspricht
   'ALL myself'. 
 
 
 
 
'SOME' 
   #on("b")#THESAURUS OP SOME (THESAURUS CONST thesaurus) #off("b")# 
   Bietet den angegebenen Thesaurus zum editieren an. Dort können nicht erwünsch­
   te Namen gestrichen werden. 
 
 
 
   #on("b")#THESAURUS OP SOME (TASK CONST task) #off("b")# 
   Aufruf von: SOME ALL task. 
 
 
   #on("b")#THESAURUS OP SOME (TEXT CONST dateiname) #off("b")# 
   Aufruf von: SOME ALL dateiname. 
 
#page# 
'remainder' 
   #on("b")#PROC remainder #off("b")# 
   Liefert nach einem 'errorstop' die noch nicht bearbeiteten Dateien. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    save all (archive) 
 
   '"....." kann nicht geschrieben werden (Archiv voll)' 
 
____________________________________________________________________________ 
 
 
 
   Nachdem man eine neue Floppy ins Archivlaufwerk gelegt hat, kann man mit 
 
 
____________________________________________________________________________ 
    gib kommando : 
    save (remainder, archive) 
 
____________________________________________________________________________ 
 
   den Rest der Dateien auf die nächste Floppy sichern. 
#page# 
'LIKE' 
   #on("b")#THESAURUS OP LIKE (THESAURUS CONST thesaurus, TEXT CONST muster) #off("b")# 
   Alle im Thesaurus enthaltenen Dateien, die dem 'muster' entsprechen sind im
   Ergebnisthesaurus enthalten. 
 
   (Die Syntax von 'muster' ist bei der Beschreibung des Pattern-Matching (5.4)
   beschrieben) 
 
 
____________________________________________________________________________ 
 
    gib kommando : 
    print (all LIKE "*.p") 
 
____________________________________________________________________________ 
 
 
  Alle Dateien, deren Name mit '.p' endet, werden gedruckt. 
 
#page# 
'+' 
   #on("b")#THESAURUS OP + (THESAURUS CONST links, rechts) #off("b")# 
   Liefert die Vereinigungsmenge von 'links' und 'rechts'. 
   Achtung: Die Vereinigungsmenge enthält keine Namen mehrfach. 
 
   #on("b")#THESAURUS OP + (THESAURUS CONST links, TEXT CONST rechts)#off("b")# 
   Fügt dem Thesaurus 'rechts' zu, wenn 'rechts' noch nicht im Thesaurus enthal­
   ten ist. 
 
 
 
 
'-' 
   #on("b")#THESAURUS OP - (THESAURUS CONST links, rechts) #off("b")# 
   Liefert die Differenzmenge. Achtung: Die Differenzmenge enthält keine Namen
   mehrfach. 
 
   #on("b")#THESAURUS OP - (THESAURUS CONST links, TEXT CONST rechts)#off("b")# 
   Nimmt den Namen 'rechts' aus dem Thesaurus. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    fetch(ALL father - ALL myself) 
 
____________________________________________________________________________ 
 
 
'/' 
   #on("b")#THESAURUS OP / (THESAURUS CONST links, rechts) #off("b")# 
   Liefert die Schnittmenge 
   Achtung: Die Schnittmenge enthält keine Namen mehrfach. 
 
 
#page# 

4.2.3  Tasks
 
Zur Identifizierung von Tasks dienen sogenannte 'interne Taskbezeichner'. Ein solcher
Taskbezeichner wird beim Einrichten einer neuen Task vergeben. Interne Taskbe­
zeichner sind auch unter Berücksichtigung der Zeit eindeutig. 
 
Der Zugriff auf interne Taskbezeichner erfolgt über Prozeduren und Operatoren, die
auf Objekte des Datentyps TASK (siehe 2.9.1) angewandt werden. 
 
Zusätzlich zum internen Tasknamen, der nicht auszugeben ist, haben Tasks meistens
einen Namen#u#1) #e#. 
#foot# 
 
1) Unbenannte Tasks haben den Pseudonamen "-". 
#end# 
 
Aus Benutzersicht können benannte Tasks innerhalb eines Rechners vollständig und
eindeutig über ihren Namen identifiziert werden. 
 
 
- Task liefern             :  / , task , niltask 
 
- Verwandtschaften         :  brother , father , myself , son 
 
- Ausgezeichnete Tasks     :  archive , printer , public , supervisor 
 
- Namen liefern            :  name 
 
- Tasknamen ändern         :  rename myself 
 
- Reservieren bes. Tasks   :  reserve 
 
#page# 
'/' 
   #on("b")#TASK OP / (TEXT CONST taskname) #off("b")# 
   Liefert die Task des angegebenen Namens, falls sie existiert. Der eigene Katal­
   og wird automatisch aktualisiert 
 
   (identisch mit der PROC task (TEXT CONST taskname). 
 
   FEHLER :   "taskname" gibt es nicht 
 
 
   #on("b")#TASK OP / (INT CONST station number, TEXT CONST name) #off("b")# 
   Liefert im Netzbetrieb die Task des angegebenen Namen von der Station mit der
   angegebenen Nummer. 
 
 
 
'niltask' 
   #on("b")#TASK CONST niltask #off("b")# 
   Bezeichner für "keine Task". So liefern die Prozeduren 'son', 'brother' und 'father'
   als Resultat 'niltask', wenn keine Sohn-, Bruder- oder Vatertask existiert. 
 
 
 
'task' 
   #on("b")#TASK PROC task (TEXT CONST taskname) #off("b")# 
   Liefert die Task des angegebenen Namens, falls sie existiert. Der eigene Katal­
   og wird automatisch aktualisiert. 
 
   FEHLER :     "taskname" gibt es nicht 
 
 
   #on("b")#TASK PROC task (INT CONST channel number) #off("b")# 
   Liefert den Namen der Task, die an dem angegebenen Kanal hängt. 
#page# 
'brother' 
   #on("b")#TASK PROC brother (TASK CONST task) #off("b")# 
   Liefert den nächsten Bruder von 'task'. Falls kein Bruder existiert, wird 'niltask'
   geliefert. Aktualisiert den eigenen Katalog nicht automatisch! 
 
 
 
'father' 
   #on("b")#TASK PROC father #off("b")# 
   Liefert die eigene Vatertask. 
 
 
   #on("b")#TASK PROC father (TASK CONST task) #off("b")# 
   Liefert den Vater von 'task'. Existiert kein Vater (z.B. bei UR), wird niltask gelie­
   fert. Aktualisiert den eigenen Katalog nicht automatisch! 
 
 
 
'myself' 
   #on("b")#TASK PROC myself #off("b")# 
   Liefert eigenen Task-Bezeichner. 
 
 
 
'son' 
   #on("b")#TASK PROC son (TASK CONST task) #off("b")# 
   Liefert den ersten Sohn von 'task'. Falls keiner im Katalog vermerkt ist, wird
   'niltask' geliefert. Aktualisiert den eigenen Katalog nicht automatisch! 
 
 
#page# 
'archive' 
   #on("b")#TASK PROC archive #off("b")# 
   Liefert den internen Taskbezeichner der aktuellen Task mit Namen ARCHIVE.
   Diese Prozedur dient zum schnellen und bequemen Ansprechen der Archivtask. 
 
 
 
'printer' 
   #on("b")#TASK PROC printer #off("b")# 
   Liefert den internen Taskbezeichner der aktuellen Task mit Namen #ib#PRINTER#ie#.
   Diese Prozedur dient zum schnellen und bequemen Ansprechen des Druckspoo­
   lers. 
 
 
'public' 
   #on("b")#TASK PROC public #off("b")# 
   Liefert den internen Taskbezeichner der Task #ib#PUBLIC#ie#. 
 
 
 
 
'supervisor' 
   #on("b")#TASK PROC supervisor #off("b")# 
   Liefert den internen Taskbezeichner des Supervisors. 
 
 
#page# 
'name' 
   #on("b")#TEXT PROC name (TASK CONST task) #off("b")# 
   Liefert den Namen von 'task'. Die Task muß noch im System existieren, sonst ist
   der Name nicht mehr bekannt. Falls die 'task' noch nicht im eigenen Katalog
   enthalten ist, wird er aktualisiert. 
 
 
 
'rename myself' 
   #on("b")#PROC rename myself (TEXT CONST neuer name) #off("b")# 
   Name der eigenen Task wird in 'neuer name' geändert. Wirkt wie Löschung und
   Wiedereinrichten der Task in Bezug auf alle TASK VAR's die sich auf diese Task
   beziehen. 
 
   FEHLER :   Task existiert bereits 
              Name unzulässig 
              => anderen Namen wählen 
 
 
 
'reserve' 
   #on("b")#PROC reserve (TASK CONST task) #off("b")# 
   Reservieren einer Task für den ausschließlichen Dialog mit der Task, in der das
   Kommando gegeben wurde. 
 
   #on("b")#PROC reserve (TEXT CONST message, TASK CONST task) #off("b")# 
   Wie 'reserve (TASK CONST task)' mit Übergabe einer 'message'. 
 
 
   Die reservierte Task muß ein spezieller Manager, (z.B. /"DOS" aus dem Werkzeug
   MS-DOS-DAT) sein ! 
#page# 

4.2.4  Handhabung von Dateien 
 
'copy' 
   #on("b")#PROC copy (TEXT CONST quelle, ziel) #off("b")# 
   Kopiert die Datei 'quelle' in eine neue Datei mit dem Namen 'ziel' in der Benut­
   zer-Task. 
 
   FEHLER :  "ziel" existiert bereits 
             "quelle" gibt es nicht 
             zu viele Dateien 
 
 
 
'forget' 
   #on("b")#PROC forget (TEXT CONST dateiname) #off("b")# 
   Löschen einer Datei mit dem Namen 'dateiname' in der Benutzer-Task. 
 
   FEHLER :  "datei" gibt es nicht 
 
 
   #on("b")#PROC forget (THESAURUS CONST thesaurus) #off("b")# 
   Löscht die im 'thesaurus' enthaltenen Dateien in der Benutzer-Task. 
 
   Im Dialog erfolgt vor dem Löschen einer Datei standardmäßig die Abfrage: 
 
 
____________________________________________________________________________ 
 
    gib kommando : 
    forget("einedatei") 
 "einedatei" löschen(j/n) ? 
 
____________________________________________________________________________ 
 
#page# 
'list' 
   #on("b")#PROC list #off("b")# 
   Listet alle Dateien der Benutzer-Task mit Namen und Datum des letzten Zugriffs
   auf dem Terminal auf. 
 
 
   #on("b")#PROC list (TASK CONST task) #off("b")# 
   Listet alle Dateien der angegebenen 'task' mit Namen und Datum der letzten
   Änderung auf dem Terminal auf. Die Task muß Manager sein. 
 
 
   #on("b")#PROC list (FILE VAR liste) #off("b")# 
   Listet alle Dateinamen in die Datei 'liste', die mit 'output'(s. 5.3.5) assoziiert sein
   muß. 
 
 
   #on("b")#PROC list (FILE VAR liste, TASK CONST manager) #off("b")# 
   Listet alle Dateien der Task 'manager' mit Namen und Datum der letzten Ände­
   rung in die Datei 'liste'. 
 
 
____________________________________________________________________________ 
 
 gib kommando : 
 FILE VAR f:= sequential file (output,"list");list(f,archive) 
 
____________________________________________________________________________ 
 
#page# 
'rename' 
   #on("b")#PROC rename (TEXT CONST altername, neuername) #off("b")# 
   Umbenennen einer Datei von 'altername' in 'neuername'. 
 
 
 
   FEHLER :   "neuername" gibt es bereits 
              "altername" gibt es nicht 
#page# 
 
4.2.5  Editor-Prozeduren  
 
'edit' 
   #on("b")#PROC edit (TEXT CONST dateiname) #off("b")# 
   Ruft den Editor mit 'dateiname' auf. 
 
 
   #on("b")#PROC edit #off("b")# 
   a) Im Monitor: 
      Ruft den Editor mit den zuletzt verwandten Dateinamen auf. 
 
   b) Im Editor: 
      Der Dateiname wird erfragt. 
 
   Für jedes 'edit' gilt: 
   Wurde 'edit' zum ersten Mal aufgerufen, nimmt das Fenster den gesamten Bild­
   schirm ein. Bei erneutem 'edit'-Aufruf wird ein Fenster nach rechts unten ab der
   aktuellen Cursor-Position eröffnet. 
 
 
   #on("b")#PROC edit (THESAURUS CONST t) #off("b")# 
   Editieren aller in dem Thesaurus 't' enthaltenen Dateien nacheinander. 
 
 
   Weitere 'edit-Prozeduren', die z.B. Variation der Fenstergröße etc. zulassen, sind
   in 5.4.6 beschrieben. 
   
#page# 
'editget' 
   #on("b")#PROC editget  (TEXT VAR editsatz) #off("b")# 
   Ausgabe einer (Kommando)zeile, in der Editorfunktionen zur Verfügung
   stehen siehe Teil 5.5.1.4. 
 
 
 
'show' 
   #on("b")#PROC show (TEXT CONST dateiname) #off("b")# 
   Die Datei wird am Bildschirm gezeigt. Positionierung und Suchen funktionieren wie
   in 'edit', Aktionen die Änderungen in der Datei bewirken würden, werden nicht
   angenommen. 
 
 
 
   #on("b")#PROC show #off("b")# 
   'show' auf der zuletzt bearbeiteten Datei. 
 
#page# 
'kommando auf taste legen' 
   #on("b")#PROC kommando auf taste legen (TEXT CONST taste, elan programm)#off("b")# 
   Die Taste 'taste' wird mit dem angegebenen ELAN-Programm belegt. Durch <ESC>
   <taste> wird das Programm direkt ausgeführt. 
 
____________________________________________________________________________ 
 
  gib kommando : 
  kommando auf taste legen ("a","fetch (SOME archive,archive)") 
 
____________________________________________________________________________ 
 
 
 
'kommando auf taste' 
   #on("b")#TEXT PROC kommando auf taste (TEXT CONST taste)#off("b")# 
   Falls 'taste' mit einem ELAN-Programm belegt ist, liefert die Prozedur den
   Programmtext, andernfalls den leeren Text niltext. 
 
____________________________________________________________________________ 
 
  gib kommando : 
  put (kommando auf taste("f")) 
 
____________________________________________________________________________ 
 
 
 
'taste enthaelt kommando' 
   #on("b")#BOOL PROC taste enthaelt kommando (TEXT CONST taste)#off("b")# 
   Liefert TRUE falls 'taste' mit einem ELAN-Programm belegt ist. 
 
 
'lernsequenz auf taste legen' 
   #on("b")#PROC lernsequenz auf taste legen (TEXT CONST taste, sequenz)#off("b")# 
   'taste' wird mit der Zeichenfolge 'sequenz' belegt. Durch <ESC> <taste> wird die
   Zeichenfolge an der aktuellen Position ausgegeben. 
 
   Als Zeichenfolge sind natürlich auch einzelne Zeichen und EUMEL-Codes zuläs­
   sig. 
 
   Die vom System vorbelegten Tasten sind in 3.4 'Zeichen schreiben' aufgelistet. 
 
____________________________________________________________________________ 
 
  gib kommando : 
  lernsequenz auf taste legen ("x","gib kommando :"13""2""2"") 
 
____________________________________________________________________________ 
 
 
 
'lernsequenz auf taste' 
   #on("b")#TEXT PROC lernsequenz auf taste (TEXT CONST taste) #off("b")# 
   Liefert die auf 'taste' gelegte Zeichenfolge. 
 
 
'std tastenbelegung' 
   #on("b")#PROC std tastenbelegung #off("b")# 
   Die Standard-Tastenbelegung (s.3.4) wird (wieder) hergestellt. 
 
 
'word wrap' 
   #on("b")#PROC word wrap (BOOL CONST b) #off("b")# 
   Der automatische Zeilenumbruch wird durch 'word wrap (FALSE)' aus- und durch
   'word wrap (TRUE)' eingeschaltet. Wird diese Prozedur während des Editierens
   aufgerufen, gilt die Einstellung für die aktuelle Textdatei. Wird die Prozedur als
   Monitor-Kommando gegeben, so gilt die Eingabe als Voreinstellung für neue
   Dateien. 
#page# 
 
4.2.6  Dateitransfer
 
Unter diesem Abschnitt sind diejenigen Prozeduren beschrieben, die der simplen
Kommunikation mit Manager-Tasks dienen: Holen oder Senden einer Dateikopie,
Löschen in der Manager-Task. 
 
#on("b")#ACHTUNG :  Für alle Prozeduren gilt: falls die Manager-Task nicht existiert, wird eine
Fehlermeldung erzeugt, existiert eine Task des angegebenen Namens, die aber nicht
Managertask ist, so terminieren die Prozeduren nicht! 
#off("b")# 
 
 
'fetch' 
   #on("b")#PROC fetch (TEXT CONST dateiname, TASK CONST manager) #off("b")# 
   Kopiert die Datei 'dateiname' aus der Task 'manager' 
 
 
   #on("b")#PROC fetch (THESAURUS CONST th, TASK CONST manager) #off("b")# 
   Kopiert alle Dateien, deren Namen im Thesaurus th enthalten sind, aus der Task
   'manager'. 
 
 
____________________________________________________________________________ 
 
   gib kommando : 
   fetch(ALL(12/"PUBLIC"), 12/"PUBLIC") 
 
____________________________________________________________________________ 
 
 
 
   Mit diesem Kommando werden (in einem EUMEL Netz) alle Dateien der Task
   'PUBLIC' des Rechners mit der Stationsnummer 12 in diesem Netz kopiert. 
 
#page# 
____________________________________________________________________________ 
 
   gib kommando : 
   fetch(SOME archive , archive) 
 
____________________________________________________________________________ 
 
 
 
   Bietet den Thesaurus von 'ARCHIVE' an, nach Auswahl werden alle Dateien deren
   Namen nicht gelöscht wurden, von der Diskette kopiert. 
 
 
   #on("b")#PROC fetch (TEXT CONST dateiname) #off("b")# 
   Kopiert die Datei 'dateiname' aus der Task 'father' 
 
 
   #on("b")#PROC fetch (THESAURUS CONST th) #off("b")# 
   Kopiert alle Dateien, deren Namen in 'th' sind aus der Task 'father'. 
 
 
 
'fetchall' 
 
   #on("b")#PROC fetchall #off("b")# 
   entspricht: fetch (ALL father, father) 
 
 
   #on("b")#PROC fetchall (TASK CONST manager)#off("b")# 
   entspricht: fetch(ALL manager, manager) 
 
#page# 
'save' 
   #on("b")#PROC save (TEXT CONST dateiname, TASK CONST manager) #off("b")# 
   Kopiert die Datei 'dateiname' in die Task 'manager' 
 
 
   #on("b")#PROC save (THESAURUS CONST th, TASK CONST manager) #off("b")# 
   Kopiert alle Dateien, deren Namen im Thesaurus th enthalten sind, in die Task
   'manager'. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    save(all, (12/"PUBLIC")) 
 
____________________________________________________________________________ 
 
 
   Mit diesem Kommando werden (in einem EUMEL Netz) alle Dateien der eigenen
   Task in die Task 'PUBLIC' des Rechners mit der Stationsnummer 12 in diesem
   Netz kopiert. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    save(SOME myself, manager) 
 
____________________________________________________________________________ 
 
 
   Bietet den eigenen Thesaurus an, nach Auswahl werden alle Dateien deren
   Namen nicht gelöscht wurden, zur Task 'manager' kopiert. 
 
 
   #on("b")#PROC save (TEXT CONST dateiname) #off("b")# 
   Kopiert die Datei 'dateiname' in die Task 'father' 
 
 
   #on("b")#PROC save (THESAURUS CONST th) #off("b")# 
   Kopiert alle Dateien, deren Namen in 'th' enthalten sind, in die Task 'father'. 
 
 
   #on("b")#PROC save #off("b")# 
   Kopiert die zuletzt bearbeitete Datei in die Task 'father' 
 
 
 
 
'saveall' 
   #on("b")#PROC saveall #off("b")# 
   entspricht: save (all, father) 
 
 
   #on("b")#PROC saveall (TASK CONST manager) #off("b")# 
   entspricht: save (ALL myself, manager) 
 
#page# 
'erase' 
   #on("b")#PROC erase (TEXT CONST dateiname, TASK CONST manager) #off("b")# 
   Löscht die Datei 'dateiname' aus der Task 'manager' 
 
 
   #on("b")#PROC erase (THESAURUS CONST th, TASK CONST manager) #off("b")# 
   Löscht alle Dateien, deren Namen im Thesaurus th enthalten sind, aus der Task
   'manager'. 
 
 
   #on("b")#PROC erase (TEXT CONST dateiname) #off("b")# 
   Löscht die Datei 'dateiname' aus der Task 'father' 
 
 
   #on("b")#PROC erase (THESAURUS CONST th) #off("b")# 
   Löscht alle Dateien, deren Namen in 'th' sind, aus der Task 'father' 
 
 
   #on("b")#PROC erase #off("b")# 
   Löscht die zuletzt bearbeitete Datei aus der Task 'father' 
 
 
#page# 
'print' 
   Das Kommando 'print' beinhaltet den Auftrag an die Task 'PRINTER' die enthal­
   tene(n) Datei(en) auszudrucken. 
 
   Voraussetzung ist natürlich, daß die Druckersoftware ordnungsgemäß benutzt
   wurde, um 'PRINTER' einzurichten. Siehe dazu Systemhandbuch Teil 6. 
 
 
   #on("b")#PROC print (TEXT CONST dateiname) #off("b")# 
   Kopiert die Datei 'dateiname' in die Task 'PRINTER'. 
 
 
   #on("b")#PROC print (THESAURUS CONST th) #off("b")# 
   Kopiert alle Dateien, deren Namen im Thesaurus 'th' enthalten sind, in die Task
   'PRINTER'. 
 
 
   #on("b")#PROC print #off("b")# 
   Kopiert die zuletzt bearbeitete Datei in die Task 'PRINTER'. 
 
 
#page# 
 
4.2.7  Passwortschutz 
 
Der Passwortschutz im EUMEL-System ist in verschiedener Ausprägung möglich.
Einfachste Möglichkeit ist der Schutz einer Task durch ein Passwort. Falls diese Task
nicht Manager ist, können alle Daten und Programme, die nur in dieser Task zur
Verfügung stehen, auch nur vom Besitzer der Task benutzt werden. 
 
Ähnlich kann auch von einer Manager-Task aus der gesamte Zweig unterhalb dieser
Task mit einem Passwort geschützt werden: beispielsweise kann es empfehlenswert
sein, den Systemzweig komplett zu schützen, indem in SYSUR ein entsprechendes
Passwort vereinbart wird. 
 
Ein Umgehen des Passwortschutzes bei Manager-Tasks (durch Einrichten einer
Sohn-Task und 'fetchall') wird durch ein 'begin password' verhindert. 
 
Auch einzelne Dateien lassen sich schützen, indem Lese/Schreibpasswörter für den
Dateitransfer vereinbart werden. 
 
Generell gilt für die Verwendung von Passworten: 
 
-  Passworte, die zu naheliegend gewählt sind (Vorname des Lebenspartners o.ä.)
   sind meistens sinnlos, falls wirklich Datenschutz bezweckt ist. 
 
-  Passworte, die so raffiniert sind, daß sogar ihr Schöpfer sie vergißt, führen zu
   100%igem Datenverlust, da die betroffene Task oder Datei nur noch gelöscht
   werden kann. 
 
-  Die Vereinbarung von "-" als Passwort bewirkt, daß die entsprechende Aktion
   nicht mehr durchgeführt werden kann. Wird z.B. '-' als 'task password'
   eingegeben, so kann die Task nie wieder an ein Terminal gekoppelt werden. 
 
-  Passwörter können geändert werden, indem das entsprechende Kommando noch
   einmal mit dem neuen Passwort gegeben wird. 
 
#page# 
'begin password' 
 
   #on("b")#PROC begin password (TEXT CONST passwort) #off("b")# 
 
   Auf Supervisor-Ebene wird vor Einrichten einer neuen Task als Sohn der Task in
   der das 'begin password' gegeben wurde, dieses erfragt. 
 
   Das Password vererbt sich auf die hinzukommenden Sohn-Tasks. 
 
____________________________________________________________________________ 
 
    #on("b")#SYSUR#off("b")# 
    maintenance : 
    begin password ("alles dicht") 
 
____________________________________________________________________________ 
 
 
bewirkt: 
 
____________________________________________________________________________ 
 
                                           Terminal 2  
 
 
                    EUMEL Version 1.8.1/M 
 
 
        gib supervisor kommando: 
        begin ("sabotage","SYSUR") 
              Passwort:  
 
 
   ESC ? --> help 
   ESC b --> begin("")            ESC h --> halt 
   ESC c --> continue("")         ESC s --> storage info 
   ESC q --> break                ESC t --> task info 
 
 
____________________________________________________________________________ 
 
 
#page# 
'enter password' 
   #on("b")#PROC enter password (TEXT CONST datei, schreibpass, lesepass) 
   #off("b")# 
   Hiermit können ausgewählte Dateien einer Manager-Task geschützt werden. Die
   angegebene Datei wird mit Schreib- und Lesepassword versehen. Die Pass­
   wörter werden in der eigenen Task nicht berücksichtigt. 
 
   Bei einem lesenden Zugriff (fetch) von irgendeiner Task aus auf die entsprechende
   Datei in der Manager-Task muß das Lesepasswort, bei schreibendem Zugriff
   (save/erase) das Schreibpasswort vereinbart sein. 
 
 
____________________________________________________________________________ 
 
    maintenance : 
    enter password ("wichtige datei","sicher","heit") 
 
____________________________________________________________________________ 
 
 
 
 
   #on("b")#PROC enter password (TEXT CONST password) #off("b")# 
   Passwort für den Dateitransfer einstellen. Falls zwei verschiedene Passwörter für
   Lesen und Schreiben vereinbart werden sollen, so sind sie als ein Text durch "/"
   getrennt einzugeben. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    enter password ("sicher/heit") 
 
    gib kommando : 
    save(SOME all) 
 
____________________________________________________________________________ 
#page# 
'family password' 
   #on("b")#PROC family password (TEXT CONST geheim) #off("b")# 
   Einstellen eines Passworts für den Zweig des Systems , der unterhalb der (Mana­
   ger) Task liegt, in der das 'family password' eingegeben wurde. Dabei erhalten
   alle Tasks, die kein Password oder dasselbe wie diese Manager-Task haben, das
   'family password'. Tasks in dem Zweig, die ein eigenes anderes besitzen, behal­
   ten dieses. 
 
____________________________________________________________________________ 
 
   PUBLIC 
 
     Task1 "" 
 
     Task2 family password("fingerweg") 
        Task21 geheim 
        Task22 "" 
 
     Task3 "" 
        Task31 "" 
 
____________________________________________________________________________ 
 
 
 
 
bewirkt: 
 
____________________________________________________________________________ 
   PUBLIC 
 
     Task1 "" 
 
     Task2 fingerweg 
        Task21 geheim 
        Task22 fingerweg 
 
     Task3 "" 
        Task31 "" 
 
____________________________________________________________________________ 
 
 
#page# 
 
'task password' 
 
   #on("b")#PROC task password (TEXT CONST geheim) #off("b")# 
   Einstellen eines Passworts für die Task in der es gegeben wird. Ist eine Task mit
   einem Passwort geschützt, so wird durch den Supervisor nach dem 'continue'-
   Kommando das Passwort angefragt (Entsprechend dem 'begin password'). Nur
   nach Eingabe des richtigen Passworts gelangt man in die gewünschte Task. Das
   Passwort kann durch nochmaligen Aufruf von 'task password' geändert werden,
   z.B. wenn es in regelmäßigen Abständen geändert werden muß, um personenbe­
   zogene Daten zu schützen. 
 
#page# 
 
4.2.8  Das Archiv 
 
Mit dem Terminus 'Archiv' wird beim EUMEL-System ein Diskettenlaufwerk bezeich­
net, das nur Datensicherungsaufgaben dient. Falls ein Rechner eins von zwei vorhan­
denen Diskettenlaufwerk als Arbeitsspeicher benutzt, so wird dieses als Hintergrund
bezeichnet. Falls Sie einen derartigen Rechner benutzen, können Sie der Installa­
tionsanleitung entnehmen, welches Laufwerk welcher Aufgabe zugeordnet ist. 
 
Das #ib#Archiv#ie# übernimmt im EUMEL-System die Verwaltung der langfristigen Daten­
haltung. Das Archiv sollen Sie benutzen, um: 
 
-  Sicherungskopien wichtiger Dateien außerhalb des Rechners zu besitzen; 
 
-  nicht benötigte Dateien außerhalb einer Task zu halten (Speicherplatzersparnis!); 
 
-  Dateien auf andere Rechner zu übertragen. 
 
Das Archiv wird im EUMEL-System durch die Task 'ARCHIVE', die das Disketten­
laufwerk des Rechners verwaltet, realisiert. 
 
- reservieren              :  archive 
 
- freigeben                :  release 
 
- löschen                  :  clear , format 
 
- prüfen                   :  check 
 
#page# 
'archive' 
   #on("b")#PROC archive (TEXT CONST archivname) #off("b")# 
   Reservierung der Task ARCHIVE für den exklusiven Dialog mit der aufrufenden
   Task. 'archivname' wird bei allen folgenden Archivoperationen mit dem der Disket­
   te zugewiesenen (und hoffentlich auf dem Aufkleber vermerkten) Namen abgegli­
   chen. 
 
 
 
'release' 
   #on("b")#PROC release (TASK CONST archive) #off("b")# 
   Nach diesem Kommando kann die Task 'ARCHIVE' mit ihren Leistungen von einer
   anderen Task in Anspruch genommen werden. Falls dieses Kommando nicht
   gegeben wird, aber seit 5 Minuten kein Dialog mit 'archive' stattfand, kann eine
   andere Task durch die Anforderung 'archive("diskettenname")' das Archiv reser­
   vieren. Durch diese Maßnahme wird verhindert, daß ein vergeßlicher Benutzer bei
   einem System mit mehreren Benutzern das Archiv blockiert. 
 
#page# 
 
'clear' 
   #on("b")#PROC clear (TASK CONST archive) #off("b")# 
   Löschen des Disketten-Inhaltsverzeichnisses und Zuweisung des in der Reservie­
   rung eingegebenen Namens. 
 
____________________________________________________________________________ 
 
    gib kommando : 
    archive("name"); #ib#clear#ie# (archive) 
 
____________________________________________________________________________ 
 
 
   Durch die Ausführung des Kommandos erhält die eingelegte Diskette den in der
   Reservierung angegebenen Namen. #on("b")#Das Inhaltsverzeichnis, das sich auf der
   Diskette befindet, wird gelöscht. Damit sind die Daten, die sich eventuell auf
   dieser Diskette befanden, nicht mehr auffindbar#off("b")#. Die Diskette entspricht einer neu
   formatierten Diskette#u#1)#e#. 
 
   Man kann also eine beschriebene Diskette nicht umbenennen, ohne die darauf
   befindlichen Daten zu löschen. 
 
   #foot# 
 
   #u#1)#e# Das Kommando 'format' enthält implizit 'clear'. 
#end# 
 
   Eine Neuformatierung ist demnach bei Wiederverwendung der Diskette nicht
   notwendig. 
 
#page# 
'format' 
   #on("b")#PROC format (TASK CONST archive) #off("b")# 
   Formatieren einer Diskette. Vor der erstmaligen Benutzung einer Archivdiskette
   muß diese formatiert, d.h. in Spuren und Sektoren für die Positionierung des
   Schreib-/Lesekopfes des Diskettenlaufwerks eingeteilt werden, um überhaupt ein
   Beschreiben der Diskette zu ermöglichen. Die Einteilung ist geräteabhängig, häufi­
   ge Formate sind: 
 
              40 Spuren zu je 9 Sektoren (360 K) 
              80 Spuren zu je 9 Sektoren (720 K). 
 
   Die #on("b")#Erst#off("b")#benutzung einer #ib#Archivdiskette#ie# erfordert nach der Reservierung des Ar­
   chivs das Kommando: 
 
____________________________________________________________________________ 
 
    gib kommando : 
    archive("diskname"); 
 
    gib kommando : 
    format (archive); 
 
____________________________________________________________________________ 
 
 
Erst nach einer Kontrollabfrage: 
 
____________________________________________________________________________ 
 
    gib kommando: 
    format (archive) 
 
  Archiv "diskname" formatieren ? (j/n) 
 
____________________________________________________________________________ 
 
 
 
   wird tatsächlich formatiert und die Diskette steht mit dem Namen "diskname" für
   Archivoperationen zur Verfügung. 
 
#page# 
 
   #on("b")#PROC format (INT CONST code, TASK CONST archive) #off("b")# 
   Bei einigen Rechnern ist es möglich, die Formatierung zu variieren. Falls beim
   Formatieren auf einem solchen Rechner ein anderes als das Standardformat
   erzeugt werden soll, so ist die Codierung des gewünschten Formats mitanzuge­
   ben. 
 
 
   Beispiel:    Für ein Gerät mit 5,25 Zoll Disketten wäre z.B. einstellbar: 
                code 0 : Standardformat 
                code 1 : 2D , 40 Spuren , 9 Sektoren 
                code 2 : 2D , 80 Spuren , 9 Sektoren 
                code 3 : HD , 80 Spuren ,15 Sektoren 
 
                'format (archive)' erzeugt ebenso wie 'format (0,archive)' eine
                standardformatierte Diskette, 'format (3,archive)' erzeugt eine High
                Density Formatierung (HD Floppy benutzen!). 
 
#on("b")# 
   ACHTUNG:   Wird eine bereits beschriebene Diskette noch einmal formatiert, so
              sind alle Daten, die auf der Diskette waren, verloren. 
 
              Die Umformatierung einer Diskette (z.B. von 720K auf 360K) auf
              unterschiedlichen Laufwerken kann zu Problemen führen. 
#off("b")# 
#page# 
'check' 
   #on("b")#PROC check (TEXT CONST dateiname, TASK CONST task) #off("b")# 
   Überprüft, ob die Datei 'dateiname' auf dem Archiv lesbar ist. 
 
 
   #on("b")#PROC check (THESAURUS CONST t, TASK CONST task) #off("b")# 
   Überprüft, ob die in dem Thesaurus 't' enthaltenen Dateien auf dem Archiv lesbar
   sind. 
 
 
   Mit diesem Kommando kann nach dem Beschreiben einer Diskette überprüft wer­
   den, ob die Datei(en) lesbar sind. Hierdurch können also verschmutzte oder
   beschädigte Disketten erkannt werden. 
 
 
____________________________________________________________________________ 
 
    gib kommando : 
    save (all , archive) 
 
    gib kommando : 
    check (ALL archive, archive) 
 
____________________________________________________________________________ 
 
#page# 
 
Beispiel: 
 
 
____________________________________________________________________________ 
 
    gib kommando : 
    archive ("neu") 
 
    gib kommando : 
    format (archive) 
 
____________________________________________________________________________ 
 
 
liefert zunächst die Kontollfrage: 
 
____________________________________________________________________________ 
 
    gib kommando : 
    format (archive) 
 
    Archiv "neu" formatieren ? (j/n) 
 
____________________________________________________________________________ 
 
 
Nach Eingabe 'j' 
 
____________________________________________________________________________ 
 
    gib kommando : 
    saveall (archive) 
 
    gib kommando : 
    archive("alt") (* nächste Diskette *) 
 
    gib kommando : 
    fetch(SOME archive ,archive) 
 
____________________________________________________________________________ 
 
 
Der Thesaurus des Archivs wird angezeigt: 
#page# 
____________________________________________________________________________ 
 
  .................alt (100 K belegt von 720 K)...............  
 
 01.02.87   25 K  "handbuch teil 1" 
 01.03.87   23 K  "handbuch teil 2" 
 01.04.87   20 K  "handbuch teil 3" 
 01.05.87   32 K  "handbuch teil 4" 
 
____________________________________________________________________________ 
 
 
 
 
 
Zum Abschluß Archiv freigeben! 
____________________________________________________________________________ 
 
    gib kommando : 
    release(archive) 
 
____________________________________________________________________________ 
#page# 

Fehlermeldungen des Archivs
Versucht man, eine Datei vom Archiv zu holen, kann es vorkommen, daß das Ar­
chiv-System 
 
____________________________________________________________________________ 
 
    gib kommando : 
    fetch ("datei", archive) 
    #ib#Lese-Fehler (Archiv)#ie# 
 
____________________________________________________________________________ 
 
 
 
meldet und den Lese-Vorgang abbricht. Dies kann auftreten, wenn die Floppy
beschädigt oder aus anderen Gründen nicht lesbar ist (z.B. nicht justierte Disket­
ten-Geräte). In einem solchen Fall vermerkt das Archiv-System intern, daß die Datei
nicht korrekt gelesen werden kann. Das sieht man z.B. bei 'list (archive)'. Dort ist der
betreffende Datei-Name mit dem Zusatz 'mit Lese-Fehler' gekennzeichnet. Um
diese Datei trotzdem zu lesen, muß man sie unter ihrem Dateinamen mit dem Zusatz
'mit Lese-Fehler' lesen. 
 
____________________________________________________________________________ 
 
    gib kommando: 
    fetch ("datei mit Lese-Fehler", archive) 
 
____________________________________________________________________________ 
 
 
 
Die Datei wird in diesem Fall trotz Lese-Fehler (Informationsverlust!) vom Archiv
gelesen. 
#page# 

Weitere Fehlermeldungen des Archivs: 
 
 
FEHLER : Lesen unmöglich (Archiv) 
         Die Archiv-Diskette ist nicht eingelegt oder die Tür des Laufwerks ist nicht
         geschlossen. 
         => Diskette einlegen bzw. Tür schließen. 
 
FEHLER : Schreiben unmöglich (Archiv) 
         Die Diskette ist schreibgeschützt. 
         => falls wirklich gewünscht, Schreibschutz entfernen. 
 
FEHLER : Archiv nicht angemeldet 
         Das Archiv wurde nicht angemeldet 
         => 'archive ("name")' geben. 
 
FEHLER : Lese-Fehler (Archiv) 
         Siehe Lesen unmöglich 
 
FEHLER : Schreibfehler (Archiv) 
         Die Diskette kann nicht (mehr) beschrieben werden. 
         => Andere Diskette verwenden. 
 
FEHLER : Speicherengpass 
         Im System ist nicht mehr genügend Platz, um eine Datei vom Archiv zu
         laden. 
         => ggf. Dateien löschen. 
 
FEHLER : RERUN bei Archiv-Zugriff Das System wurde bei einer Archiv-Operation
         durch Ausschalten bzw. Reset unterbrochen. 
 
FEHLER : "dateiname" gibt es nicht 
         Die Datei "dateiname" gibt es nicht auf dem Archiv. 
         => mit 'list(archive)' Archiv prüfen. 
 
FEHLER : Archiv heißt ... 
         Die eingelegte Diskette hat einen anderen als den eingegebenen Archivna­
         men. 
         => Kommando 'archive' mit korrektem Namen geben. 
 
FEHLER : Archiv wird von Task ... benutzt 
         Das Archiv wurde von einem anderen Benutzer reserviert. 
         => Abwarten. 
 
FEHLER : "dateiname" kann nicht geschrieben werden (Archiv voll) 
         Die Datei ist zu groß für die eingelegte Diskette. 
         => Andere Diskette für diese Datei nehmen. 
 
FEHLER : Archiv inkonsistent 
         Die eingelegte Diskette hat nicht die Struktur einer Archiv-Diskette. 
         => 'format (archive)' vergessen. 
 
FEHLER : save/erase wegen Lese-Fehler verboten 
         Bei Archiven mit Lese-Fehler sind Schreiboperationen verboten, weil ein
         Erfolg nicht garantiert werden kann. 

