#page nr ("%", 31)# 
#head# 
EUMEL-BASIC-Compiler    8. Übersicht über die Befehle und Funktionen    % 
 
#end# 
 
8. Übersicht über die Anweisungen und Funktionen 
    
 
 
In diesem Kapitel sind alle Anweisungen und Funktionen des vom Compiler übersetz­
baren BASIC-Sprachumfangs in alphabetischer Reihenfolge aufgeführt. 
Auch die Anweisungsbestandteile (z.B. ELSE und TO) sind mit einem Hinweis auf die
zugehörige Anweisung eingeordnet. 
Sind bei Funktionen INT- oder REAL-Ausdrücke als Argumente angegeben, so ist
dies als Hinweis auf den Sinn der Funktion zu verstehen. Es können auch Ausdrücke
des jeweils anderen Datentyps eingesetzt werden. Wird statt eines INT-Ausdrucks
ein REAL-Ausdruck angegeben, so darf dessen Wert aber nur innerhalb des
Wertebereichs für INTs liegen, da der REAL-Wert bei der Ausführung der Funktion
in einen INT-Wert konvertiert wird. 
 
 
 
Funktion : ABS 
 
Zweck :        Berechnung des Betrages (Absolutwertes) einer Zahl 
 
Syntax :       ABS (<num. Ausdruck>) 
 
Erklärung :   Liefert den Betrag des numerischen Ausdrucks. 
              Das Ergebnis ist vom gleichen Typ wie das Argument. 
 
 
Beispiel :      10 a = -12.74 
                20 PRINT ABS (a) 
                Ausgabe: 12.74 
 
Vergleiche :  SGN-Funktion 
 
 
 
Operator :  AND 
 
Siehe Kapitel 4.4. (Operatoren) 
 
 
 
Anweisungsbestandteil : AS 
 
Siehe NAME-Anweisung 
 
 
 
Funktion : ASC 
 
Zweck :        Ermittlung des ASCII-Codes eines Textzeichens 
 
Syntax :       ASC (<TEXT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert den ASCII-Code des ersten Zeichens des
              TEXT-Ausdrucks. 
              Der Code wird als INT geliefert. 
 
 
Beispiel :      10 a$ = "Guten Tag !" 
                20 PRINT ASC (a$) 
                Ausgabe:  71 
 
Vergleiche :  CHR$-Funktion (Komplementärfunktion) 
 
 
 
Funktion : ATN 
 
Zweck :        Berechnung des Arcustangens 
 
Syntax :       ATN (<num. Ausdruck>) 
 
Erklärung :   Die Funktion liefert den Arcustangens des 
              numerischen Ausdrucks in Radiant. 
 
 
Beispiel :      10 LET x = 4 
                20 PRINT ATN (x) 
                Ausgabe: 1.325818 
 
Vergleiche :  TAN-Funktion (Komplementärfunktion), SIN, COS 
 
 
 
Anweisungsbestandteil : BASE 
 
Siehe OPTION BASE-Anweisung 
 
 
 
Anweisung : CALL 
 
Zweck :        Aufruf einer insertierten Prozedur 
 
Syntax :       CALL <Prozedurname> #right#[ (<Parameter> [, <Parameter>] [...] ) ] 
 
Erklärung :   <Prozedurname>: Folge aus Zeichen, die für Prozeduren im
              EUMEL-System zugelassen sind (also Buchstaben und  - ab der
              zweiten Stelle -  Zahlen), aber keine Leerzeichen. 
 
              <Parameter>: <CONST-Parameter> | <VAR-Parameter> 
 
              <CONST-Parameter>:   Ausdruck (genau des von der Prozedur
                                   benötigten Typs) 
              <VAR-Parameter>:     Variable (genau des von der Prozedur benö­
                                   tigten Typs) 
 
              Die Prozedur mit dem angegebenen <Prozedurnamen> wird mit den
              angegebenen Parametern aufgerufen. 
              Die aufgerufene Prozedur darf keinen Wert liefern (vgl. USR-Funk­
              tion). 
 
              Mögliche Fehlerfälle: 
              - Eine Prozedur mit dem Namen <Prozedurnamen> und den an­
                gegebenen Parametern gibt es nicht. 
              - Die Prozedur liefert einen Wert. 
              - Die Prozedur benötigt Parametertypen, die in BASIC nicht bekannt
                sind (z.B. BOOL, FILE, TASK, QUIET). 
              - Ein Parameter ist CONST, es wird aber ein VAR-Parameter ver­
                langt. 
 
              Weitere Informationen finden Sie in Kapitel 4.7. 
 
Hinweis :     1.  Bei den Parametern wird keine Typkonvertierung vorgenommen. 
              2. Der Prozedurname muß (entgegen der ELAN-Gewohnheit) ohne
                 Leerzeichen angegeben werden. 
              3. Statt des Anweisungswortes CALL kann auch CHAIN geschrieben
                 werden. CALL und CHAIN werden im EUMEL-BASIC nicht wie
                 in Microsoft-BASIC benutzt. 
 
 
Beispiel :      10 CALL sysout ("Meine Datei") 
                20 PRINT "Dieser Text geht nun in die Datei" 
                30 CALL sysout ("") 
                40 PRINT "Wieder auf den Bildschirm" 
                 
 
Vergleiche :  USR-Funktion 
 
 
 
Funktion : CDBL 
 
Zweck :        Konvertierung in den Datentyp REAL 
 
Syntax :       CDBL (<num. Ausdruck>) 
 
Erklärung :   Das Ergebnis des numerischen Ausdrucks wird als REAL geliefert. 
 
 
Beispiel :      10 LET a! = 17 
                20 PRINT USR max (CDBL (a!), 152.3) 
                30 REM max benötigt zwei REALs als Parameter 
 
 
Vergleiche :  CINT-Funktion 
 
 
 
Anweisung : CHAIN 
 
Vollkommen identisch mit der CALL-Anweisung (Erklärung siehe dort !) 
 
 
 
Funktion : CHR$ 
 
Zweck :        Erzeugung eines Textzeichens mit einem bestimmten ASCII-Code 
 
Syntax :       CHR$ (<INT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert das Zeichen mit dem ASCII-Code, den der
              INT-Ausdruck angibt. 
              Das Zeichen wird als TEXT geliefert. 
              Die Leistung der Funktion ist nur für Werte im Bereich 0 bis 255
              definiert. 
 
 
Beispiel :      10 PRINT CHR$ (61) 
                Ausgabe:  = 
 
Vergleiche :  ASC-Funktion (Komplementärfunktion) 
 
 
 
Funktion : CINT 
 
Zweck :        Konvertierung in den Datentyp INT 
 
Syntax :       CINT (<num. Ausdruck>) 
 
Erklärung :   Das Ergebnis des numerischen Ausdrucks wird als INT geliefert.
              REALs werden gerundet. Werte außerhalb des INT-Bereichs führen
              zu einem INT-Überlauf. 
 
 
Beispiel :      10 LET a = 17.625 
                20 PRINT CINT (a); CINT (-a) 
                Ausgabe:  18  -18 
 
Vergleiche :  CDBL-, FIX-, INT-Funktionen 
 
 
 
Anweisung : CLS 
 
Zweck :        Löschen des Bildschirms 
 
Syntax :       CLS 
 
Erklärung :   Löscht den Bildschirm und positioniert den Cursor in die linke obere
              Bildschirmecke (Position 1, 1). 
 
 
Beispiel :      10 CLS 
                20 PRINT "PROGRAMMBEGINN" 
 
 
 
 
Funktion : COS 
 
Zweck :        Berechnung des Cosinus eines Radiantwertes 
 
Syntax :       COS (<Winkel>) 
 
Erklärung :   <Winkel>: REAL-Ausdruck, der den Winkel in Radiant angibt. 
              Die Funktion liefert den Cosinus des Winkels als REAL. 
 
 
Beispiel :      10 PI = 3.141593 
                20 PRINT COS (PI/4) 
                Ausgabe:  .7071067 
 
Vergleiche :  SIN-, TAN-Funktionen 
 
 
 
Funktion : CSRLIN 
 
Zweck :        Ermittlung der aktuellen Cursorzeile 
 
Syntax :       CSRLIN 
 
Erklärung :   Geliefert wird die Nummer der Zeile (als INT), in der sich der Cursor
              auf dem Bildschirm befindet. Die oberste Zeile hat die Nummer 1. 
 
 
Beispiel :      10 CLS 
                20 PRINT 
                30 PRINT CSRLIN 
                Ausgabe:  2 
 
Vergleiche :  POS-Funktion 
 
 
 
Funktion : CVD, CVI 
 
Zweck :        Decodierung von in Texten verschlüsselten Zahlenwerten 
 
Syntax :       CVD (<TEXT-Ausdruck>) 
              CVI (<TEXT-Ausdruck>) 
 
Erklärung :   INTs und REALs können (mit MKI$ und MKD$) zu Texten codiert
              werden. 
              CVD decodiert einen in 8 TEXT-Zeichen codierten REAL-Wert. 
              CVI decodiert einen in 2 TEXT-Zeichen codierten INT-Wert. 
              Es wird beim ersten Zeichen des TEXT-Ausdrucks mit der Dekodie­
              rung begonnen. 
              Ist der TEXT zu kurz, so wird mit der Meldung "Ueberlauf bei Subs­
              kription" abgebrochen. 
 
 
Beispiel :      10 zahl$ = MKD$ (3.1415) 
                20 PRINT CVD (zahl$) 
                Ausgabe:  3.1415 
 
Vergleiche :  MKD$-, MKI$- Funktionen (Komplementärfunktionen) 
 
 
 
Anweisung : DATA 
 
Zweck :        Ablegen von Konstanten 
 
Syntax :       DATA [<string>] [, [<string>]] [...] 
 
Erklärung :   <string>         : <quoted string> | <unquoted string> 
              <quoted string>  : von Anführungszeichen umschlossene Zeichen­
                                 folge, die alle Zeichen außer Anführungs­
                                 zeichen enthalten darf 
              <unquoted string>: Zeichenfolge, die alle Zeichen außer Komma
                                 und Doppelpunkt enthalten darf 
 
              Eine DATA-Anweisung stellt einen Datenspeicher dar, der mit READ
              (s.d.) ausgelesen werden kann. 
              In der DATA-Anweisung können "quoted strings" oder "unquo­
              ted strings" angegeben werden. "quoted strings" können später nur
              noch als Texte ausgelesen werden. 
              Bei "unquoted strings" wird der Datentyp in der DATA-Anweisung
              dagegen nicht festgelegt. Sie können also als INTs, REALs oder
              TEXTe ausgelesen werden. Sollen "unquoted strings" Zahlenwerte
              darstellen, so müssen sie den in BASIC üblichen Schreibregeln für
              die numerischen Konstanten des jeweiligen Typs genügen. Es sind
              allerdings zusätzlich noch Vorzeichen erlaubt. 
              Wenn die <strings> nicht angegeben sind, so wird ein "nil-Datum"
              abgelegt. Dieses bewirkt bei einem READ mit numerischer Variable
              die Lieferung des Wertes null und bei einem READ mit TEXT-Vari­
              able die Lieferung eines Leertextes. 
 
              Die DATA-Anweisungen können an beliebiger Stelle im Programm
              (vor oder hinter den zugehörigen READ-Anweisungen) stehen. 
 
              Alle DATA-Anweisungen eines Programms bilden zusammen einen
              großen sequentiellen Speicher, auf den mit READ der Reihe nach
              zugegriffen wird. Intern wird ein sogenannter READ-DATA-Zeiger
              geführt, der immer auf das nächste auszulesende Element zeigt. 
              Die RESTORE-Anweisung (s.d.) ermöglicht es, den READ-
              DATA-Zeiger auf das erste Element einer bestimmten DATA-Zeile
              zu setzen. 
 
 
Beispiel :      2020 PRINT "Stadt", "Land", "Fluß" 
                2030 READ stadt$, land$, fluß$ 
                2040 PRINT stadt$, land$, fluß$ 
                . 
                5000 DATA Paris, Frankreich, Seine 
 
 
Vergleiche :  READ-, RESTORE-Anweisungen 
 
 
 
Funktion : DATE$ 
 
Zweck :        Abrufen des aktuellen Tagesdatums 
 
Syntax :       DATE$ 
 
Erklärung :   Das Tagesdatum wird als Text in der Form TT.MM.JJ geliefert. 
 
 
Beispiel :      10 PRINT "Heute ist der " + DATE$ 
                Ausgabe (z.B.):  Heute ist der 28.08.87 
 
Vergleiche :  TIME$-Funktion 
 
 
 
Anweisung : DEFDBL, DEFINT, DEFSNG, DEFSTR 
 
Zweck :        Definition von Anfangsbuchstaben zur Kennzeichnung bestimmter
              Variablentypen 
 
Syntax :       DEFDBL <Buchstabe1> [ - <Buchstabe2>] 
              #right#[, <Buchstabe3> [ - <Buchstabe4>] ] [...] 
              DEFINT <Buchstabe1> [ - <Buchstabe2>] 
              #right#[, <Buchstabe3> [ - <Buchstabe4>] ] [...] 
              DEFSNG <Buchstabe1> [ - <Buchstabe2>] 
              #right#[, <Buchstabe3> [ - <Buchstabe4>] ] [...] 
              DEFSTR <Buchstabe1> [ - <Buchstabe2>] 
              #right#[, <Buchstabe3> [ - <Buchstabe4>] ] [...] 
 
 
Erklärung :   Mit den aufgeführten Anweisungen ist es möglich, bestimmte Buch­
              staben festzulegen, die, wenn sie als Anfangsbuchstaben eines
              Variablennamens verwendet werden, der Variablen einen bestimmten
              Typ zuordnen. 
 
              Die Typfestlegung durch Kennzeichnung mit den Zeichen '!', '\#', '%'
              oder '$' hat jedoch Vorrang vor den festgelegten Anfangsbuchstaben.
              Eine genaue Erläuterung, nach welchen Kriterien der BASIC-Compi­
              ler den Typ einer Variablen feststellt, befindet sich in Kapitel 4.3. 
 
              Die DEFINT-Anweisung legt Anfangsbuchstaben für INT-Variablen
              fest. 
              Mit der DEFSTR-Anweisung werden Anfangsbuchstaben von
              TEXT-Variablen festgelegt. 
              Die Anweisungen DEFDBL- und DEFSNG- wurden nur aus Kom­
              patibilitätsgründen implementiert. Sie werden zwar auf syntaktische
              Richtigkeit überprüft, aber ansonsten vom Compiler nicht beachtet. 
 
              Werden bei den Anweisungen ganze Buchstabenbereiche angegeben,
              so muß der Buchstabe vor dem Bindestrich auch im Alphabet vor
              dem Buchstaben hinter dem Bindestrich stehen. 
 
Hinweis :     1.  Die oben beschriebenen Anweisungen gelten stets erst für die im
                 weiteren Text neu benutzten (also neu eingerichteten) Variablen. 
              2. Die beschriebenen Anweisungen dürfen auch mehr als einmal in
                 einem Programm vorkommen. Die Buchstaben, die in der zweiten
                 und in den folgenden Anweisungen festgelegt werden, werden
                 #on("izusätzlich#off("i zu den in der ersten Anweisung festgelegten Buchsta­
                 ben als Kennzeichen für den betreffenden Datentyp vom Compiler
                 vermerkt. 
              3. Der Compiler überprüft nicht, ob gleiche Buchstaben als Kennzei­
                 chen für mehr als einen Variablentyp angegeben werden (siehe
                 Kapitel 4.3.). Der Benutzer ist also selbst dafür verantwortlich, daß
                 solche Überschneidungen nicht vorkommen. 
 
 
Beispiel :      10 DEFSTR s - z 
                20 DEFINT a - h, n 
                30 DIM tabelle (17) 'TEXT-Feld 
                40 LET c = 4        'INT-Variable 
                50 LET nummer = 17  'INT-Variable 
                60 LET ueberschrift = "Willkommen" 'TEXT-Variable 
                70 LET reellezahl = 19.563 'REAL-Variable 
                80 LET aha\# = -1.36E17     'REAL-Variable 
                 
 
 
 
Anweisung : DEF FN 
 
Zweck :        Definition einer benutzer-definierten Funktion 
 
Syntax :       DEF FN<Name> [ ( <Parameter> [, <Parameter>] #right# [...] ) ] = <Funktionsdefinition> 
 
Erklärung :   <Name>     :  Zeichenfolge, die der Syntax für Variablennamen
                            entsprechen muß 
                            FN<Name> bilden zusammen den Namen der
                            neuen Funktion 
              <Parameter>:  Zeichenfolge, die der Syntax für Variablennamen
                            entsprechen muß 
              <Funktionsdefinition>:  Ausdruck, der Konstanten, Variablen, die
                                      Parameter der Funktion und Aufrufe
                                      anderer Funktionen enthalten darf 
 
              Mit der DEF FN-Anweisung wird eine benutzer-definierte Funktion
              ("user function") mit dem Funktionsnamen FN<Name> definiert
              (vergleiche hierzu auch Kapitel 4.5.). 
              Die benutzer-definierte Funktion liefert, genau wie die standard­
              mäßig eingebauten Funktionen, einen Wert, der sich aus der Auswer­
              tung des unter <Funktionsdefinition> angegebenen Ausdrucks
              ergibt. 
              Das letzte Zeichen des Funktionsnamens gibt den Typ des Wertes
              an, den die Funktion liefert. Soll die Funktion einen TEXT liefern, so
              muß der Name mit "$" enden. Soll ein INT geliefert werden, muß der
              Name mit "%" enden. Für alle anderen Endungen wird eine REAL-
              liefernde Funktion eingetragen. 
              Bezeichnet der Funktionsname eine TEXT-liefernde Funktion, so
              muß auch die Funktionsdefinition ein Ergebnis vom Typ TEXT liefern.
              Zwischen INTs und REALs findet eine Typanpassung statt. 
 
              Die Parameter stehen für die beim Aufruf der Funktion übergebenen
              Argumente. 
              Sie haben nur bei der Definition Gültigkeit. Hierbei 'überdecken' sie
              (für diese Zeile) eventuell im BASIC-Programm vorhandene gleich­
              namige Variablen. 
              Die Syntax der Parameternamen entspricht der Syntax der Namen
              von einfachen Variablen. 
              Jeder Parameter darf in der Parameterliste nur einmal vorkommen. 
 
              In der Definition dürfen auch Aufrufe von zuvor definierten anderen
              "user functions" erscheinen, nicht aber die zu definierende Funktion
              selbst (rekursive Definition). 
 
              Die Funktionen sind allein durch ihre Namen gekennzeichnet. Gene­
              rische Funktionen (gleicher Name, aber unterschiedliche Parameter)
              können somit nicht definiert werden. 
 
Hinweis :     1.  Die Definition einer "user function" muß ihrem ersten Aufruf
                 immer textuell vorausgehen. 
              2. "user functions" können auch mehrfach definiert werden. Der
                 Compiler gibt in einem solchen Fall aber eine Warnung aus, da
                 die neue Definition nur für die textuell folgenden Aufrufe gültig ist. 
 
 
Beispiel :      10 LET pi = 3.1415927 
                20 DEF FNkreisflaeche (radius) 
                #right#= 4.0 * pi * radius * radius 
                1010 PRINT FNkreisflaeche (1.75) 
                Ausgabe:  38.48451 
 
 
 
Anweisung : DIM 
 
Zweck :        Dimensionierung eines Feldes 
 
Syntax :       DIM <Felddeklaration> [, <Felddeklaration>] [...] 
 
Erklärung :   <Felddeklaration>: <Feldvariable> (<INT-Konstante> 
                                 #right#[, <INT-Konstante>] [...] ) 
              <Feldvariable>: Name des Feldes (Syntax wie Name von einfachen
                              Variablen, vgl. 4.3.) 
 
              Mit der DIM-Anweisung wird ein Feld dimensioniert, das heißt die
              Anzahl seiner Dimensionen sowie der kleinste und größte Index in
              jeder Dimension werden festgelegt und der Speicherplatz für seine
              Elemente (siehe 4.3.) wird reserviert. 
 
              Der kleinste Index in allen Dimensionen richtet sich nach der letzten
              vorausgegangenen OPTION BASE-Anweisung. 
              Geht der Dimensionierung die Anweisung OPTION BASE 0 textuell
              voraus oder ist keine OPTION BASE-Anweisung vor der Dimensio­
              nierung vorhanden, so ist der kleinste Index in allen Dimensionen
              null. 
              Wenn der Dimensionierung aber eine OPTION BASE 1-Anweisung
              vorausgeht, dann ist der kleinste Index in allen Dimensionen eins. 
 
              Der größte Feldindex wird für jede Dimension durch die in Klammern
              stehenden INT-Konstanten angegeben. Die Anzahl dieser INT-Kon­
              stanten bestimmt auch, wie viele Dimensionen das dimensionierte
              Feld hat. 
 
              Wird auf ein Element einer Feldvariablen zugegriffen, ohne daß die
              Feldvariable vorher dimensioniert wurde, dann wird das Feld automa­
              tisch dimensioniert, wobei die Anzahl der Dimensionen anhand der
              Anzahl der Indizes beim Aufruf ermittelt wird. Der größte Feldindex
              wird bei dieser automatischen Dimensionierung in jeder Dimension
              auf zehn gesetzt. Der kleinste Index richtet sich nach den vorausge­
              gangenen OPTION BASE-Anweisungen (siehe oben). 
 
              Fehlerfälle bei der Dimensionierung: 
              - "Das Feld ist bereits dimensioniert": 
                Das Feld wurde bereits explizit, oder automatisch durch den Zugriff
                auf ein Feldelement dimensioniert . 
              - "Die Obergrenze muß >= 1 sein": 
                Es wurde versucht, 0 als größten Index in einer Dimension festzu­
                legen, obwohl mit OPTION BASE der kleinste Index auf eins fest­
                gelegt wurde. 
 
              Fehlerfälle beim Zugriff auf ein Feldelement: 
              - "Dimensioniert in ... Dimensionen, gefundene Anzahl Indizes ...": 
                Beim Zugriff wurde eine Anzahl von Indizes gefunden, die nicht mit
                der Anzahl der Dimensionen übereinstimmt (Fehler zur Über­
                setzungszeit). 
              - "Ueberlauf bei Subskription" oder "Unterlauf bei Subskription": 
                Der Index ist zu groß beziehungsweise zu klein (Fehler zur Lauf­
                zeit). 
 
 
Beispiel :      10 DIM a% (20, 10), text$ (30, 40) 
                20 DIM tabelle (5, 7, 25) 
                30 LET element = matrix (1, 7) 
 
              Zeile 30 führt eine automatische Dimensionierung durch, die einem
              DIM matrix (10, 10) entspricht. 
 
 
 
Anweisungsbestandteil : ELSE 
 
Siehe IF-Anweisung 
 
 
 
Anweisung : END 
 
Zweck :        Beenden der Programmausführung eines BASIC-Programms 
 
Syntax :       END 
 
Erklärung :   END beendet die Programmausführung des BASIC-Programms ohne
              eine Meldung (im Gegensatz zu STOP, s.d.). 
              END-Anweisungen dürfen im Programm an beliebiger Stelle stehen,
              und es darf auch mehr als eine END-Anweisung in einem
              Programm vorkommen. 
              Der Compiler übersetzt ein Programm auch nach Erreichen einer
              END-Anweisung weiter. 
              Nach der letzten Anweisung eines Programms muß kein END stehen. 
 
 
Beispiel :      2020 PRINT "Das war's !" 
                2030 REM Hiernach hört's auf 
                2040 END 
 
 
Vergleiche :  STOP-Anweisung 
 
 
 
Anweisungsbestandteil : EOF 
 
Siehe INPUT-Anweisung 
 
 
 
 
Operator : EQV 
 
Siehe Kapitel 4.4. (Operatoren) 
 
 
 
Funktion : ERL 
 
Zweck :        Ermittlung der letzten Fehlerzeile 
 
Syntax :       ERL 
 
Erklärung :   Die Nummer der Zeile, in der der letzte Fehler auftrat, wird als INT
              geliefert. 
 
Hinweis :     ERL ist realisiert durch Aufruf der Prozedur 'errorline' des Betriebs­
              systems. 
              Da die Fehlerbehandlungs-Anweisung ON ERROR nicht zur Verfü­
              gung steht, ist diese Funktion nicht im üblichen BASIC-Sinne
              brauchbar. 
 
Vergleiche :  ERM$, ERR-Funktionen, ERROR-Anweisung 
 
 
 
Funktion : ERM$ 
 
Zweck :        Ermittlung der letzten Fehlermeldung 
 
Syntax :       ERM$ 
 
Erklärung :   Die letzte Fehlermeldung wird als TEXT geliefert. 
 
Hinweis :     ERM$ ist realisiert durch Aufruf der Prozedur 'errormessage' des
              Betriebssystems. 
              Da die Fehlerbehandlungs-Anweisung ON ERROR nicht zur Verfü­
              gung steht, ist diese Funktion nicht im üblichen BASIC-Sinne
              brauchbar. 
 
Vergleiche :  ERL-, ERR-Funktionen, ERROR-Anweisung 
 
 
 
Funktion : ERR 
 
Zweck :        Ermittlung des letzten Fehlercodes 
 
Syntax :       ERR 
 
Erklärung :   Der Code des letzten aufgetretenen Fehlers wird als INT geliefert. 
 
Hinweis :     ERR ist realisiert durch Aufruf der Prozedur 'errorcode' des Betriebs­
              systems. 
              Da die Fehlerbehandlungs-Anweisung ON ERROR nicht zur Verfü­
              gung steht, ist diese Funktion nicht im üblichen BASIC-Sinne
              brauchbar. 
 
Vergleiche :  ERL-, ERM$-Funktionen, ERROR-Anweisung 
 
 
 
Anweisung : ERROR 
 
Zweck :        Auslösen eines Fehlers mit bestimmtem Fehlercode 
 
Syntax :       ERROR <INT-Ausdruck> 
 
Erklärung :   Es wird ein Fehler mit dem durch den INT-Ausdruck bestimmten
              Fehlercode ausgelöst. 
 
Hinweis :     ERROR ist realisiert durch Aufruf der Prozedur 'errorstop' des Be­
              triebssystems. 
              Da die Fehlerbehandlungs-Anweisung ON ERROR nicht zur Verfü­
              gung steht, ist diese Anweisung nicht im üblichen BASIC-Sinne
              brauchbar. 
 
Vergleiche :  ERL-, ERM$-, ERR-Funktionen 
 
 
 
Funktion : EXP 
 
Zweck :        Berechnung einer Potenz der Eulerschen Zahl 
 
Syntax :       EXP (<REAL-Ausdruck>) 
 
Erklärung :   Die Funktion liefert e (die Basis des natürlichen Logarithmus) poten­
              ziert mit dem Wert des REAL-Ausdrucks. 
              Bei zu großen Werten kommt es zum Fehler 'REAL-Ueberlauf'. 
              Das Ergebnis der Funktion wird als REAL geliefert. 
 
 
Beispiel :      10 PRINT EXP (10.0) 
                Ausgabe:  22026.47 
 
Vergleiche :  LOG-Funktion (Komplementärfunktion) 
 
 
 
Funktion : FIX 
 
Zweck :        Ermittlung der Vorkommastellen einer REAL-Zahl 
 
Syntax :       FIX (<REAL-Ausdruck>) 
 
Erklärung :   Die Funktion schneidet die Nachkommastellen ab und liefert nur die
              Vorkommastellen des REAL-Ausdrucks. 
              Die Vorkommastellen werden ebenfalls als REALs geliefert. 
 
 
Beispiel :      10 zahl = 1.2345E2 
                20 PRINT FIX (zahl) 
                Ausgabe:  123 
 
Vergleiche :  CINT-, INT-Funktionen 
 
 
 
Anweisung : FOR 
 
Zweck :        Beginn einer Zählschleife 
 
Syntax :       FOR <num. Variable> = <Anfangswert> #ib(3)#TO#ie(3)# <Endwert> 
              #right#[ #ib(3)#STEP#ie(3)# <Schrittweite> ] 
              <Schleifenrumpf> 
 
 
Erklärung :   <num. Variable> : INT- oder REAL-Variable 
              <Anfangswert>   : numerischer Ausdruck 
              <Endwert>       : numerischer Ausdruck 
              <Schrittweite>  : numerischer Ausdruck 
              <Schleifenrumpf>: Folge von Programmzeilen 
 
              Die FOR-Anweisung erlaubt die komfortable Programmierung von
              automatischen Zählschleifen (sogenannten FOR-NEXT-Schleifen).
              Gelangt das Programm während der Ausführung an eine FOR-An­
              weisung, so werden zunächst die Ausdrücke <Anfangswert>,
              <Endwert> sowie gegebenenfalls <Schrittweite> ausgewertet. Der
              Anfangswert wird dann der Variablen zugewiesen. 
              Wenn der Wert der Variablen größer ist als der Endwert (bzw. kleiner
              als der Endwert bei negativer Schrittweite), dann wird das Programm
              mit der nach dem korrespondierenden NEXT (s.d.) folgenden
              Anweisung fortgesetzt. 
              Ist dies jedoch nicht der Fall, werden die Anweisungen des <Schlei­
              fenrumpfs> ausgeführt. Erreicht das Programm nun die zum FOR
              gehörige NEXT-Anweisung (gleiche Variable), so wird der Wert der
              Variablen um die Schrittweite erhöht beziehungsweise erniedrigt (je
              nach Vorzeichen), und wieder an den Anfang der Schleife verzweigt.
              Hier findet dann wieder der Vergleich des Variableninhalts mit dem
              Endwert statt (siehe oben). 
 
              Die Laufvariable darf innerhalb der Schleife in Ausdrücken vorkom­
              men. Sie darf sogar verändert werden (, was aber zu unübersichtli­
              chen Effekten führen kann). Auch eine Schachtelung mehrerer
              Schleifen mit der gleichen Laufvariable ist syntaktisch möglich, sollte
              aber #on("iunter allen Umständen#off("i vermieden werden. 
 
              FOR-NEXT-Schleifen dürfen (auch mit WHILE-WEND-Schleifen,
              s.d.) geschachtelt werden. Überschneidungen von FOR-NEXT-
              Schleifen und WHILE-WEND-Schleifen sind aber nicht zulässig. 
 
 
Beispiel :      10 DIM name$ (5) 
                20 FOR i = 1 TO 5 
                30 PRINT "Bitte geben Sie den " + STR$ (i) 
                #right#+ ". Namen ein:"; 
                40 INPUT name$ (i) 
                50 NEXT i 
 
 
              Es werden die fünf Elemente des Feldes 'name$' eingelesen. 
 
Vergleiche :  NEXT-, WHILE-, IF-Anweisungen 
 
 
 
Funktion : FRE 
 
Zweck :        Ermittlung des verfügbaren Speicherplatzes 
 
Syntax :       FRE (<num. Ausdruck>) 
              FRE (<TEXT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert die Anzahl der freien Bytes. 
              FRE veranlaßt außerdem ein 'collect heap garbage' (EUMEL-
              Systemprozedur). 
 
              Das Ergebnis der Funktion wird als REAL geliefert. 
              Der Argument-Ausdruck ist ein Dummy-Argument (hat keinen
              Einfluß auf den gelieferten Wert). 
 
Hinweis :     Bei der EUMEL M+ Version wird ein korrektes Ergebnis geliefert
              (vgl.'storage info'). 
 
 
Beispiel :      10 PRINT FRE (0) 
                Ausgabe (z.B.):  5324800 
 
 
 
Anweisungsbestandteil : GO 
 
Siehe GOSUB und GOTO 
 
 
 
Anweisung : GOSUB 
 
Zweck :        Unterprogramm-Aufruf 
 
Syntax :       GOSUB <Zeilennummer> 
 
Erklärung :   <Zeilennummer>: INT-Konstante 
              Statt GOSUB darf auch GO #ib(3)#SUB#ie(3)# geschrieben werden. 
 
              Die Programmausführung wird in der Zeile mit der angegebenen
              Zeilennummer fortgesetzt. Die Zeile mit der Zeilennummer muß im
              Programm existieren. 
              Wird im weiteren Programmablauf die Anweisung RETURN gefunden,
              so wird hinter dem letzten abgearbeiteten GOSUB die Programm­
              ausführung fortgesetzt. 
              GOSUB dient zum Aufruf von #on("iUnterprogrammen#off("i, die von mehr als
              einer Stelle im Programm (und auch in anderen Unterprogrammen)
              aufgerufen werden können. 
 
Hinweis :     Es wird empfohlen, Unterprogramme im Programm deutlich als solche
              zu kennzeichnen und (durch END, STOP oder GOTO) sicherzustel­
              len, daß nur mit GOSUB zu ihnen verzweigt wird, da es sonst leicht
              zu der (Laufzeit-) Fehlermeldung "RETURN ohne GOSUB" kommen
              kann. 
 
 
Beispiel :      140 GOSUB 10000  'Zeige Uhrzeit 
                . 
                . 
                370 GOSUB 10000  'Zeige Uhrzeit 
                9990 END 
                10000 REM Unterprogramm Zeige Uhrzeit 
                10010 PRINT "Es ist " + TIME$ + " Uhr" 
                10020 RETURN 
 
 
Vergleiche :  RETURN-, ON-, GOTO- Anweisungen 
 
 
 
Anweisung : GOTO 
 
Zweck :        Sprung zu einer angegebenen Zeile 
 
Syntax :       GOTO <Zeilennummer> 
 
Erklärung :   <Zeilennummer>: INT-Konstante 
              Statt GOTO darf auch GO #ib(3)#TO#ie(3)# geschrieben werden. 
 
              Die Programmausführung wird in der Zeile mit der angegebenen
              Zeilennummer fortgesetzt. Die Zeile mit der Zeilennummer muß im
              Programm existieren. 
 
 
Beispiel :      10 INPUT "Monat (1-12)", monat% 
                20 IF monat% < 1 OR monat% > 12 THEN GOTO 10 
 
 
Vergleiche :  ON-, IF-, GOSUB- Anweisungen 
 
 
 
Funktion : HEX$ 
 
Zweck :        Erzeugung der hexadezimalen Darstellung einer Zahl als Text 
 
Syntax :       HEX$ (<INT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert die hexadezimale (Zweierkomplement-) Darstel­
              lung der Zahl, die sich aus dem INT-Ausdruck ergibt. 
 
 
Beispiel :      10 PRINT HEX$ (10000) 
                Ausgabe:  2710 
 
Vergleiche :  OCT$-Funktion 
 
 
 
Anweisung : IF 
 
Zweck :        Sprung zu einer angegebenen Zeile 
 
Syntax :       IF <Bedingung> 
              #right#[,] #ib(3)#THEN#ie(3)# <Anweisung(en)>|<Zeilennummer> 
              #right#[ [,] #ib(3)#ELSE#ie(3)# <Anweisung(en)>|<Zeilennummer>] 
              IF <Bedingung> [,] GOTO <Zeilennummer> 
              #right#[ [,] ELSE <Anweisung(en)>|<Zeilennummer>] 
 
Erklärung :   <Bedingung>    : numerischer Ausdruck 
              <Anweisung(en)>: Eine oder mehrere BASIC-Anweisungen, wobei
                               mehrere wie gewohnt durch ':' zu trennen sind 
              <Zeilennummer> : INT-Konstante 
              Statt GOTO darf auch GO TO geschrieben werden. 
 
              Anhand der Bedingung wird entschieden, ob die Abarbeitung des
              Programms mit dem THEN- oder ELSE-Zweig fortgesetzt werden
              soll. Mit dem THEN-Zweig wird das Programm fortgesetzt, wenn die
              Bedingung erfüllt ist (, d.h. der numerische Ausdruck ungleich null
              ist). Im anderen Fall (Bedingung nicht erfüllt, numerischer Ausdruck
              gleich null) wird das Programm mit dem ELSE-Teil fortgesetzt. Ist
              kein ELSE-Teil angegeben, so wird die Abarbeitung des
              Programmes in der folgenden #on("iZeile#off("i (nicht nach ':') fortgesetzt. 
 
              Sind statt Anweisungen Zeilennummern nach THEN oder ELSE
              angegeben, so entspricht dies einem GOTO (s.d.) zu diesen Zeilen­
              nummern. 
 
 
Hinweis :     Auch eine IF-Anweisung muß in #on("ieiner#off("i Programmzeile stehen. 
 
 
Beispiel :      10 IF a >= b THEN IF a > b THEN 
                #right#PRINT "a größer b" ELSE PRINT "a gleich b" 
                #right#ELSE PRINT "a kleiner b" 
 
 
              Das Beispiel zeigt, daß bei geschachtelten IF-Anweisungen die
              ELSE-Teile immer auf das letzte vorhergehende IF bezogen werden,
              für das noch kein ELSE-Teil gefunden wurde. 
 
 
 
Vergleiche :  GOTO-, GOSUB-, ON-Anweisungen 
 
 
 
Operator : IMP 
 
Siehe Kapitel 4.4. (Operatoren) 
 
 
 
Funktion : INKEY$ 
 
Zweck :        Holen eines Zeichens von der Tastatur 
 
Syntax :       INKEY$ 
 
Erklärung :   Die Funktion liefert ein Textzeichen aus dem Tastaturzeichenpuffer.
              Wurde kein Zeichen eingegeben, so wird ein Leertext (niltext) gelie­
              fert. 
              Die gelieferten Zeichen erscheinen nicht auf dem Bildschirm. 
 
 
Beispiel :      10 REM Schreibmaschine 
                20 LET a$ = INKEY$ 
                30 IF ASC (a$) = 27 THEN STOP 
                40 PRINT a$; 
                50 GOTO 20 
 
 
              Die eingegebenen Zeichen werden ausgegeben. Abbruch mit ESC. 
 
Vergleiche :  INPUT$-Funktion, INPUT-Anweisung 
 
 
 
Anweisung : INPUT 
 
Zweck :        Einlesen von Daten von der Tastatur 
 
Syntax :       INPUT [;] [<Eingabeaufforderung> ,|; ][ #ib(3)#EOF#ie(3)#
        <Zeilennummer>] 
              #right#<Variable> [, <Variable> ] [...]  
 
Erklärung :   <Eingabeaufforderung>:  TEXT-Konstante 
              <Zeilennummer>:         INT-Konstante 
              <Variable>:             Variable, der der eingelesene Werte
                                      zugewiesen werden soll 
 
              Mit der INPUT-Anweisung werden Daten zur Laufzeit des
              Programms von der Tastatur in Variablen eingelesen. 
 
              Folgt dem INPUT-Statement ein Semikolon, so wird nach
              Beendigung der Eingabe kein Zeilenwechsel vorgenommen. 
 
              Fehlt die <Eingabeaufforderung>, so wird "? " als Eingabe­
              aufforderung ausgegeben. 
              Folgt der  ein Semikolon, so wird "? " noch zusätzlich ausge­
              geben. Bei einem Komma wird dieser Standard-Prompt unter­
              drückt. 
 
              Folgt der <Eingabeaufforderung> die Zeichenfolge 'EOF', so wird
              bei Eingabe eines Leertextes zu der nach 'EOF' angegebenen
              Zeilennumer verzweigt. 
 
              Sollen mehrere Variablen eingelesen werden, so muß der Benutzer
              auch entsprechend viele Daten (durch Kommata getrennt) zur Verfü­
              gung stellen. 
 
              Wird nichts eingegeben beziehungsweise nur die richtige Anzahl von
              Kommata, so wird den entsprechenden Variablen 0, 0.0 bzw. 'niltext'
              zugewiesen. 
 
              Bei der Eingabe für eine Textvariable können alle Zeichen (außer
              Steuerzeichen) eingegeben werden. Beginnt eine Eingabe mit dem
              Anführungszeichen oder endet sie damit, dann muß sie auch damit
              enden beziehungsweise beginnen. Diese beiden Anführungszeichen
              werden nicht mit zugewiesen. Innerhalb dieser Texteingabe dürfen
              Anführungszeichen stehen, aber keine Kommata. 
 
              Eingaben für numerische Variablen müssen in der für Konstanten
              üblichen Schreibweise erfolgen. Vorzeichen sind allerdings zusätzlich
              erlaubt. 
 
              Vor Zuweisung der eingegebenen Werte an die Variablen werden
              Anzahl und Typ(en)  und die Anzahl überprüft. 
              Dabei können folgende Fehlerfälle auftreten: 
              - "falscher Typ": 
                Es wurde ein Text statt einer Zahl eingegeben, es wurde ein REAL
                statt eines INTs eingegeben oder eine Texteingabe ist fehlerhaft. 
              - "zu wenig Daten" 
              - "zu viele Daten" 
              - "Überlauf": 
                Es wurde eine zu große (oder zu kleine) Zahl eingegeben. 
 
              Kommt es zu einem Fehler, dann wird nach der Meldung "?Eingabe
              wiederholen !  (<Fehlerbeschreibung>)" die Eingabe zum Editieren
              angeboten. 
 
Hinweis :     Bei Eingabe von 'ESC k' kann die letzte Eingabezeile zum Editieren
              zurückgeholt werden. 
 
              Die Eingabe kann mit der Systemprozedur 'sysin' aus einer Datei
              erfolgen. Aus der Eingabedatei wird für jedes INPUT-Statement eine
              Zeile eingelesen. Die Ausgabe der Eingabeaufforderung und der
              Zeilenwechsel nach der Eingabe werden unterdrückt. Sind die
              Eingabedaten fehlerhaft, so wird das Programm mit 'errorstop'
              abgebrochen. 
 
              Wird die Ausgabe mit 'sysout' umgeleitet, so werden die Eingabe­
              aufforderung, die Eingabezeichenfolge und der Zeilenwechsel nach
              der Eingabe auf den Bildschirm und in die Ausgabedatei ausgegeben,
              auch dann, wenn der Text der Eingabe aus einer Datei eingelesen
              wurde. 
 
 
Beispiel :      1990 INPUT "Name, Vorname, Alter"; 
                #right#name$, vorname$, alter% 
 
 
Vergleiche :  INKEY$-, INPUT$-Funktionen 
 
 
 
Funktion : INPUT$ 
 
Zweck :        Holen einer Zeichenfolge von der Tastatur 
 
Syntax :       INPUT$ (<Anzahl Zeichen>) 
 
Erklärung :   <Anzahl Zeichen>: INT-Ausdruck 
 
              Die Funktion liefert eine Folge von <Anzahl Zeichen> Textzeichen
              aus dem Tastaturzeichenpuffer. Enthält der Puffer nicht alle ge­
              wünschten Zeichen, so wird auf weitere Zeichen von der Tastatur
              gewartet. 
              Die gelieferten Zeichen erscheinen nicht auf dem Bildschirm. 
 
 
Beispiel :      10 PRINT "Bitte drei Zeichen eingeben !" 
                20 LET a$ = INPUT$ (3) 
                30 PRINT "Danke schön !" 
 
 
Vergleiche :  INKEY$-Funktion, INPUT-Anweisung 
 
 
 
Funktion : INSTR 
 
Zweck :        Suchen einer Zeichenfolge in einer anderen 
 
Syntax :       INSTR ( [<Startposition>,] <TEXT-Ausdruck1>, 
              #right#<TEXT-Ausdruck 2>) 
 
Erklärung :   <Startposition>: INT-Ausdruck 
 
              Die Funktion liefert die Position, ab der der TEXT-Ausdruck 2 das
              erste Mal im TEXT-Ausdruck 1 vorkommt. 
              Die Position wird als INT geliefert. 
 
 
Beispiel :      10 LET a$ = "hallihallo" 
                20 LET b$ = "all" 
                30 PRINT INSTR (a$, b$); INSTR (5, a$, b$) 
                Ausgabe:   2  7 
 
 
 
Funktion : INT 
 
Zweck :        Ermittlung der nächstkleineren ganzen Zahl 
 
Syntax :       INT (<REAL-Ausdruck>) 
 
Erklärung :   Die Funktion liefert die größte ganze Zahl, für die gilt: 
              n kleiner gleich <REAL-Ausdruck>. 
              Bei positiven Werten bedeutet das, daß die Nachkommastellen abge­
              schnitten werden. 
              Das Ergebnis wird als REAL geliefert. 
 
 
Beispiel :      10 PRINT INT (11.74); INT (-11.74) 
                Ausgabe:  11  -12 
 
Vergleiche :  CINT-, FIX-Funktionen 
 
 
 
Anweisung : KILL 
 
Zweck :        Löschen einer Datei in der Task 
 
Syntax :       KILL <Dateiname> 
 
Erklärung :   <Dateiname>: TEXT-Ausdruck 
              Die Datei <Dateiname> wird (ohne Nachfrage) gelöscht. 
 
 
Beispiel :      2110 KILL "Scratchdatei" 
 
 
 
 
Funktion : LEFT$ 
 
Zweck :        Erzeugung eines Teiltextes aus einem anderen Text 
 
Syntax :       LEFT$ (<TEXT-Ausdruck>, <Anzahl Zeichen>) 
 
Erklärung :   <Anzahl Zeichen>: INT-Ausdruck 
 
              Die Funktion liefert die ersten <Anzahl Zeichen> Textzeichen des
              TEXT-Ausdrucks. 
 
 
Beispiel :      10 LET a$ = "hallihallo" 
                20 PRINT LEFT$ (a$, 4) 
                Ausgabe:   hall 
 
Vergleiche :  MID$-, RIGHT$-Funktionen, LSET-, MID$-, RSET-
              Anweisungen 
 
 
 
Funktion : LEN 
 
Zweck :        Ermittlung der Länge eines Textes 
 
Syntax :       LEN (<TEXT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert die Anzahl der im TEXT-Ausdruck enthaltenen
              Zeichen (also die Länge des Textes). Die Länge wird als INT
              geliefert. 
              Ein Leertext (niltext, "") hat die Länge null. 
 
 
Beispiel :      10 LET a$ = "hallihallo" 
                20 PRINT LEN (a$) 
                Ausgabe:   10 
 
 
 
Anweisung : LET 
 
Zweck :        Zuweisung eines Wertes an eine Variable 
 
Syntax :       [LET] <Variable> = <Ausdruck> 
 
Erklärung :   Die LET-Anweisung ermöglicht das Zuweisen von Werten an Variab­
              len (dazu gehören auch die Elemente von Feldern). 
 
              Das Schlüsselwort LET ist optional, d.h. eine Zuweisung wird auch
              ohne dieses Schlüsselwort erkannt. 
 
              #on("iZuweisung an TEXT-Variablen:#off("i 
                LET <TEXT-Variable> = <TEXT-Ausdruck> oder <num.
                Konstante> 
              Die numerische Konstante wird automatisch in einen TEXT umge­
              wandelt (vgl. STR$-Funktion) 
 
              #on("iZuweisung an INT-Variablen:#off("i 
                LET <INT-Variable> = <num. Ausdruck> 
              Ist der numerische Ausdruck ein REAL-Ausdruck, so wird automa­
              tisch nach INT konvertiert (vgl. CINT-Funktion). 
 
              #on("iZuweisung an REAL-Variablen:#off("i 
                LET <REAL-Variable> = <num. Ausdruck> 
              Ist der numerische Ausdruck ein INT-Ausdruck, so wird automatisch
              nach REAL konvertiert (vgl. CDBL-Funktion). 
 
 
Beispiel :      10 LET t$ = "murmel marmel" 
                20 LET t$ = 1245.3 'wie "1245.3" 
                30 LET i% = 852 
                40 LET i% = 12.73  'aufgerundet: 13 
                50 LET r = 564     'wie 564. 
                60 LET r = 157.36 
 
 
 
 
Anweisung : LINE INPUT 
 
Zweck :        Einlesen einer Eingabe von der Tastatur in eine TEXT-Variable 
 
Syntax :       LINE INPUT [;] [<Eingabeaufforderung>;] 
              #right#<TEXT-Variable> 
 
Erklärung :   Die LINE INPUT-Anweisung ermöglicht das Einlesen von Eingaben
              in TEXT-Variablen, aber im Gegensatz zu INPUT ohne Beachtung
              von Trennzeichen (z.B. ","). 
 
              Steht direkt nach LINE INPUT ein Semikolon, so wird nach Beendi­
              gung der Eingabe der Zeilenwechsel unterdrückt. 
 
              Der eingegebene Text wird (bis auf das CR-Zeichen) der TEXT-
              Variablen zugewiesen. 
 
 
Beispiel :      2110 LINE INPUT "Name: ";name$ 
 
 
              Der Benutzer könnte nun auch folgendes eingeben: 
              Neumann, Alfred E. 
 
Vergleiche :  INPUT-Anweisung 
 
 
 
Funktion : LOG 
 
Zweck :        Berechnung des natürlichen Logarithmus einer Zahl 
 
Syntax :       LOG (<REAL-Ausdruck>) 
 
Erklärung :   Die Funktion liefert den natürlichen Logarithmus des Wertes des
              REAL-Ausdrucks. 
              Bei nicht-positiven Werten kommt es zu einem Fehler in der
              EUMEL-Prozedur 'log2'. 
              Das Ergebnis der Funktion wird als REAL geliefert. 
 
 
Beispiel :      10 PRINT LOG (10.0) 
                Ausgabe:  2.302585 
 
Vergleiche :  EXP-Funktion (Komplementärfunktion) 
 
 
 
Funktion : LPOS 
 
Zweck :        Ermittlung der aktuellen Druckspalte 
 
Syntax :       LPOS (<num. Ausdruck>) 
 
Erklärung :   Geliefert wird die Nummer der Spalte (als INT), in die das nächste
              nächste Zeichen mit LPRINT ausgegeben wird. Die Spalte ganz links
              hat die Nummer 1. 
              Der Argument-Ausdruck ist ein Dummy-Argument (hat keinen
              Einfluß auf den gelieferten Wert). 
 
 
Beispiel :      3010 IF LPOS (0) > 65 THEN LPRINT 
                3020 LPRINT name$ 
 
 
              Falls die Druckposition hinter Spalte 65 liegt, wird eine neue Druck­
              zeile begonnen. 
 
Vergleiche :  LPRINT-Anweisung, TAB-, POS-Funktion 
 
 
 
Anweisung : LPRINT 
 
Zweck :        Ausgabe in eine Druckdatei 
 
Syntax :       LPRINT [#ib(3)#USING#ie(3)# <Format> ;] 
              #right#[ #ib(3)#TAB#ie(3)# (<Spalte>) | , | ; | <Ausdruck> ] [...] 
 
Erklärung :   <Format>  : TEXT-Ausdruck für USING (vgl. PRINT) 
              <Spalte>  : INT-Ausdruck (vgl. PRINT) 
              <Ausdruck>: TEXT-Ausdruck oder numerischer Ausdruck 
 
              Die LPRINT-Anweisung arbeitet wie PRINT (siehe dort), mit dem
              Unterschied, daß LPRINT die Zeichen nicht auf den Bildschirm, son­
              dern in eine Datei mit dem Namen "BASIC LPRINT OUTPUT"
              ausgibt. Diese Datei wird automatisch eingerichtet, falls sie noch
              nicht existiert. Ist sie schon vorhanden, so werden die auszugeben­
              den Zeichen am Ende der Datei angefügt. 
              Nach oder bei Ablauf des Programms kann die Datei (evtl. nach
              vorheriger Aufbereitung durch Textverarbeitungsprogramme) mit
              'print', wie im EUMEL-System üblich, an den Drucker geschickt
              werden. Der Benutzer ist selbst dafür verantwortlich, daß er die
              Druckdatei, sofern die Daten nicht mehr benötigt werden, vor einem
              neuen Programmlauf leert oder löscht. Versäumt er dies, so bleiben
              die alten Daten in der Druckdatei, und die neuen Ausgaben werden
              hinten angefügt. Das Löschen der Druckdatei kann zum Beispiel
              durch das BASIC-Programm mit der KILL-Anweisung erreicht
              werden. 
 
              Die Art der Ausgabe und die Syntax ist sonst analog zur PRINT-
              Anweisung (siehe Erläuterungen dort). 
 
 
Beispiel :      2110 LPRINT "Dieser Text geht in die Druckdatei" 
                2120 LPRINT TAB (12); "Datum: " DATE$ 
                2130 LPRINT 1, 2, 3 
 
 
Vergleiche :  PRINT-Anweisung, LPOS-Funktion 
 
 
 
Anweisung : LSET 
 
Zweck :        Ersetzen von Zeichen eines Textes von links her 
 
Syntax :       LSET <TEXT-Variable> = <TEXT-Ausdruck> 
 
Erklärung :   Das Ergebnis des TEXT-Ausdrucks wird, links beginnend, in der
              TEXT-Variablen eingesetzt. Es werden höchstens so viele Zeichen
              ersetzt, wie bisher schon in der Variablen vorhanden waren, das heißt
              die Länge des Textes in der Variablen ändert sich nicht. 
 
 
Beispiel :      210 LET a$ = "12345" 
                220 LSET a$ = "ABCDEFG" 
                230 PRINT a$, 
                240 LSET a$ = "abc" 
                250 PRINT a$ 
                Ausgabe:    ABCDE         abcDE 
 
Vergleiche :  MID$-, RSET-Anweisungen, LEFT$-, MID$-, RIGHT$-Funk­
              tionen 
 
 
 
Anweisung : MID$ 
 
Zweck :        Ersetzen von Zeichen innnerhalb eines Textes 
 
Syntax :       MID$ (<TEXT-Variable>, <Startposition> 
              #right#[, <Anzahl Zeichen>] ) = <TEXT-Ausdruck> 
 
Erklärung :   <Startposition> : INT-Ausdruck 
              <Anzahl Zeichen>: INT-Ausdruck 
 
              Das Ergebnis des TEXT-Ausdrucks wird, bei <Startposition>
              beginnend, in der TEXT-Variablen eingesetzt. Es werden höch­
              stens LEN <TEXT-Variable> Textzeichen ersetzt. Ist keine
              <Anzahl Zeichen> angegeben, so werden so viele Zeichen des
              TEXT-Ausdrucks wie möglich in der TEXT-Variablen eingetragen. 
              Außerdem gilt: Es wird nicht über das bisherige Ende des Variablen­
              inhalts ersetzt, das heißt die Länge des Textes in der Variablen
              ändert sich nicht. 
 
 
Beispiel :      210 LET a$ = "12345" 
                220 MID$ (a$, 3) = "ABCDEFG" 
                230 PRINT a$, 
                240 MID$ (a$, 2, 1) = "abc" 
                250 PRINT a$ 
                Ausgabe:    12ABC           1aABC 
 
Vergleiche :  LEFT$-, MID$-, RIGHT$-Funktionen, LSET-, RSET-
              Anweisungen 
 
 
 
Funktion : MID$ 
 
Zweck :        Erzeugung eines Teiltextes aus einem anderen Text 
 
Syntax :       MID$ (<TEXT-Ausdruck>, 
              #right#<Startposition> [, <Anzahl Zeichen>]) 
 
Erklärung :   <Startposition> : INT-Ausdruck 
              <Anzahl Zeichen>: INT-Ausdruck 
 
              Die Funktion liefert höchstens <Anzahl Zeichen> Textzeichen des
              TEXT-Ausdrucks von Position <Startposition> an. 
              Wird <Anzahl Zeichen> nicht angegeben, so werden alle Zeichen
              ab Startposition geliefert. 
              Werden rechts von <Startposition> keine Zeichen mehr gefunden
              oder ist <Anzahl Zeichen> gleich null, so wird ein Leertext geliefert. 
 
 
Beispiel :      10 LET a$ = "hallihallo" 
                20 PRINT MID$ (a$, 4, 4), 
                30 PRINT MID$ (a$, 6) 
                Ausgabe:   liha           hallo 
 
Vergleiche :  LEFT$-, RIGHT$-Funktionen, LSET-, MID$-, RSET-
              Anweisungen 
 
 
 
Funktion : MKD$, MKI$ 
 
Zweck :        Codierung von Zahlenwerten in Texte 
 
Syntax :       MKD$ (<REAL-Ausdruck>) 
              MKI$ (<INT-Ausdruck>) 
 
Erklärung :   Mit MKD$ und MKI$ können INTs und REALs zu Texten codiert
              werden. 
 
              Die Funktion MKD$ liefert einen 8 Zeichen langen TEXT, der den
              Wert des REAL-Ausdrucks codiert enthält. 
              Vergleichbar arbeitet MKI$, das einen 2 Zeichen langen TEXT liefert,
              der den Wert des INT-Ausdrucks darstellt. 
 
              Mit MKD$ und MKI$ codierte Werte können mit CVD und CVI (s.d.)
              wieder decodiert werden. 
 
 
Beispiel :      10 zahl$ = MKD$ (3.1415) 
                20 PRINT CVD (zahl$) 
                Ausgabe:  3.1415 
 
Vergleiche :  CVD-, CVI-Funktionen 
 
 
 
Operator : MOD 
 
Siehe Kapitel 4.4. (Operatoren) 
 
 
 
Anweisung : NAME 
 
Zweck :        Umbenennen einer Datei 
 
Syntax :       NAME <alter Name> AS <neuer Name> 
 
Erklärung :   <alter Name>: TEXT-Ausdruck 
              <alter Name>: TEXT-Ausdruck 
 
              NAME benennt die Datei <alter Name> in <neuer Name> um. 
 
 
Beispiel :      10 NAME "Käufer" AS "Kunden" 
 
 
 
 
Anweisung : NEXT 
 
Zweck :        Markierung des Endes einer FOR-Schleife 
 
Syntax :       NEXT [<num. Variable>] [, <num. Variable>] [...] 
 
Erklärung :   NEXT markiert das Ende einer FOR-Schleife (vergleiche FOR-
              Anweisung). 
 
              Wird keine Variable angegeben, so bezieht sich das NEXT auf das
              letzte textuell vorhergehende FOR. 
              Wird eine Laufvariable angegeben, so muß sie mit der im letzten
              FOR verwendeten Laufvariable übereinstimmen. 
              Werden mehrere Variablen angegeben, so werden durch die
              NEXT-Anweisung mehrere FOR-Schleifen abgeschlossen. 
              Beachten Sie, daß FOR-Schleifen sich nicht überschneiden dürfen,
              sondern nur Schachtelungen zulässig sind. Es kommt daher auf die
              Reihenfolge der Variablen bei den NEXT-Anweisungen an. Die
              letzte (innerste) FOR-Schleife muß als erste wieder mit dem zuge­
              hörigen NEXT abgeschlossen werden. 
 
Vergleiche :  FOR-, WHILE-Anweisungen 
 
 
 
Operator : NOT 
 
Siehe Kapitel 4.4. (Operatoren) 
 
 
 
Funktion : OCT$ 
 
Zweck :        Erzeugung der oktalen Darstellung einer Zahl als Text 
 
Syntax :       OCT$ (<INT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert die oktale (Zweierkomplement-) Darstellung der
              Zahl, die sich aus dem INT-Ausdruck ergibt. 
 
 
Beispiel :      10 PRINT OCT$ (10000) 
                Ausgabe:  23420 
 
Vergleiche :  OCT$-Funktion 
 
 
 
Anweisung : ON 
 
Zweck :        Ausführung eines "berechneten" Sprungs oder Unterprogramm-
              Aufrufs 
 
Syntax :       ON <Sprungziel Nr.> GOTO | GOSUB 
              #right#<Zeilennummer> [, <Zeilennummer>] [...] 
 
Erklärung :   <Sprungziel Nr.>: INT-Ausdruck 
              <Zeilennummer>   : INT-Konstante 
 
              ON ermöglicht die Verzweigung des Programms an eine von mehre­
              ren Stellen abhängig vom Ergebnis eines INT-Ausdrucks. 
              Gelangt das Programm an eine ON-Anweisung, dann wird zunächst
              der Wert des INT-Ausdrucks berechnet. Dieses Ergebnis bildet dann
              die Nummer n des Sprungziels. Danach wird zur n-ten Zeilen­
              nummer, die nach GOTO beziehungsweise GOSUB steht, verzweigt. 
              Die maximale Anzahl von Zeilennummern, die nach GOTO oder
              GOSUB angegeben werden dürfen, ist 512. 
              Nimmt <Sprungziel Nr.> einen Wert an, zu dem keine Zeile in der
              Liste gefunden wird (z.B. Werte kleiner gleich null oder Werte größer
              als die Anzahl der angegebenen Zeilennummern), so wird das Pro­
              gramm mit der der ON-Anweisung folgenden Programmzeile fortge­
              setzt. 
 
              Statt GOTO und GOSUB darf auch GO TO beziehungsweise
              GO SUB geschrieben werden. 
 
Hinweis :     Die ON-Anweisung muß in #on("ieiner#off("i Programmzeile stehen. 
 
 
Beispiel :      260 INPUT "Menüpunkt 1, 2 oder 3", a 
                270 ON VAL (a) GOTO 300, 400, 500 
                280 GOTO 260 
                300 PRINT "Menüpunkt 1" 
                . 
                . 
                400 PRINT "Menüpunkt 2" 
                . 
                . 
                500 PRINT "Menüpunkt 3" 
 
 
              Entsprechend der Eingabe wird nach 300, 400 oder 500 verzweigt.
              Bei Fehleingaben wird Zeile 280 ausgeführt. 
 
Vergleiche :  GOSUB-, GOTO-, IF-Anweisungen 
 
 
 
Anweisung : OPTION BASE 
 
Zweck :        Festlegung des kleinsten Wertes für Feldindizes 
 
Syntax :       OPTION BASE 0|1 
 
Erklärung :   OPTION BASE legt fest, ob die nachfolgend dimensionierten Felder
              Elemente mit dem Index 0 erhalten, oder ob der niedrigste Index 1
              ist. Voreingestellt ist OPTION BASE 0. 
 
Hinweis :     Der niedrigste Feldindex kann für jedes Feld individuell eingestellt
              werden. Die OPTION BASE-Anweisung gilt für alle Felder, deren
              Dimensionierung ihr textuell nachfolgen. Eine erneute OPTION
              BASE-Anweisung kann dann die Untergrenze für die #on("iihr#off("i folgenden
              Dimensionierungen festlegen. 
 
 
Beispiel :      10 DIM a (100)       'Indizes 0-100 
                20 OPTION BASE 1 
                30 b$ (3) = "hallo"  'Indizes 1-10 
                40 DIM a% (5)        'Indizes 1-5 
                50 OPTION BASE 0 
                60 DIM c% (9)        'Indizes 0-9 
                70 LET d (4) = 12.3  'Indizes 0-10 
 
 
Vergleiche :  DIM-Anweisung 
 
 
 
Operator : OR 
 
Siehe Kapitel 4.4. (Operatoren) 
 
 
 
Funktion : POS 
 
Zweck :        Ermittlung der aktuellen Cursorspalte 
 
Syntax :       POS (<num. Ausdruck>) 
 
Erklärung :   Geliefert wird die Nummer der Spalte (als INT), in der sich der Cursor
              auf dem Bildschirm befindet. Die Spalte ganz links hat die Num­
              mer 1. 
              Der Argument-Ausdruck ist ein Dummy-Argument (hat keinen
              Einfluß auf den gelieferten Wert). 
 
 
Beispiel :      10 CLS 
                20 PRINT "testtext"; 
                30 PRINT POS (0) 
                Ausgabe:  testtext 9 
 
 
Vergleiche :  CSRLIN-, LPOS-Funktionen 
 
 
 
Anweisung : PRINT 
 
Zweck :        Ausgabe auf den Bildschirm 
 
Syntax :       PRINT [#ib(3)#USING#ie(3)# <Format> ;] 
              #right#[ #ib(3)#TAB#ie(3)# (<Spalte>) | , | ; | <Ausdruck> ] [...] 
 
Erklärung :   <Format>  : TEXT-Ausdruck für USING (s. u.) 
              <Spalte>  : INT-Ausdruck (s. u.) 
              <Ausdruck>: TEXT-Ausdruck oder numerischer Ausdruck, der
                          ausgegeben werden soll. 
 
               PRINT dient der Ausgabe von Zeichen auf dem Bildschirm. 
               Numerische Werte werden mit sieben signifikanten Ziffer ausgege­
               ben. Bei Exponentendarstellung werden für den Exponent maximal 3
               Ziffern ausgegeben. Hinter allen numerischen Werten und vor posi­
               tiven numerischen Werten wird jeweils ein Leerzeichen ausgegeben. 
 
               TAB bewirkt eine Positionierung des Cursors auf die angegebene
               Spalte (die Spalte ganz links hat die Nummer 1). Ist die Spaltenzahl
               größer als die mit WIDTH eingestellte Ausgabebreite, so wird auf die
               Spalte mit der Nummer Spalte MODULO Ausgabebreite positioniert.
               Eine Spaltennummer kleiner gleich null bewirkt eine entsprechende
               Warnung. 
               Ist die Spalte mit der angegebenen Nummer in der aktuellen Zeile
               bereits überschritten, dann wird auf die nächste Zeile positioniert. 
 
               Ein Semikolon bewirkt, daß der Cursor an der gerade erreichten
               Position bleibt. 
 
               Ein Komma bewirkt die Positionierung auf die nächste gültige Spal­
               te, für deren Nummer gilt: Nummer MODULO 16 ist 1. 
               Das Komma dient also der Ausgabe in 16 Zeichen breiten Zonen. 
 
               Endet die PRINT-Anweisung mit TAB (<Spalte>), einem Komma
               oder einem Semikolon, dann wird kein Zeilenvorschub ausgelöst. 
 
               #onbold#USING 
               Der EUMEL-BASIC-Compiler unterstützt auch die PRINT
               USING-Anweisung für formatierte Ausgaben. 
               Der nach dem Wort USING angegebene TEXT-Ausdruck spezifi­
               ziert das Ausgabeformat für eine PRINT USING-Anweisung. 
 
               Formatierung von Texten: 
               "!": Nur das erste Zeichen einer Zeichenfolge wird ausgegeben 
               "\n Leerzeichen\": Es werden die 2 + n ersten Zeichen einer
                    Zeichenfolge ausgegeben 
               "&": Alle Zeichen einer Zeichenfolge werden ausgegeben 
 
               Formatierung von Zahlen: 
               "\#": bezeichnet eine Ziffernposition 
               ".": Position des Dezimalpunkts 
               "+": (vor oder nach Zahlen) Ausgabe des Vorzeichens 
               "-": (nach Zahlen) gegebenenfalls Ausgabe von "-" hinter der
                    Zahl 
               "**": Führende Leerstellen werden mit Sternchen aufgefüllt; wirkt
                     außerdem wie "\#\#". 
               "$$": Es wird ein Dollarzeichen links vor der formatierten Zahl ausgegeben;
                     wirkt außerdem wie "\#\#". 
               "**$": Führende Leerstellen werden mit Sternchen ausgefüllt und direkt vor
                      der formatierten Zahl wird ein Dollarzeichen ausgegeben; wirkt
                      außerdem wie "\#\#\#". 
               ",": (vor Dezimalpunkt) Unterteilung der Vorkommastellen in Dreier­
                    gruppen mittels Komma 
               "^^^^": Position des Exponenten 
               "_": Ein Zeichen, das einem Unterstreichungsstrich folgt, wird unverändert
                    ausgegeben 
 
               Ist der Format-Ausdruck fehlerhaft, so kommt es zum Fehler "USING-
               Format fehlerhaft". 
               Überschreitet eine auszugebende Zahl in irgendeiner Hinsicht die im
               Format-Ausdruck für sie vorgesehene Stellenzahl, so wird das Zeichen "%"
               ausgegeben, um den Fehler anzuzeigen. 
 
 
Hinweis :      1.  PRINT (und PRINT USING) richtet sich bei allen Ausgaben nach
                  der mit WIDTH eingestellten Ausgabebreite. 
               2. Alle Ausgaben von PRINT können mit der Systemprozedur
                  'sysout' in eine Datei umgeleitet werden. Dann wird nichts auf
                  das Terminal ausgegeben. 
               3. Das Verhalten beim Erreichen der letzten Bildschirmzeile kann
                  mit der Prozedur 'basic page' gesteuert werden. Vergleiche
                  hierzu Kapitel 5, "Steuerung der Bildschirmausgabe". 
 
 
Beispiel :      10 PRINT "hallo", 2 ^ 32 TAB (33) "Ende"; 
 
               Ausgabe:  hallo            4.294967E+09   Ende 
               Position: 1234567890123456789012345678901234567890 
 
 
Vergleiche :   WRITE-, LPRINT-Anweisungen, POS-, CSRLIN-, SPC-
               Funktionen 
 
 
 
Anweisung : RANDOMIZE 
 
Zweck :        Festlegung eines Anfangswertes für den Zufallszahlengenerator 
 
Syntax :       RANDOMIZE [<num. Ausdruck>] 
 
Erklärung :   Mit RANDOMIZE erhält der Zufallszahlengenerator einen bestimmten
              Startwert. 
              Ist kein numerischer Ausdruck angegeben, so wird während des
              Programmlaufs die Meldung "Startwert des Zufallszahlen­
              generators ?" ausgegeben und ein Startwert eingelesen. 
 
              Wird der Zufallszahlengenerator immer mit dem gleichen Wert gestar­
              tet, so liefert er auch immer die gleichen Zufallszahlen. Soll er immer
              verschiedene Werte liefern, so kann er zum Beispiel mit der System­
              uhr auf zufällige Startwerte gesetzt werden (RANDOMIZE TIMER). 
 
 
Beispiel :      10 RANDOMIZE 4711 
                20 FOR i = 1 TO 5 
                30 PRINT INT (RND * 10); 
                40 NEXT i 
                Ausgabe:   5  6  2  9  6 
 
Vergleiche :  RND-Funktion 
 
 
 
Anweisung : READ 
 
Zweck :        Auslesen von Daten aus DATA-Anweisungen 
 
Syntax :       READ <Variable> [, <Variable>] [...] 
 
Erklärung :   <Variable>: numerische Variable oder TEXT-Variable 
 
              Die READ-Anweisung liest die nächsten Elemente aus der aktuellen
              DATA-Anweisung (s.d.) in die angegebenen Variablen ein. 
 
              In TEXT-Variablen können sowohl "quoted strings" als auch "un­
              quoted strings" (vgl. DATA-Anweisung) eingelesen werden. 
              In numerische Variablen können dagegen nur "unquoted strings"
              eingelesen werden. Außerdem müssen die Zeichen des "unquoted
              string" eine gültige Darstellung einer numerischen Konstanten (even­
              tuell mit Vorzeichen) sein. Sind diese Bedingungen nicht erfüllt, so
              kommt es bei der Ausführung des Programms zu entsprechenden
              Fehlern. 
 
              Eine READ-Anweisung kann Daten aus vorangehenden und nach­
              folgenden DATA-Anweisungen lesen. 
              Alle DATA-Anweisungen eines Programms bilden zusammen einen
              großen sequentiellen Speicher, auf den mit READ der Reihe nach
              zugegriffen wird. Intern wird ein sogenannter READ-DATA-Zeiger
              geführt, der immer auf das nächste auszulesende Element zeigt. 
 
              Die RESTORE-Anweisung (s.d.) ermöglicht es, den READ-DATA-
              Zeiger auf das erste Element einer bestimmten DATA-Zeile zu
              setzen. 
 
              Sind keine Daten mehr für READ vorhanden, so wird die Ausführung
              des Programms mit der Fehlermeldung "Keine Daten mehr für
              READ" abgebrochen. 
 
 
Beispiel :      2020 PRINT "Stadt", "Land", "Fluß" 
                2030 READ stadt$, land$, fluß$ 
                2040 PRINT stadt$, land$, fluß$ 
                . 
                5000 DATA Köln, Bundesrepublik Deutschland, Rhein 
 
 
Vergleiche :  DATA-, RESTORE-Anweisungen 
 
 
 
Anweisung : REM 
 
Zweck :        Ermöglicht das Einfügen von Kommentaren in ein Programm 
 
Syntax :       REM <Zeichenfolge> 
 
Erklärung :   <Zeichenfolge>: Beliebige Folge von Zeichen 
 
              Wird eine REM-Anweisung gefunden, so wird der Rest der Pro­
              grammzeile nicht weiter beachtet. Die Compilierung wird in der fol­
              genden Zeile fortgesetzt. 
              Es empfielt sich, von Kommentarzeilen möglichst oft Gebrauch zu
              machen, weil sie den Programmtext dokumentieren und strukturieren. 
 
Hinweis :     Nach REM können keine weiteren Anweisungen mehr in einer Pro­
              grammzeile stehen, da sie nicht übersetzt werden. Auch der Doppel­
              punkt wird nach REM nicht beachtet. 
 
 
Beispiel :      1000 REM Ausgabe des Feldes 
                1010 FOR i = 1 TO feldgroesse% 
                1020 PRINT "Eintrag"; i; feld (i) 
                1030 NEXT i 
 
 
 
Anweisung : RESTORE 
 
Zweck :        Setzen des READ-DATA-Zeigers auf den Anfang einer angegebe­
              nen Zeile 
 
Syntax :       RESTORE [<Zeilennummer>] 
 
Erklärung :   <Zeilennummer>: INT-Konstante 
 
              Der READ-DATA-Zeiger (vgl. DATA-Anweisung) wird auf die Zeile
              <Zeilennummer> gesetzt. 
              Wird keine Zeilennummer angegeben, so wird für <Zeilennummer>
              1 eingesetzt. 
 
              Existiert die Programmzeile <Zeilennummer> nicht oder ist in ihr
              keine DATA-Anweisung vorhanden, so wird der Zeiger auf die
              nächste textuell folgende DATA-Anweisung gesetzt. 
              Folgt der angegebenen Zeilennummer im Programm keine DATA-
              Anweisung mehr, kommt es zu der Fehlermeldung "RESTORE: Keine
              DATA-Anweisung in oder nach Zeile <Zeilennummer> gefunden !" 
 
 
Beispiel :      10 READ a, b, c 
                20 RESTORE 
                30 READ d, e, f 
                40 DATA 2, 3, 5 
                50 PRINT a; b; c; d; e; f 
                Ausgabe:   2  3  5  2  3  5 
 
Vergleiche :  DATA-, READ-Anweisungen 
 
 
 
Anweisung : RETURN 
 
Zweck :        Rücksprung aus einem Unterprogramm 
 
Syntax :       RETURN 
 
Erklärung :   RETURN bewirkt einen Rücksprung aus dem Unterprogramm hinter
              die aufrufende GOSUB-Anweisung. 
 
              Es dürfen auch mehrere RETURN-Anweisungen in einem Unterpro­
              gramm vorkommen, um es an verschiedenen Stellen zu verlassen. 
 
              Wird ein RETURN gefunden, ohne daß ein GOSUB durchlaufen
              wurde, so wird mit der Fehlermeldung "RETURN ohne GOSUB"
              abgebrochen. 
 
 
Beispiel :      140 GOSUB 10000  'Zeige Uhrzeit 
                . 
                . 
                370 GOSUB 10000  'Zeige Uhrzeit 
                9990 END 
                10000 REM Unterprogramm Zeige Uhrzeit 
                10010 PRINT "Es ist " + TIME$ + " Uhr" 
                10020 RETURN 
 
 
Vergleiche :  GOSUB-, ON-Anweisungen 
 
 
 
Funktion : RIGHT$ 
 
Zweck :        Erzeugung eines Teiltextes aus einem anderen Text 
 
Syntax :       RIGHT$ (<TEXT-Ausdruck>, <Anzahl Zeichen>) 
Erklärung :   <Anzahl Zeichen>: INT-Ausdruck 
 
              Die Funktion liefert die letzten <Anzahl Zeichen> Textzeichen des
              TEXT-Ausdrucks. 
              Ist <Anzahl Zeichen> größer gleich der Länge des TEXT-
              Ausdrucks, so wird der gesamte Ausdruck geliefert. 
 
 
Beispiel :      10 LET a$ = "hallihallo" 
                20 PRINT RIGHT$ (a$, 5) 
                Ausgabe:   hallo 
 
Vergleiche :  LEFT$-, MID$-Funktionen, LSET-, MID$-, RSET-Anweisungen 
 
 
 
Funktion : RND 
 
Zweck :        Erzeugung von Zufallszahlen 
 
Syntax :       RND [<num. Ausdruck>] 
 
Erklärung :   Wird kein Argument angegeben, so wird ein Wert größer null für den
              Ausdruck angenommen. 
 
              RND (x) liefert 
 
              für x > 0: 
              eine neue Zufallszahl. Es gilt immer: 0 <= RND < 1. Der Betrag
              des Arguments hat keinen Einfluß auf das Ergebnis. 
 
              für x = 0: 
              die letzte gelieferte Zufallszahl noch einmal. 
 
              für x < 0: 
              eine neue Zufallszahl. Vorher wird aber RANDOMIZE x (s.d.) ausge­
              führt. 
 
              Die Zufallszahlen werden als REALs geliefert. 
              Der Zufallszahlengenerator kann mit der RANDOMIZE-Anweisung
              auf bestimmte Startwerte eingestellt werden. 
 
 
Beispiel :      10 FOR i = 1 TO 5 
                20 PRINT INT (RND * 10) 
                30 NEXT i 
                Ausgabe (z.B.):   7  9  9  5  0 
 
Vergleiche :  RANDOMIZE-Anweisung 
 
 
 
Anweisung : RSET 
 
Zweck :        Ersetzen von Zeichen eines Textes von rechts her 
 
Syntax :       RSET <TEXT-Variable> = <TEXT-Ausdruck> 
 
Erklärung :   Das Ergebnis des TEXT-Ausdrucks wird, rechts beginnend, in der
              TEXT-Variablen eingesetzt. Es werden höchstens so viele Zeichen
              ersetzt, wie bisher schon in der Variablen vorhanden waren, das heißt
              die Länge des Textes in der Variablen ändert sich nicht. 
              Soll ein Text eingesetzt werden, der länger ist als der Text in der
              Variablen, so wird die Variable nicht verändert. 
 
 
Beispiel :      210 LET a$ = "ABCDEFG" 
                220 RSET a$ = "12345" 
                230 PRINT a$, 
                240 RSET a$ = "abc" 
                250 PRINT a$ 
                Ausgabe:    AB12345           AB12abc 
 
Vergleiche :  LSET-, MID$-Anweisungen, LEFT$-, MID$-, RIGHT$-Funk­
              tionen 
 
 
 
Funktion : SGN 
 
Zweck :        Ermittlung des Vorzeichens einer Zahl 
 
Syntax :       SGN (<num. Ausdruck>) 
 
Erklärung :   SGN (x) liefert 
              für x > 0:   1 
              für x = 0:   0 
              für x < 0:  -1 . 
 
 
Beispiel :      10 a = -12.74 
                20 PRINT SGN (a); SGN (-a); SGN (0 * a) 
                Ausgabe:  -1  1  0 
 
Vergleiche :  ABS-Funktion 
 
 
 
Funktion : SIN 
 
Zweck :        Berechnung des Sinus eines Radiantwertes 
 
Syntax :       SIN (<Winkel>) 
 
Erklärung :   <Winkel>: REAL-Ausdruck, der den Winkel in Radiant angibt. 
              Die Funktion liefert den Sinus des Winkels als REAL. 
 
 
Beispiel :      10 PI = 3.141593 
                20 PRINT SIN (PI/4) 
                Ausgabe:  .7071068 
 
Vergleiche :  COS-, TAN-Funktionen 
 
 
 
Funktion : SPACE$ 
 
Zweck :        Erzeugung einer bestimmten Anzahl von Leerzeichen 
 
Syntax :       SPACE$ (<INT-Ausdruck>) 
 
Erklärung :   Die SPACE$-Funktion liefert einen TEXT, der aus so vielen Leerzei­
              chen (Code 32) besteht, wie der Wert des INT-Ausdrucks angibt. 
 
 
Beispiel :      10 PRINT "123456789" 
                20 PRINT "^" + SPACE$ (7) + "^" 
 
              Ausgabe:  123456789 
                        ^       ^ 
 
 
Vergleiche :  STRING$-Funktion 
 
 
 
Funktion : SPC 
 
Diese Funktion entspricht exakt der SPACE$-Funktion und wurde nur aus Kompatibi­
litätsgründen implementiert. 
 
 
 
Funktion : SQR 
 
Zweck :        Berechnung der Quadratwurzel einer Zahl 
 
Syntax :       SQR (<num. Ausdruck>) 
 
Erklärung :   SQR (x) liefert die Quadratwurzel des durch den numerischen Aus­
              druck angegebenen Wertes. 
              Das Ergebnis wird als REAL geliefert. 
 
 
Beispiel :      10 PRINT SQR (100); 
                20 PRINT SQR (2); 
                30 PRINT SQR (17.453) 
                Ausgabe:  10  1.414214  4.177679 
 
 
 
Anweisungsbestandteil : STEP 
 
Siehe FOR-Anweisung 
 
 
 
Anweisung : STOP 
 
Zweck :        Beenden der Programmausführung eines BASIC-Programms mit
              Meldung 
 
Syntax :       STOP 
 
Erklärung :   STOP beendet die Programmausführung des BASIC-Programms. 
              Im Gegensatz zu END (s.d.) erzeugt STOP dabei die Meldung "STOP
              beendet das Programm in Zeile ...". 
 
              STOP-Anweisungen dürfen im Programm an beliebiger Stelle
              stehen, und es darf auch mehr als eine STOP-Anweisung in einem
              Programm vorkommen. 
              Der Compiler übersetzt ein Programm auch nach Erreichen einer
              STOP-Anweisung weiter. 
 
 
Beispiel :      3220 IF eingabe$ = "Ende" THEN STOP 
 
 
Vergleiche :  END-Anweisung 
 
 
 
Funktion : STR$ 
 
Zweck :        Konvertierung einer Zahl in einen Text 
 
Syntax :       STR$ (<num. Ausdruck>) 
 
Erklärung :   Die Funktion liefert die Darstellung des Wertes des numerischen
              Ausdrucks als TEXT. 
              Die Zahlen werden so als Text geliefert, wie sie bei einer PRINT-
              Anweisung auf dem Bildschirm erscheinen würden. 
 
 
Beispiel :      10 LET zahl$ = STR$ (1e6) 
                20 PRINT zahl$; LEN (zahl$) 
                Ausgabe:   1000000  7 
 
Vergleiche :  VAL-Funktion (Komplementärfunktion) 
 
 
 
Funktion : STRING$ 
 
Zweck :        Erzeugung eines Textes mit mehreren gleichen Zeichen 
 
Syntax :       STRING$ (<Anzahl>, <Code>|<TEXT-Ausdruck>) 
 
Erklärung :   <Anzahl>: INT-Ausdruck 
              <Code>  : INT-Ausdruck  (Wert im Bereich 0 bis 255) 
 
              Die Funktion liefert <Anzahl> mal das Zeichen, 
              - das den ASCII-Code <Code> hat oder 
              - das am Anfang vom Ergebnis des TEXT-Ausdrucks steht. 
 
 
Beispiel :      10 LET pfeil$ = STRING$ (10, "=") + ">" 
                20 PRINT pfeil$;" ";STRING$ (5, 35) '35 entspr. \# 
                Ausgabe:   ==========> \#\#\#\#\# 
 
Vergleiche :  SPACE$-Funktion 
 
 
 
Anweisungsbestandteil : SUB 
 
Siehe GOSUB-Anweisung 
 
 
 
Anweisung : SWAP 
 
Zweck :        Tauschen der Inhalte zweier Variablen 
 
Syntax :       SWAP <Variable1>, <Variable2> 
 
Erklärung :   SWAP tauscht die Inhalte der beiden Variablen. 
 
              Die beiden Variablen müssen vom gleichen Typ sein. 
 
 
Beispiel :      3220 LET a = 10 
                3230 LET b = 20 
                3240 SWAP a, b 
                3250 PRINT a; b 
                Ausgabe:  20  10 
 
 
 
Anweisungsbestandteil : TAB 
 
Siehe PRINT- und LPRINT-Anweisung 
 
 
 
Funktion : TAN 
 
Zweck :        Berechnung des Tangens eines Radiantwertes 
 
Syntax :       TAN (<Winkel>) 
 
Erklärung :   <Winkel>: REAL-Ausdruck, der den Winkel in Radiant angibt. 
              Die Funktion liefert den Tangens des Winkels als REAL. 
 
 
Beispiel :      10 PI = 3.141593 
                20 PRINT TAN (PI/4) 
                Ausgabe:  1 
 
Vergleiche :  COS-, SIN-Funktionen 
 
 
 
Anweisungsbestandteil : THEN 
 
Siehe IF-Anweisung 
 
 
 
Funktion : TIMER 
 
Zweck :        Lesen der Systemuhr (CPU-Zeit der Task) 
 
Syntax :       TIMER 
 
Erklärung :   Die bisher von der Task verbrauchte CPU-Zeit (in Sekunden) wird
              als REAL geliefert. 
 
              TIMER eignet sich auch zum Starten des Zufallszahlengenerators
              (vgl. RANDOMIZE-Anweisung). 
 
 
Beispiel :      2010 LET starttime = TIMER 
                . 
                . 
                2620 PRINT "Verbrauchte CPU-Zeit:"; 
                2630 PRINT TIMER - starttime; "Sekunden" 
 
 
Vergleiche :  TIME$-Funktion 
 
 
 
Funktion : TIME$ 
 
Zweck :        Abrufen der aktuellen Tageszeit 
 
Syntax :       TIME$ 
 
Erklärung :   Die Tageszeit wird als Text in der Form HH.MM.SS geliefert. 
 
 
Beispiel :      10 PRINT "Es ist jetzt "; TIME$; " Uhr" 
                Ausgabe (z.B.):  Es ist jetzt 10:51:17 Uhr 
 
Vergleiche :  DATE$-, TIMER-Funktionen 
 
 
 
Anweisungsbestandteil : TO 
 
Siehe FOR- und GOTO-Anweisungen 
 
 
 
Anweisung : TRON / TROFF 
 
Zweck :        Ein- und Ausschalten der TRACE-Funktion 
 
Syntax :       TRON 
              TROFF 
 
Erklärung :   Der TRACE-Modus dient der Suche nach logischen Fehlern bei der
              Entwicklung von BASIC-Programmen. 
 
              TRON schaltet den TRACE-Modus für die nachfolgend übersetzten
              Programmzeilen ein. 
 
              Ist der TRACE-Modus eingeschaltet, so wird für jede gefundene
              Zeilennummer die Ausgabe dieser Zeilennummer in eckigen
              Klammern mit in den erzeugten Code aufgenommen. Dies hat dann
              während des Laufens den Effekt, daß immer bei Abarbeitung der im
              TRACE-Modus übersetzten Zeilen die aktuelle Zeilennummer aus­
              gegeben wird. Es ist so leicht zu verfolgen, in welcher Reihenfolge
              die Zeilen des Programms ausgeführt werden. 
 
              TROFF schaltet den TRACE-Modus für die textuell folgenden Pro­
              grammzeilen wieder aus. 
 
 
Beispiel :      5220 TRON 
                5230 REM hier beginnt die kritische 
                5240 REM Programmstelle 
                . 
                . 
                . 
                5970 TROFF 
 
 
              Die Zeilen 5230 bis 5970 werden im TRACE-Modus übersetzt. 
 
 
 
Anweisungsbestandteil : USING 
 
Siehe PRINT-Anweisung 
 
 
 
Funktion : USR 
 
Zweck :        Aufruf einer wertliefernden insertierten Prozedur 
 
Syntax :       USR <Prozedurname> 
              #right#[ (<Parameter> [, <Parameter>] [...] ) ] 
 
Erklärung :   <Prozedurname>: Folge aus Zeichen, die für Prozeduren im
              EUMEL-System zugelassen sind (also Buchstaben und  - ab der
              zweiten Stelle -  Zahlen), jedoch keine Leerzeichen. 
 
              <Parameter>: <CONST-Parameter> | <VAR-Parameter> 
 
              <CONST-Parameter>:   Ausdruck (genau des von der Prozedur
                                   benötigten Typs) 
              <VAR-Parameter>:     Variable (genau des von der Prozedur benö­
                                   tigten Typs) 
 
              Die Prozedur mit dem angegebenen <Prozedurnamen> und den
              angegebenen Parametern wird aufgerufen. 
              Die USR-Funktion liefert nach Ausführung der Prozedur das von der
              Prozedur übergebene Ergebnis (Typ INT, REAL oder TEXT). 
 
              Mögliche Fehlerfälle: 
              - Eine Prozedur mit dem Namen <Prozedurnamen> und den ange­
                gebenen Parametern gibt es nicht. 
              - Die Prozedur liefert keinen Wert. 
              - Die Prozedur liefert einen Typ, der in BASIC unbekannt ist (zum
                Beispiel BOOL). 
              - Die Prozedur benötigt Parametertypen, die in BASIC nicht bekannt
                sind (z.B. BOOL, FILE, TASK, QUIET). 
              - Ein Parameter ist CONST, es wird aber ein VAR-Parameter ver­
                langt. 
 
              Weitere Informationen finden Sie in Kapitel 4.7. 
 
Hinweis :     1.  Bei den Parametern wird keine Typkonvertierung vorgenommen. 
              2. Der Prozedurname muß (entgegen der ELAN-Gewohnheit) ohne
                 Leerzeichen angegeben werden. 
              3. USR ist die einzige Funktion, bei der das Argument (nämlich der
                 Prozeduraufruf) nicht in Klammern stehen darf. 
 
 
Beispiel :      10 LET euler = USR e 
                20 PRINT euler 
                Ausgabe:  2.718282 
 
Vergleiche :  CALL-, CHAIN-Anweisungen 
 
 
 
Funktion : VAL 
 
Zweck :        Konvertierung eines Texts in eine Zahl 
 
Syntax :       VAL (<TEXT-Ausdruck>) 
 
Erklärung :   Die Funktion liefert den Wert der Zahl, deren Darstellung in dem
              übergebenen TEXT-Ausdruck enthalten ist. Führende Leerstellen
              werden dabei überlesen. 
              Sobald ein nicht wandelbares Zeichen festgestellt wird, wird der bis
              dahin ermittelte Wert (am Anfang null) geliefert. 
 
 
Beispiel :      10 LET zahl$ = "-1.256E-63" 
                20 PRINT VAL (zahl$) 
                Ausgabe:   -1.256E-63 
 
Vergleiche :  STR$-Funktion (Komplementärfunktion) 
 
 
 
Anweisung : WEND 
 
Zweck :        Markierung des Endes einer WHILE-Schleife 
 
Syntax :       WEND 
 
Erklärung :   WEND markiert das Ende einer WHILE-Schleife (vergleiche
              WHILE-Anweisung). 
 
Vergleiche :  WHILE-, FOR-Anweisungen 
 
 
 
Anweisung : WHILE 
 
Zweck :        Beginn einer abweisenden Schleife 
 
Syntax :       WHILE <Bedingung> 
              <Schleifenrumpf> 
 
Erklärung :   <Bedingung>     : numerischer Ausdruck 
              <Schleifenrumpf>: Folge von Programmzeilen 
 
              Die WHILE-Anweisung erlaubt die komfortable Programmierung von
              abweisenden Schleifen (sogenannten WHILE-WEND-Schleifen) in
              BASIC. 
              Gelangt das Programm während der Ausführung an eine WHILE-
              Anweisung, so wird zunächst der Bedingungs-Ausdruck ausge­
              wertet. Ist die Bedingung nicht erfüllt (falsch, Wert gleich null), so
              wird das Programm mit der nächsten Anweisung hinter der korres­
              pondierenden WEND-Anweisung fortgesetzt. 
              Ist die Bedingung dagegen erfüllt (wahr, Wert ungleich null), so
              werden die Anweisungen des Schleifenrumpfs abgearbeitet. Beim
              Erreichen der WEND-Anweisung springt das Programm wieder zur
              WHILE-Anweisung zurück, die Bedingung wird erneut überprüft und,
              je nach Ergebnis, wird der Schleifenrumpf oder die Anweisung nach
              WEND ausgeführt. 
 
              WHILE-WEND-Schleifen dürfen (auch mit FOR-NEXT-Schleifen,
              s.d.) geschachtelt werden. Überschneidungen von WHILE-WEND-
              Schleifen und FOR-NEXT-Schleifen sind jedoch nicht zulässig. 
 
 
Beispiel :      10 LET weiter$ = "j" 
                20 WHILE LEFT$ (weiter$, 1) = "j" 
                30 REM Hier beginnt das eigentliche Programm 
                . 
                . 
                1650 INPUT "Weiter ? (j/n)", weiter$ 
                1660 WEND 
 
 
              Das eigentliche Programm wird so lange ausgeführt, bis der Benutzer
              etwas anderes als "j" an der ersten Stelle von 'weiter$' eingibt. 
 
Vergleiche :  FOR-, IF-Anweisungen 
 
 
 
Anweisung : WIDTH 
 
Zweck :        Einstellung der Bildschirmbreite 
 
Syntax :       WIDTH <Zeichen pro Zeile> 
 
Erklärung :   <Zeichen pro Zeile>     : INT-Ausdruck 
 
              Mit der WIDTH-Anweisung wird festgelegt, wie viele Zeichen pro
              Zeile bei Ausgaben auf den Bildschirm oder in Dateien pro Zeile
              ausgegeben werden sollen. 
              Soll für die Druckdatei eine andere Anzahl von Zeichen pro Zeile
              gelten als für den Bildschirm, dann muß vor jeder Sequenz von
              LPRINT-Anweisungen die gewünschte Anzahl mit WIDTH einge­
              stellt werden. 
              WIDTH gilt auch für Ausgaben in 'sysout'-Dateien. 
              Insbesondere bei der Ausgabe in Dateien kann ein Wert von mehr als
              80 Zeichen pro Zeile sinnvoll sein. 
 
 
Beispiel :      10 REM es sollen nur 45 Zeichen pro Zeile 
                20 REM ausgegeben werden 
                30 WIDTH 45 
                 
 
Vergleiche :  PRINT-, LPRINT-, WRITE-Anweisungen 
 
 
 
Anweisung : WRITE 
 
Zweck :        Ausgabe von Zahlen und Texten auf dem Bildschirm 
 
Syntax :       WRITE [<Ausdruck>] [, <Ausdruck>] [...] 
 
Erklärung :   <Ausdruck>: numerischer Ausdruck oder TEXT-Ausdruck 
 
              Die WRITE-Anweisung erlaubt die Ausgabe von Daten auf dem
              Bildschirm. Die angegebenen Ausdrücke werden ausgewertet und
              ausgegeben. Dabei werden numerische Werte im gleichen Format
              wie bei der PRINT-Anweisung (s.d.) ausgegeben, mit der Einschrän­
              kung, daß den Zahlen keine Leerstelle folgt. 
              Die Ergebnisse von Text-Ausdrücken werden von Anführungszei­
              chen umschlossen ausgegeben. 
              Alle Einzelausgaben werden durch Kommata voneinander getrennt. 
 
              Nach Ausgabe aller angegebenen Ausdrücke wird der Cursor an den
              Anfang der nächsten Zeile positioniert. 
 
 
Beispiel :      10 LET a = 10.7: b = 20 
                20 LET c$ = "Testtext" 
                30 WRITE a, b, c$ 
                Ausgabe:  10.7, 20,"Testtext" 
 
Vergleiche :  PRINT-, LPRINT-, WIDTH-Anweisungen 
 
 
 
Operator : XOR 
 
Siehe Kapitel 4.4. (Operatoren) 

