#block##pageblock##page (2)##setcount (1)##count per page# 
#head# 
#center#DYNAMO-Compiler 
#center#____________________________________________________________ 
 
#end# 
#bottom odd# 
#center#____________________________________________________________ 
GMD #right#DYNAMO - % 
#end# 
#bottom even# 
#center#____________________________________________________________ 
DYNAMO - % #right#GMD 
#end# 
 
#ib#1. Einleitung#ie# 
 
 
 
Diese Handbuch beschreibt die Funktion des EUMEL-DYNAMO-Compilers in der
Version 3.3+ und seine Einschränkungen oder Änderungen gegenüber dem
DYNAMO-Sprachstandard. In keiner Weise kann diese Beschreibung eine Einfüh­
rung in die Programmiersprache DYNAMO ersetzen! 
 
Die beschriebene Compilerversion enthält nun auch ein Modul zur Unterstützung von
hochauflösender Grafik durch die häufig in IBM-PC/AT-Kompatiblen eingesetzte
CGA-Grafikkarte. Dennoch ist es einfach möglich, diesen Grafikmodus auszuschal­ 
ten, und somit die alte, zeichenorientierte Grafik weiter zu verwenden. 
 
Der DYNAMO-Compiler wurde 1983 von Robert Keil und Torsten Fröhlich (Helm­
holtz-Gymnasium, Bonn) im Rahmen des MIKROS-Projektes am Informatik-Kolleg 
der GMD entwickelt. Für Spezifikation und Betreuung der Entwicklung war Dr. Diether
Craemer verantwortlich, software-technische Unterstützung kam von Prof. John
Henize, Dr. Peter Heyderhoff, Rudolf Legde und Dipl.- Math. Lothar Oppor. Die 
Grafik wurde von D.Giffeler beigesteuert. 
 
 
 
 
#ib#1.1. Referenzliteratur#ie# 
 
 
 
 
  [1]  Craemer, Diether 
       "Mathematisches Modellieren dynamischer Vorgänge" 
       e. Einf. in die Programmiersprache DYNAMO 
       Stuttgart, Teuber, 1985 
       ISBN 3-519-02477-2 
 
  [2]  Craemer, Diether 
       "Fluß und Zustand - Simulation dynamischer Vorgänge in DYNAMO" 
       in: LOGIN 5 (1985), Heft 1, S. 20-23 
 
  [3]  Pugh, Alexander L. 
       "DYNAMO II User's Manual" 
       Cambridge, London 1973: MIT-Press 
       ISBN 0-262-66018-0 
#page# 
 
#ib#1.2. Die Programmiersprache DYNAMO#ie# 
 
 
 
DYNAMO wurde von einer Gruppe um Jay FORRESTER am Massachusetts Institute
of Technology (MIT) um 1960 entwickelt. Die Sprache basiert auf der #on ("i")# System
Dynamic#off ("i")# von FORRESTER. 
 
In DYNAMO (#on ("u")##on ("b")#Dyna#off ("b")##off ("u")#mic #on ("u")##on ("b")#Mo#off ("b")##off ("u")#delling Language) können Systeme, in denen Veränderun­ 
gen kontinuierlich geschehen, modelliert und simuliert werden. 
 
Kontinuierliche Veränderungen von Größen werden über deren Veränderungsrate im
Wesentlichen nach folgender Gleichung berechnet 
 
Größe jetzt = Größe früher + DT * Veränderungsrate, 
 
dabei ist DT die Länge des Zeitintervalls von "früher" bis "jetzt". 
 
Außer diesen Gleichungen für Größen braucht man Gleichungen für die Verände­
rungsraten, für Hilfsgrößen, zur Initialisierung von Größen, zur Definition von Konstan­
ten und Tabellen, zu Angaben von Simulationsläufen und zur Wiedergabe von Ergeb­
nissen in Zahlentabellen oder Diagrammen. 
 
Alle diese Gleichungen können einfach in der Form, wie man sie aus dem Mathema­
tik-Unterricht der Sekundarstufe kennt, hingeschrieben werden, ohne sich Gedanken
über den Ablauf des Programms machen zu müssen. 
 
#on ("b")# 
DYNAMO ist also eine einfache funktional-applikative, nicht-prozedurale Sprache.#off ("b")# 
 
Das macht ihren Reiz und ihre Leistungsfähigkeit aus, die zur Formulierung der be­
kannten Weltmodelle von FORRESTER, MEADOWS ("Die Grenzen des Wachstums"),
PESTEL, MESAROVIC u.a. in dieser Sprache führten. 
 
Anwendungsgebiete der Sprache sind ökologische, gesellschaftliche, wirtschaftliche
und technische Systeme, deren dynamisches Verhalten der Modellbildner nachbilden
und studieren möchte. 
 
Im Allgemeinen verfolgt der Modellbildner mit seinem Modell einen Zweck (Verhaltens­
änderung des nachgebildeten Systems), so daß auch neben gesicherten Fakten die
Wertvorstellungen des Modellbildners in das Modell eingehen. 
 
 
 
 
#ib#1.3 Kurz-Einführung in die DYNAMO-
Schreibweise#ie# 
 
 
 
Die System Dynamic Methode benutzt als Analogie-Bild den Archetyp des Flusses: 
 
  -  Wasser fließt durch das Flußbett, kann in Seen gestaut und in der Ge­
     schwindigkeit durch Schleusen und Wehre reguliert werden. 
 
  -  Analog dazu "fließt" Geld auf dem Überweisungsweg, wird in Konten gestaut,
     und die Liquidität kann durch Zinssätze reguliert werden. 
 
  -  Gedanken "fließen" auf Nervenbahnen, werden im Gehirn gespeichert, und
     Gedankenströme werden über Synapsen reguliert. 
 
  -  Autos "fließen" über Straßen, werden auf Parkplätzen gestaut, und der Ver­
     kehrsfluß wird über Ampeln reguliert. 
 
  -  Menschen "fließen" über Wanderwege, halten sich in Wohnorten auf, und die
     Bevölkerungsdynamik wird durch ein komplexes, rückgekoppeltes Zusammen­
     spiel von Ein- und Auswanderungsraten sowie Geburts- und Sterberaten
     reguliert. 
 
Am letzten Beispiel wird deutlich, daß sich ein soziales Phänomen nur im Zusam­
menwirken vieler netzartig miteinander verbundener Variablen beschreiben läßt (wenn
überhaupt). 
 
Solange jedoch einigen Variablen ZUSTANDS-CHARAKTER ("Wasserstand") und
anderen VERÄNDERUNGS-CHARAKTER ("Flußgeschwindigkeit") zugeordnet
werden kann, können die Größen für Berechnungen folgender Art verwendet werden: 
 
 
  Wasserstand jetzt = Wasserstand früher + vergangene Zeit * 
                      (Zuflußrate - Abflußrate) 
 
 
analog:  
 
  Bevölkerung jetzt = Bevölkerung früher + vergangene Zeit * 
                      (Geburtsrate - Sterberate) 
 
 
Diese Schreibweise kann praktisch so in ein Computerprogramm übernommen wer­
den. Mit geringfügigen Änderungen handelt es sich bei diesen Gleichungen schon um
gültige Zeilen in der Programmiersprache DYNAMO. 
 
In DYNAMO wird er Zeitpunkt "jetzt" durch das Anhängsel .K, der Zeitpunkt "früher"
durch das Anhängsel .J, die Zeitspanne von jetzt bis später durch das Anhängsel .KL,
die Zeitspanne von früher bis jetzt durch das Anhänsel .JK und die vergangene Zeit
mit DT (wie "Delta Tempus": Zeitdifferenz) bezeichnet. Die Variablen mit Zustands-
Charakter heißen LEVELS (Niveaus) und die Veränderungs-Charakter heißen RATES
(Veränderungsraten, Geschwindigkeiten). Die entsprechenden Gleichungen werden mit
L bzw. R gekennzeichnet. Es gib weitere Kennzeichnungen: 
 
  C  für Konstantendefinition            (constant) 
  T  für Tabellendefintion               (table) 
  A  für Hilfsgrößen                     (auxiliaries) 
  N  für Anfangswerte                    (initial) 
  X  für Folgezeile                      (extension) 
  PRINT für Ausgabe von Zahlen 
  PLOT für Ausgabe von Diagrammen 
 
Ein einfaches Bevölkerungsmodell könnte z.B. so geschriben werden: 
 
 
  L BEVÖLKERUNG.K=BEVÖLKERUNG.J+DT*(GEBURTENRATE.JK 
  X               -STERBERATE.JK) 
  R STERBERATE.KL=5 
  R GEBURTENRATE.KL=20 
  N BEVÖLKERUNG=1000 
  C DT=1                      (jedes Jahr wird neu berechnet) 
  C LENGTH=60                 (60 Jahre werden simuliert) 
  PRINT BEVÖLKERUNG 
 
 
Für eine tiefere Einführung in DYNAMO sollte man die Referenzliteratur zu Rate
ziehen. 
 
 
 
 
#ib#1.4 Eine erste, kleine Sitzung mit dem
DYNAMO-System#ie# 
 
 
 
Wir gehen davon aus, daß das DYNAMO-System in ihrer Task generiert worden ist
(siehe 2.). 
 
  1. Tippen Sie das obrige Programm mittels des EUMEL-Editors ab. 
 
  2. Verlassen Sie den Editor mit <ESC><q> und starten Sie den DYNAMO-
     Compiler durch die Eingabe des Befehls "dynamo". 
 
  3. Nach erfolgreichem Übersetzen sollte Ihnen nun das DYNAMO-Runtime-
     System zur Verfügung stehen. Durch den Befehl 'run' wird das Programm aus­
     geführt und Sie erhalten eine Zahlenkolonne, die die Entwicklung der Bevöl­
     kerung in den zu untersuchenden 60 Jahren angibt. Falls Ihnen beim Abtippen
     des Programms Fehler unterlaufen sein sollten, so kann das Programm nicht
     fehlerfrei übersetzt werden. Fehlermeldunggen zur Compile-Zeit des
     DYNAMO-Compilers werden im Paralleleditor angezeigt; das Programm kann
     im oberen der beiden Editorfenster (in diesem befinden Sie sich auch nach
     Fehlern) korrigiert werden. Danach können Sie erneut wie nach Punkt 2 ver­
     fahren. 
#page# 
 
 
 
#ib#2. Generierung des DYNAMO-Compilers#ie# 
 
 
 
Der DYNAMO-Compiler, seine Funktionen und die Beispielprogramme werden auf
zwei Archiv-Disketten a#b#' 360 KB ausgeliefert. 
 
Zum Generieren des DYNAMO-Systems legen Sie bitte die erste Diskette in das
Dikettenlaufwerk Ihres Rechners und durch folgende Kommandozeile lesen Sie den
Generator vom Archiv und starten ihn: 
 
 
       archive ("dynamo"); fetch ("dyn.inserter", archive); run 
 
 
Danach holt der Generator alle benötigten Dateien vom eingelegten Archiv bzw. von
dem zweiten Archiv (nachdem er Sie zum Wechseln der Diskette aufgefordert hat).
Anschließend wird der DYNAMO-Compiler insertiert. Am Ende der Generierung
werden Sie gefragt werden, ob Sie den Compiler mit Grafik#u##count ("Grafik")##e# oder ohne benutzen
wollen. Nach der Meldung "dynamo system generiert" können Sie den Compiler#foot#
#u##value ("Grafik")##e# Es kann z.Zt. nur eine CGA-Grafikkarte betrieben werden 
#end# 
nutzen. 
#page# 
 
 
 
#ib#3. Der EUMEL-DYNAMO-Compiler#ie# 
 
 
 
Der im EUMEL-System implementierte DYNAMO-Compiler ist ein 2-Pass-
Compiler, der die DYNAMO-Programme zunächst in ELAN übersetzt. Der Vorteil
dieser Methode besteht darin, daß es möglich ist, übersetzte Programme unabhängig
vom DYNAMO-Compiler zur Ausführung bringen zu können. 
 
Die Notation der im folgenden aufgeführten ELAN-Prozeduren des Compilers ent­
spricht der in den EUMEL-Handbüchern üblichen Prozedurkopf-Schreibweise. 
 
Als Beispiel: 
 
 
  dynamo ("dyn.grasshasenfuchs") 
 
 
ein Beispiel für den Aufruf der Prozedur mit der Prozedurkopf-Schreibweise 
 
  PROC dynamo (TEXT CONST filename) 
 
auf der Kommando-Ebene des Betriebssystems EUMEL. 
 
Der Prozedur 'dynamo' wird beim Aufruf der Dateiname (TEXT) 'filename' übergeben
und dadurch der Compiler auf die Datei mit dem Namen 'filename' angewendet. 
 
 
 
 
#ib#3.1. Benutzung des DYNAMO-Compiler#ie# 
 
 
 
Um ein DYNAMO-Programm zu Übersetzen, gibt es grundsätzlich zwei Möglichkei­
ten. Erst einmal kann man ein DYNAMO-Programm in ein ELAN-Programm um­
wandeln, jedoch ohne es dabei zur Ausführung zu bringen. Dieses ELAN-Programm
kann man nun unabhängig vom eingentlichen Compiler starten. Die zweite, wohl öfter
angewendete Methode ist, ein DYNAMO-Programm in ein ELAN-Programm zu
compilieren, wobei es danach direkt ausgeführt wird. Ob danach ein ELAN-
Programm zur Verfügung stehen soll, kann der Benutzer selbst entscheiden. 
 
 
PROC dynamo 
 
  Zweck: Aufruf des DYNAMO-Compilers mit 'quelldatei' = 'last param', d.h. das
         zu übersetzende Programm steht in der zuletzt bearbeiteten Datei. 
 
 
PROC dynamo (TEXT CONST quelldatei) 
 
  Zweck: Ruft den DYNAMO-Compiler für die Datei 'quelldatei' auf. Anmerkung:
         Gleichbedeutend mit 'dynamo (quelltext, quelltext + ".elan", TRUE)', s.
         nächste Prozedur. 
 
  Beispiel: 
   
 
           dynamo ("dyn.grashasenfuchs") 
   
 
         Der DYNAMO-Compiler wird auf die Datei "dyn.grashasenfuchs" ange­
         wendet. 
 
 
PROC dynamo (TEXT CONST quelldatei, zieldatei, 
             BOOL CONST pass2 ausfuehren) 
 
  Zweck: Diese Prozedur startet den DYNAMO-Compiler. 'quelldatei' gibt den
         Namen der Datei an, in welcher der DYNAMO-Quelltext enthalten ist,
         'zieldatei' ist der Name der Datei, die das erzeugte ELAN-Programm
         beinhalten soll. Wenn 'pass2 ausfuehren' = TRUE, dann wird dieses auch
         durch den ELAN-Compiler weiterverarbeitet (das Programm wird zur
         Ausführung gebracht). 
 
  Beispiel: 
 
 
           dynamo ("dyn.grashasenfuchs", 
                   "grashasenfuchs.elanprogramm", FALSE) 
 
 
         Im obigen Beispiel wird der in der Datei "dyn.grashasenfuchs" enthaltene
         DYNAMO-Quelltext in die Datei "grashasenfuchs.elanprogramm" als
         ELAN-Programm geschrieben. Das ELAN-Programm wird nicht ausge­
         führt. 
 
 
PROC erase (BOOL CONST erase option) 
 
  Zweck: Wenn 'erase option' = TRUE, so werden die erzeugten ELAN-Programme
         nach Beendigung der Ausführung gelöscht, bei 'erase option' = FALSE
         bleiben sie erhalten (Voreinstellung: 'erase option' = FALSE). 
 
 
PROC error listing (TEXT CONST fehlerdatei) 
 
  Zweck: Falls gewünscht ist, die Fehlermeldungen, die ggf. beim Übersetzen ein­
         treten, auch in eine Datei zu schreiben, so können Sie hier unter 'fehler­
         datei' einen Dateinamen angeben. Bei der Angabe von "" wird die Umlei­
         tung in die Datei ausgeschaltet werden (Voreingestellt ist 'fehlerdatei' =
         ""). 
 
 
PROC graphic (BOOL CONST graphic option) 
 
  Zweck: Mit dieser Prozedur läßt sich einstellen, ob bei der DYNAMO-Anweisung
         PLOT die hochauflösende Grafik ('graphic option' = TRUE) oder die zei­
         chenorientierte Grafik ('grafik option' = FALSE) verwendet werden soll. Die
         Voreinstellung wird bei der Installation des Compilers erfragt. 
 
 
PROC protokoll (BOOL CONST protokoll option) 
 
  Zweck: Bei 'protokoll option' = TRUE werden alle Textausgaben, die bei der
         Laufzeit des DYNAMO-Programmes auftreten, nicht nur auf dem Bild­
         schirm dargestellt, sondern auch in eine Datei mit dem Namen "dyn.out"
         protokolliert (voreingestellt ist 'protokoll option' = FALSE). Die Datei
         "dyn.out" enthält auch Seitenvorschubbefehle ('\#page\#') und sollte nur mit
         einem EUMEL-Printer ausgedruckt werden. 
 
 
 
 
#ib#3.2. Abweichungen gegenüber dem 
     Sprachstandard#ie# 
 
 
 
 -  Die Länge der Namen ist nicht auf 7 Zeichen festgelegt, sondern praktisch be­
    liebig (32000). Dies ist eine Erweiterung; wer seine Programme auch auf ande­
    ren DYNAMO-Compilern laufen lassen will, sollte sich aber auf 7 Zeichen be­
    schränken. 
 
 -  Zahlen werden intern mit einer Mantisse von 13 Stellen abgespeichert, von denen
    nur die ersten 7 bei der Ausgabe dargestellt werden. Die größte darstellbare Zahl
    ist daher 9.999999999999e126. 
 
 -  Die maximale Anzahl der Gleichungen ist auf 950 festgelegt. 
 
 -  Der Compiler akzeptiert aus Gründen der besseren Lesbarkeit auch Programme,
    die in Kleinschrift geschrieben sind. Dabei ist es sinnvoll, die Quellprogramme
    konsistent zu halten (d.h. Groß- und Kleinschrift nicht zu vermischen). Man
    sollte grundsätzlich Kleinschrift vorziehen, da diese vom Compiler auch effizienter
    verarbeitet werden kann. 
 
 -  Quellprogramme dürfen eine beliebige Zahl von Leerzeilen enthalten. X - Befeh­
    le (Fortschreibungszeilen) werden davon nicht beeinflußt. 
 
 -  In der augenblicklichen Version 3.3 des Compilers gelten folgende Einschränkun­
    gen : 
 
   1. Bei der Verarbeitung von Array-Gleichungen werden Compilerseitig keine
      Semantik-Überprüfungen auf eventuell unzureichende Initialisierung oder
      Überlappung (d.h. mehrfaches Setzen desselben Elements) durchgeführt.
      Defaultmäßig bekommen alle Elemente einer Array-Gleichung bei der Initiali­
      sierung den Wert '0.0' zugewiesen. 
 
   2. Die maximale Größe von Tables und Array-Gleichungen ist durch Verwen­
      dung des Vector-Pakets auf 4000 Elemente festgelegt. Da pro Table-Ele­
      ment aber zur Zeit eine Zeile im Zielprogramm generiert wird, sollte man dies
      besser nicht ausnutzen. 
 
   3. Supplementary-Gleichungen werden aus Kompatibilitäts-Gründen korrekt
      übersetzt, aber sonst wie Auxiliary-Gleichungen behandelt. 
 
   4. Print ('prtper')- und Plotperiode ('pltper') werden nur als Konstanten verarbei­
      tet. Falls Gleichungen für 'prtper' oder 'pltper' angegeben werden, so bewirken
      diese keine Veränderung. 
 
   5. Array-Gleichungen dürfen nicht mehr als eine Dimension besitzen. 
 
   6. Für Gleichungen, die Makro-Aufrufe enthalten, sollten Initialisierungs (N)-
      Gleichungen angegeben werden. 
 
 
 
#ib#3.3. Das DYNAMO Runtime-System#ie# 
 
 
 
Nach erfolgreicher Übersetzung wird vom Zielprogramm das Runtime-System aufge­
rufen. In diesem Modus (das DYNAMO-Runtime-System meldet sich mit "dynamo
runtime system :") ist es möglich, Konstanten zu ändern und DynamoProgramme zur
Ausführung zu bringen. 
 
Im DYNAMO-Runtime-System stehen folgende Kommandos zur Verfügung (näheres
zur Notation siehe Kapitel 4, S. #to page ("Anweisungen und Funktionen")#). 
 
 
  run 
 
    Zweck: Ausführen des übersetzten Programms 
 
 
  run <name> 
 
    Zweck: Ausführen des übersetzten Programms und retten des Konstantendaten­
           raums in des Datenraum mit dem Namen "<name>.const". Existiert der
           Datenraum bereits, werden die Konstanten aus dem Datenraum in den
           Lauf übernommen. Somit ermöglicht der Compiler, Konstantenwerte aus
           einem früheren Lauf wieder zu verwenden. 
 
 
  c <Konstantenname>=Wert [/<Konstantenname>=Wert [...]] 
 
    Zweck: Änderung einer oder mehrerer Konstanten 
 
 
  ? 
 
    Zweck: Anzeigen der Konstanten und ihrer Werte 
 
 
  quit 
 
    Zweck: Verlassen des Runtime-Systems 
 
 
  help 
 
    Zweck: Zeigt eine kurze Erklärung 
 
 
Bei PRINT- und PLOT-Ausgaben sind folgende Kommandos möglich: 
 
  +       Nächster Bildschirm 
  o       (Off), keine Unterbrechung der Ausgabe (nicht möglich bei hochauflösen­
          der Grafik) 
  e       (End), Zurück zum Runtime System 
  p       Phasendiagramm (nur bei hochauflösender Grafik möglich) 
 
 
 
#ib#3.4. Fehlermeldungen des 
     DYNAMO-Compilers#ie# 
 
 
 
Falls der Compiler einen Fehler im DYNAMO-Programm entdeckt, gibt er eine Feh­
lermeldung nach dem folgenden Muster aus: 
"Fehler in Zeile  <zeilennummer>  bei >>  <symbol>  <<  :  <fehlertext>. 
 
Im  folgenden sind alle Fehlermeldungen und Möglichkeiten zur Abhilfe aufgelistet,
sofern diese nicht klar ersichtlich sind: 
 
 1   GLEICHUNG DOPPELT DEFINIERT 
 
 2   DOPPELTE INITIALISIERUNG 
 
 3   FALSCHER ZEILENTYP 
     ->  Erlaubt sind :  a, c, l, n, r, s, print, plot, note, spec, *, x, macro, mend,
                         for, noise, run. 
 
 4   VERSCHACHTELTE MAKRO-DEFINITION 
     ->  'mend' - Befehl fehlt. 
 
 5   MAKRO-NAME ERWARTET 
 
 6   '(' ERWARTET 
 
 7   FORMALER PARAMETER ERWARTET 
 
 8  ')' NACH PARAMETERLISTE ERWARTET 
 
 9  BEI AUXILIARIES NUR SUBSKRIPTION MIT '.K' ERLAUBT 
 
10  BEI KONSTANTEN-DEFINITION NAME ERWARTET 
 
11  BEI LEVELS NUR SUBSKRIPTION MIT '.K' ERLAUBT 
 
12  BEI RATES NUR SUBSKRIPTTION MIT '.KL' ERLAUBT 
 
13  BEI TABLE-DEFINITIONEN KEINE SUBSKRIPTION ERLAUBT 
 
14  X - BEFEHL HIER NICHT ERLAUBT 
 
15  BEI FOR-DEFINITION NAME ERWARTET 
 
16  '=' NACH FOR-VARIABLE ERWARTET 
 
17  BEREICHSANGABE ERWARTET 
 
18  ',' ERWARTET 
 
19  LOKALE GLEICHUNG NUR IN MAKRO ERLAUBT 
 
20  BEI DEFINITION NAME ERWARTET 
 
21  '=' ERWARTET 
 
22  INDEX NICHT KORREKT 
    ->  Als Index ist nur erlaubt :  <for variable> !, 
                                     <add op> <ganze zahl>!. 
                                     <add op> ::= "+"; "-". 
 
23  ')' NACH INDIZIERUNG ERWARTET 
 
24  PRTPER NICHT DEFINIERT 
    ->  Wenn das Programm einen Print-Befehl enthält, muß 'prtper' (Printperiode)
        als Konstante definiert werden. 
 
25  PLTPER NICHT DEFINIERT 
    ->  Wenn das Programm einen Plot-Befehl enthält, muß 'pltper' (Plotperiode)
        als Konstante definiert werden. 
 
26  '/' ODER ',' BEI PLOT ERWARTET 
 
27  NAME ALS PLOTPARAMETER ERWARTET 
 
28  DOPPELTE SCALE - ANGABE IN EINER GRUPPE 
    ->  Wenn mehrere Plotparameter mit ',' getrennt werden (also die gleiche Ska­
        lierung erhalten), dürfen nicht mehrere feste Skalierungen angegeben wer­
        den. 
 
29  ERSTE SCALE - ANGABE ERWARTET 
 
30  ZWEITE SCALE - ANGABE ERWARTET 
 
31  ')' NACH SCALE - ANGABE FEHLT 
 
32  PRINTPARAMETER NICHT DEFINIERT 
 
33  PRINTPARAMETER ERWARTET 
 
34  TIME DARF NUR INITIALISIERT WERDEN 
 
35  DT NICHT DEFINIERT 
 
36  LENGTH NICHT DEFINIERT 
 
37  BEI KONSTANTEN - DEFINITION ZAHL ERWARTET 
 
38  BEI INITIALISIERUNG KONSTANTE ERWARTET 
 
39  LEVELS MUESSEN INITIALISIERT WERDEN 
 
40  KONSTANTE BEI TABLE ERWARTET 
 
41  '/' ODER "," ERWARTET 
 
42  TABLE - DEFINITION OHNE BENUTZUNG 
 
43  SIMULTANE GLEICHUNGEN 
    ->  Bei dem Versuch, A, R, oder N - Gleichungen zu sortieren, trat eine
        direkte oder indirekte Rekursion auf. 
 
44  FAKTOR ERWARTET 
    ->  Erwartet :  <zahl>; 
                    <funktions aufruf>; 
                    <macro aufruf>; 
                    <gleichungs name>; 
                    '(', <ausdruck>, ')'; 
                    <monadischer operator>, <faktor>. 
                    <monadischer operator> ::= '+'; '-'. 
 
45  TIME MUSS MIT '.J' ODER '.K' SUBSKRIBIERT WERDEN 
 
46  SYMBOL NICHT DEFINIERT 
 
47  FUNKTION NICHT DEFINIERT 
 
48  UNZULAESSIGE INDIZIERUNG 
    ->  Die Indices auf beiden Seiten der Gleichung müssen immer gleich sein. 
 
49  FALSCHE PARAMETERANZAHL 
 
50  FALSCHES TRENNSYMBOL ZWISCHEN PARAMETERN 
 
51  ALS PARAMETER TABLE ERWARTET 
 
52  FALSCHER PARAMETER IN TABLEFUNKTION 
 
53  ZU VIELE AKTUELLE PARAMETER 
 
54  ')' NACH MAKROAUFRUF FEHLT 
 
55  REKURSIVER MAKROAUFRUF 
 
56  BEI N - GLEICHUNG KEINE SUBSKRIPTION ERLAUBT 
 
57  FALSCHE SUBSKRIPTION IN AUXILIARY - GLEICHUNG 
 
58  ')' ERWARTET 
 
59  FALSCHE SUBSKRIPTION IN LEVEL - GLEICHUNG 
 
60  FALSCHE SUBSKRIPTION IN RATE - GLEICHUNG 
 
61  FOR - VARIABLE NICHT DEFINIERT 
    ->  Eine FOR - Variable muß vor der ersten Benutzung definiert werden. 
 
62  KONSTANTE ERWARTET 
 
63  FALSCHES REAL - FORMAT 
    ->  Exponent fehlt 
 
64  GLOBALE GLEICHUNG IN MACRO NICHT ERLAUBT 
 
65  DOPPELTE DEFINITION BEI MEHRFACHEM MAKROAFRUF 
 
66  ALS NOISE - PARAMETER ZAHL ERWARTET 
#page# 
 
#ib#4. Anweisungen und Funktionen des
   EUMEL-DYNAMO-Compilers#ie# 
#goal page ("Anweisungen und Funktionen")# 
 
 
Dieses Kapitel gibt eine alphabetische Übersicht über die im EUMEL-DYNAMO-
Compiler realisierten Anweisungen und Funktionen (wertliefernde Algorithmen). 
 
Die Beschreibung der Anweisungen und Funktionen ist nach der DYNAMO-
Syntaxregel angegeben, wobei folgende Zeichen mit besonderer Bedeutung verwendet
werden: 
 
  []          optionale Angabe 
  [...]       beliebig häufige Wiederholung der letzten optionalen Angabe 
  < >         in spitzen Klammern stehende Namen sind Variablen- bzw. Konstan­
              tennamen 
  <Name>      steht für einen beliebigen Bezeichner gemäß der DYNAMO-Syntax 
  <Zahl>      bezeichnet einen beliebigen Wert (also auch eine Ausdruck) 
  {}          Alternative Angabe 
 
  X           DYNAMO Anweisung, kennzeichnet eine Fortsetzungsszeile der
              vorhergegangenen Anweiung (S. #to page ("X")#) 
 
Alle Anweisungen und Funktionen werden nach dem gleichen Schema dargestellt: 
 
 
 
Funktionsname#right#Typ (Funkt. oder Anweisung) 
 
 
Zweck:     Schlagwort zur Wirkung 
 
Format:    Beschreibung des Formates (spezielle Zeichen s.o.) 
 
Erklärung: kurze Beschreibung der Anweisung/Funktion 
 
Beispiel:  Anwendung der Anweisung/Funktion 
 
Programm:  Beispielprogramm, in welchem die Anweisung/Funktion angewendet wird. 
 
Referenz:  Verweis auf ähnliche oder äquivalente Anweisungen/Funktionen im
           Format '<Funktions- bzw. Anweisungsname>, Seitennummer'. 
 
 
Eine oder mehrere dieser Felder können fehlen (z.B. wenn es keine Referenz oder
kein Beispielprogramm gibt). 
#page# 
 
 
 
#ib#4.1. Übersicht über die Anweisungen und
     Funktionen#ie# 
 
 
 
#goal page ("A")##ib (2)#A#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Auxiliary-Gleichung (A-Gleichung, Hilfsgleichung) 
 
Format:    A <Auxiliary-Name>.K=<Ausdruck>#u##count ("Ausdruck")##e# 
#foot# 
#u##value ("Ausdruck")##e# genaueres über die Definition eines Ausdruckes siehe [1], S. 93 
#end# 
 
Erklärung: Mit Hilfe von Auxiliary-Gleichungen werden Level- und Hilfsgrößen
           (Auxiliaries) zum selben Zeitpunkt verknüpft. 
 
Beispiel:  A JM.K=MM.K/MEJ 
 
Programm:  "dyn.workfluc" 
 
 
 
#ib (2)#ABS#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Absolutbetrag 
 
Format:    ABS(<Zahl>) 
 
Erklärung: Liefert den Absolutbetrag 
 
 
           IF <Zahl> >= 0 THEN 
             <Zahl> 
           ELSE 
             -  <Zahl> 
           END IF  
 
Beispiel:  N X=ABS(A*2.0) 
 
 
 
#goal page ("ARCTAN")#ARCTAN#on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Arcustangens 
 
Format:    ARCTAN(<Zahl>) 
 
Erklärung: Berechnet den Arcustangens von <Zahl>; Ergebnis im Bogenmaß. 
 
Beispiel:  N X=ARCTAN(TAN(1.3))                (X = 1.3) 
 
 
Referenz:  COSD, S. #to page ("COSD")# 
           SIN, S. #to page ("SIN")# 
           SIND, S. #to page ("SIND")# 
           TAN, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           ARCTAND, S. #to page ("ARCTAN")# 
           COS, S. #to page ("COS")# 
 
 
 
#goal page ("ARCTAND")##ib (2)#ARCTAND#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Arcustangens 
 
Format:    ARCTAND(<Zahl>) 
 
Erklärung: Berechnet den Arcustangens von <Zahl>; Ergebnis im Gradmaß 
 
Beispiel:  N X=ARCTAND(TAND(45.0))             (X = 45.0) 
 
 
Referenz:  COSD, S. #to page ("COSD")# 
           SIN, S. #to page ("SIN")# 
           SIND, S. #to page ("SIND")# 
           TAN, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           COS, S. #to page ("COS")# 
           ARCTAN, S. #to page ("ARCTAND")# 
 
 
 
#goalpage ("C")##ib (2)#C#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Konstantendefinition 
 
Format:    C <Name>=<Zahl> 
 
Erklärung: Werte, die während eines Simulationslaufes gleich bleiben, können durch
           die Konstantendefintion benannt werden (s. auch 'c' im Runtime-
           System). 
 
Beispiel:  C POPI=30.3 
 
Programm:  "dyn.wohnen" 
 
 
 
#goal page ("CLIP")##ib (2)#CLIP#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Wert nach Bedingung 
 
Format:    CLIP(<Zahl1>,<Zahl2>,<Zahl3>,<Zahl4>) 
 
Erklärung: Liefert den Wert des ersten Argumentes, wenn das dritte Argument
           größer oder gleich dem vierten Argument ist. Andernfalls wird der Wert
           des zweiten Argumentes geliefert. 
 
 
           IF <Zahl3> >= <Zahl4> THEN 
             <Zahl1> 
           ELSE 
             <Zahl2> 
           END IF  
 
Beispiel:  N X=CLIP(1.0,2.0,3.0,4.0)         (X = 2.0) 
 
 
Programm:  "dyn.welt/forrester" 
 
Referenz:  FIFGE, S. #to page ("FIFGE")#     (äquivalente Funktion) 
 
 
 
#goalpage ("COS")#COS#on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Cosinus 
 
Format:    COS(<Zahl>) 
 
Erklärung: Es wird der Cosinus des Wertes <Zahl>, welcher im Bogenmaß vorlie­
           gen muß, geliefert. 
 
Beispiel:  N X=COS(1.6)  
 
Referenz:  COSD, S. #to page ("COSD")# 
           SIN, S. #to page ("SIN")# 
           SIND, S. #to page ("SIND")# 
           TAN, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           ARCTAN, S. #to page ("ARCTAN")# 
           ARCTAND, S. #to page ("ARCTAND")# 
 
 
 
#goal page ("COSD")##ib (2)#COSD#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Cosinus 
 
Format:    COSD(<Zahl>) 
 
Erklärung: Es wird der Cosinus des Wertes <Zahl>, welcher im Gradmaß vorliegen
           muß, geliefert. 
 
Beispiel:  N X=COSD(33.5)  
 
Referenz:  COS, S. #to page ("COS")# 
           SIN, S. #to page ("SIN")# 
           SIND, S. #to page ("SIND")# 
           TAN, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           ARCTAN, S. #to page ("ARCTAN")# 
           ARCTAND, S. #to page ("ARCTAND")# 
 
 
 
#goal page ("EXP")##ib (2)#EXP#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Exponentialfunktion zur Basis e 
 
Format:    EXP(<Zahl>) 
 
Erklärung: Liefert e#u#<Zahl>#e# 
 
Beispiel:  N X=EXP(1.0)                          (X = 2.71 = e) 
 
 
Referenz:  LN, S. #to page ("LN")#           (Umkehrfunktion) 
 
 
 
#goal page ("FIFGE")##ib (2)#FIFGE#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Wert nach Bedingung (#on ("u")#f#off ("u")#irst #on ("u")#if#off ("u")# #on ("u")#g#off ("u")#reater or #on ("u")#e#off ("u")#qual) 
 
Format:    FIFGE(<Zahl1>,<Zahl2>,<Zahl3>,<Zahl4>) 
 
Erklärung: Liefert den Wert des ersten Argumentes, wenn das dritte Argument
           größer oder gleich dem vierten Argument ist. Andernfalls wird der Wert
           des zweiten Argumentes geliefert. 
 
 
           IF <Zahl3> >= <Zahl4> THEN 
             <Zahl1> 
           ELSE 
             <Zahl2> 
           END IF  
 
Beispiel:  N X=FIFGE(1.0,2.0,3.0,4.0)         (X = 2.0) 
 
 
Referenz:  CLIP, S. #to page ("CLIP")#          (äquivalente Funktion) 
 
 
 
#goal page ("FIFZE")##ib (2)#FIFZE#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Wert nach Bedingung (#on ("u")#f#off ("u")#irst #on ("u")#if#off ("u")# #on ("u")#ze#off ("u")#ro) 
 
Format:    FIFZE(<Zahl1>,<Zahl2>,<Zahl3>) 
 
Erklärung: Wenn der Parameter <Zahl3> den Wert 0 hat, so wird <Zahl1>
           geliefert, andernfalls <Zahl2> 
 
 
           IF <Zahl3> = 0 THEN 
             <Zahl1> 
           ELSE 
             <Zahl2> 
           END IF  
 
Beispiel:  N X=FIFZE(1.0,2.0,3.0)              (X = 2.0) 
 
 
Referenz:  SWITCH, S. #to page ("SWITCH")# 
 
 
 
#goal page ("FLOOR")##ib (2)#FLOOR#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Vorkommastellen 
 
Format:    FLOOR(<Zahl>) 
 
Erklärung: Liefert die Vorkommastellen von <Zahl> 
 
Beipiel:   N X=FLOOR(3.14)                      (X = 3.0) 
 
 
Referenz:  FRAC, S. #to page ("FRAC")# 
 
 
 
#ib (2)#FOR#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Schleifen-Definition 
 
Format:    FOR <Name>=<Zahl1>,<Zahl2> 
 
Erklärung: <Name> bezeichnet eine Schleifenvariable, die von <Zahl1> bis
           <Zahl2> hochgezählt wird. Somit ist es möglich, gleiche Berechnungen
           für die verschiedenen Werte einer Tabelle durchzuführen. 
 
Beispiel:  FOR BERECHNUNGSZEITRAUM=1900,2100 
 
 
Programm:  "dyn.bev" 
 
 
 
#goal page ("FRAC")##ib (2)#FRAC#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Nachkommastellen 
 
Format:    FRAC(<Zahl>) 
 
Erklärung: Liefert die Nachkommastellen von <Zahl> 
 
Beispiel:  N X=FRAC(3.14)                        (X = 0.14) 
 
 
Referenz:  FLOOR, S. #to page ("FLOOR")# 
 
 
 
#goal page ("L")##ib (2)#L#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Level-Gleichung 
 
Format:    L <Level-Name>.K=<Level-Name>.J+ 
                            <Vergangenheitsausdruck> 
 
Erklärung: Die Level-Gleichung stellt einen gegenwärtigen Wert in Bezug zu
           seinem Wert in der Vergangenheit und seiner Veränderungsrate in der
           bis dahin vergangenen Zeit (Vergangenheitsausdruck s. [1], S. 96). 
 
Beispiel:  L HASEN.K=CLIP(HASEN.J+DT*(HGRATE.JK 
           X         -HSRATE.JK),0,HASEN.J,0)  
 
Programm:  "dyn.grashasenfuchs" 
 
 
 
#goal page ("LN")##ib (2)#LN#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Logarithmus-Funktion 
 
Format:    LN(<Zahl>) 
 
Erklärung: Berechnet den natürlichen Logarithmus von <Zahl> 
 
Beispiel:  N X=LN(1.0)                           (X = 0.0) 
 
 
Programm:  "dyn.wasseröko" 
 
Referenz:  LOG2, S. #to page ("LOG2")# 
           LOG10, S. #to page ("LOG10")# 
           EXP, S. #to page ("EXP")# 
 
 
 
#goal page ("LOG2")##ib (2)#LOG2#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Logarithmus-Funktion 
 
Format:    LOG2(<Zahl>) 
 
Erklärung: Berechnet den Logarithmus von <Zahl> zur Basis 2 
 
Beispiel:  N X=LOG2(8.0)                         (X = 3.0) 
 
 
Referenz:  LN, S. #to page ("LN")# 
           LOG10, S. #to page ("LOG10")# 
 
 
 
#goal page ("LOG10")##ib (2)#LOG10#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Logarithmus-Funktion 
 
Format:    LOG10(<Zahl>) 
 
Erklärung: Berechnet den Logarithmus von <Zahl> zur Basis 10 
 
Beispiel:  N X=LOG10(100.0)                      (X = 2.0) 
 
 
Referenz:  LOG2, S. #to page ("LOG2")# 
           LN, S. #to page ("LN")# 
           EXP, S. #to page ("EXP")# 
 
 
 
#goal page ("MACRO")##ib (2)#MACRO#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Macro-Definition 
 
Format:    MACRO <Name>(<Ausdruck>[,<Ausdruck>[...]]) 
 
Erklärung: Durch die Verwendung der MACRO-Anweisung können Sie einer oder
           mehreren DYNAMO-Gleichungen einen Namen geben (<Name>).
           Macros müssen durch MEND abgeschloßen werden und dürfen #on ("u")#nicht#off ("u")#
           rekursiv aufgerufen werden (vergl. Refinements in ELAN). 
 
Beispiel:  MACRO SMOOTH(IN,DEL) 
           L     SMOOTH.K=SMOOTH.J+DT*(IN.J-SMOOTH.J)/DEL 
           N     SMOOTH=IN 
           MEND  
 
Programm:  "dyn.mac"     (diese Datei enthält alle bisherigen Makros) 
 
Referenz:  MEND, S. #to page ("MEND")# 
 
 
 
#goal page ("MAX")##ib (2)#MAX#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Maximum zweier Größen 
 
Format:    MAX(<Zahl1>,<Zahl2>) 
 
Erklärung: Liefert die größere Zahl aus <Zahl1> und <Zahl2> 
 
 
           IF <Zahl1> > <Zahl2> THEN 
             <Zahl1> 
           ELSE 
             <Zahl2> 
           END IF  
 
Beispiel:  N X=MAX(1.0,2.0)                     (X = 2.0) 
 
 
Referenz:  MIN, S. #to page ("MIN")# 
 
 
 
#goal page ("MEND")##ib (2)#MEND#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Macro-Definition 
 
Format:    MEND 
 
Erklärung: MEND beendet eine Macro-Definition 
 
Beispiel:  MACRO SMOOTH(IN,DEL)  
           L     SMOOTH.K=SMOOTH.J+DT*(IN.J-SMOOTH.J)  
           X     /DEL  
           N     SMOOTH=IN 
           MEND  
 
Programm:  "dyn.mac"       (diese Datei enthält alle bisherigen Makros) 
 
Referenz:  MACRO, S. #to page ("MACRO")# 
 
 
 
#goal page ("MIN")##ib (2)#MIN#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Minimum zweier Größen 
 
Format:    MIN(<Zahl1>,<Zahl2>) 
 
Erklärung: Liefert die kleinere Zahl aus <Zahl1> und <Zahl2> 
 
Beispiel:  N X=MIN(1.0,2.0)                     (X = 1.0) 
 
 
Programm:  "dyn.forst7" 
 
Referenz:  MAX, S. #to page ("MAX")# 
 
 
 
#goal page ("N")##ib (2)#N#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Initialisierungsgleichung 
 
Format:    N <Name>=<Zahl> 
 
Erklärung: Initialisert eine Variable mit dem Bezeichner <Name> auf den Wert
           <Zahl>, d.h. es wird ihr ein Startwert zugewiesen. 
 
Beispiel:  N X=1900  
 
Programm:  "dyn.grashasenfuchs" 
 
 
 
#goal page ("NOISE")##ib (2)#NOISE#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Pseudo-Zufallszahlen-Generator 
 
Format:    NOISE(<Zahl>) 
 
Erklärung: Diese Funktion liefert eine Pseudo-Zufallszahl zwischen -0.5 und +0.5
           und setzt einen neuen Startwert für den Generator fest. Der Parameter
           <Zahl> wird nicht ausgewertet. 
 
Beispiel:  N X=NOISE(0) 
 
Referenz:  NORMRN, S. #to page ("NORMRN")# 
 
 
 
#goal page ("NORMRN")##ib (2)#NORMRN#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Pseudo-Zufallszahlen-Generator 
 
Format:    NORM(<Zahl1>,<Zahl2>) 
 
Erklärung: Liefert einen Wert zwischen <Zahl1> - <Zahl2> * 2.4 und <Zahl1>
           + <Zahl2> * 2.4. 
 
Beispiel:  N X=NORM(1.0,10.0) 
 
Referenz:  NOISE, S. #to page ("NOISE")# 
 
 
 
#ib (2)#NOTE#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Kommentar 
 
Format:    NOTE <Kommentarzeile> 
 
Erklärung: Die Zeilen, die mit NOTE gekennzeichnet sind, werden vom Compiler als
           Kommentarzeilen erkannt und nicht beachtet. NOTE-Zeilen haben nur
           dokumentierenden Charakter und sind für den Programmlauf ohne jede
           Bedeutung. Dennoch sollte man, wenn immer möglich, Kommentare in
           sein DYNAMO-Programm einfügen, denn sie sind in DYNAMO an­
           nähernd die einzige Möglichkeit, ein Programm lesbar zu machen, damit
           es auch nach längerer Zeit noch korrigiert werden kann. 
 
Beispiel:  NOTE Dies ist eine Kommentarzeile 
 
Programm:  "dyn.welt/forrester" 
 
 
 
#goal page ("PLOT")##ib (2)#PLOT#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Darstellen der Ergebnisse in Diagrammform 
 
Format:    PLOT <Name>[=<Druckzeichen>][(<Skalenbegin>, 
                        <Skalenende>)][/...][,...] 
 
Erklärung: Durch diese Anweisung werden die Größen nach PLTPER Zeiteinheiten
           in einem Diagramm ausgegeben. Die Angabe eines Druckzeichens ist
           nur bei zeichenorientierten Grafik erforderlich, denn bei hochauflösender
           Grafik werden die Graphen der verschiedenen Größen durch unterschied­
           liche Linientypen gezeichnet; fehlt bei der zeichenorientierten Grafik das
           Druckzeichen, so werden die Graphen durch die Zahlen von 0...9 darge­
           stellt. Bei "/" werden verschiedene, bei "," gleiche Skalen benutzt. 
 
Beispiel:  PLOT GRAS=G(995,1005)/HASEN=H(85,115)  
           X    /FUECHS=F(15,35)  
 
Programm:  "dyn.grashasenfuchs" 
 
Referenz:  PRINT, S. #to page ("PRINT")# 
 
 
 
#goal page ("POWER")##ib (2)#POWER#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Potenzfunktion 
 
Format:    POWER(<Zahl1>,<Zahl2>) 
 
Erklärung: Liefert <Zahl1>#u#<Zahl2>#e# 
 
Beipiel:   N X=POWER(2, 2)                       (X = 4) 
 
 
Referenz:  SQRT, S. #to page ("SQRT")# 
 
 
 
#goal page ("PRINT")##ib (2)#PRINT#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Darstellung der Ergebnisse in Tabellenform 
 
Format:    PRINT <Name>[/...][,...] 
 
Erklärung: Durch diese Anweisung werden die Werte (<Name>) nach PRTPER
           Zeiteinheiten in einer Tabelle ausgegeben. Die Ausgabe kann umgeleitet
           werden (s. 'protokoll'). 
 
Beispiel:  PRINT GBEV,BEV(1),BEV(40),BEV(60),BEV(63)  
           X     ,BEV(65),ZBEV,PRENT 
 
Programm:  "dyn.bev" 
 
Referenz:  PLOT, S. #to page ("PLOT")# 
 
 
 
#goal page ("R")##ib (2)#R#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Rate-Gleichung 
 
Format:    R<Rate-Name>.KL=<Gegenwartsausdruck> 
 
Erklärung: Eine Rate-Gleichung stellt die Veränderungsrate in Bezug zu den aktu­
           ellen Level-Größen. 
 
Beispiel:  R FGRATE.KL=FGK*HASEN*FUECHS.K 
 
 
Programm:  "dyn.grashasenfuchs" 
 
Referenz:  A, S. #to page ("A")# 
           C, S. #to page ("C")# 
           L, S. #to page ("L")# 
 
 
 
#ib (2)#RAMP#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Wert nach Bedingung 
 
Format:    RAMP(<Zahl1>,<Zahl2>) 
 
Erklärung: Wenn TIME kleiner <Zahl2>, dann liefert RAMP 0, andernfalls wird
           <Zahl1> * (TIME - <Zahl2>) geliefert. 
 
 
           IF TIME < <Zahl2> THEN 
             0 
           ELSE 
             <Zahl1> * (TIME - <Zahl2>) 
           END IF  
 
 
 
#goal page ("RUN")##ib (2)#RUN#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Überschrift 
 
Format:    RUN <Überschrift> 
 
Erklärung: Gibt dem aktuellen Lauf eine Überschrift. Gleichzeitig ist
           "<Überschrift>.const" der Name eines Datenraums, in dem die Kon­
           stanten dieses Laufs aufgehoben werden (s. 'run' im Runtime-System). 
 
Beispiel:  RUN Überschrift  
 
Referenz:  *, S. #to page ("*")# 
 
 
 
#ib (2)#S#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Supplementary-Gleichung 
 
Format:    S <Name>.K=<Vergangenheitsausdruck> 
 
Erklärung: Gleichungen für Hilfsgrößen werden durch Supplementary-Gleichungen
           ausgedrückt. 
 
Beispiel:  S SCHADSTOFFVERHÄLTNIS.K=COZWEI.K/OZWEI.K 
 
 
 
 
#ib (2)#SCLPRD#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Skalarprodukt 
 
Format:    SCLPRD(<Tabelle1>,<Zahl1>,<Zahl2>,<Tabelle2>,<Zahl3>) 
 
Erklärung: Liefert das Skalarprokukt der Tabellen <Tabelle1> und <Tabelle2>,
           wobei <Zahl1> und <Zahl2> den Ausschnitt aus der ersten Tabelle
           angeben und <Zahl3> den Startindex für den Vektor in der zweiten
           Tabelle angibt. 
 
Beispiel:  GB.K=SCLPRD(BEV.K,15,44,GR,1)/2 
 
 
Programm:  "dyn.bev" 
 
 
 
#goal page ("SIN")##ib (2)#SIN#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Sinus 
 
Format:    SIN(<Zahl>) 
 
Erklärung: Berechnet den Sinus von <Zahl>, welche im Bogenmaß angegeben
           wird. 
 
Beispiel:  N X=SIN(0.5) 
 
Referenz:  COS, S. #to page ("COS")# 
           COSD, S. #to page ("COSD")# 
           SIND, S. #to page ("SIND")# 
           TAN, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           ARCTAN, S. #to page ("ARCTAN")# 
           ARCTAND, S. #to page ("ARCTAND")# 
 
 
 
#goal page ("SIND")##ib (2)#SIND#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Sinus 
 
Format:    SIND(<Zahl>) 
 
Erklärung: Berechnet den Sinus von <Zahl>, welche im Gradmaß angegeben wird. 
 
Beispiel:  N X=SIND(45.0)  
 
Referenz:  COS, S. #to page ("COS")# 
           SIN, S. #to page ("SIN")# 
           COSD, S. #to page ("COSD")# 
           TAN, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           ARCTAN, S. #to page ("ARCTAN")# 
           ARCTAND, S. #to page ("ARCTAND")# 
 
 
 
#ib (2)#SPEC#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Lauf-Anweisung 
 
                   DT=<Zahl1> 
Format:    SPEC {  LENGTH=<Zahl2>    }[/...] 
                   PLTPER=<Zahl3> 
                   PRTPER=<Zahl4> 
 
Erklärung: Durch die Lauf-Anweisung werden die Systemkonstanten festgesetzt.
           Sie darf pro Lauf nur einmal benutzt werden. 
 
Beispiel:  SPEC DT=1/PLTPER=1/PRTPER=1/LENGTH=2000 
 
 
Referenz:  C, S. #to page ("C")#     (SPEC kann durch C-Def. ersetzt werden) 
 
 
 
#goal page ("SQRT")##ib (2)#SQRT#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Quadratwurzel 
 
Format:    SQRT(<Zahl>) 
 
Erklärung: Berechnet die Quadratwurzel aus <Zahl> 
 
Beispiel:  N X=SQRT(4.0)                         (X = 2.0) 
 
 
Referenz:  POWER, S. #to page ("POWER")# 
 
 
 
#ib (2)#STEP#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
Zweck:     Wert nach Bedingung 
 
Format:    STEP(<Zahl1>,<Zahl2>) 
 
Erklärung: Ist TIME kleiner <Zahl2>, so wird 0 geliefert, ansonsten <Zahl1> 
 
 
           IF TIME < <Zahl2> THEN 
             0.0 
           ELSE 
             <Zahl1> 
           END IF  
 
Beispiel:  N X=STEP(12.0,12.0)  
 
 
 
#goal page ("SUM")##ib (2)#SUM#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Summierung einer Tabelle 
 
Format:    SUM(<Tabelle>) 
 
Erklärung: Liefert die Summe der Einträge in einer Tabelle 
 
Beispiel:  A GESAMTBEV.K=SUM(BEV.K) 
 
Programm:  "dyn.bev" 
 
Referenz:  SUMV, S. #to page ("SUMV")# 
 
 
 
#goal page ("SUMV")##ib (2)#SUMV#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Summierung einer Tabelle 
 
Format:    SUMV(<Tabelle>,<Zahl1>,<Zahl2>) 
 
Erklärung: Summierung der Einträge in der Tabelle von Element <Zahl1> bis
           Element <Zahl2> 
 
Beispiel:  A ZBEV.K=SUMV(BEV.K,16,59)          Teilbevölkerung 
 
 
Programm:  "dyn.bev" 
 
Referenz:  SUM, S. #to page ("SUM")# 
 
 
 
#goal page ("SWITCH")##ib (2)#SWITCH#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Wert nach Bedingung 
 
Format:    SWITCH(<Zahl1>,<Zahl2>,<Zahl3>) 
 
Erklärung: Wenn der Parameter <Zahl3> den Wert 0 hat, so wird <Zahl1>
           geliefert, andernfalls <Zahl2> (gleichbedeutend mit FIFZE). 
 
 
           IF <Zahl3> = 0 THEN 
             <Zahl1> 
           ELSE 
             <Zahl2> 
           END IF  
 
Beispiel:  N X=SWITCH(1.0,2.0,3.0)              (X = 2.0) 
 
 
Referenz:  FIFZE, S. #to page ("FIFZE")# 
 
 
 
#goal page ("T")##ib (2)#T#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Tabellen-Definition 
 
Format:    T <Name>=<Zahl1>[/<Zahl2>[....]] 
 
Erklärung: Durch die T-Anweisung wird eine Tabelle definiert, die Elemente wer­
           den durch "/" getrennt hintereinander angegeben. 
 
Beispiel:  T TABELLE=1/2/3/4/5/6/8/9/10/11/12 
 
 
Programm:  "dyn.bev" 
 
Referenz:  TABLE, S. #to page ("TABLE")# 
           TABHL, S. #to page ("TABHL")# 
 
 
 
#goal page ("TABHL")##ib (2)#TABHL#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Tabellenfunktion 
 
Format:    TABHL(<Tabelle>,<Zahl1>,<Zahl2>,<Zahl3>) 
 
Erklärung: IF <Zahl1> < <Zahl2> THEN  
             <Tabelle> (<Zahl2>)  
           ELIF <Zahl2> <= <Zahl1> AND <Zahl1> <= <Zahl3> THEN  
             TABLE (<Tabelle>, <Zahl1>, <Zahl2>, <Zahl3>)  
           ELSE  
             <Tabelle> (<Zahl3>)  
           END IF  
 
Beispiel:  A BRMM.K=TABHL(BRMMT,MSL.K,0,5,1) 
 
 
Programm:  "dyn.welt/forrester" 
 
Referenz:  T, S. #to page ("T")# 
           TABLE, S. #to page ("TABLE")# 
 
 
 
#goal page ("TABLE")##ib (2)#TABLE#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Tabellenfunktion 
 
Format:    TABLE(<Tabelle>,<Zahl1>,<Zahl2>,<Zahl3>,<Zahl4>) 
 
Erklärung: Verknüpft die Werte aus <Tabelle> mit <Zahl1>, wobei <Zahl2> den
           ersten und <Zahl3> den letzten Tabelleneintrag angibt. <Zahl4> stellt
           die Schrittweite dar. 
 
Beispiel:  T TABELLE=1/2/3/4/5  
           A BEISP.K=TABLE(TABELLE,X.K,2,4,1)  
 
Programm:  "dyn.welt/forrester" 
 
Referenz:  T, S. #to page ("T")# 
           TABHL, S. #to page ("TABHL")# 
 
 
 
#goal page ("TAN")##ib (2)#TAN#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Tangens 
 
Format:    TAN(<Zahl>) 
 
Erklärung: Berechnet den Tangens von <Zahl>, welche im Bogenmaß angegeben
           wird. 
 
Beispiel:  N X=TAN(0.5)  
 
Referenz:  COS, S. #to page ("COS")# 
           SIN, S. #to page ("SIN")# 
           COSD, S. #to page ("COSD")# 
           SIND, S. #to page ("TAN")# 
           TAND, S. #to page ("TAND")# 
           ARCTAN, S. #to page ("ARCTAN")# 
           ARCTAND, S. #to page ("ARCTAND")# 
 
 
 
#goal page ("TAND")##ib (2)#TAND#ie (2)##on ("i")##right#Funktion#off ("i")# 
 
 
Zweck:     Berechnung der trigonometrischen Funktion Tangens 
 
Format:    TAND(<Zahl>) 
 
Erklärung: Berechnet den Tangens von <Zahl>, welche im Gradmaß angegeben
           wird. 
 
Beispiel:  N X=TAND(45.0)  
 
Referenz:  COS, S. #to page ("COS")# 
           SIN, S. #to page ("SIN")# 
           COSD, S. #to page ("COSD")# 
           TAN, S. #to page ("TAN")# 
           SIND, S. #to page ("SIND")# 
           ARCTAN, S. #to page ("ARCTAN")# 
           ARCTAND, S. #to page ("ARCTAND")# 
 
 
 
#goalpage ("X")##ib (2)#X#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Fortsetzungszeile 
 
Format:    X <Fortsetzungszeile> 
 
Erklärung: Eine in der vorangegangenen Zeile nicht beendete Anweisung wird nach
           einer X-Anweisung fortgesetzt (Es können beliebig viele X-Anweisun­
           gen nacheinander folgen). 
 
Beispiel:  T TABELLE=1/2/3/4/5/6/7/8/9/10/11/12/13/14 
           X         /15/16/17/18/19  
 
Programm:  "dyn.bev" 
 
 
 
#goal page ("*")##ib (2)#*#ie (2)##on ("i")##right#Anweisung#off ("i")# 
 
 
Zweck:     Überschrift 
 
Format:    * <Überschrift> 
 
Erklärung: Gibt dem aktuellen Lauf eine Überschrift 
 
Beispiel:  * Überschrift  
 
Referenz:  RUN, S. #to page ("RUN")# 
#page# 
 
#ib#5. Makros in DYNAMO#ie# 
 
 
 
 
Der DYNAMO-Compiler bietet die Möglichkeit, benutzereigene Funktionen zu definie­
ren. Makros werden ähnlich wie Refinements in ELAN in das DYNAMO-Programm
eingesetzt. Beim EUMEL-DYNAMO-Compiler werden mit "zz" beginnende Namen
generiert, so daß Sie es vermeiden sollten, eigene Namen mit "zz" beginnen zu
lassen. Weiterhin sollte man als Namen der aktuellen Parameter nicht die Namen der
formellen Parameter verwenden. 
 
Folgende Makros werden standardmäßig vom DYNAMO-Compiler zur Verfügung
gestellt: 
 
    macro delay1 (in, del)             Verzögerung erster Ordnung 
 
    macro delay3 (in, del)             Verzögerung dritter Ordnung 
                                       Material 
 
    macro delay3p (in, del, ppl)       Verzögerung dritter Ordnung mit 
                                       Pipeline 
 
    macro delinf3 (in, del)            Verzögerung dritter Ordnung für 
                                       Information 
 
    macro smooth (in, del)             Verzögerung erster Ordnung für 
                                       Information 
 
 
 
 
#ib#5.1. Insertieren von Makros#ie# 
 
 
 
 
Makros werden durch folgende Prozedur in die Compilertabelle eingetragen: 
 
 
PROC insert macro (TEXT CONST filename): 
 
  Zweck: Fügt die in der Datei 'filename' enthaltenen Makros in die Makrotabelle ein.
         Die Datei sollte zweckmäßigerweise nur Makrodefinitionen enthalten. Es ist
         - im Gegensatz zu normalen DYNAMO-Programmen - nicht nötig, die
         Systemkonstanten zu definieren (die Standard-Makros sind in der Datei
         "dyn.mac" enthalten; diese Datei kann beliebig ergänzt werden). 
 
 
 
 
#ib#5.2. Aufbau eines Makros#ie# 
 
 
 
 
Makros beginnen in DYNAMO immer mit der Anweisung MACRO (s. auch Seite #to page ("MACRO")#)
und enden mit MEND (s. Seite #to page ("MEND")#). Dazwischen steht ein Makrorumpf, bestehend
aus einer oder mehreren DYNAMO-Gleichungen. Beim Makroaufruf können, soweit
vorher definiert, Parameter angegeben werden, jedoch rekursiv aufrufen kann man
Makros nicht. 
 
Beispiel:  MACRO SMOOTH (IN, DEL)  
           L     SMOOTH.K = SMOOTH.J + DT * (IN.J - SMOOTH.J) 
           X     /DEL  
           N     SMOOTH   = IN  
           MEND  
 
Lokale Variablen in Makros beginnen mit einem $-Zeichen. Der Makro-Expandierer
ersetzt das $-Zeichen durch "zz" gefolgt von einer Zahl. Aus diesem Grund sollen
eigene Namen nicht mit "zz" beginnen. 
 
Falls Sie eine Fehlermeldung bekommen, die sich auf einen mit "zz" beginnenden
Namen bezieht, sollten Sie den Fehler in dem entsprechenden Makro suchen. 
 
#on ("b")# 
Achtung: #off ("b")#Makros sollten nur von fortgeschrittenden DYNAMO-Programmieren
         verwendet werden, da Makros Eigenschaften von Refinements (textuelle
         Ersetzung) und Prozeduren (Parameterübergabe) vereinigen. Der daraus
         folgende Effekt ist nicht ganz einfach zu durchschauen. 
#page# 
 
 
 
#ib#6. Erweiterung des Sprachumfangs#ie# 
 
 
 
 
Während Makros in DYNAMO geschrieben werden, ist es ferner möglich, die Menge
der Funktionen mittels der Sprache ELAN zu erweitern. 
 
Hierbei geht man wie folgt vor: 
 
  1. Schreiben einer Funktion in ELAN (näheres siehe unten) 
 
  2. Einbinden der Funktion in die Tabellen des DYNAMO-Compilers 
 
    2.1. Einschreiben des Namens der Funktion, gefolgt von den Typen der Ein­
         gabeparameter in die bestehende Datei "dyn.std", wobei folgende Typen
         existieren: 
 
           r     real (Datentyp REAL) 
           t     table (Datentyp TAB) 
 
         Abgeschlossen wird die "dyn.std"-Datei durch die Zeichensequenz "/*". 
 
         Beispiele:  
 
           power rr table trrrr /* 
 
 
    2.2. Laden der Funktion(en) mittels der Prozedur 'init std ("dyn.std")' 
 
 
Eine zur Einbindung in den DYNAMO-Compiler vorgesehene ELAN-Funktion wird
unter Beachtung gewisser Regeln erstellt: 
 
  1. Die deklarierten ELAN-Prozeduren dürfen nur Parameter vom Typ REAL oder
     TAB besitzen oder gänzlich ohne Parameter sein. 
 
  2. Der Typ des Resultaten muß vom Typ REAL sein. 
 
Zur Manipulation von Tabellen wurde der Datentyp TAB geschaffen, auf welchen man
wie auf das Standard-Vektorpaket zugreifen kann. 
 
Beispiel:  
 
    REAL PROC abs (REAL CONST a): 
      IF a < 0.0 THEN 
        -a 
      ELSE 
         a 
      END IF 
    END PROC abs; 
 
    PROC sumv (TAB CONST tab, REAL CONST erstes, letztes): 
      REAL VAR summe := 0.0; 
      INT VAR i; 
      FOR i FROM int (erstes) UPTO int (letztes) REPEAT 
        summe INCR wert (tab, i) 
      END REPEAT; 
      summe 
    END PROC sumv  
 
 
 
 
#ib#6.1. Für fortgeschrittende ELAN-Program­
     mierer#ie# 
 
 
 
Der Quellcode des EUMEL-DYNAMO-Compilers wird mit ausgeliefert. Daher
können Einschränkungen (s. 3.2 Abweichungen gegenüber dem Sprachstandard)
leicht beseitigt werden. Wem z.B. die Anzahl der Gleichungen (950) zu wenig ist, der
kann im Quelltext des Compilers diesen Wert (annähernd) beliebig nach oben hin
erhöhen. 

